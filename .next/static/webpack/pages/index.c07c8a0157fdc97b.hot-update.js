"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./public/useFlappyBirdGame.ts":
/*!*************************************!*\
  !*** ./public/useFlappyBirdGame.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFlappyBirdGame: function() { return /* binding */ useFlappyBirdGame; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n// hooks/useFlappyBirdGame.ts\n\n// Constants\nconst GRAVITY = 0.7;\nconst FLAP = -11;\nconst PIPE_WIDTH = 90;\nconst PIPE_SPACING = 230;\nconst BIRD_WIDTH = 50;\nconst BIRD_HEIGHT = 50;\nconst COIN_SIZE = 100;\n// How long between pipe spawns (in milliseconds). ~1.66s => 1667ms\nconst PIPE_SPAWN_INTERVAL = 1000;\n// Horizontal speed (pixels per \"60fps\" frame). We'll scale it by (deltaTime/16.67).\nconst HORIZONTAL_SPEED = 4;\n// Rotation speed of coin (complete flip from scale 1 to 0 to 1). 1 = full cycle.\nconst ROTATION_SPEED = 0.01;\n// A small constant representing the \"ideal frame\" for scaling calculations (about 60fps).\nconst IDEAL_FRAME = 16.67; // ms\nfunction useFlappyBirdGame(canvasRef, isPaused, autoStart) {\n    const requestIdRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // State\n    const [highScore, setHighScore] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [currentScore, setCurrentScore] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    // Refs to track game state\n    const birdYRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const birdVelocityRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const pipesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const coinsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const gameOverRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const gameStartedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // For coin rotation\n    const coinRotationRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // Track time for spawning pipes\n    const pipeSpawnTimerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // We'll track the previous timestamp for time-based movement\n    const lastTimeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // Bird animation frames\n    let birdImages = [];\n    let pipeTop;\n    let pipeBottom;\n    let background;\n    let coinImage;\n    if (true) {\n        const birdUp = new Image();\n        birdUp.src = \"/assets/redbird-upflap.png\";\n        const birdMid = new Image();\n        birdMid.src = \"/assets/redbird-midflap.png\";\n        const birdDown = new Image();\n        birdDown.src = \"/assets/redbird-downflap.png\";\n        birdImages = [\n            birdUp,\n            birdMid,\n            birdDown\n        ];\n        pipeTop = new Image();\n        pipeTop.src = \"/assets/TopTiny.png\";\n        pipeBottom = new Image();\n        pipeBottom.src = \"/assets/BottomTiny.png\";\n        background = new Image();\n        background.src = \"/assets/background-day.png\";\n        coinImage = new Image();\n        coinImage.src = \"/assets/CoinTiny.png\";\n    }\n    // Current bird frame index (0=up, 1=mid, 2=down). We'll keep the quick flap code.\n    const currentBirdFrameRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // Load high score from localStorage on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (true) {\n            const storedHighScore = localStorage.getItem(\"highScore\");\n            if (storedHighScore) {\n                setHighScore(parseInt(storedHighScore, 10));\n            }\n        }\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        // Utility to ensure an image is fully loaded\n        const loadImage = (img)=>{\n            return new Promise((resolve, reject)=>{\n                if (img.complete) {\n                    resolve();\n                } else {\n                    img.onload = ()=>resolve();\n                    img.onerror = ()=>reject(new Error(\"Failed to load image: \".concat(img.src)));\n                }\n            });\n        };\n        // Load all assets then init\n        const loadAssets = async ()=>{\n            try {\n                await Promise.all([\n                    ...birdImages.map((img)=>loadImage(img)),\n                    loadImage(pipeTop),\n                    loadImage(pipeBottom),\n                    loadImage(background),\n                    loadImage(coinImage)\n                ]);\n                initializeGame();\n            } catch (error) {\n                console.error(\"Error loading assets:\", error);\n            }\n        };\n        loadAssets();\n        function initializeGame() {\n            if (!canvasRef.current) return;\n            if (!ctx) return;\n            // Fixed canvas size\n            canvasRef.current.width = 360;\n            canvasRef.current.height = 640;\n            drawStartScreen(ctx, canvasRef.current);\n        }\n        function resetGame() {\n            if (!canvasRef.current) return;\n            const { width, height } = canvasRef.current;\n            birdYRef.current = height / 3;\n            birdVelocityRef.current = 0;\n            pipesRef.current = [];\n            coinsRef.current = [];\n            setCurrentScore(0);\n            gameOverRef.current = false;\n            gameStartedRef.current = false;\n            coinRotationRef.current = 0;\n            pipeSpawnTimerRef.current = 0;\n            currentBirdFrameRef.current = 0;\n        }\n        // Start game\n        function startGame() {\n            resetGame();\n            gameStartedRef.current = true;\n            lastTimeRef.current = performance.now(); // reset our time-based reference\n            animate();\n        }\n        // Flap function to be called directly\n        function flap1() {\n            if (!gameStartedRef.current && !gameOverRef.current) {\n                startGame();\n            } else if (gameOverRef.current) {\n                startGame();\n            } else {\n                birdVelocityRef.current = FLAP;\n                flapAnimation();\n            }\n        }\n        // Quick flap animation\n        function flapAnimation() {\n            currentBirdFrameRef.current = 1;\n            setTimeout(()=>{\n                currentBirdFrameRef.current = 2;\n                setTimeout(()=>{\n                    currentBirdFrameRef.current = 0;\n                }, 170);\n            }, 170);\n        }\n        // Main game loop\n        function animate(currentTime) {\n            if (!gameStartedRef.current) {\n                // If game hasn't started, just schedule the next frame\n                requestIdRef.current = requestAnimationFrame(animate);\n                return;\n            }\n            if (isPaused) {\n                // If paused, just schedule the next frame\n                requestIdRef.current = requestAnimationFrame(animate);\n                return;\n            }\n            if (!canvasRef.current) return;\n            const context = canvasRef.current.getContext(\"2d\");\n            if (!context) return;\n            // Compute deltaTime\n            const now = currentTime !== null && currentTime !== void 0 ? currentTime : performance.now();\n            const deltaTime = now - lastTimeRef.current;\n            lastTimeRef.current = now;\n            // Update the game state\n            updateGameState(canvasRef.current, deltaTime);\n            // Render\n            draw(context, canvasRef.current);\n            if (!gameOverRef.current) {\n                requestIdRef.current = requestAnimationFrame(animate);\n            } else {\n                drawGameOverScreen(context, canvasRef.current);\n            }\n        }\n        function updateGameState(canvas, deltaTime) {\n            // Scale factor relative to ~60fps = 16.67ms per frame\n            const scale = deltaTime / IDEAL_FRAME;\n            // Gravity\n            birdVelocityRef.current += GRAVITY * scale;\n            birdYRef.current += birdVelocityRef.current * scale;\n            // Update pipe spawn timer\n            pipeSpawnTimerRef.current += deltaTime;\n            if (pipeSpawnTimerRef.current >= PIPE_SPAWN_INTERVAL) {\n                pipeSpawnTimerRef.current -= PIPE_SPAWN_INTERVAL;\n                createPipe(canvas);\n            }\n            // Move pipes & coins\n            movePipesAndCoins(scale);\n            // Rotate coin (0 -> 1 is a full cycle in our usage)\n            coinRotationRef.current += ROTATION_SPEED * scale;\n            if (coinRotationRef.current >= 1) {\n                coinRotationRef.current = 0;\n            }\n            // Check collisions\n            if (checkCollisions(canvas)) {\n                gameOverRef.current = true;\n                return;\n            }\n            // Check coin collection\n            checkCoinCollection();\n            // Update score if we pass pipes\n            updateScore();\n        }\n        function draw(ctx, canvas) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawBackground(ctx, canvas);\n            drawBird(ctx);\n            drawPipes(ctx);\n            drawCoins(ctx);\n        }\n        function drawStartScreen(ctx, canvas) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawBackground(ctx, canvas);\n            ctx.font = \"bold 30px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.fillStyle = \"#ffffff\";\n            ctx.shadowColor = \"black\";\n            ctx.textBaseline = \"middle\";\n            ctx.fillText(\"Tap to Start\", canvas.width / 2, canvas.height / 2);\n        }\n        function drawGameOverScreen(ctx, canvas) {\n            ctx.fillStyle = \"#ffcc00\";\n            ctx.font = \"bold 50px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"middle\";\n            ctx.shadowColor = \"black\";\n            ctx.shadowBlur = 10;\n            ctx.fillText(\"Game Over!\", canvas.width / 2, canvas.height / 2 - 40);\n            ctx.fillStyle = \"#ffffff\";\n            ctx.font = \"bold 30px Arial\";\n            ctx.fillText(\"Tap to Restart\", canvas.width / 2, canvas.height / 2 + 20);\n        }\n        function drawBackground(ctx, canvas) {\n            ctx.drawImage(background, 0, 0, canvas.width, canvas.height);\n        }\n        function drawBird(ctx) {\n            const currentImage = birdImages[currentBirdFrameRef.current];\n            // Draw the bird at a fixed X (100) and current birdY\n            if (currentImage.complete) {\n                ctx.drawImage(currentImage, 100, birdYRef.current, BIRD_WIDTH, BIRD_HEIGHT);\n            }\n        }\n        function drawPipes(ctx) {\n            for (const pipe of pipesRef.current){\n                ctx.drawImage(pipeTop, pipe.x, 0, PIPE_WIDTH, pipe.topHeight);\n                ctx.drawImage(pipeBottom, pipe.x, pipe.bottomY, PIPE_WIDTH, pipe.bottomHeight);\n            }\n        }\n        function drawCoins(ctx) {\n            // We'll flip the coin horizontally using scale\n            const scaleX = Math.abs(Math.cos(coinRotationRef.current * Math.PI * 2));\n            const halfSize = COIN_SIZE / 2;\n            for (const coin of coinsRef.current){\n                if (!coin.collected) {\n                    ctx.save();\n                    ctx.translate(coin.x + halfSize, coin.y + halfSize);\n                    ctx.scale(scaleX, 1); // Horizontal flip effect\n                    ctx.drawImage(coinImage, -halfSize, -halfSize, COIN_SIZE, COIN_SIZE);\n                    ctx.restore();\n                }\n            }\n        }\n        function createPipe(canvas) {\n            // Random top pipe height\n            const pipeHeight = Math.random() * (canvas.height - PIPE_SPACING - 100) + 50;\n            const bottomY = pipeHeight + PIPE_SPACING;\n            pipesRef.current.push({\n                x: canvas.width,\n                topHeight: pipeHeight,\n                bottomY,\n                bottomHeight: canvas.height - bottomY,\n                scored: false\n            });\n            // 50% chance to spawn a coin\n            if (Math.random() > 0.5) {\n                coinsRef.current.push({\n                    x: canvas.width + PIPE_WIDTH / 2 - COIN_SIZE / 2,\n                    y: pipeHeight + PIPE_SPACING / 2 - COIN_SIZE / 2,\n                    width: COIN_SIZE,\n                    height: COIN_SIZE,\n                    collected: false\n                });\n            }\n        }\n        function movePipesAndCoins(scale) {\n            // Move them to the left based on scale\n            for (const pipe of pipesRef.current){\n                pipe.x -= HORIZONTAL_SPEED * scale;\n            }\n            // Filter out pipes that have scrolled offscreen\n            pipesRef.current = pipesRef.current.filter((pipe)=>pipe.x + PIPE_WIDTH > 0);\n            for (const coin of coinsRef.current){\n                coin.x -= HORIZONTAL_SPEED * scale;\n            }\n            // Filter out coins that have scrolled offscreen or are collected\n            coinsRef.current = coinsRef.current.filter((coin)=>coin.x + coin.width > 0 && !coin.collected);\n        }\n        function checkCollisions(canvas) {\n            // Check top/bottom boundaries\n            if (birdYRef.current < 0 || birdYRef.current + BIRD_HEIGHT > canvas.height) {\n                return true;\n            }\n            const birdLeft = 100;\n            const birdRight = birdLeft + BIRD_WIDTH;\n            const birdTop = birdYRef.current;\n            const birdBottom = birdYRef.current + BIRD_HEIGHT;\n            // Pipe collision\n            for (const pipe of pipesRef.current){\n                const withinPipeX = birdRight > pipe.x && birdLeft < pipe.x + PIPE_WIDTH;\n                const withinPipeY = birdTop < pipe.topHeight || birdBottom > pipe.bottomY;\n                if (withinPipeX && withinPipeY) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function checkCoinCollection() {\n            const birdLeft = 100;\n            const birdRight = birdLeft + BIRD_WIDTH;\n            const birdTop = birdYRef.current;\n            const birdBottom = birdYRef.current + BIRD_HEIGHT;\n            for (const coin of coinsRef.current){\n                if (!coin.collected) {\n                    const coinLeft = coin.x;\n                    const coinRight = coin.x + coin.width;\n                    const coinTop = coin.y;\n                    const coinBottom = coin.y + coin.height;\n                    if (birdRight > coinLeft && birdLeft < coinRight && birdBottom > coinTop && birdTop < coinBottom) {\n                        // Collect coin\n                        coin.collected = true;\n                        setCurrentScore((prevScore)=>{\n                            const newScore = prevScore + 5;\n                            setHighScore((prevHighScore)=>Math.max(prevHighScore, newScore));\n                            return newScore;\n                        });\n                    }\n                }\n            }\n        }\n        function updateScore() {\n            for (const pipe of pipesRef.current){\n                // Score +1 for passing each pipe, only once\n                if (!pipe.scored && pipe.x + PIPE_WIDTH < 100) {\n                    pipe.scored = true;\n                    setCurrentScore((prevScore)=>{\n                        const newScore = prevScore + 1;\n                        setHighScore((prevHighScore)=>{\n                            const updatedHighScore = Math.max(prevHighScore, newScore);\n                            if (true) {\n                                localStorage.setItem(\"highScore\", updatedHighScore.toString());\n                            }\n                            return updatedHighScore;\n                        });\n                        return newScore;\n                    });\n                }\n            }\n        }\n        function draw(ctx, canvas) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawBackground(ctx, canvas);\n            drawBird(ctx);\n            drawPipes(ctx);\n            drawCoins(ctx);\n        }\n        function drawStartScreen(ctx, canvas) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawBackground(ctx, canvas);\n            ctx.font = \"bold 30px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.fillStyle = \"#ffffff\";\n            ctx.shadowColor = \"black\";\n            ctx.textBaseline = \"middle\";\n            ctx.fillText(\"Tap to Start\", canvas.width / 2, canvas.height / 2);\n        }\n        function drawGameOverScreen(ctx, canvas) {\n            ctx.fillStyle = \"#ffcc00\";\n            ctx.font = \"bold 50px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"middle\";\n            ctx.shadowColor = \"black\";\n            ctx.shadowBlur = 10;\n            ctx.fillText(\"Game Over!\", canvas.width / 2, canvas.height / 2 - 40);\n            ctx.fillStyle = \"#ffffff\";\n            ctx.font = \"bold 30px Arial\";\n            ctx.fillText(\"Tap to Restart\", canvas.width / 2, canvas.height / 2 + 20);\n        }\n        function drawBackground(ctx, canvas) {\n            ctx.drawImage(background, 0, 0, canvas.width, canvas.height);\n        }\n        function drawBird(ctx) {\n            const currentImage = birdImages[currentBirdFrameRef.current];\n            // Draw the bird at a fixed X (100) and current birdY\n            if (currentImage.complete) {\n                ctx.drawImage(currentImage, 100, birdYRef.current, BIRD_WIDTH, BIRD_HEIGHT);\n            }\n        }\n        function drawPipes(ctx) {\n            for (const pipe of pipesRef.current){\n                ctx.drawImage(pipeTop, pipe.x, 0, PIPE_WIDTH, pipe.topHeight);\n                ctx.drawImage(pipeBottom, pipe.x, pipe.bottomY, PIPE_WIDTH, pipe.bottomHeight);\n            }\n        }\n        function drawCoins(ctx) {\n            // We'll flip the coin horizontally using scale\n            const scaleX = Math.abs(Math.cos(coinRotationRef.current * Math.PI * 2));\n            const halfSize = COIN_SIZE / 2;\n            for (const coin of coinsRef.current){\n                if (!coin.collected) {\n                    ctx.save();\n                    ctx.translate(coin.x + halfSize, coin.y + halfSize);\n                    ctx.scale(scaleX, 1); // Horizontal flip effect\n                    ctx.drawImage(coinImage, -halfSize, -halfSize, COIN_SIZE, COIN_SIZE);\n                    ctx.restore();\n                }\n            }\n        }\n        function createPipe(canvas) {\n            // Random top pipe height\n            const pipeHeight = Math.random() * (canvas.height - PIPE_SPACING - 100) + 50;\n            const bottomY = pipeHeight + PIPE_SPACING;\n            pipesRef.current.push({\n                x: canvas.width,\n                topHeight: pipeHeight,\n                bottomY,\n                bottomHeight: canvas.height - bottomY,\n                scored: false\n            });\n            // 50% chance to spawn a coin\n            if (Math.random() > 0.5) {\n                coinsRef.current.push({\n                    x: canvas.width + PIPE_WIDTH / 2 - COIN_SIZE / 2,\n                    y: pipeHeight + PIPE_SPACING / 2 - COIN_SIZE / 2,\n                    width: COIN_SIZE,\n                    height: COIN_SIZE,\n                    collected: false\n                });\n            }\n        }\n        function movePipesAndCoins(scale) {\n            // Move them to the left based on scale\n            for (const pipe of pipesRef.current){\n                pipe.x -= HORIZONTAL_SPEED * scale;\n            }\n            // Filter out pipes that have scrolled offscreen\n            pipesRef.current = pipesRef.current.filter((pipe)=>pipe.x + PIPE_WIDTH > 0);\n            for (const coin of coinsRef.current){\n                coin.x -= HORIZONTAL_SPEED * scale;\n            }\n            // Filter out coins that have scrolled offscreen or are collected\n            coinsRef.current = coinsRef.current.filter((coin)=>coin.x + coin.width > 0 && !coin.collected);\n        }\n        function checkCollisions(canvas) {\n            // Check top/bottom boundaries\n            if (birdYRef.current < 0 || birdYRef.current + BIRD_HEIGHT > canvas.height) {\n                return true;\n            }\n            const birdLeft = 100;\n            const birdRight = birdLeft + BIRD_WIDTH;\n            const birdTop = birdYRef.current;\n            const birdBottom = birdYRef.current + BIRD_HEIGHT;\n            // Pipe collision\n            for (const pipe of pipesRef.current){\n                const withinPipeX = birdRight > pipe.x && birdLeft < pipe.x + PIPE_WIDTH;\n                const withinPipeY = birdTop < pipe.topHeight || birdBottom > pipe.bottomY;\n                if (withinPipeX && withinPipeY) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function checkCoinCollection() {\n            const birdLeft = 100;\n            const birdRight = birdLeft + BIRD_WIDTH;\n            const birdTop = birdYRef.current;\n            const birdBottom = birdYRef.current + BIRD_HEIGHT;\n            for (const coin of coinsRef.current){\n                if (!coin.collected) {\n                    const coinLeft = coin.x;\n                    const coinRight = coin.x + coin.width;\n                    const coinTop = coin.y;\n                    const coinBottom = coin.y + coin.height;\n                    if (birdRight > coinLeft && birdLeft < coinRight && birdBottom > coinTop && birdTop < coinBottom) {\n                        // Collect coin\n                        coin.collected = true;\n                        setCurrentScore((prevScore)=>{\n                            const newScore = prevScore + 5;\n                            setHighScore((prevHighScore)=>Math.max(prevHighScore, newScore));\n                            return newScore;\n                        });\n                    }\n                }\n            }\n        }\n        function updateScore() {\n            for (const pipe of pipesRef.current){\n                // Score +1 for passing each pipe, only once\n                if (!pipe.scored && pipe.x + PIPE_WIDTH < 100) {\n                    pipe.scored = true;\n                    setCurrentScore((prevScore)=>{\n                        const newScore = prevScore + 1;\n                        setHighScore((prevHighScore)=>{\n                            const updatedHighScore = Math.max(prevHighScore, newScore);\n                            if (true) {\n                                localStorage.setItem(\"highScore\", updatedHighScore.toString());\n                            }\n                            return updatedHighScore;\n                        });\n                        return newScore;\n                    });\n                }\n            }\n        }\n        function draw(ctx, canvas) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawBackground(ctx, canvas);\n            drawBird(ctx);\n            drawPipes(ctx);\n            drawCoins(ctx);\n        }\n        function drawStartScreen(ctx, canvas) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawBackground(ctx, canvas);\n            ctx.font = \"bold 30px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.fillStyle = \"#ffffff\";\n            ctx.shadowColor = \"black\";\n            ctx.textBaseline = \"middle\";\n            ctx.fillText(\"Tap to Start\", canvas.width / 2, canvas.height / 2);\n        }\n        function drawGameOverScreen(ctx, canvas) {\n            ctx.fillStyle = \"#ffcc00\";\n            ctx.font = \"bold 50px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"middle\";\n            ctx.shadowColor = \"black\";\n            ctx.shadowBlur = 10;\n            ctx.fillText(\"Game Over!\", canvas.width / 2, canvas.height / 2 - 40);\n            ctx.fillStyle = \"#ffffff\";\n            ctx.font = \"bold 30px Arial\";\n            ctx.fillText(\"Tap to Restart\", canvas.width / 2, canvas.height / 2 + 20);\n        }\n        function drawBackground(ctx, canvas) {\n            ctx.drawImage(background, 0, 0, canvas.width, canvas.height);\n        }\n        function drawBird(ctx) {\n            const currentImage = birdImages[currentBirdFrameRef.current];\n            // Draw the bird at a fixed X (100) and current birdY\n            if (currentImage.complete) {\n                ctx.drawImage(currentImage, 100, birdYRef.current, BIRD_WIDTH, BIRD_HEIGHT);\n            }\n        }\n        function drawPipes(ctx) {\n            for (const pipe of pipesRef.current){\n                ctx.drawImage(pipeTop, pipe.x, 0, PIPE_WIDTH, pipe.topHeight);\n                ctx.drawImage(pipeBottom, pipe.x, pipe.bottomY, PIPE_WIDTH, pipe.bottomHeight);\n            }\n        }\n        function drawCoins(ctx) {\n            // We'll flip the coin horizontally using scale\n            const scaleX = Math.abs(Math.cos(coinRotationRef.current * Math.PI * 2));\n            const halfSize = COIN_SIZE / 2;\n            for (const coin of coinsRef.current){\n                if (!coin.collected) {\n                    ctx.save();\n                    ctx.translate(coin.x + halfSize, coin.y + halfSize);\n                    ctx.scale(scaleX, 1); // Horizontal flip effect\n                    ctx.drawImage(coinImage, -halfSize, -halfSize, COIN_SIZE, COIN_SIZE);\n                    ctx.restore();\n                }\n            }\n        }\n        function createPipe(canvas) {\n            // Random top pipe height\n            const pipeHeight = Math.random() * (canvas.height - PIPE_SPACING - 100) + 50;\n            const bottomY = pipeHeight + PIPE_SPACING;\n            pipesRef.current.push({\n                x: canvas.width,\n                topHeight: pipeHeight,\n                bottomY,\n                bottomHeight: canvas.height - bottomY,\n                scored: false\n            });\n            // 50% chance to spawn a coin\n            if (Math.random() > 0.5) {\n                coinsRef.current.push({\n                    x: canvas.width + PIPE_WIDTH / 2 - COIN_SIZE / 2,\n                    y: pipeHeight + PIPE_SPACING / 2 - COIN_SIZE / 2,\n                    width: COIN_SIZE,\n                    height: COIN_SIZE,\n                    collected: false\n                });\n            }\n        }\n        function movePipesAndCoins(scale) {\n            // Move them to the left based on scale\n            for (const pipe of pipesRef.current){\n                pipe.x -= HORIZONTAL_SPEED * scale;\n            }\n            // Filter out pipes that have scrolled offscreen\n            pipesRef.current = pipesRef.current.filter((pipe)=>pipe.x + PIPE_WIDTH > 0);\n            for (const coin of coinsRef.current){\n                coin.x -= HORIZONTAL_SPEED * scale;\n            }\n            // Filter out coins that have scrolled offscreen or are collected\n            coinsRef.current = coinsRef.current.filter((coin)=>coin.x + coin.width > 0 && !coin.collected);\n        }\n        function checkCollisions(canvas) {\n            // Check top/bottom boundaries\n            if (birdYRef.current < 0 || birdYRef.current + BIRD_HEIGHT > canvas.height) {\n                return true;\n            }\n            const birdLeft = 100;\n            const birdRight = birdLeft + BIRD_WIDTH;\n            const birdTop = birdYRef.current;\n            const birdBottom = birdYRef.current + BIRD_HEIGHT;\n            // Pipe collision\n            for (const pipe of pipesRef.current){\n                const withinPipeX = birdRight > pipe.x && birdLeft < pipe.x + PIPE_WIDTH;\n                const withinPipeY = birdTop < pipe.topHeight || birdBottom > pipe.bottomY;\n                if (withinPipeX && withinPipeY) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function checkCoinCollection() {\n            const birdLeft = 100;\n            const birdRight = birdLeft + BIRD_WIDTH;\n            const birdTop = birdYRef.current;\n            const birdBottom = birdYRef.current + BIRD_HEIGHT;\n            for (const coin of coinsRef.current){\n                if (!coin.collected) {\n                    const coinLeft = coin.x;\n                    const coinRight = coin.x + coin.width;\n                    const coinTop = coin.y;\n                    const coinBottom = coin.y + coin.height;\n                    if (birdRight > coinLeft && birdLeft < coinRight && birdBottom > coinTop && birdTop < coinBottom) {\n                        // Collect coin\n                        coin.collected = true;\n                        setCurrentScore((prevScore)=>{\n                            const newScore = prevScore + 5;\n                            setHighScore((prevHighScore)=>Math.max(prevHighScore, newScore));\n                            return newScore;\n                        });\n                    }\n                }\n            }\n        }\n        function updateScore() {\n            for (const pipe of pipesRef.current){\n                // Score +1 for passing each pipe, only once\n                if (!pipe.scored && pipe.x + PIPE_WIDTH < 100) {\n                    pipe.scored = true;\n                    setCurrentScore((prevScore)=>{\n                        const newScore = prevScore + 1;\n                        setHighScore((prevHighScore)=>{\n                            const updatedHighScore = Math.max(prevHighScore, newScore);\n                            if (true) {\n                                localStorage.setItem(\"highScore\", updatedHighScore.toString());\n                            }\n                            return updatedHighScore;\n                        });\n                        return newScore;\n                    });\n                }\n            }\n        }\n        function draw(ctx, canvas) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawBackground(ctx, canvas);\n            drawBird(ctx);\n            drawPipes(ctx);\n            drawCoins(ctx);\n        }\n        function drawStartScreen(ctx, canvas) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawBackground(ctx, canvas);\n            ctx.font = \"bold 30px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.fillStyle = \"#ffffff\";\n            ctx.shadowColor = \"black\";\n            ctx.textBaseline = \"middle\";\n            ctx.fillText(\"Tap to Start\", canvas.width / 2, canvas.height / 2);\n        }\n        function drawGameOverScreen(ctx, canvas) {\n            ctx.fillStyle = \"#ffcc00\";\n            ctx.font = \"bold 50px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"middle\";\n            ctx.shadowColor = \"black\";\n            ctx.shadowBlur = 10;\n            ctx.fillText(\"Game Over!\", canvas.width / 2, canvas.height / 2 - 40);\n            ctx.fillStyle = \"#ffffff\";\n            ctx.font = \"bold 30px Arial\";\n            ctx.fillText(\"Tap to Restart\", canvas.width / 2, canvas.height / 2 + 20);\n        }\n        function drawBackground(ctx, canvas) {\n            ctx.drawImage(background, 0, 0, canvas.width, canvas.height);\n        }\n        function drawBird(ctx) {\n            const currentImage = birdImages[currentBirdFrameRef.current];\n            // Draw the bird at a fixed X (100) and current birdY\n            if (currentImage.complete) {\n                ctx.drawImage(currentImage, 100, birdYRef.current, BIRD_WIDTH, BIRD_HEIGHT);\n            }\n        }\n        function drawPipes(ctx) {\n            for (const pipe of pipesRef.current){\n                ctx.drawImage(pipeTop, pipe.x, 0, PIPE_WIDTH, pipe.topHeight);\n                ctx.drawImage(pipeBottom, pipe.x, pipe.bottomY, PIPE_WIDTH, pipe.bottomHeight);\n            }\n        }\n        function drawCoins(ctx) {\n            // We'll flip the coin horizontally using scale\n            const scaleX = Math.abs(Math.cos(coinRotationRef.current * Math.PI * 2));\n            const halfSize = COIN_SIZE / 2;\n            for (const coin of coinsRef.current){\n                if (!coin.collected) {\n                    ctx.save();\n                    ctx.translate(coin.x + halfSize, coin.y + halfSize);\n                    ctx.scale(scaleX, 1); // Horizontal flip effect\n                    ctx.drawImage(coinImage, -halfSize, -halfSize, COIN_SIZE, COIN_SIZE);\n                    ctx.restore();\n                }\n            }\n        }\n        function createPipe(canvas) {\n            // Random top pipe height\n            const pipeHeight = Math.random() * (canvas.height - PIPE_SPACING - 100) + 50;\n            const bottomY = pipeHeight + PIPE_SPACING;\n            pipesRef.current.push({\n                x: canvas.width,\n                topHeight: pipeHeight,\n                bottomY,\n                bottomHeight: canvas.height - bottomY,\n                scored: false\n            });\n            // 50% chance to spawn a coin\n            if (Math.random() > 0.5) {\n                coinsRef.current.push({\n                    x: canvas.width + PIPE_WIDTH / 2 - COIN_SIZE / 2,\n                    y: pipeHeight + PIPE_SPACING / 2 - COIN_SIZE / 2,\n                    width: COIN_SIZE,\n                    height: COIN_SIZE,\n                    collected: false\n                });\n            }\n        }\n        function movePipesAndCoins(scale) {\n            // Move them to the left based on scale\n            for (const pipe of pipesRef.current){\n                pipe.x -= HORIZONTAL_SPEED * scale;\n            }\n            // Filter out pipes that have scrolled offscreen\n            pipesRef.current = pipesRef.current.filter((pipe)=>pipe.x + PIPE_WIDTH > 0);\n            for (const coin of coinsRef.current){\n                coin.x -= HORIZONTAL_SPEED * scale;\n            }\n            // Filter out coins that have scrolled offscreen or are collected\n            coinsRef.current = coinsRef.current.filter((coin)=>coin.x + coin.width > 0 && !coin.collected);\n        }\n        function checkCollisions(canvas) {\n            // Check top/bottom boundaries\n            if (birdYRef.current < 0 || birdYRef.current + BIRD_HEIGHT > canvas.height) {\n                return true;\n            }\n            const birdLeft = 100;\n            const birdRight = birdLeft + BIRD_WIDTH;\n            const birdTop = birdYRef.current;\n            const birdBottom = birdYRef.current + BIRD_HEIGHT;\n            // Pipe collision\n            for (const pipe of pipesRef.current){\n                const withinPipeX = birdRight > pipe.x && birdLeft < pipe.x + PIPE_WIDTH;\n                const withinPipeY = birdTop < pipe.topHeight || birdBottom > pipe.bottomY;\n                if (withinPipeX && withinPipeY) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function checkCoinCollection() {\n            const birdLeft = 100;\n            const birdRight = birdLeft + BIRD_WIDTH;\n            const birdTop = birdYRef.current;\n            const birdBottom = birdYRef.current + BIRD_HEIGHT;\n            for (const coin of coinsRef.current){\n                if (!coin.collected) {\n                    const coinLeft = coin.x;\n                    const coinRight = coin.x + coin.width;\n                    const coinTop = coin.y;\n                    const coinBottom = coin.y + coin.height;\n                    if (birdRight > coinLeft && birdLeft < coinRight && birdBottom > coinTop && birdTop < coinBottom) {\n                        // Collect coin\n                        coin.collected = true;\n                        setCurrentScore((prevScore)=>{\n                            const newScore = prevScore + 5;\n                            setHighScore((prevHighScore)=>Math.max(prevHighScore, newScore));\n                            return newScore;\n                        });\n                    }\n                }\n            }\n        }\n        function updateScore() {\n            for (const pipe of pipesRef.current){\n                // Score +1 for passing each pipe, only once\n                if (!pipe.scored && pipe.x + PIPE_WIDTH < 100) {\n                    pipe.scored = true;\n                    setCurrentScore((prevScore)=>{\n                        const newScore = prevScore + 1;\n                        setHighScore((prevHighScore)=>{\n                            const updatedHighScore = Math.max(prevHighScore, newScore);\n                            if (true) {\n                                localStorage.setItem(\"highScore\", updatedHighScore.toString());\n                            }\n                            return updatedHighScore;\n                        });\n                        return newScore;\n                    });\n                }\n            }\n        }\n        // Event Listeners for Touch and Click Inputs\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            const canvas = canvasRef.current;\n            if (!canvas) return;\n            let lastTap = 0;\n            const handleInput = (e)=>{\n                e.preventDefault(); // Prevent default to avoid duplicate events\n                const currentTime = new Date().getTime();\n                const tapLength = currentTime - lastTap;\n                clearTimeout(this.timeout);\n                if (tapLength < 300 && tapLength > 0) {\n                    // Double tap, ignore\n                    return;\n                } else {\n                    flap1();\n                }\n                lastTap = currentTime;\n            };\n            canvas.addEventListener(\"touchstart\", handleInput);\n            canvas.addEventListener(\"mousedown\", handleInput);\n            return ()=>{\n                canvas.removeEventListener(\"touchstart\", handleInput);\n                canvas.removeEventListener(\"mousedown\", handleInput);\n            };\n        }, [\n            canvasRef,\n            isPaused,\n            autoStart\n        ]);\n        // Cleanup on unmount\n        return ()=>{\n            if (requestIdRef.current) {\n                cancelAnimationFrame(requestIdRef.current);\n            }\n        };\n    }, [\n        canvasRef,\n        isPaused,\n        autoStart\n    ]);\n    // Provide a stable reference for user input (tap/click)\n    // Removed handleUserInput as it's no longer needed\n    return {\n        highScore,\n        currentScore,\n        flap\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFJQyxhQUFhOEIsT0FBTyxFQUFFO2dCQUN4QjBHLHFCQUFxQnhJLGFBQWE4QixPQUFPO1lBQzNDO1FBQ0Y7SUFDRixHQUFHO1FBQUNqQztRQUFXQztRQUFVQztLQUFVO0lBRW5DLHdEQUF3RDtJQUN4RCxtREFBbUQ7SUFFbkQsT0FBTztRQUNMRTtRQUNBRTtRQUNBcUQ7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3B1YmxpYy91c2VGbGFwcHlCaXJkR2FtZS50cz81Yzc4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGhvb2tzL3VzZUZsYXBweUJpcmRHYW1lLnRzXHJcblxyXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcclxuXHJcbi8vIFR5cGVzIGZvciBnYW1lIG9iamVjdHNcclxuaW50ZXJmYWNlIFBpcGUge1xyXG4gIHg6IG51bWJlcjtcclxuICB0b3BIZWlnaHQ6IG51bWJlcjtcclxuICBib3R0b21ZOiBudW1iZXI7XHJcbiAgYm90dG9tSGVpZ2h0OiBudW1iZXI7XHJcbiAgc2NvcmVkOiBib29sZWFuO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgQ29pbiB7XHJcbiAgeDogbnVtYmVyO1xyXG4gIHk6IG51bWJlcjtcclxuICB3aWR0aDogbnVtYmVyO1xyXG4gIGhlaWdodDogbnVtYmVyO1xyXG4gIGNvbGxlY3RlZDogYm9vbGVhbjtcclxufVxyXG5cclxuLy8gQ29uc3RhbnRzXHJcbmNvbnN0IEdSQVZJVFkgPSAwLjc7XHJcbmNvbnN0IEZMQVAgPSAtMTE7XHJcbmNvbnN0IFBJUEVfV0lEVEggPSA5MDtcclxuY29uc3QgUElQRV9TUEFDSU5HID0gMjMwO1xyXG5jb25zdCBCSVJEX1dJRFRIID0gNTA7XHJcbmNvbnN0IEJJUkRfSEVJR0hUID0gNTA7XHJcbmNvbnN0IENPSU5fU0laRSA9IDEwMDtcclxuXHJcbi8vIEhvdyBsb25nIGJldHdlZW4gcGlwZSBzcGF3bnMgKGluIG1pbGxpc2Vjb25kcykuIH4xLjY2cyA9PiAxNjY3bXNcclxuY29uc3QgUElQRV9TUEFXTl9JTlRFUlZBTCA9IDEwMDA7XHJcblxyXG4vLyBIb3Jpem9udGFsIHNwZWVkIChwaXhlbHMgcGVyIFwiNjBmcHNcIiBmcmFtZSkuIFdlJ2xsIHNjYWxlIGl0IGJ5IChkZWx0YVRpbWUvMTYuNjcpLlxyXG5jb25zdCBIT1JJWk9OVEFMX1NQRUVEID0gNDtcclxuXHJcbi8vIFJvdGF0aW9uIHNwZWVkIG9mIGNvaW4gKGNvbXBsZXRlIGZsaXAgZnJvbSBzY2FsZSAxIHRvIDAgdG8gMSkuIDEgPSBmdWxsIGN5Y2xlLlxyXG5jb25zdCBST1RBVElPTl9TUEVFRCA9IDAuMDE7XHJcblxyXG4vLyBBIHNtYWxsIGNvbnN0YW50IHJlcHJlc2VudGluZyB0aGUgXCJpZGVhbCBmcmFtZVwiIGZvciBzY2FsaW5nIGNhbGN1bGF0aW9ucyAoYWJvdXQgNjBmcHMpLlxyXG5jb25zdCBJREVBTF9GUkFNRSA9IDE2LjY3OyAvLyBtc1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUZsYXBweUJpcmRHYW1lKFxyXG4gIGNhbnZhc1JlZjogUmVhY3QuUmVmT2JqZWN0PEhUTUxDYW52YXNFbGVtZW50PixcclxuICBpc1BhdXNlZDogYm9vbGVhbixcclxuICBhdXRvU3RhcnQ6IGJvb2xlYW5cclxuKSB7XHJcbiAgY29uc3QgcmVxdWVzdElkUmVmID0gdXNlUmVmPG51bWJlciB8IG51bGw+KG51bGwpO1xyXG5cclxuICAvLyBTdGF0ZVxyXG4gIGNvbnN0IFtoaWdoU2NvcmUsIHNldEhpZ2hTY29yZV0gPSB1c2VTdGF0ZSgwKTtcclxuICBjb25zdCBbY3VycmVudFNjb3JlLCBzZXRDdXJyZW50U2NvcmVdID0gdXNlU3RhdGUoMCk7XHJcblxyXG4gIC8vIFJlZnMgdG8gdHJhY2sgZ2FtZSBzdGF0ZVxyXG4gIGNvbnN0IGJpcmRZUmVmID0gdXNlUmVmPG51bWJlcj4oMCk7XHJcbiAgY29uc3QgYmlyZFZlbG9jaXR5UmVmID0gdXNlUmVmPG51bWJlcj4oMCk7XHJcbiAgY29uc3QgcGlwZXNSZWYgPSB1c2VSZWY8UGlwZVtdPihbXSk7XHJcbiAgY29uc3QgY29pbnNSZWYgPSB1c2VSZWY8Q29pbltdPihbXSk7XHJcbiAgY29uc3QgZ2FtZU92ZXJSZWYgPSB1c2VSZWY8Ym9vbGVhbj4oZmFsc2UpO1xyXG4gIGNvbnN0IGdhbWVTdGFydGVkUmVmID0gdXNlUmVmPGJvb2xlYW4+KGZhbHNlKTtcclxuXHJcbiAgLy8gRm9yIGNvaW4gcm90YXRpb25cclxuICBjb25zdCBjb2luUm90YXRpb25SZWYgPSB1c2VSZWY8bnVtYmVyPigwKTtcclxuXHJcbiAgLy8gVHJhY2sgdGltZSBmb3Igc3Bhd25pbmcgcGlwZXNcclxuICBjb25zdCBwaXBlU3Bhd25UaW1lclJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xyXG5cclxuICAvLyBXZSdsbCB0cmFjayB0aGUgcHJldmlvdXMgdGltZXN0YW1wIGZvciB0aW1lLWJhc2VkIG1vdmVtZW50XHJcbiAgY29uc3QgbGFzdFRpbWVSZWYgPSB1c2VSZWY8bnVtYmVyPigwKTtcclxuXHJcbiAgLy8gQmlyZCBhbmltYXRpb24gZnJhbWVzXHJcbiAgbGV0IGJpcmRJbWFnZXM6IEhUTUxJbWFnZUVsZW1lbnRbXSA9IFtdO1xyXG4gIGxldCBwaXBlVG9wOiBIVE1MSW1hZ2VFbGVtZW50O1xyXG4gIGxldCBwaXBlQm90dG9tOiBIVE1MSW1hZ2VFbGVtZW50O1xyXG4gIGxldCBiYWNrZ3JvdW5kOiBIVE1MSW1hZ2VFbGVtZW50O1xyXG4gIGxldCBjb2luSW1hZ2U6IEhUTUxJbWFnZUVsZW1lbnQ7XHJcblxyXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICBjb25zdCBiaXJkVXAgPSBuZXcgSW1hZ2UoKTtcclxuICAgIGJpcmRVcC5zcmMgPSBcIi9hc3NldHMvcmVkYmlyZC11cGZsYXAucG5nXCI7XHJcblxyXG4gICAgY29uc3QgYmlyZE1pZCA9IG5ldyBJbWFnZSgpO1xyXG4gICAgYmlyZE1pZC5zcmMgPSBcIi9hc3NldHMvcmVkYmlyZC1taWRmbGFwLnBuZ1wiO1xyXG5cclxuICAgIGNvbnN0IGJpcmREb3duID0gbmV3IEltYWdlKCk7XHJcbiAgICBiaXJkRG93bi5zcmMgPSBcIi9hc3NldHMvcmVkYmlyZC1kb3duZmxhcC5wbmdcIjtcclxuXHJcbiAgICBiaXJkSW1hZ2VzID0gW2JpcmRVcCwgYmlyZE1pZCwgYmlyZERvd25dO1xyXG5cclxuICAgIHBpcGVUb3AgPSBuZXcgSW1hZ2UoKTtcclxuICAgIHBpcGVUb3Auc3JjID0gXCIvYXNzZXRzL1RvcFRpbnkucG5nXCI7XHJcblxyXG4gICAgcGlwZUJvdHRvbSA9IG5ldyBJbWFnZSgpO1xyXG4gICAgcGlwZUJvdHRvbS5zcmMgPSBcIi9hc3NldHMvQm90dG9tVGlueS5wbmdcIjtcclxuXHJcbiAgICBiYWNrZ3JvdW5kID0gbmV3IEltYWdlKCk7XHJcbiAgICBiYWNrZ3JvdW5kLnNyYyA9IFwiL2Fzc2V0cy9iYWNrZ3JvdW5kLWRheS5wbmdcIjtcclxuXHJcbiAgICBjb2luSW1hZ2UgPSBuZXcgSW1hZ2UoKTtcclxuICAgIGNvaW5JbWFnZS5zcmMgPSBcIi9hc3NldHMvQ29pblRpbnkucG5nXCI7XHJcbiAgfVxyXG5cclxuICAvLyBDdXJyZW50IGJpcmQgZnJhbWUgaW5kZXggKDA9dXAsIDE9bWlkLCAyPWRvd24pLiBXZSdsbCBrZWVwIHRoZSBxdWljayBmbGFwIGNvZGUuXHJcbiAgY29uc3QgY3VycmVudEJpcmRGcmFtZVJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xyXG5cclxuICAvLyBMb2FkIGhpZ2ggc2NvcmUgZnJvbSBsb2NhbFN0b3JhZ2Ugb24gbW91bnRcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgY29uc3Qgc3RvcmVkSGlnaFNjb3JlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJoaWdoU2NvcmVcIik7XHJcbiAgICAgIGlmIChzdG9yZWRIaWdoU2NvcmUpIHtcclxuICAgICAgICBzZXRIaWdoU2NvcmUocGFyc2VJbnQoc3RvcmVkSGlnaFNjb3JlLCAxMCkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSwgW10pO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XHJcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICBpZiAoIWN0eCkgcmV0dXJuO1xyXG5cclxuICAgIC8vIFV0aWxpdHkgdG8gZW5zdXJlIGFuIGltYWdlIGlzIGZ1bGx5IGxvYWRlZFxyXG4gICAgY29uc3QgbG9hZEltYWdlID0gKGltZzogSFRNTEltYWdlRWxlbWVudCk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIGlmIChpbWcuY29tcGxldGUpIHtcclxuICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHJlc29sdmUoKTtcclxuICAgICAgICAgIGltZy5vbmVycm9yID0gKCkgPT5cclxuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgaW1hZ2U6ICR7aW1nLnNyY31gKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gTG9hZCBhbGwgYXNzZXRzIHRoZW4gaW5pdFxyXG4gICAgY29uc3QgbG9hZEFzc2V0cyA9IGFzeW5jICgpID0+IHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgICAuLi5iaXJkSW1hZ2VzLm1hcCgoaW1nKSA9PiBsb2FkSW1hZ2UoaW1nKSksXHJcbiAgICAgICAgICBsb2FkSW1hZ2UocGlwZVRvcCksXHJcbiAgICAgICAgICBsb2FkSW1hZ2UocGlwZUJvdHRvbSksXHJcbiAgICAgICAgICBsb2FkSW1hZ2UoYmFja2dyb3VuZCksXHJcbiAgICAgICAgICBsb2FkSW1hZ2UoY29pbkltYWdlKSxcclxuICAgICAgICBdKTtcclxuICAgICAgICBpbml0aWFsaXplR2FtZSgpO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsb2FkaW5nIGFzc2V0czpcIiwgZXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGxvYWRBc3NldHMoKTtcclxuXHJcbiAgICBmdW5jdGlvbiBpbml0aWFsaXplR2FtZSgpIHtcclxuICAgICAgaWYgKCFjYW52YXNSZWYuY3VycmVudCkgcmV0dXJuO1xyXG4gICAgICBpZiAoIWN0eCkgcmV0dXJuO1xyXG4gICAgICAvLyBGaXhlZCBjYW52YXMgc2l6ZVxyXG4gICAgICBjYW52YXNSZWYuY3VycmVudC53aWR0aCA9IDM2MDtcclxuICAgICAgY2FudmFzUmVmLmN1cnJlbnQuaGVpZ2h0ID0gNjQwO1xyXG4gICAgICBkcmF3U3RhcnRTY3JlZW4oY3R4LCBjYW52YXNSZWYuY3VycmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVzZXRHYW1lKCkge1xyXG4gICAgICBpZiAoIWNhbnZhc1JlZi5jdXJyZW50KSByZXR1cm47XHJcbiAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gY2FudmFzUmVmLmN1cnJlbnQ7XHJcbiAgICAgIGJpcmRZUmVmLmN1cnJlbnQgPSBoZWlnaHQgLyAzO1xyXG4gICAgICBiaXJkVmVsb2NpdHlSZWYuY3VycmVudCA9IDA7XHJcbiAgICAgIHBpcGVzUmVmLmN1cnJlbnQgPSBbXTtcclxuICAgICAgY29pbnNSZWYuY3VycmVudCA9IFtdO1xyXG4gICAgICBzZXRDdXJyZW50U2NvcmUoMCk7XHJcbiAgICAgIGdhbWVPdmVyUmVmLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgICAgZ2FtZVN0YXJ0ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xyXG4gICAgICBjb2luUm90YXRpb25SZWYuY3VycmVudCA9IDA7XHJcbiAgICAgIHBpcGVTcGF3blRpbWVyUmVmLmN1cnJlbnQgPSAwO1xyXG4gICAgICBjdXJyZW50QmlyZEZyYW1lUmVmLmN1cnJlbnQgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFN0YXJ0IGdhbWVcclxuICAgIGZ1bmN0aW9uIHN0YXJ0R2FtZSgpIHtcclxuICAgICAgcmVzZXRHYW1lKCk7XHJcbiAgICAgIGdhbWVTdGFydGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xyXG4gICAgICBsYXN0VGltZVJlZi5jdXJyZW50ID0gcGVyZm9ybWFuY2Uubm93KCk7IC8vIHJlc2V0IG91ciB0aW1lLWJhc2VkIHJlZmVyZW5jZVxyXG4gICAgICBhbmltYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRmxhcCBmdW5jdGlvbiB0byBiZSBjYWxsZWQgZGlyZWN0bHlcclxuICAgIGZ1bmN0aW9uIGZsYXAoKSB7XHJcbiAgICAgIGlmICghZ2FtZVN0YXJ0ZWRSZWYuY3VycmVudCAmJiAhZ2FtZU92ZXJSZWYuY3VycmVudCkge1xyXG4gICAgICAgIHN0YXJ0R2FtZSgpO1xyXG4gICAgICB9IGVsc2UgaWYgKGdhbWVPdmVyUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBzdGFydEdhbWUoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBiaXJkVmVsb2NpdHlSZWYuY3VycmVudCA9IEZMQVA7XHJcbiAgICAgICAgZmxhcEFuaW1hdGlvbigpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUXVpY2sgZmxhcCBhbmltYXRpb25cclxuICAgIGZ1bmN0aW9uIGZsYXBBbmltYXRpb24oKSB7XHJcbiAgICAgIGN1cnJlbnRCaXJkRnJhbWVSZWYuY3VycmVudCA9IDE7XHJcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIGN1cnJlbnRCaXJkRnJhbWVSZWYuY3VycmVudCA9IDI7XHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICBjdXJyZW50QmlyZEZyYW1lUmVmLmN1cnJlbnQgPSAwO1xyXG4gICAgICAgIH0sIDE3MCk7XHJcbiAgICAgIH0sIDE3MCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTWFpbiBnYW1lIGxvb3BcclxuICAgIGZ1bmN0aW9uIGFuaW1hdGUoY3VycmVudFRpbWU/OiBudW1iZXIpIHtcclxuICAgICAgaWYgKCFnYW1lU3RhcnRlZFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgLy8gSWYgZ2FtZSBoYXNuJ3Qgc3RhcnRlZCwganVzdCBzY2hlZHVsZSB0aGUgbmV4dCBmcmFtZVxyXG4gICAgICAgIHJlcXVlc3RJZFJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaXNQYXVzZWQpIHtcclxuICAgICAgICAvLyBJZiBwYXVzZWQsIGp1c3Qgc2NoZWR1bGUgdGhlIG5leHQgZnJhbWVcclxuICAgICAgICByZXF1ZXN0SWRSZWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFjYW52YXNSZWYuY3VycmVudCkgcmV0dXJuO1xyXG4gICAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzUmVmLmN1cnJlbnQuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgICBpZiAoIWNvbnRleHQpIHJldHVybjtcclxuXHJcbiAgICAgIC8vIENvbXB1dGUgZGVsdGFUaW1lXHJcbiAgICAgIGNvbnN0IG5vdyA9IGN1cnJlbnRUaW1lID8/IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICBjb25zdCBkZWx0YVRpbWUgPSBub3cgLSBsYXN0VGltZVJlZi5jdXJyZW50O1xyXG4gICAgICBsYXN0VGltZVJlZi5jdXJyZW50ID0gbm93O1xyXG5cclxuICAgICAgLy8gVXBkYXRlIHRoZSBnYW1lIHN0YXRlXHJcbiAgICAgIHVwZGF0ZUdhbWVTdGF0ZShjYW52YXNSZWYuY3VycmVudCwgZGVsdGFUaW1lKTtcclxuXHJcbiAgICAgIC8vIFJlbmRlclxyXG4gICAgICBkcmF3KGNvbnRleHQsIGNhbnZhc1JlZi5jdXJyZW50KTtcclxuXHJcbiAgICAgIGlmICghZ2FtZU92ZXJSZWYuY3VycmVudCkge1xyXG4gICAgICAgIHJlcXVlc3RJZFJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRyYXdHYW1lT3ZlclNjcmVlbihjb250ZXh0LCBjYW52YXNSZWYuY3VycmVudCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVHYW1lU3RhdGUoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgZGVsdGFUaW1lOiBudW1iZXIpIHtcclxuICAgICAgLy8gU2NhbGUgZmFjdG9yIHJlbGF0aXZlIHRvIH42MGZwcyA9IDE2LjY3bXMgcGVyIGZyYW1lXHJcbiAgICAgIGNvbnN0IHNjYWxlID0gZGVsdGFUaW1lIC8gSURFQUxfRlJBTUU7XHJcblxyXG4gICAgICAvLyBHcmF2aXR5XHJcbiAgICAgIGJpcmRWZWxvY2l0eVJlZi5jdXJyZW50ICs9IEdSQVZJVFkgKiBzY2FsZTtcclxuICAgICAgYmlyZFlSZWYuY3VycmVudCArPSBiaXJkVmVsb2NpdHlSZWYuY3VycmVudCAqIHNjYWxlO1xyXG5cclxuICAgICAgLy8gVXBkYXRlIHBpcGUgc3Bhd24gdGltZXJcclxuICAgICAgcGlwZVNwYXduVGltZXJSZWYuY3VycmVudCArPSBkZWx0YVRpbWU7XHJcbiAgICAgIGlmIChwaXBlU3Bhd25UaW1lclJlZi5jdXJyZW50ID49IFBJUEVfU1BBV05fSU5URVJWQUwpIHtcclxuICAgICAgICBwaXBlU3Bhd25UaW1lclJlZi5jdXJyZW50IC09IFBJUEVfU1BBV05fSU5URVJWQUw7XHJcbiAgICAgICAgY3JlYXRlUGlwZShjYW52YXMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBNb3ZlIHBpcGVzICYgY29pbnNcclxuICAgICAgbW92ZVBpcGVzQW5kQ29pbnMoc2NhbGUpO1xyXG5cclxuICAgICAgLy8gUm90YXRlIGNvaW4gKDAgLT4gMSBpcyBhIGZ1bGwgY3ljbGUgaW4gb3VyIHVzYWdlKVxyXG4gICAgICBjb2luUm90YXRpb25SZWYuY3VycmVudCArPSBST1RBVElPTl9TUEVFRCAqIHNjYWxlO1xyXG4gICAgICBpZiAoY29pblJvdGF0aW9uUmVmLmN1cnJlbnQgPj0gMSkge1xyXG4gICAgICAgIGNvaW5Sb3RhdGlvblJlZi5jdXJyZW50ID0gMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2hlY2sgY29sbGlzaW9uc1xyXG4gICAgICBpZiAoY2hlY2tDb2xsaXNpb25zKGNhbnZhcykpIHtcclxuICAgICAgICBnYW1lT3ZlclJlZi5jdXJyZW50ID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoZWNrIGNvaW4gY29sbGVjdGlvblxyXG4gICAgICBjaGVja0NvaW5Db2xsZWN0aW9uKCk7XHJcblxyXG4gICAgICAvLyBVcGRhdGUgc2NvcmUgaWYgd2UgcGFzcyBwaXBlc1xyXG4gICAgICB1cGRhdGVTY29yZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXcoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcclxuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICBkcmF3QmFja2dyb3VuZChjdHgsIGNhbnZhcyk7XHJcbiAgICAgIGRyYXdCaXJkKGN0eCk7XHJcbiAgICAgIGRyYXdQaXBlcyhjdHgpO1xyXG4gICAgICBkcmF3Q29pbnMoY3R4KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3U3RhcnRTY3JlZW4oY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcclxuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICBkcmF3QmFja2dyb3VuZChjdHgsIGNhbnZhcyk7XHJcblxyXG4gICAgICBjdHguZm9udCA9IFwiYm9sZCAzMHB4IEFyaWFsXCI7XHJcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xyXG4gICAgICBjdHguZmlsbFN0eWxlID0gXCIjZmZmZmZmXCI7XHJcbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFwiYmxhY2tcIjtcclxuICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XHJcblxyXG4gICAgICBjdHguZmlsbFRleHQoXHJcbiAgICAgICAgXCJUYXAgdG8gU3RhcnRcIixcclxuICAgICAgICBjYW52YXMud2lkdGggLyAyLFxyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgLyAyXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd0dhbWVPdmVyU2NyZWVuKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNmZmNjMDBcIjtcclxuICAgICAgY3R4LmZvbnQgPSBcImJvbGQgNTBweCBBcmlhbFwiO1xyXG4gICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcclxuICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XHJcbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFwiYmxhY2tcIjtcclxuICAgICAgY3R4LnNoYWRvd0JsdXIgPSAxMDtcclxuXHJcbiAgICAgIGN0eC5maWxsVGV4dChcIkdhbWUgT3ZlciFcIiwgY2FudmFzLndpZHRoIC8gMiwgY2FudmFzLmhlaWdodCAvIDIgLSA0MCk7XHJcblxyXG4gICAgICBjdHguZmlsbFN0eWxlID0gXCIjZmZmZmZmXCI7XHJcbiAgICAgIGN0eC5mb250ID0gXCJib2xkIDMwcHggQXJpYWxcIjtcclxuICAgICAgY3R4LmZpbGxUZXh0KFxyXG4gICAgICAgIFwiVGFwIHRvIFJlc3RhcnRcIixcclxuICAgICAgICBjYW52YXMud2lkdGggLyAyLFxyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgLyAyICsgMjBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3QmFja2dyb3VuZChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkge1xyXG4gICAgICBjdHguZHJhd0ltYWdlKGJhY2tncm91bmQsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd0JpcmQoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcclxuICAgICAgY29uc3QgY3VycmVudEltYWdlID0gYmlyZEltYWdlc1tjdXJyZW50QmlyZEZyYW1lUmVmLmN1cnJlbnRdO1xyXG4gICAgICAvLyBEcmF3IHRoZSBiaXJkIGF0IGEgZml4ZWQgWCAoMTAwKSBhbmQgY3VycmVudCBiaXJkWVxyXG4gICAgICBpZiAoY3VycmVudEltYWdlLmNvbXBsZXRlKSB7XHJcbiAgICAgICAgY3R4LmRyYXdJbWFnZShjdXJyZW50SW1hZ2UsIDEwMCwgYmlyZFlSZWYuY3VycmVudCwgQklSRF9XSURUSCwgQklSRF9IRUlHSFQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd1BpcGVzKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XHJcbiAgICAgIGZvciAoY29uc3QgcGlwZSBvZiBwaXBlc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY3R4LmRyYXdJbWFnZShwaXBlVG9wLCBwaXBlLngsIDAsIFBJUEVfV0lEVEgsIHBpcGUudG9wSGVpZ2h0KTtcclxuICAgICAgICBjdHguZHJhd0ltYWdlKHBpcGVCb3R0b20sIHBpcGUueCwgcGlwZS5ib3R0b21ZLCBQSVBFX1dJRFRILCBwaXBlLmJvdHRvbUhlaWdodCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3Q29pbnMoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcclxuICAgICAgLy8gV2UnbGwgZmxpcCB0aGUgY29pbiBob3Jpem9udGFsbHkgdXNpbmcgc2NhbGVcclxuICAgICAgY29uc3Qgc2NhbGVYID0gTWF0aC5hYnMoTWF0aC5jb3MoY29pblJvdGF0aW9uUmVmLmN1cnJlbnQgKiBNYXRoLlBJICogMikpO1xyXG4gICAgICBjb25zdCBoYWxmU2l6ZSA9IENPSU5fU0laRSAvIDI7XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGNvaW4gb2YgY29pbnNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGlmICghY29pbi5jb2xsZWN0ZWQpIHtcclxuICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICBjdHgudHJhbnNsYXRlKGNvaW4ueCArIGhhbGZTaXplLCBjb2luLnkgKyBoYWxmU2l6ZSk7XHJcbiAgICAgICAgICBjdHguc2NhbGUoc2NhbGVYLCAxKTsgLy8gSG9yaXpvbnRhbCBmbGlwIGVmZmVjdFxyXG4gICAgICAgICAgY3R4LmRyYXdJbWFnZShjb2luSW1hZ2UsIC1oYWxmU2l6ZSwgLWhhbGZTaXplLCBDT0lOX1NJWkUsIENPSU5fU0laRSk7XHJcbiAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBpcGUoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkge1xyXG4gICAgICAvLyBSYW5kb20gdG9wIHBpcGUgaGVpZ2h0XHJcbiAgICAgIGNvbnN0IHBpcGVIZWlnaHQgPSBNYXRoLnJhbmRvbSgpICogKGNhbnZhcy5oZWlnaHQgLSBQSVBFX1NQQUNJTkcgLSAxMDApICsgNTA7XHJcbiAgICAgIGNvbnN0IGJvdHRvbVkgPSBwaXBlSGVpZ2h0ICsgUElQRV9TUEFDSU5HO1xyXG4gICAgICBwaXBlc1JlZi5jdXJyZW50LnB1c2goe1xyXG4gICAgICAgIHg6IGNhbnZhcy53aWR0aCxcclxuICAgICAgICB0b3BIZWlnaHQ6IHBpcGVIZWlnaHQsXHJcbiAgICAgICAgYm90dG9tWSxcclxuICAgICAgICBib3R0b21IZWlnaHQ6IGNhbnZhcy5oZWlnaHQgLSBib3R0b21ZLFxyXG4gICAgICAgIHNjb3JlZDogZmFsc2UsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gNTAlIGNoYW5jZSB0byBzcGF3biBhIGNvaW5cclxuICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPiAwLjUpIHtcclxuICAgICAgICBjb2luc1JlZi5jdXJyZW50LnB1c2goe1xyXG4gICAgICAgICAgeDogY2FudmFzLndpZHRoICsgUElQRV9XSURUSCAvIDIgLSBDT0lOX1NJWkUgLyAyLFxyXG4gICAgICAgICAgeTogcGlwZUhlaWdodCArIFBJUEVfU1BBQ0lORyAvIDIgLSBDT0lOX1NJWkUgLyAyLFxyXG4gICAgICAgICAgd2lkdGg6IENPSU5fU0laRSxcclxuICAgICAgICAgIGhlaWdodDogQ09JTl9TSVpFLFxyXG4gICAgICAgICAgY29sbGVjdGVkOiBmYWxzZSxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1vdmVQaXBlc0FuZENvaW5zKHNjYWxlOiBudW1iZXIpIHtcclxuICAgICAgLy8gTW92ZSB0aGVtIHRvIHRoZSBsZWZ0IGJhc2VkIG9uIHNjYWxlXHJcbiAgICAgIGZvciAoY29uc3QgcGlwZSBvZiBwaXBlc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgcGlwZS54IC09IEhPUklaT05UQUxfU1BFRUQgKiBzY2FsZTtcclxuICAgICAgfVxyXG4gICAgICAvLyBGaWx0ZXIgb3V0IHBpcGVzIHRoYXQgaGF2ZSBzY3JvbGxlZCBvZmZzY3JlZW5cclxuICAgICAgcGlwZXNSZWYuY3VycmVudCA9IHBpcGVzUmVmLmN1cnJlbnQuZmlsdGVyKChwaXBlKSA9PiBwaXBlLnggKyBQSVBFX1dJRFRIID4gMCk7XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGNvaW4gb2YgY29pbnNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGNvaW4ueCAtPSBIT1JJWk9OVEFMX1NQRUVEICogc2NhbGU7XHJcbiAgICAgIH1cclxuICAgICAgLy8gRmlsdGVyIG91dCBjb2lucyB0aGF0IGhhdmUgc2Nyb2xsZWQgb2Zmc2NyZWVuIG9yIGFyZSBjb2xsZWN0ZWRcclxuICAgICAgY29pbnNSZWYuY3VycmVudCA9IGNvaW5zUmVmLmN1cnJlbnQuZmlsdGVyKFxyXG4gICAgICAgIChjb2luKSA9PiBjb2luLnggKyBjb2luLndpZHRoID4gMCAmJiAhY29pbi5jb2xsZWN0ZWRcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjaGVja0NvbGxpc2lvbnMoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCk6IGJvb2xlYW4ge1xyXG4gICAgICAvLyBDaGVjayB0b3AvYm90dG9tIGJvdW5kYXJpZXNcclxuICAgICAgaWYgKGJpcmRZUmVmLmN1cnJlbnQgPCAwIHx8IGJpcmRZUmVmLmN1cnJlbnQgKyBCSVJEX0hFSUdIVCA+IGNhbnZhcy5oZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgYmlyZExlZnQgPSAxMDA7XHJcbiAgICAgIGNvbnN0IGJpcmRSaWdodCA9IGJpcmRMZWZ0ICsgQklSRF9XSURUSDtcclxuICAgICAgY29uc3QgYmlyZFRvcCA9IGJpcmRZUmVmLmN1cnJlbnQ7XHJcbiAgICAgIGNvbnN0IGJpcmRCb3R0b20gPSBiaXJkWVJlZi5jdXJyZW50ICsgQklSRF9IRUlHSFQ7XHJcblxyXG4gICAgICAvLyBQaXBlIGNvbGxpc2lvblxyXG4gICAgICBmb3IgKGNvbnN0IHBpcGUgb2YgcGlwZXNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGNvbnN0IHdpdGhpblBpcGVYID0gYmlyZFJpZ2h0ID4gcGlwZS54ICYmIGJpcmRMZWZ0IDwgcGlwZS54ICsgUElQRV9XSURUSDtcclxuICAgICAgICBjb25zdCB3aXRoaW5QaXBlWSA9IGJpcmRUb3AgPCBwaXBlLnRvcEhlaWdodCB8fCBiaXJkQm90dG9tID4gcGlwZS5ib3R0b21ZO1xyXG4gICAgICAgIGlmICh3aXRoaW5QaXBlWCAmJiB3aXRoaW5QaXBlWSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjaGVja0NvaW5Db2xsZWN0aW9uKCkge1xyXG4gICAgICBjb25zdCBiaXJkTGVmdCA9IDEwMDtcclxuICAgICAgY29uc3QgYmlyZFJpZ2h0ID0gYmlyZExlZnQgKyBCSVJEX1dJRFRIO1xyXG4gICAgICBjb25zdCBiaXJkVG9wID0gYmlyZFlSZWYuY3VycmVudDtcclxuICAgICAgY29uc3QgYmlyZEJvdHRvbSA9IGJpcmRZUmVmLmN1cnJlbnQgKyBCSVJEX0hFSUdIVDtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgY29pbiBvZiBjb2luc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgaWYgKCFjb2luLmNvbGxlY3RlZCkge1xyXG4gICAgICAgICAgY29uc3QgY29pbkxlZnQgPSBjb2luLng7XHJcbiAgICAgICAgICBjb25zdCBjb2luUmlnaHQgPSBjb2luLnggKyBjb2luLndpZHRoO1xyXG4gICAgICAgICAgY29uc3QgY29pblRvcCA9IGNvaW4ueTtcclxuICAgICAgICAgIGNvbnN0IGNvaW5Cb3R0b20gPSBjb2luLnkgKyBjb2luLmhlaWdodDtcclxuXHJcbiAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIGJpcmRSaWdodCA+IGNvaW5MZWZ0ICYmXHJcbiAgICAgICAgICAgIGJpcmRMZWZ0IDwgY29pblJpZ2h0ICYmXHJcbiAgICAgICAgICAgIGJpcmRCb3R0b20gPiBjb2luVG9wICYmXHJcbiAgICAgICAgICAgIGJpcmRUb3AgPCBjb2luQm90dG9tXHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgLy8gQ29sbGVjdCBjb2luXHJcbiAgICAgICAgICAgIGNvaW4uY29sbGVjdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgc2V0Q3VycmVudFNjb3JlKChwcmV2U2NvcmUpID0+IHtcclxuICAgICAgICAgICAgICBjb25zdCBuZXdTY29yZSA9IHByZXZTY29yZSArIDU7XHJcbiAgICAgICAgICAgICAgc2V0SGlnaFNjb3JlKChwcmV2SGlnaFNjb3JlKSA9PiBNYXRoLm1heChwcmV2SGlnaFNjb3JlLCBuZXdTY29yZSkpO1xyXG4gICAgICAgICAgICAgIHJldHVybiBuZXdTY29yZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdXBkYXRlU2NvcmUoKSB7XHJcbiAgICAgIGZvciAoY29uc3QgcGlwZSBvZiBwaXBlc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgLy8gU2NvcmUgKzEgZm9yIHBhc3NpbmcgZWFjaCBwaXBlLCBvbmx5IG9uY2VcclxuICAgICAgICBpZiAoIXBpcGUuc2NvcmVkICYmIHBpcGUueCArIFBJUEVfV0lEVEggPCAxMDApIHtcclxuICAgICAgICAgIHBpcGUuc2NvcmVkID0gdHJ1ZTtcclxuICAgICAgICAgIHNldEN1cnJlbnRTY29yZSgocHJldlNjb3JlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1Njb3JlID0gcHJldlNjb3JlICsgMTtcclxuICAgICAgICAgICAgc2V0SGlnaFNjb3JlKChwcmV2SGlnaFNjb3JlKSA9PiB7XHJcbiAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZEhpZ2hTY29yZSA9IE1hdGgubWF4KHByZXZIaWdoU2NvcmUsIG5ld1Njb3JlKTtcclxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJoaWdoU2NvcmVcIiwgdXBkYXRlZEhpZ2hTY29yZS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZWRIaWdoU2NvcmU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3U2NvcmU7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3KGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICAgICAgZHJhd0JhY2tncm91bmQoY3R4LCBjYW52YXMpO1xyXG4gICAgICBkcmF3QmlyZChjdHgpO1xyXG4gICAgICBkcmF3UGlwZXMoY3R4KTtcclxuICAgICAgZHJhd0NvaW5zKGN0eCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd1N0YXJ0U2NyZWVuKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICAgICAgZHJhd0JhY2tncm91bmQoY3R4LCBjYW52YXMpO1xyXG5cclxuICAgICAgY3R4LmZvbnQgPSBcImJvbGQgMzBweCBBcmlhbFwiO1xyXG4gICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiI2ZmZmZmZlwiO1xyXG4gICAgICBjdHguc2hhZG93Q29sb3IgPSBcImJsYWNrXCI7XHJcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xyXG5cclxuICAgICAgY3R4LmZpbGxUZXh0KFxyXG4gICAgICAgIFwiVGFwIHRvIFN0YXJ0XCIsXHJcbiAgICAgICAgY2FudmFzLndpZHRoIC8gMixcclxuICAgICAgICBjYW52YXMuaGVpZ2h0IC8gMlxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdHYW1lT3ZlclNjcmVlbihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkge1xyXG4gICAgICBjdHguZmlsbFN0eWxlID0gXCIjZmZjYzAwXCI7XHJcbiAgICAgIGN0eC5mb250ID0gXCJib2xkIDUwcHggQXJpYWxcIjtcclxuICAgICAgY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XHJcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xyXG4gICAgICBjdHguc2hhZG93Q29sb3IgPSBcImJsYWNrXCI7XHJcbiAgICAgIGN0eC5zaGFkb3dCbHVyID0gMTA7XHJcblxyXG4gICAgICBjdHguZmlsbFRleHQoXCJHYW1lIE92ZXIhXCIsIGNhbnZhcy53aWR0aCAvIDIsIGNhbnZhcy5oZWlnaHQgLyAyIC0gNDApO1xyXG5cclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiI2ZmZmZmZlwiO1xyXG4gICAgICBjdHguZm9udCA9IFwiYm9sZCAzMHB4IEFyaWFsXCI7XHJcbiAgICAgIGN0eC5maWxsVGV4dChcclxuICAgICAgICBcIlRhcCB0byBSZXN0YXJ0XCIsXHJcbiAgICAgICAgY2FudmFzLndpZHRoIC8gMixcclxuICAgICAgICBjYW52YXMuaGVpZ2h0IC8gMiArIDIwXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd0JhY2tncm91bmQoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcclxuICAgICAgY3R4LmRyYXdJbWFnZShiYWNrZ3JvdW5kLCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdCaXJkKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XHJcbiAgICAgIGNvbnN0IGN1cnJlbnRJbWFnZSA9IGJpcmRJbWFnZXNbY3VycmVudEJpcmRGcmFtZVJlZi5jdXJyZW50XTtcclxuICAgICAgLy8gRHJhdyB0aGUgYmlyZCBhdCBhIGZpeGVkIFggKDEwMCkgYW5kIGN1cnJlbnQgYmlyZFlcclxuICAgICAgaWYgKGN1cnJlbnRJbWFnZS5jb21wbGV0ZSkge1xyXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoY3VycmVudEltYWdlLCAxMDAsIGJpcmRZUmVmLmN1cnJlbnQsIEJJUkRfV0lEVEgsIEJJUkRfSEVJR0hUKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdQaXBlcyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xyXG4gICAgICBmb3IgKGNvbnN0IHBpcGUgb2YgcGlwZXNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UocGlwZVRvcCwgcGlwZS54LCAwLCBQSVBFX1dJRFRILCBwaXBlLnRvcEhlaWdodCk7XHJcbiAgICAgICAgY3R4LmRyYXdJbWFnZShwaXBlQm90dG9tLCBwaXBlLngsIHBpcGUuYm90dG9tWSwgUElQRV9XSURUSCwgcGlwZS5ib3R0b21IZWlnaHQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd0NvaW5zKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XHJcbiAgICAgIC8vIFdlJ2xsIGZsaXAgdGhlIGNvaW4gaG9yaXpvbnRhbGx5IHVzaW5nIHNjYWxlXHJcbiAgICAgIGNvbnN0IHNjYWxlWCA9IE1hdGguYWJzKE1hdGguY29zKGNvaW5Sb3RhdGlvblJlZi5jdXJyZW50ICogTWF0aC5QSSAqIDIpKTtcclxuICAgICAgY29uc3QgaGFsZlNpemUgPSBDT0lOX1NJWkUgLyAyO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBjb2luIG9mIGNvaW5zUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBpZiAoIWNvaW4uY29sbGVjdGVkKSB7XHJcbiAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgY3R4LnRyYW5zbGF0ZShjb2luLnggKyBoYWxmU2l6ZSwgY29pbi55ICsgaGFsZlNpemUpO1xyXG4gICAgICAgICAgY3R4LnNjYWxlKHNjYWxlWCwgMSk7IC8vIEhvcml6b250YWwgZmxpcCBlZmZlY3RcclxuICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoY29pbkltYWdlLCAtaGFsZlNpemUsIC1oYWxmU2l6ZSwgQ09JTl9TSVpFLCBDT0lOX1NJWkUpO1xyXG4gICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVQaXBlKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcclxuICAgICAgLy8gUmFuZG9tIHRvcCBwaXBlIGhlaWdodFxyXG4gICAgICBjb25zdCBwaXBlSGVpZ2h0ID0gTWF0aC5yYW5kb20oKSAqIChjYW52YXMuaGVpZ2h0IC0gUElQRV9TUEFDSU5HIC0gMTAwKSArIDUwO1xyXG4gICAgICBjb25zdCBib3R0b21ZID0gcGlwZUhlaWdodCArIFBJUEVfU1BBQ0lORztcclxuICAgICAgcGlwZXNSZWYuY3VycmVudC5wdXNoKHtcclxuICAgICAgICB4OiBjYW52YXMud2lkdGgsXHJcbiAgICAgICAgdG9wSGVpZ2h0OiBwaXBlSGVpZ2h0LFxyXG4gICAgICAgIGJvdHRvbVksXHJcbiAgICAgICAgYm90dG9tSGVpZ2h0OiBjYW52YXMuaGVpZ2h0IC0gYm90dG9tWSxcclxuICAgICAgICBzY29yZWQ6IGZhbHNlLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIDUwJSBjaGFuY2UgdG8gc3Bhd24gYSBjb2luXHJcbiAgICAgIGlmIChNYXRoLnJhbmRvbSgpID4gMC41KSB7XHJcbiAgICAgICAgY29pbnNSZWYuY3VycmVudC5wdXNoKHtcclxuICAgICAgICAgIHg6IGNhbnZhcy53aWR0aCArIFBJUEVfV0lEVEggLyAyIC0gQ09JTl9TSVpFIC8gMixcclxuICAgICAgICAgIHk6IHBpcGVIZWlnaHQgKyBQSVBFX1NQQUNJTkcgLyAyIC0gQ09JTl9TSVpFIC8gMixcclxuICAgICAgICAgIHdpZHRoOiBDT0lOX1NJWkUsXHJcbiAgICAgICAgICBoZWlnaHQ6IENPSU5fU0laRSxcclxuICAgICAgICAgIGNvbGxlY3RlZDogZmFsc2UsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtb3ZlUGlwZXNBbmRDb2lucyhzY2FsZTogbnVtYmVyKSB7XHJcbiAgICAgIC8vIE1vdmUgdGhlbSB0byB0aGUgbGVmdCBiYXNlZCBvbiBzY2FsZVxyXG4gICAgICBmb3IgKGNvbnN0IHBpcGUgb2YgcGlwZXNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIHBpcGUueCAtPSBIT1JJWk9OVEFMX1NQRUVEICogc2NhbGU7XHJcbiAgICAgIH1cclxuICAgICAgLy8gRmlsdGVyIG91dCBwaXBlcyB0aGF0IGhhdmUgc2Nyb2xsZWQgb2Zmc2NyZWVuXHJcbiAgICAgIHBpcGVzUmVmLmN1cnJlbnQgPSBwaXBlc1JlZi5jdXJyZW50LmZpbHRlcigocGlwZSkgPT4gcGlwZS54ICsgUElQRV9XSURUSCA+IDApO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBjb2luIG9mIGNvaW5zUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBjb2luLnggLT0gSE9SSVpPTlRBTF9TUEVFRCAqIHNjYWxlO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIEZpbHRlciBvdXQgY29pbnMgdGhhdCBoYXZlIHNjcm9sbGVkIG9mZnNjcmVlbiBvciBhcmUgY29sbGVjdGVkXHJcbiAgICAgIGNvaW5zUmVmLmN1cnJlbnQgPSBjb2luc1JlZi5jdXJyZW50LmZpbHRlcihcclxuICAgICAgICAoY29pbikgPT4gY29pbi54ICsgY29pbi53aWR0aCA+IDAgJiYgIWNvaW4uY29sbGVjdGVkXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2hlY2tDb2xsaXNpb25zKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpOiBib29sZWFuIHtcclxuICAgICAgLy8gQ2hlY2sgdG9wL2JvdHRvbSBib3VuZGFyaWVzXHJcbiAgICAgIGlmIChiaXJkWVJlZi5jdXJyZW50IDwgMCB8fCBiaXJkWVJlZi5jdXJyZW50ICsgQklSRF9IRUlHSFQgPiBjYW52YXMuaGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGJpcmRMZWZ0ID0gMTAwO1xyXG4gICAgICBjb25zdCBiaXJkUmlnaHQgPSBiaXJkTGVmdCArIEJJUkRfV0lEVEg7XHJcbiAgICAgIGNvbnN0IGJpcmRUb3AgPSBiaXJkWVJlZi5jdXJyZW50O1xyXG4gICAgICBjb25zdCBiaXJkQm90dG9tID0gYmlyZFlSZWYuY3VycmVudCArIEJJUkRfSEVJR0hUO1xyXG5cclxuICAgICAgLy8gUGlwZSBjb2xsaXNpb25cclxuICAgICAgZm9yIChjb25zdCBwaXBlIG9mIHBpcGVzUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBjb25zdCB3aXRoaW5QaXBlWCA9IGJpcmRSaWdodCA+IHBpcGUueCAmJiBiaXJkTGVmdCA8IHBpcGUueCArIFBJUEVfV0lEVEg7XHJcbiAgICAgICAgY29uc3Qgd2l0aGluUGlwZVkgPSBiaXJkVG9wIDwgcGlwZS50b3BIZWlnaHQgfHwgYmlyZEJvdHRvbSA+IHBpcGUuYm90dG9tWTtcclxuICAgICAgICBpZiAod2l0aGluUGlwZVggJiYgd2l0aGluUGlwZVkpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2hlY2tDb2luQ29sbGVjdGlvbigpIHtcclxuICAgICAgY29uc3QgYmlyZExlZnQgPSAxMDA7XHJcbiAgICAgIGNvbnN0IGJpcmRSaWdodCA9IGJpcmRMZWZ0ICsgQklSRF9XSURUSDtcclxuICAgICAgY29uc3QgYmlyZFRvcCA9IGJpcmRZUmVmLmN1cnJlbnQ7XHJcbiAgICAgIGNvbnN0IGJpcmRCb3R0b20gPSBiaXJkWVJlZi5jdXJyZW50ICsgQklSRF9IRUlHSFQ7XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGNvaW4gb2YgY29pbnNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGlmICghY29pbi5jb2xsZWN0ZWQpIHtcclxuICAgICAgICAgIGNvbnN0IGNvaW5MZWZ0ID0gY29pbi54O1xyXG4gICAgICAgICAgY29uc3QgY29pblJpZ2h0ID0gY29pbi54ICsgY29pbi53aWR0aDtcclxuICAgICAgICAgIGNvbnN0IGNvaW5Ub3AgPSBjb2luLnk7XHJcbiAgICAgICAgICBjb25zdCBjb2luQm90dG9tID0gY29pbi55ICsgY29pbi5oZWlnaHQ7XHJcblxyXG4gICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICBiaXJkUmlnaHQgPiBjb2luTGVmdCAmJlxyXG4gICAgICAgICAgICBiaXJkTGVmdCA8IGNvaW5SaWdodCAmJlxyXG4gICAgICAgICAgICBiaXJkQm90dG9tID4gY29pblRvcCAmJlxyXG4gICAgICAgICAgICBiaXJkVG9wIDwgY29pbkJvdHRvbVxyXG4gICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIC8vIENvbGxlY3QgY29pblxyXG4gICAgICAgICAgICBjb2luLmNvbGxlY3RlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHNldEN1cnJlbnRTY29yZSgocHJldlNjb3JlKSA9PiB7XHJcbiAgICAgICAgICAgICAgY29uc3QgbmV3U2NvcmUgPSBwcmV2U2NvcmUgKyA1O1xyXG4gICAgICAgICAgICAgIHNldEhpZ2hTY29yZSgocHJldkhpZ2hTY29yZSkgPT4gTWF0aC5tYXgocHJldkhpZ2hTY29yZSwgbmV3U2NvcmUpKTtcclxuICAgICAgICAgICAgICByZXR1cm4gbmV3U2NvcmU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZVNjb3JlKCkge1xyXG4gICAgICBmb3IgKGNvbnN0IHBpcGUgb2YgcGlwZXNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIC8vIFNjb3JlICsxIGZvciBwYXNzaW5nIGVhY2ggcGlwZSwgb25seSBvbmNlXHJcbiAgICAgICAgaWYgKCFwaXBlLnNjb3JlZCAmJiBwaXBlLnggKyBQSVBFX1dJRFRIIDwgMTAwKSB7XHJcbiAgICAgICAgICBwaXBlLnNjb3JlZCA9IHRydWU7XHJcbiAgICAgICAgICBzZXRDdXJyZW50U2NvcmUoKHByZXZTY29yZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdTY29yZSA9IHByZXZTY29yZSArIDE7XHJcbiAgICAgICAgICAgIHNldEhpZ2hTY29yZSgocHJldkhpZ2hTY29yZSkgPT4ge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRIaWdoU2NvcmUgPSBNYXRoLm1heChwcmV2SGlnaFNjb3JlLCBuZXdTY29yZSk7XHJcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwiaGlnaFNjb3JlXCIsIHVwZGF0ZWRIaWdoU2NvcmUudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVkSGlnaFNjb3JlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld1Njb3JlO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhdyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkge1xyXG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcbiAgICAgIGRyYXdCYWNrZ3JvdW5kKGN0eCwgY2FudmFzKTtcclxuICAgICAgZHJhd0JpcmQoY3R4KTtcclxuICAgICAgZHJhd1BpcGVzKGN0eCk7XHJcbiAgICAgIGRyYXdDb2lucyhjdHgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdTdGFydFNjcmVlbihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkge1xyXG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcbiAgICAgIGRyYXdCYWNrZ3JvdW5kKGN0eCwgY2FudmFzKTtcclxuXHJcbiAgICAgIGN0eC5mb250ID0gXCJib2xkIDMwcHggQXJpYWxcIjtcclxuICAgICAgY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNmZmZmZmZcIjtcclxuICAgICAgY3R4LnNoYWRvd0NvbG9yID0gXCJibGFja1wiO1xyXG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcclxuXHJcbiAgICAgIGN0eC5maWxsVGV4dChcclxuICAgICAgICBcIlRhcCB0byBTdGFydFwiLFxyXG4gICAgICAgIGNhbnZhcy53aWR0aCAvIDIsXHJcbiAgICAgICAgY2FudmFzLmhlaWdodCAvIDJcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3R2FtZU92ZXJTY3JlZW4oY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiI2ZmY2MwMFwiO1xyXG4gICAgICBjdHguZm9udCA9IFwiYm9sZCA1MHB4IEFyaWFsXCI7XHJcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xyXG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcclxuICAgICAgY3R4LnNoYWRvd0NvbG9yID0gXCJibGFja1wiO1xyXG4gICAgICBjdHguc2hhZG93Qmx1ciA9IDEwO1xyXG5cclxuICAgICAgY3R4LmZpbGxUZXh0KFwiR2FtZSBPdmVyIVwiLCBjYW52YXMud2lkdGggLyAyLCBjYW52YXMuaGVpZ2h0IC8gMiAtIDQwKTtcclxuXHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNmZmZmZmZcIjtcclxuICAgICAgY3R4LmZvbnQgPSBcImJvbGQgMzBweCBBcmlhbFwiO1xyXG4gICAgICBjdHguZmlsbFRleHQoXHJcbiAgICAgICAgXCJUYXAgdG8gUmVzdGFydFwiLFxyXG4gICAgICAgIGNhbnZhcy53aWR0aCAvIDIsXHJcbiAgICAgICAgY2FudmFzLmhlaWdodCAvIDIgKyAyMFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdCYWNrZ3JvdW5kKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgIGN0eC5kcmF3SW1hZ2UoYmFja2dyb3VuZCwgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3QmlyZChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xyXG4gICAgICBjb25zdCBjdXJyZW50SW1hZ2UgPSBiaXJkSW1hZ2VzW2N1cnJlbnRCaXJkRnJhbWVSZWYuY3VycmVudF07XHJcbiAgICAgIC8vIERyYXcgdGhlIGJpcmQgYXQgYSBmaXhlZCBYICgxMDApIGFuZCBjdXJyZW50IGJpcmRZXHJcbiAgICAgIGlmIChjdXJyZW50SW1hZ2UuY29tcGxldGUpIHtcclxuICAgICAgICBjdHguZHJhd0ltYWdlKGN1cnJlbnRJbWFnZSwgMTAwLCBiaXJkWVJlZi5jdXJyZW50LCBCSVJEX1dJRFRILCBCSVJEX0hFSUdIVCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3UGlwZXMoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcclxuICAgICAgZm9yIChjb25zdCBwaXBlIG9mIHBpcGVzUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBjdHguZHJhd0ltYWdlKHBpcGVUb3AsIHBpcGUueCwgMCwgUElQRV9XSURUSCwgcGlwZS50b3BIZWlnaHQpO1xyXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UocGlwZUJvdHRvbSwgcGlwZS54LCBwaXBlLmJvdHRvbVksIFBJUEVfV0lEVEgsIHBpcGUuYm90dG9tSGVpZ2h0KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdDb2lucyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xyXG4gICAgICAvLyBXZSdsbCBmbGlwIHRoZSBjb2luIGhvcml6b250YWxseSB1c2luZyBzY2FsZVxyXG4gICAgICBjb25zdCBzY2FsZVggPSBNYXRoLmFicyhNYXRoLmNvcyhjb2luUm90YXRpb25SZWYuY3VycmVudCAqIE1hdGguUEkgKiAyKSk7XHJcbiAgICAgIGNvbnN0IGhhbGZTaXplID0gQ09JTl9TSVpFIC8gMjtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgY29pbiBvZiBjb2luc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgaWYgKCFjb2luLmNvbGxlY3RlZCkge1xyXG4gICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgIGN0eC50cmFuc2xhdGUoY29pbi54ICsgaGFsZlNpemUsIGNvaW4ueSArIGhhbGZTaXplKTtcclxuICAgICAgICAgIGN0eC5zY2FsZShzY2FsZVgsIDEpOyAvLyBIb3Jpem9udGFsIGZsaXAgZWZmZWN0XHJcbiAgICAgICAgICBjdHguZHJhd0ltYWdlKGNvaW5JbWFnZSwgLWhhbGZTaXplLCAtaGFsZlNpemUsIENPSU5fU0laRSwgQ09JTl9TSVpFKTtcclxuICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlUGlwZShjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgIC8vIFJhbmRvbSB0b3AgcGlwZSBoZWlnaHRcclxuICAgICAgY29uc3QgcGlwZUhlaWdodCA9IE1hdGgucmFuZG9tKCkgKiAoY2FudmFzLmhlaWdodCAtIFBJUEVfU1BBQ0lORyAtIDEwMCkgKyA1MDtcclxuICAgICAgY29uc3QgYm90dG9tWSA9IHBpcGVIZWlnaHQgKyBQSVBFX1NQQUNJTkc7XHJcbiAgICAgIHBpcGVzUmVmLmN1cnJlbnQucHVzaCh7XHJcbiAgICAgICAgeDogY2FudmFzLndpZHRoLFxyXG4gICAgICAgIHRvcEhlaWdodDogcGlwZUhlaWdodCxcclxuICAgICAgICBib3R0b21ZLFxyXG4gICAgICAgIGJvdHRvbUhlaWdodDogY2FudmFzLmhlaWdodCAtIGJvdHRvbVksXHJcbiAgICAgICAgc2NvcmVkOiBmYWxzZSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyA1MCUgY2hhbmNlIHRvIHNwYXduIGEgY29pblxyXG4gICAgICBpZiAoTWF0aC5yYW5kb20oKSA+IDAuNSkge1xyXG4gICAgICAgIGNvaW5zUmVmLmN1cnJlbnQucHVzaCh7XHJcbiAgICAgICAgICB4OiBjYW52YXMud2lkdGggKyBQSVBFX1dJRFRIIC8gMiAtIENPSU5fU0laRSAvIDIsXHJcbiAgICAgICAgICB5OiBwaXBlSGVpZ2h0ICsgUElQRV9TUEFDSU5HIC8gMiAtIENPSU5fU0laRSAvIDIsXHJcbiAgICAgICAgICB3aWR0aDogQ09JTl9TSVpFLFxyXG4gICAgICAgICAgaGVpZ2h0OiBDT0lOX1NJWkUsXHJcbiAgICAgICAgICBjb2xsZWN0ZWQ6IGZhbHNlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbW92ZVBpcGVzQW5kQ29pbnMoc2NhbGU6IG51bWJlcikge1xyXG4gICAgICAvLyBNb3ZlIHRoZW0gdG8gdGhlIGxlZnQgYmFzZWQgb24gc2NhbGVcclxuICAgICAgZm9yIChjb25zdCBwaXBlIG9mIHBpcGVzUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBwaXBlLnggLT0gSE9SSVpPTlRBTF9TUEVFRCAqIHNjYWxlO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIEZpbHRlciBvdXQgcGlwZXMgdGhhdCBoYXZlIHNjcm9sbGVkIG9mZnNjcmVlblxyXG4gICAgICBwaXBlc1JlZi5jdXJyZW50ID0gcGlwZXNSZWYuY3VycmVudC5maWx0ZXIoKHBpcGUpID0+IHBpcGUueCArIFBJUEVfV0lEVEggPiAwKTtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgY29pbiBvZiBjb2luc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY29pbi54IC09IEhPUklaT05UQUxfU1BFRUQgKiBzY2FsZTtcclxuICAgICAgfVxyXG4gICAgICAvLyBGaWx0ZXIgb3V0IGNvaW5zIHRoYXQgaGF2ZSBzY3JvbGxlZCBvZmZzY3JlZW4gb3IgYXJlIGNvbGxlY3RlZFxyXG4gICAgICBjb2luc1JlZi5jdXJyZW50ID0gY29pbnNSZWYuY3VycmVudC5maWx0ZXIoXHJcbiAgICAgICAgKGNvaW4pID0+IGNvaW4ueCArIGNvaW4ud2lkdGggPiAwICYmICFjb2luLmNvbGxlY3RlZFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNoZWNrQ29sbGlzaW9ucyhjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KTogYm9vbGVhbiB7XHJcbiAgICAgIC8vIENoZWNrIHRvcC9ib3R0b20gYm91bmRhcmllc1xyXG4gICAgICBpZiAoYmlyZFlSZWYuY3VycmVudCA8IDAgfHwgYmlyZFlSZWYuY3VycmVudCArIEJJUkRfSEVJR0hUID4gY2FudmFzLmhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBiaXJkTGVmdCA9IDEwMDtcclxuICAgICAgY29uc3QgYmlyZFJpZ2h0ID0gYmlyZExlZnQgKyBCSVJEX1dJRFRIO1xyXG4gICAgICBjb25zdCBiaXJkVG9wID0gYmlyZFlSZWYuY3VycmVudDtcclxuICAgICAgY29uc3QgYmlyZEJvdHRvbSA9IGJpcmRZUmVmLmN1cnJlbnQgKyBCSVJEX0hFSUdIVDtcclxuXHJcbiAgICAgIC8vIFBpcGUgY29sbGlzaW9uXHJcbiAgICAgIGZvciAoY29uc3QgcGlwZSBvZiBwaXBlc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY29uc3Qgd2l0aGluUGlwZVggPSBiaXJkUmlnaHQgPiBwaXBlLnggJiYgYmlyZExlZnQgPCBwaXBlLnggKyBQSVBFX1dJRFRIO1xyXG4gICAgICAgIGNvbnN0IHdpdGhpblBpcGVZID0gYmlyZFRvcCA8IHBpcGUudG9wSGVpZ2h0IHx8IGJpcmRCb3R0b20gPiBwaXBlLmJvdHRvbVk7XHJcbiAgICAgICAgaWYgKHdpdGhpblBpcGVYICYmIHdpdGhpblBpcGVZKSB7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNoZWNrQ29pbkNvbGxlY3Rpb24oKSB7XHJcbiAgICAgIGNvbnN0IGJpcmRMZWZ0ID0gMTAwO1xyXG4gICAgICBjb25zdCBiaXJkUmlnaHQgPSBiaXJkTGVmdCArIEJJUkRfV0lEVEg7XHJcbiAgICAgIGNvbnN0IGJpcmRUb3AgPSBiaXJkWVJlZi5jdXJyZW50O1xyXG4gICAgICBjb25zdCBiaXJkQm90dG9tID0gYmlyZFlSZWYuY3VycmVudCArIEJJUkRfSEVJR0hUO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBjb2luIG9mIGNvaW5zUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBpZiAoIWNvaW4uY29sbGVjdGVkKSB7XHJcbiAgICAgICAgICBjb25zdCBjb2luTGVmdCA9IGNvaW4ueDtcclxuICAgICAgICAgIGNvbnN0IGNvaW5SaWdodCA9IGNvaW4ueCArIGNvaW4ud2lkdGg7XHJcbiAgICAgICAgICBjb25zdCBjb2luVG9wID0gY29pbi55O1xyXG4gICAgICAgICAgY29uc3QgY29pbkJvdHRvbSA9IGNvaW4ueSArIGNvaW4uaGVpZ2h0O1xyXG5cclxuICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgYmlyZFJpZ2h0ID4gY29pbkxlZnQgJiZcclxuICAgICAgICAgICAgYmlyZExlZnQgPCBjb2luUmlnaHQgJiZcclxuICAgICAgICAgICAgYmlyZEJvdHRvbSA+IGNvaW5Ub3AgJiZcclxuICAgICAgICAgICAgYmlyZFRvcCA8IGNvaW5Cb3R0b21cclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAvLyBDb2xsZWN0IGNvaW5cclxuICAgICAgICAgICAgY29pbi5jb2xsZWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBzZXRDdXJyZW50U2NvcmUoKHByZXZTY29yZSkgPT4ge1xyXG4gICAgICAgICAgICAgIGNvbnN0IG5ld1Njb3JlID0gcHJldlNjb3JlICsgNTtcclxuICAgICAgICAgICAgICBzZXRIaWdoU2NvcmUoKHByZXZIaWdoU2NvcmUpID0+IE1hdGgubWF4KHByZXZIaWdoU2NvcmUsIG5ld1Njb3JlKSk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIG5ld1Njb3JlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVTY29yZSgpIHtcclxuICAgICAgZm9yIChjb25zdCBwaXBlIG9mIHBpcGVzUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAvLyBTY29yZSArMSBmb3IgcGFzc2luZyBlYWNoIHBpcGUsIG9ubHkgb25jZVxyXG4gICAgICAgIGlmICghcGlwZS5zY29yZWQgJiYgcGlwZS54ICsgUElQRV9XSURUSCA8IDEwMCkge1xyXG4gICAgICAgICAgcGlwZS5zY29yZWQgPSB0cnVlO1xyXG4gICAgICAgICAgc2V0Q3VycmVudFNjb3JlKChwcmV2U2NvcmUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbmV3U2NvcmUgPSBwcmV2U2NvcmUgKyAxO1xyXG4gICAgICAgICAgICBzZXRIaWdoU2NvcmUoKHByZXZIaWdoU2NvcmUpID0+IHtcclxuICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkSGlnaFNjb3JlID0gTWF0aC5tYXgocHJldkhpZ2hTY29yZSwgbmV3U2NvcmUpO1xyXG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcImhpZ2hTY29yZVwiLCB1cGRhdGVkSGlnaFNjb3JlLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlZEhpZ2hTY29yZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdTY29yZTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXcoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcclxuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICBkcmF3QmFja2dyb3VuZChjdHgsIGNhbnZhcyk7XHJcbiAgICAgIGRyYXdCaXJkKGN0eCk7XHJcbiAgICAgIGRyYXdQaXBlcyhjdHgpO1xyXG4gICAgICBkcmF3Q29pbnMoY3R4KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3U3RhcnRTY3JlZW4oY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcclxuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICBkcmF3QmFja2dyb3VuZChjdHgsIGNhbnZhcyk7XHJcblxyXG4gICAgICBjdHguZm9udCA9IFwiYm9sZCAzMHB4IEFyaWFsXCI7XHJcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xyXG4gICAgICBjdHguZmlsbFN0eWxlID0gXCIjZmZmZmZmXCI7XHJcbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFwiYmxhY2tcIjtcclxuICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XHJcblxyXG4gICAgICBjdHguZmlsbFRleHQoXHJcbiAgICAgICAgXCJUYXAgdG8gU3RhcnRcIixcclxuICAgICAgICBjYW52YXMud2lkdGggLyAyLFxyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgLyAyXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd0dhbWVPdmVyU2NyZWVuKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNmZmNjMDBcIjtcclxuICAgICAgY3R4LmZvbnQgPSBcImJvbGQgNTBweCBBcmlhbFwiO1xyXG4gICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcclxuICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XHJcbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFwiYmxhY2tcIjtcclxuICAgICAgY3R4LnNoYWRvd0JsdXIgPSAxMDtcclxuXHJcbiAgICAgIGN0eC5maWxsVGV4dChcIkdhbWUgT3ZlciFcIiwgY2FudmFzLndpZHRoIC8gMiwgY2FudmFzLmhlaWdodCAvIDIgLSA0MCk7XHJcblxyXG4gICAgICBjdHguZmlsbFN0eWxlID0gXCIjZmZmZmZmXCI7XHJcbiAgICAgIGN0eC5mb250ID0gXCJib2xkIDMwcHggQXJpYWxcIjtcclxuICAgICAgY3R4LmZpbGxUZXh0KFxyXG4gICAgICAgIFwiVGFwIHRvIFJlc3RhcnRcIixcclxuICAgICAgICBjYW52YXMud2lkdGggLyAyLFxyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgLyAyICsgMjBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3QmFja2dyb3VuZChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkge1xyXG4gICAgICBjdHguZHJhd0ltYWdlKGJhY2tncm91bmQsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd0JpcmQoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcclxuICAgICAgY29uc3QgY3VycmVudEltYWdlID0gYmlyZEltYWdlc1tjdXJyZW50QmlyZEZyYW1lUmVmLmN1cnJlbnRdO1xyXG4gICAgICAvLyBEcmF3IHRoZSBiaXJkIGF0IGEgZml4ZWQgWCAoMTAwKSBhbmQgY3VycmVudCBiaXJkWVxyXG4gICAgICBpZiAoY3VycmVudEltYWdlLmNvbXBsZXRlKSB7XHJcbiAgICAgICAgY3R4LmRyYXdJbWFnZShjdXJyZW50SW1hZ2UsIDEwMCwgYmlyZFlSZWYuY3VycmVudCwgQklSRF9XSURUSCwgQklSRF9IRUlHSFQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd1BpcGVzKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XHJcbiAgICAgIGZvciAoY29uc3QgcGlwZSBvZiBwaXBlc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY3R4LmRyYXdJbWFnZShwaXBlVG9wLCBwaXBlLngsIDAsIFBJUEVfV0lEVEgsIHBpcGUudG9wSGVpZ2h0KTtcclxuICAgICAgICBjdHguZHJhd0ltYWdlKHBpcGVCb3R0b20sIHBpcGUueCwgcGlwZS5ib3R0b21ZLCBQSVBFX1dJRFRILCBwaXBlLmJvdHRvbUhlaWdodCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3Q29pbnMoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcclxuICAgICAgLy8gV2UnbGwgZmxpcCB0aGUgY29pbiBob3Jpem9udGFsbHkgdXNpbmcgc2NhbGVcclxuICAgICAgY29uc3Qgc2NhbGVYID0gTWF0aC5hYnMoTWF0aC5jb3MoY29pblJvdGF0aW9uUmVmLmN1cnJlbnQgKiBNYXRoLlBJICogMikpO1xyXG4gICAgICBjb25zdCBoYWxmU2l6ZSA9IENPSU5fU0laRSAvIDI7XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGNvaW4gb2YgY29pbnNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGlmICghY29pbi5jb2xsZWN0ZWQpIHtcclxuICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICBjdHgudHJhbnNsYXRlKGNvaW4ueCArIGhhbGZTaXplLCBjb2luLnkgKyBoYWxmU2l6ZSk7XHJcbiAgICAgICAgICBjdHguc2NhbGUoc2NhbGVYLCAxKTsgLy8gSG9yaXpvbnRhbCBmbGlwIGVmZmVjdFxyXG4gICAgICAgICAgY3R4LmRyYXdJbWFnZShjb2luSW1hZ2UsIC1oYWxmU2l6ZSwgLWhhbGZTaXplLCBDT0lOX1NJWkUsIENPSU5fU0laRSk7XHJcbiAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBpcGUoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkge1xyXG4gICAgICAvLyBSYW5kb20gdG9wIHBpcGUgaGVpZ2h0XHJcbiAgICAgIGNvbnN0IHBpcGVIZWlnaHQgPSBNYXRoLnJhbmRvbSgpICogKGNhbnZhcy5oZWlnaHQgLSBQSVBFX1NQQUNJTkcgLSAxMDApICsgNTA7XHJcbiAgICAgIGNvbnN0IGJvdHRvbVkgPSBwaXBlSGVpZ2h0ICsgUElQRV9TUEFDSU5HO1xyXG4gICAgICBwaXBlc1JlZi5jdXJyZW50LnB1c2goe1xyXG4gICAgICAgIHg6IGNhbnZhcy53aWR0aCxcclxuICAgICAgICB0b3BIZWlnaHQ6IHBpcGVIZWlnaHQsXHJcbiAgICAgICAgYm90dG9tWSxcclxuICAgICAgICBib3R0b21IZWlnaHQ6IGNhbnZhcy5oZWlnaHQgLSBib3R0b21ZLFxyXG4gICAgICAgIHNjb3JlZDogZmFsc2UsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gNTAlIGNoYW5jZSB0byBzcGF3biBhIGNvaW5cclxuICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPiAwLjUpIHtcclxuICAgICAgICBjb2luc1JlZi5jdXJyZW50LnB1c2goe1xyXG4gICAgICAgICAgeDogY2FudmFzLndpZHRoICsgUElQRV9XSURUSCAvIDIgLSBDT0lOX1NJWkUgLyAyLFxyXG4gICAgICAgICAgeTogcGlwZUhlaWdodCArIFBJUEVfU1BBQ0lORyAvIDIgLSBDT0lOX1NJWkUgLyAyLFxyXG4gICAgICAgICAgd2lkdGg6IENPSU5fU0laRSxcclxuICAgICAgICAgIGhlaWdodDogQ09JTl9TSVpFLFxyXG4gICAgICAgICAgY29sbGVjdGVkOiBmYWxzZSxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1vdmVQaXBlc0FuZENvaW5zKHNjYWxlOiBudW1iZXIpIHtcclxuICAgICAgLy8gTW92ZSB0aGVtIHRvIHRoZSBsZWZ0IGJhc2VkIG9uIHNjYWxlXHJcbiAgICAgIGZvciAoY29uc3QgcGlwZSBvZiBwaXBlc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgcGlwZS54IC09IEhPUklaT05UQUxfU1BFRUQgKiBzY2FsZTtcclxuICAgICAgfVxyXG4gICAgICAvLyBGaWx0ZXIgb3V0IHBpcGVzIHRoYXQgaGF2ZSBzY3JvbGxlZCBvZmZzY3JlZW5cclxuICAgICAgcGlwZXNSZWYuY3VycmVudCA9IHBpcGVzUmVmLmN1cnJlbnQuZmlsdGVyKChwaXBlKSA9PiBwaXBlLnggKyBQSVBFX1dJRFRIID4gMCk7XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGNvaW4gb2YgY29pbnNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGNvaW4ueCAtPSBIT1JJWk9OVEFMX1NQRUVEICogc2NhbGU7XHJcbiAgICAgIH1cclxuICAgICAgLy8gRmlsdGVyIG91dCBjb2lucyB0aGF0IGhhdmUgc2Nyb2xsZWQgb2Zmc2NyZWVuIG9yIGFyZSBjb2xsZWN0ZWRcclxuICAgICAgY29pbnNSZWYuY3VycmVudCA9IGNvaW5zUmVmLmN1cnJlbnQuZmlsdGVyKFxyXG4gICAgICAgIChjb2luKSA9PiBjb2luLnggKyBjb2luLndpZHRoID4gMCAmJiAhY29pbi5jb2xsZWN0ZWRcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjaGVja0NvbGxpc2lvbnMoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCk6IGJvb2xlYW4ge1xyXG4gICAgICAvLyBDaGVjayB0b3AvYm90dG9tIGJvdW5kYXJpZXNcclxuICAgICAgaWYgKGJpcmRZUmVmLmN1cnJlbnQgPCAwIHx8IGJpcmRZUmVmLmN1cnJlbnQgKyBCSVJEX0hFSUdIVCA+IGNhbnZhcy5oZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgYmlyZExlZnQgPSAxMDA7XHJcbiAgICAgIGNvbnN0IGJpcmRSaWdodCA9IGJpcmRMZWZ0ICsgQklSRF9XSURUSDtcclxuICAgICAgY29uc3QgYmlyZFRvcCA9IGJpcmRZUmVmLmN1cnJlbnQ7XHJcbiAgICAgIGNvbnN0IGJpcmRCb3R0b20gPSBiaXJkWVJlZi5jdXJyZW50ICsgQklSRF9IRUlHSFQ7XHJcblxyXG4gICAgICAvLyBQaXBlIGNvbGxpc2lvblxyXG4gICAgICBmb3IgKGNvbnN0IHBpcGUgb2YgcGlwZXNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGNvbnN0IHdpdGhpblBpcGVYID0gYmlyZFJpZ2h0ID4gcGlwZS54ICYmIGJpcmRMZWZ0IDwgcGlwZS54ICsgUElQRV9XSURUSDtcclxuICAgICAgICBjb25zdCB3aXRoaW5QaXBlWSA9IGJpcmRUb3AgPCBwaXBlLnRvcEhlaWdodCB8fCBiaXJkQm90dG9tID4gcGlwZS5ib3R0b21ZO1xyXG4gICAgICAgIGlmICh3aXRoaW5QaXBlWCAmJiB3aXRoaW5QaXBlWSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjaGVja0NvaW5Db2xsZWN0aW9uKCkge1xyXG4gICAgICBjb25zdCBiaXJkTGVmdCA9IDEwMDtcclxuICAgICAgY29uc3QgYmlyZFJpZ2h0ID0gYmlyZExlZnQgKyBCSVJEX1dJRFRIO1xyXG4gICAgICBjb25zdCBiaXJkVG9wID0gYmlyZFlSZWYuY3VycmVudDtcclxuICAgICAgY29uc3QgYmlyZEJvdHRvbSA9IGJpcmRZUmVmLmN1cnJlbnQgKyBCSVJEX0hFSUdIVDtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgY29pbiBvZiBjb2luc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgaWYgKCFjb2luLmNvbGxlY3RlZCkge1xyXG4gICAgICAgICAgY29uc3QgY29pbkxlZnQgPSBjb2luLng7XHJcbiAgICAgICAgICBjb25zdCBjb2luUmlnaHQgPSBjb2luLnggKyBjb2luLndpZHRoO1xyXG4gICAgICAgICAgY29uc3QgY29pblRvcCA9IGNvaW4ueTtcclxuICAgICAgICAgIGNvbnN0IGNvaW5Cb3R0b20gPSBjb2luLnkgKyBjb2luLmhlaWdodDtcclxuXHJcbiAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIGJpcmRSaWdodCA+IGNvaW5MZWZ0ICYmXHJcbiAgICAgICAgICAgIGJpcmRMZWZ0IDwgY29pblJpZ2h0ICYmXHJcbiAgICAgICAgICAgIGJpcmRCb3R0b20gPiBjb2luVG9wICYmXHJcbiAgICAgICAgICAgIGJpcmRUb3AgPCBjb2luQm90dG9tXHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgLy8gQ29sbGVjdCBjb2luXHJcbiAgICAgICAgICAgIGNvaW4uY29sbGVjdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgc2V0Q3VycmVudFNjb3JlKChwcmV2U2NvcmUpID0+IHtcclxuICAgICAgICAgICAgICBjb25zdCBuZXdTY29yZSA9IHByZXZTY29yZSArIDU7XHJcbiAgICAgICAgICAgICAgc2V0SGlnaFNjb3JlKChwcmV2SGlnaFNjb3JlKSA9PiBNYXRoLm1heChwcmV2SGlnaFNjb3JlLCBuZXdTY29yZSkpO1xyXG4gICAgICAgICAgICAgIHJldHVybiBuZXdTY29yZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdXBkYXRlU2NvcmUoKSB7XHJcbiAgICAgIGZvciAoY29uc3QgcGlwZSBvZiBwaXBlc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgLy8gU2NvcmUgKzEgZm9yIHBhc3NpbmcgZWFjaCBwaXBlLCBvbmx5IG9uY2VcclxuICAgICAgICBpZiAoIXBpcGUuc2NvcmVkICYmIHBpcGUueCArIFBJUEVfV0lEVEggPCAxMDApIHtcclxuICAgICAgICAgIHBpcGUuc2NvcmVkID0gdHJ1ZTtcclxuICAgICAgICAgIHNldEN1cnJlbnRTY29yZSgocHJldlNjb3JlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1Njb3JlID0gcHJldlNjb3JlICsgMTtcclxuICAgICAgICAgICAgc2V0SGlnaFNjb3JlKChwcmV2SGlnaFNjb3JlKSA9PiB7XHJcbiAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZEhpZ2hTY29yZSA9IE1hdGgubWF4KHByZXZIaWdoU2NvcmUsIG5ld1Njb3JlKTtcclxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJoaWdoU2NvcmVcIiwgdXBkYXRlZEhpZ2hTY29yZS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZWRIaWdoU2NvcmU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3U2NvcmU7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBFdmVudCBMaXN0ZW5lcnMgZm9yIFRvdWNoIGFuZCBDbGljayBJbnB1dHNcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xyXG4gICAgICBpZiAoIWNhbnZhcykgcmV0dXJuO1xyXG5cclxuICAgICAgbGV0IGxhc3RUYXAgPSAwO1xyXG5cclxuICAgICAgY29uc3QgaGFuZGxlSW5wdXQgPSAoZTogVG91Y2hFdmVudCB8IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIFByZXZlbnQgZGVmYXVsdCB0byBhdm9pZCBkdXBsaWNhdGUgZXZlbnRzXHJcbiAgICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICBjb25zdCB0YXBMZW5ndGggPSBjdXJyZW50VGltZSAtIGxhc3RUYXA7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XHJcbiAgICAgICAgaWYgKHRhcExlbmd0aCA8IDMwMCAmJiB0YXBMZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAvLyBEb3VibGUgdGFwLCBpZ25vcmVcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZmxhcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsYXN0VGFwID0gY3VycmVudFRpbWU7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgaGFuZGxlSW5wdXQpO1xyXG4gICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBoYW5kbGVJbnB1dCk7XHJcblxyXG4gICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBoYW5kbGVJbnB1dCk7XHJcbiAgICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgaGFuZGxlSW5wdXQpO1xyXG4gICAgICB9O1xyXG4gICAgfSwgW2NhbnZhc1JlZiwgaXNQYXVzZWQsIGF1dG9TdGFydF0pO1xyXG5cclxuICAgIC8vIENsZWFudXAgb24gdW5tb3VudFxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgaWYgKHJlcXVlc3RJZFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmVxdWVzdElkUmVmLmN1cnJlbnQpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH0sIFtjYW52YXNSZWYsIGlzUGF1c2VkLCBhdXRvU3RhcnRdKTtcclxuXHJcbiAgLy8gUHJvdmlkZSBhIHN0YWJsZSByZWZlcmVuY2UgZm9yIHVzZXIgaW5wdXQgKHRhcC9jbGljaylcclxuICAvLyBSZW1vdmVkIGhhbmRsZVVzZXJJbnB1dCBhcyBpdCdzIG5vIGxvbmdlciBuZWVkZWRcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGhpZ2hTY29yZSxcclxuICAgIGN1cnJlbnRTY29yZSxcclxuICAgIGZsYXAsIC8vIEV4cG9zZWQgZmxhcCBmdW5jdGlvblxyXG4gIH07XHJcbn1cclxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwiR1JBVklUWSIsIkZMQVAiLCJQSVBFX1dJRFRIIiwiUElQRV9TUEFDSU5HIiwiQklSRF9XSURUSCIsIkJJUkRfSEVJR0hUIiwiQ09JTl9TSVpFIiwiUElQRV9TUEFXTl9JTlRFUlZBTCIsIkhPUklaT05UQUxfU1BFRUQiLCJST1RBVElPTl9TUEVFRCIsIklERUFMX0ZSQU1FIiwidXNlRmxhcHB5QmlyZEdhbWUiLCJjYW52YXNSZWYiLCJpc1BhdXNlZCIsImF1dG9TdGFydCIsInJlcXVlc3RJZFJlZiIsImhpZ2hTY29yZSIsInNldEhpZ2hTY29yZSIsImN1cnJlbnRTY29yZSIsInNldEN1cnJlbnRTY29yZSIsImJpcmRZUmVmIiwiYmlyZFZlbG9jaXR5UmVmIiwicGlwZXNSZWYiLCJjb2luc1JlZiIsImdhbWVPdmVyUmVmIiwiZ2FtZVN0YXJ0ZWRSZWYiLCJjb2luUm90YXRpb25SZWYiLCJwaXBlU3Bhd25UaW1lclJlZiIsImxhc3RUaW1lUmVmIiwiYmlyZEltYWdlcyIsInBpcGVUb3AiLCJwaXBlQm90dG9tIiwiYmFja2dyb3VuZCIsImNvaW5JbWFnZSIsImJpcmRVcCIsIkltYWdlIiwic3JjIiwiYmlyZE1pZCIsImJpcmREb3duIiwiY3VycmVudEJpcmRGcmFtZVJlZiIsInN0b3JlZEhpZ2hTY29yZSIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJwYXJzZUludCIsImNhbnZhcyIsImN1cnJlbnQiLCJjdHgiLCJnZXRDb250ZXh0IiwibG9hZEltYWdlIiwiaW1nIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJjb21wbGV0ZSIsIm9ubG9hZCIsIm9uZXJyb3IiLCJFcnJvciIsImxvYWRBc3NldHMiLCJhbGwiLCJtYXAiLCJpbml0aWFsaXplR2FtZSIsImVycm9yIiwiY29uc29sZSIsIndpZHRoIiwiaGVpZ2h0IiwiZHJhd1N0YXJ0U2NyZWVuIiwicmVzZXRHYW1lIiwic3RhcnRHYW1lIiwicGVyZm9ybWFuY2UiLCJub3ciLCJhbmltYXRlIiwiZmxhcCIsImZsYXBBbmltYXRpb24iLCJzZXRUaW1lb3V0IiwiY3VycmVudFRpbWUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjb250ZXh0IiwiZGVsdGFUaW1lIiwidXBkYXRlR2FtZVN0YXRlIiwiZHJhdyIsImRyYXdHYW1lT3ZlclNjcmVlbiIsInNjYWxlIiwiY3JlYXRlUGlwZSIsIm1vdmVQaXBlc0FuZENvaW5zIiwiY2hlY2tDb2xsaXNpb25zIiwiY2hlY2tDb2luQ29sbGVjdGlvbiIsInVwZGF0ZVNjb3JlIiwiY2xlYXJSZWN0IiwiZHJhd0JhY2tncm91bmQiLCJkcmF3QmlyZCIsImRyYXdQaXBlcyIsImRyYXdDb2lucyIsImZvbnQiLCJ0ZXh0QWxpZ24iLCJmaWxsU3R5bGUiLCJzaGFkb3dDb2xvciIsInRleHRCYXNlbGluZSIsImZpbGxUZXh0Iiwic2hhZG93Qmx1ciIsImRyYXdJbWFnZSIsImN1cnJlbnRJbWFnZSIsInBpcGUiLCJ4IiwidG9wSGVpZ2h0IiwiYm90dG9tWSIsImJvdHRvbUhlaWdodCIsInNjYWxlWCIsIk1hdGgiLCJhYnMiLCJjb3MiLCJQSSIsImhhbGZTaXplIiwiY29pbiIsImNvbGxlY3RlZCIsInNhdmUiLCJ0cmFuc2xhdGUiLCJ5IiwicmVzdG9yZSIsInBpcGVIZWlnaHQiLCJyYW5kb20iLCJwdXNoIiwic2NvcmVkIiwiZmlsdGVyIiwiYmlyZExlZnQiLCJiaXJkUmlnaHQiLCJiaXJkVG9wIiwiYmlyZEJvdHRvbSIsIndpdGhpblBpcGVYIiwid2l0aGluUGlwZVkiLCJjb2luTGVmdCIsImNvaW5SaWdodCIsImNvaW5Ub3AiLCJjb2luQm90dG9tIiwicHJldlNjb3JlIiwibmV3U2NvcmUiLCJwcmV2SGlnaFNjb3JlIiwibWF4IiwidXBkYXRlZEhpZ2hTY29yZSIsInNldEl0ZW0iLCJ0b1N0cmluZyIsImxhc3RUYXAiLCJoYW5kbGVJbnB1dCIsImUiLCJwcmV2ZW50RGVmYXVsdCIsIkRhdGUiLCJnZXRUaW1lIiwidGFwTGVuZ3RoIiwiY2xlYXJUaW1lb3V0IiwidGltZW91dCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./public/useFlappyBirdGame.ts\n"));

/***/ })

});