"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./public/useFlappyBirdGame.ts":
/*!*************************************!*\
  !*** ./public/useFlappyBirdGame.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFlappyBirdGame: function() { return /* binding */ useFlappyBirdGame; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n// hooks/useFlappyBirdGame.ts\n\n// ... [Other imports and interfaces remain unchanged]\nfunction useFlappyBirdGame(canvasRef, isPaused, autoStart) {\n    const requestIdRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // State\n    const [highScore, setHighScore] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [currentScore, setCurrentScore] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    // Refs to track game state\n    const birdYRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const birdVelocityRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const pipesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const coinsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const gameOverRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const gameStartedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // For coin rotation\n    const coinRotationRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // Track time for spawning pipes\n    const pipeSpawnTimerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // We'll track the previous timestamp for time-based movement\n    const lastTimeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // Current bird frame index (0=up, 1=mid, 2=down)\n    const currentBirdFrameRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // Load high score from localStorage on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (true) {\n            const storedHighScore = localStorage.getItem(\"highScore\");\n            if (storedHighScore) {\n                setHighScore(parseInt(storedHighScore, 10));\n            }\n        }\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        // Utility to ensure an image is fully loaded\n        const loadImage = (img)=>{\n            return new Promise((resolve, reject)=>{\n                if (img.complete) {\n                    resolve();\n                } else {\n                    img.onload = ()=>resolve();\n                    img.onerror = ()=>reject(new Error(\"Failed to load image: \".concat(img.src)));\n                }\n            });\n        };\n        // Load all assets then init\n        const loadAssets = async ()=>{\n            try {\n                await Promise.all([\n                    ...birdImages.map((img)=>loadImage(img)),\n                    loadImage(pipeTop),\n                    loadImage(pipeBottom),\n                    loadImage(background),\n                    loadImage(coinImage)\n                ]);\n                initializeGame();\n            } catch (error) {\n                console.error(\"Error loading assets:\", error);\n            }\n        };\n        loadAssets();\n        function initializeGame() {\n            if (!canvasRef.current) return;\n            if (!ctx) return;\n            // Fixed canvas size\n            canvasRef.current.width = 360;\n            canvasRef.current.height = 640;\n            drawStartScreen(ctx, canvasRef.current);\n        }\n        function resetGame() {\n            if (!canvasRef.current) return;\n            const { width, height } = canvasRef.current;\n            birdYRef.current = height / 3;\n            birdVelocityRef.current = 0;\n            pipesRef.current = [];\n            coinsRef.current = [];\n            setCurrentScore(0);\n            gameOverRef.current = false;\n            gameStartedRef.current = false;\n            coinRotationRef.current = 0;\n            pipeSpawnTimerRef.current = 0;\n            currentBirdFrameRef.current = 0;\n        }\n        // Removed handleKeyDown since we'll handle input directly\n        // Start game\n        function startGame() {\n            resetGame();\n            gameStartedRef.current = true;\n            lastTimeRef.current = performance.now(); // reset our time-based reference\n            animate();\n        }\n        // Flap function to be called directly\n        function flap1() {\n            if (!gameStartedRef.current && !gameOverRef.current) {\n                startGame();\n            } else if (gameOverRef.current) {\n                startGame();\n            } else {\n                birdVelocityRef.current = FLAP;\n                flapAnimation();\n            }\n        }\n        // Quick flap animation\n        function flapAnimation() {\n            currentBirdFrameRef.current = 1;\n            setTimeout(()=>{\n                currentBirdFrameRef.current = 2;\n                setTimeout(()=>{\n                    currentBirdFrameRef.current = 0;\n                }, 170);\n            }, 170);\n        }\n        // Main game loop\n        function animate(currentTime) {\n            if (!gameStartedRef.current) {\n                // If game hasn't started, just schedule the next frame\n                requestIdRef.current = requestAnimationFrame(animate);\n                return;\n            }\n            if (isPaused) {\n                // If paused, just schedule the next frame\n                requestIdRef.current = requestAnimationFrame(animate);\n                return;\n            }\n            if (!canvasRef.current) return;\n            const context = canvasRef.current.getContext(\"2d\");\n            if (!context) return;\n            // Compute deltaTime\n            const now = currentTime !== null && currentTime !== void 0 ? currentTime : performance.now();\n            const deltaTime = now - lastTimeRef.current;\n            lastTimeRef.current = now;\n            // Update the game state\n            updateGameState(canvasRef.current, deltaTime);\n            // Render\n            draw(context, canvasRef.current);\n            if (!gameOverRef.current) {\n                requestIdRef.current = requestAnimationFrame(animate);\n            } else {\n                drawGameOverScreen(context, canvasRef.current);\n            }\n        }\n        function updateGameState(canvas, deltaTime) {\n            // Scale factor relative to ~60fps = 16.67ms per frame\n            const scale = deltaTime / IDEAL_FRAME;\n            // Gravity\n            birdVelocityRef.current += GRAVITY * scale;\n            birdYRef.current += birdVelocityRef.current * scale;\n            // Update pipe spawn timer\n            pipeSpawnTimerRef.current += deltaTime;\n            if (pipeSpawnTimerRef.current >= PIPE_SPAWN_INTERVAL) {\n                pipeSpawnTimerRef.current -= PIPE_SPAWN_INTERVAL;\n                createPipe(canvas);\n            }\n            // Move pipes & coins\n            movePipesAndCoins(scale);\n            // Rotate coin (0 -> 1 is a full cycle in our usage)\n            coinRotationRef.current += ROTATION_SPEED * scale;\n            if (coinRotationRef.current >= 1) {\n                coinRotationRef.current = 0;\n            }\n            // Check collisions\n            if (checkCollisions(canvas)) {\n                gameOverRef.current = true;\n                return;\n            }\n            // Check coin collection\n            checkCoinCollection();\n            // Update score if we pass pipes\n            updateScore();\n        }\n        function draw(ctx, canvas) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawBackground(ctx, canvas);\n            drawBird(ctx);\n            drawPipes(ctx);\n            drawCoins(ctx);\n        }\n        function drawStartScreen(ctx, canvas) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawBackground(ctx, canvas);\n            ctx.font = \"bold 30px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.fillStyle = \"#ffffff\";\n            ctx.shadowColor = \"black\";\n            ctx.textBaseline = \"middle\";\n            ctx.fillText(\"Tap to Start\", canvas.width / 2, canvas.height / 2);\n        }\n        function drawGameOverScreen(ctx, canvas) {\n            ctx.fillStyle = \"#ffcc00\";\n            ctx.font = \"bold 50px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"middle\";\n            ctx.shadowColor = \"black\";\n            ctx.shadowBlur = 10;\n            ctx.fillText(\"Game Over!\", canvas.width / 2, canvas.height / 2 - 40);\n            ctx.fillStyle = \"#ffffff\";\n            ctx.font = \"bold 30px Arial\";\n            ctx.fillText(\"Tap to Restart\", canvas.width / 2, canvas.height / 2 + 20);\n        }\n        function drawBackground(ctx, canvas) {\n            ctx.drawImage(background, 0, 0, canvas.width, canvas.height);\n        }\n        function drawBird(ctx) {\n            const currentImage = birdImages[currentBirdFrameRef.current];\n            // Draw the bird at a fixed X (100) and current birdY\n            if (currentImage.complete) {\n                ctx.drawImage(currentImage, 100, birdYRef.current, BIRD_WIDTH, BIRD_HEIGHT);\n            }\n        }\n        function drawPipes(ctx) {\n            for (const pipe of pipesRef.current){\n                ctx.drawImage(pipeTop, pipe.x, 0, PIPE_WIDTH, pipe.topHeight);\n                ctx.drawImage(pipeBottom, pipe.x, pipe.bottomY, PIPE_WIDTH, pipe.bottomHeight);\n            }\n        }\n        function drawCoins(ctx) {\n            // We'll flip the coin horizontally using scale\n            const scaleX = Math.abs(Math.cos(coinRotationRef.current * Math.PI * 2));\n            const halfSize = COIN_SIZE / 2;\n            for (const coin of coinsRef.current){\n                if (!coin.collected) {\n                    ctx.save();\n                    ctx.translate(coin.x + halfSize, coin.y + halfSize);\n                    ctx.scale(scaleX, 1); // Horizontal flip effect\n                    ctx.drawImage(coinImage, -halfSize, -halfSize, COIN_SIZE, COIN_SIZE);\n                    ctx.restore();\n                }\n            }\n        }\n        function createPipe(canvas) {\n            // Random top pipe height\n            const pipeHeight = Math.random() * (canvas.height - PIPE_SPACING - 100) + 50;\n            const bottomY = pipeHeight + PIPE_SPACING;\n            pipesRef.current.push({\n                x: canvas.width,\n                topHeight: pipeHeight,\n                bottomY,\n                bottomHeight: canvas.height - bottomY,\n                scored: false\n            });\n            // 50% chance to spawn a coin\n            if (Math.random() > 0.5) {\n                coinsRef.current.push({\n                    x: canvas.width + PIPE_WIDTH / 2 - COIN_SIZE / 2,\n                    y: pipeHeight + PIPE_SPACING / 2 - COIN_SIZE / 2,\n                    width: COIN_SIZE,\n                    height: COIN_SIZE,\n                    collected: false\n                });\n            }\n        }\n        function movePipesAndCoins(scale) {\n            // Move them to the left based on scale\n            for (const pipe of pipesRef.current){\n                pipe.x -= HORIZONTAL_SPEED * scale;\n            }\n            // Filter out pipes that have scrolled offscreen\n            pipesRef.current = pipesRef.current.filter((pipe)=>pipe.x + PIPE_WIDTH > 0);\n            for (const coin of coinsRef.current){\n                coin.x -= HORIZONTAL_SPEED * scale;\n            }\n            // Filter out coins that have scrolled offscreen or are collected\n            coinsRef.current = coinsRef.current.filter((coin)=>coin.x + coin.width > 0 && !coin.collected);\n        }\n        function checkCollisions(canvas) {\n            // Check top/bottom boundaries\n            if (birdYRef.current < 0 || birdYRef.current + BIRD_HEIGHT > canvas.height) {\n                return true;\n            }\n            const birdLeft = 100;\n            const birdRight = birdLeft + BIRD_WIDTH;\n            const birdTop = birdYRef.current;\n            const birdBottom = birdYRef.current + BIRD_HEIGHT;\n            // Pipe collision\n            for (const pipe of pipesRef.current){\n                const withinPipeX = birdRight > pipe.x && birdLeft < pipe.x + PIPE_WIDTH;\n                const withinPipeY = birdTop < pipe.topHeight || birdBottom > pipe.bottomY;\n                if (withinPipeX && withinPipeY) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function checkCoinCollection() {\n            const birdLeft = 100;\n            const birdRight = birdLeft + BIRD_WIDTH;\n            const birdTop = birdYRef.current;\n            const birdBottom = birdYRef.current + BIRD_HEIGHT;\n            for (const coin of coinsRef.current){\n                if (!coin.collected) {\n                    const coinLeft = coin.x;\n                    const coinRight = coin.x + coin.width;\n                    const coinTop = coin.y;\n                    const coinBottom = coin.y + coin.height;\n                    if (birdRight > coinLeft && birdLeft < coinRight && birdBottom > coinTop && birdTop < coinBottom) {\n                        // Collect coin\n                        coin.collected = true;\n                        setCurrentScore((prevScore)=>{\n                            const newScore = prevScore + 5;\n                            setHighScore((prevHighScore)=>Math.max(prevHighScore, newScore));\n                            return newScore;\n                        });\n                    }\n                }\n            }\n        }\n        function updateScore() {\n            for (const pipe of pipesRef.current){\n                // Score +1 for passing each pipe, only once\n                if (!pipe.scored && pipe.x + PIPE_WIDTH < 100) {\n                    pipe.scored = true;\n                    setCurrentScore((prevScore)=>{\n                        const newScore = prevScore + 1;\n                        setHighScore((prevHighScore)=>{\n                            const updatedHighScore = Math.max(prevHighScore, newScore);\n                            if (true) {\n                                localStorage.setItem(\"highScore\", updatedHighScore.toString());\n                            }\n                            return updatedHighScore;\n                        });\n                        return newScore;\n                    });\n                }\n            }\n        }\n        // Touch and Click Events Handling\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            const canvas = canvasRef.current;\n            if (!canvas) return;\n            // Handle touch and click events to trigger flap\n            const handleInput = (e)=>{\n                e.preventDefault(); // Prevent default to avoid duplicate events\n                flap1();\n            };\n            // Add touchstart and mousedown listeners\n            canvas.addEventListener(\"touchstart\", handleInput);\n            canvas.addEventListener(\"mousedown\", handleInput);\n            return ()=>{\n                canvas.removeEventListener(\"touchstart\", handleInput);\n                canvas.removeEventListener(\"mousedown\", handleInput);\n            };\n        }, [\n            canvasRef,\n            isPaused,\n            autoStart\n        ]);\n        return ()=>{\n            if (requestIdRef.current) {\n                cancelAnimationFrame(requestIdRef.current);\n            }\n        };\n    }, [\n        canvasRef,\n        isPaused,\n        autoStart\n    ]);\n    // Provide a stable reference for user input (tap/click)\n    // Removed handleUserInput as it's no longer needed\n    return {\n        highScore,\n        currentScore,\n        flap\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFRO1lBRWIsZ0RBQWdEO1lBQ2hELE1BQU1pSCxjQUFjLENBQUNDO2dCQUNuQkEsRUFBRUMsY0FBYyxJQUFJLDRDQUE0QztnQkFDaEVsRjtZQUNGO1lBRUEseUNBQXlDO1lBQ3pDakMsT0FBT29ILGdCQUFnQixDQUFDLGNBQWNIO1lBQ3RDakgsT0FBT29ILGdCQUFnQixDQUFDLGFBQWFIO1lBRXJDLE9BQU87Z0JBQ0xqSCxPQUFPcUgsbUJBQW1CLENBQUMsY0FBY0o7Z0JBQ3pDakgsT0FBT3FILG1CQUFtQixDQUFDLGFBQWFKO1lBQzFDO1FBQ0YsR0FBRztZQUFDdkk7WUFBV0M7WUFBVUM7U0FBVTtRQUVuQyxPQUFPO1lBQ0wsSUFBSUMsYUFBYW9CLE9BQU8sRUFBRTtnQkFDeEJxSCxxQkFBcUJ6SSxhQUFhb0IsT0FBTztZQUMzQztRQUNGO0lBQ0YsR0FBRztRQUFDdkI7UUFBV0M7UUFBVUM7S0FBVTtJQUVuQyx3REFBd0Q7SUFDeEQsbURBQW1EO0lBRW5ELE9BQU87UUFDTEU7UUFDQUU7UUFDQWlEO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wdWJsaWMvdXNlRmxhcHB5QmlyZEdhbWUudHM/NWM3OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBob29rcy91c2VGbGFwcHlCaXJkR2FtZS50c1xyXG5cclxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XHJcblxyXG4vLyAuLi4gW090aGVyIGltcG9ydHMgYW5kIGludGVyZmFjZXMgcmVtYWluIHVuY2hhbmdlZF1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VGbGFwcHlCaXJkR2FtZShcclxuICBjYW52YXNSZWY6IFJlYWN0LlJlZk9iamVjdDxIVE1MQ2FudmFzRWxlbWVudD4sXHJcbiAgaXNQYXVzZWQ6IGJvb2xlYW4sXHJcbiAgYXV0b1N0YXJ0OiBib29sZWFuXHJcbikge1xyXG4gIGNvbnN0IHJlcXVlc3RJZFJlZiA9IHVzZVJlZjxudW1iZXIgfCBudWxsPihudWxsKTtcclxuXHJcbiAgLy8gU3RhdGVcclxuICBjb25zdCBbaGlnaFNjb3JlLCBzZXRIaWdoU2NvcmVdID0gdXNlU3RhdGUoMCk7XHJcbiAgY29uc3QgW2N1cnJlbnRTY29yZSwgc2V0Q3VycmVudFNjb3JlXSA9IHVzZVN0YXRlKDApO1xyXG5cclxuICAvLyBSZWZzIHRvIHRyYWNrIGdhbWUgc3RhdGVcclxuICBjb25zdCBiaXJkWVJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xyXG4gIGNvbnN0IGJpcmRWZWxvY2l0eVJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xyXG4gIGNvbnN0IHBpcGVzUmVmID0gdXNlUmVmPFBpcGVbXT4oW10pO1xyXG4gIGNvbnN0IGNvaW5zUmVmID0gdXNlUmVmPENvaW5bXT4oW10pO1xyXG4gIGNvbnN0IGdhbWVPdmVyUmVmID0gdXNlUmVmPGJvb2xlYW4+KGZhbHNlKTtcclxuICBjb25zdCBnYW1lU3RhcnRlZFJlZiA9IHVzZVJlZjxib29sZWFuPihmYWxzZSk7XHJcblxyXG4gIC8vIEZvciBjb2luIHJvdGF0aW9uXHJcbiAgY29uc3QgY29pblJvdGF0aW9uUmVmID0gdXNlUmVmPG51bWJlcj4oMCk7XHJcblxyXG4gIC8vIFRyYWNrIHRpbWUgZm9yIHNwYXduaW5nIHBpcGVzXHJcbiAgY29uc3QgcGlwZVNwYXduVGltZXJSZWYgPSB1c2VSZWY8bnVtYmVyPigwKTtcclxuXHJcbiAgLy8gV2UnbGwgdHJhY2sgdGhlIHByZXZpb3VzIHRpbWVzdGFtcCBmb3IgdGltZS1iYXNlZCBtb3ZlbWVudFxyXG4gIGNvbnN0IGxhc3RUaW1lUmVmID0gdXNlUmVmPG51bWJlcj4oMCk7XHJcblxyXG4gIC8vIEN1cnJlbnQgYmlyZCBmcmFtZSBpbmRleCAoMD11cCwgMT1taWQsIDI9ZG93bilcclxuICBjb25zdCBjdXJyZW50QmlyZEZyYW1lUmVmID0gdXNlUmVmPG51bWJlcj4oMCk7XHJcblxyXG4gIC8vIExvYWQgaGlnaCBzY29yZSBmcm9tIGxvY2FsU3RvcmFnZSBvbiBtb3VudFxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICBjb25zdCBzdG9yZWRIaWdoU2NvcmUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImhpZ2hTY29yZVwiKTtcclxuICAgICAgaWYgKHN0b3JlZEhpZ2hTY29yZSkge1xyXG4gICAgICAgIHNldEhpZ2hTY29yZShwYXJzZUludChzdG9yZWRIaWdoU2NvcmUsIDEwKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LCBbXSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcclxuICAgIGlmICghY2FudmFzKSByZXR1cm47XHJcblxyXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuICAgIGlmICghY3R4KSByZXR1cm47XHJcblxyXG4gICAgLy8gVXRpbGl0eSB0byBlbnN1cmUgYW4gaW1hZ2UgaXMgZnVsbHkgbG9hZGVkXHJcbiAgICBjb25zdCBsb2FkSW1hZ2UgPSAoaW1nOiBIVE1MSW1hZ2VFbGVtZW50KTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgaWYgKGltZy5jb21wbGV0ZSkge1xyXG4gICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpbWcub25sb2FkID0gKCkgPT4gcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgaW1nLm9uZXJyb3IgPSAoKSA9PlxyXG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBpbWFnZTogJHtpbWcuc3JjfWApKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBMb2FkIGFsbCBhc3NldHMgdGhlbiBpbml0XHJcbiAgICBjb25zdCBsb2FkQXNzZXRzID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgICAgICAgIC4uLmJpcmRJbWFnZXMubWFwKChpbWcpID0+IGxvYWRJbWFnZShpbWcpKSxcclxuICAgICAgICAgIGxvYWRJbWFnZShwaXBlVG9wKSxcclxuICAgICAgICAgIGxvYWRJbWFnZShwaXBlQm90dG9tKSxcclxuICAgICAgICAgIGxvYWRJbWFnZShiYWNrZ3JvdW5kKSxcclxuICAgICAgICAgIGxvYWRJbWFnZShjb2luSW1hZ2UpLFxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIGluaXRpYWxpemVHYW1lKCk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGxvYWRpbmcgYXNzZXRzOlwiLCBlcnJvcik7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgbG9hZEFzc2V0cygpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGluaXRpYWxpemVHYW1lKCkge1xyXG4gICAgICBpZiAoIWNhbnZhc1JlZi5jdXJyZW50KSByZXR1cm47XHJcbiAgICAgIGlmICghY3R4KSByZXR1cm47XHJcbiAgICAgIC8vIEZpeGVkIGNhbnZhcyBzaXplXHJcbiAgICAgIGNhbnZhc1JlZi5jdXJyZW50LndpZHRoID0gMzYwO1xyXG4gICAgICBjYW52YXNSZWYuY3VycmVudC5oZWlnaHQgPSA2NDA7XHJcbiAgICAgIGRyYXdTdGFydFNjcmVlbihjdHgsIGNhbnZhc1JlZi5jdXJyZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZXNldEdhbWUoKSB7XHJcbiAgICAgIGlmICghY2FudmFzUmVmLmN1cnJlbnQpIHJldHVybjtcclxuICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBjYW52YXNSZWYuY3VycmVudDtcclxuICAgICAgYmlyZFlSZWYuY3VycmVudCA9IGhlaWdodCAvIDM7XHJcbiAgICAgIGJpcmRWZWxvY2l0eVJlZi5jdXJyZW50ID0gMDtcclxuICAgICAgcGlwZXNSZWYuY3VycmVudCA9IFtdO1xyXG4gICAgICBjb2luc1JlZi5jdXJyZW50ID0gW107XHJcbiAgICAgIHNldEN1cnJlbnRTY29yZSgwKTtcclxuICAgICAgZ2FtZU92ZXJSZWYuY3VycmVudCA9IGZhbHNlO1xyXG4gICAgICBnYW1lU3RhcnRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICAgIGNvaW5Sb3RhdGlvblJlZi5jdXJyZW50ID0gMDtcclxuICAgICAgcGlwZVNwYXduVGltZXJSZWYuY3VycmVudCA9IDA7XHJcbiAgICAgIGN1cnJlbnRCaXJkRnJhbWVSZWYuY3VycmVudCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVtb3ZlZCBoYW5kbGVLZXlEb3duIHNpbmNlIHdlJ2xsIGhhbmRsZSBpbnB1dCBkaXJlY3RseVxyXG5cclxuICAgIC8vIFN0YXJ0IGdhbWVcclxuICAgIGZ1bmN0aW9uIHN0YXJ0R2FtZSgpIHtcclxuICAgICAgcmVzZXRHYW1lKCk7XHJcbiAgICAgIGdhbWVTdGFydGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xyXG4gICAgICBsYXN0VGltZVJlZi5jdXJyZW50ID0gcGVyZm9ybWFuY2Uubm93KCk7IC8vIHJlc2V0IG91ciB0aW1lLWJhc2VkIHJlZmVyZW5jZVxyXG4gICAgICBhbmltYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRmxhcCBmdW5jdGlvbiB0byBiZSBjYWxsZWQgZGlyZWN0bHlcclxuICAgIGZ1bmN0aW9uIGZsYXAoKSB7XHJcbiAgICAgIGlmICghZ2FtZVN0YXJ0ZWRSZWYuY3VycmVudCAmJiAhZ2FtZU92ZXJSZWYuY3VycmVudCkge1xyXG4gICAgICAgIHN0YXJ0R2FtZSgpO1xyXG4gICAgICB9IGVsc2UgaWYgKGdhbWVPdmVyUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBzdGFydEdhbWUoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBiaXJkVmVsb2NpdHlSZWYuY3VycmVudCA9IEZMQVA7XHJcbiAgICAgICAgZmxhcEFuaW1hdGlvbigpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUXVpY2sgZmxhcCBhbmltYXRpb25cclxuICAgIGZ1bmN0aW9uIGZsYXBBbmltYXRpb24oKSB7XHJcbiAgICAgIGN1cnJlbnRCaXJkRnJhbWVSZWYuY3VycmVudCA9IDE7XHJcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIGN1cnJlbnRCaXJkRnJhbWVSZWYuY3VycmVudCA9IDI7XHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICBjdXJyZW50QmlyZEZyYW1lUmVmLmN1cnJlbnQgPSAwO1xyXG4gICAgICAgIH0sIDE3MCk7XHJcbiAgICAgIH0sIDE3MCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTWFpbiBnYW1lIGxvb3BcclxuICAgIGZ1bmN0aW9uIGFuaW1hdGUoY3VycmVudFRpbWU/OiBudW1iZXIpIHtcclxuICAgICAgaWYgKCFnYW1lU3RhcnRlZFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgLy8gSWYgZ2FtZSBoYXNuJ3Qgc3RhcnRlZCwganVzdCBzY2hlZHVsZSB0aGUgbmV4dCBmcmFtZVxyXG4gICAgICAgIHJlcXVlc3RJZFJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaXNQYXVzZWQpIHtcclxuICAgICAgICAvLyBJZiBwYXVzZWQsIGp1c3Qgc2NoZWR1bGUgdGhlIG5leHQgZnJhbWVcclxuICAgICAgICByZXF1ZXN0SWRSZWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFjYW52YXNSZWYuY3VycmVudCkgcmV0dXJuO1xyXG4gICAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzUmVmLmN1cnJlbnQuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgICBpZiAoIWNvbnRleHQpIHJldHVybjtcclxuXHJcbiAgICAgIC8vIENvbXB1dGUgZGVsdGFUaW1lXHJcbiAgICAgIGNvbnN0IG5vdyA9IGN1cnJlbnRUaW1lID8/IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICBjb25zdCBkZWx0YVRpbWUgPSBub3cgLSBsYXN0VGltZVJlZi5jdXJyZW50O1xyXG4gICAgICBsYXN0VGltZVJlZi5jdXJyZW50ID0gbm93O1xyXG5cclxuICAgICAgLy8gVXBkYXRlIHRoZSBnYW1lIHN0YXRlXHJcbiAgICAgIHVwZGF0ZUdhbWVTdGF0ZShjYW52YXNSZWYuY3VycmVudCwgZGVsdGFUaW1lKTtcclxuXHJcbiAgICAgIC8vIFJlbmRlclxyXG4gICAgICBkcmF3KGNvbnRleHQsIGNhbnZhc1JlZi5jdXJyZW50KTtcclxuXHJcbiAgICAgIGlmICghZ2FtZU92ZXJSZWYuY3VycmVudCkge1xyXG4gICAgICAgIHJlcXVlc3RJZFJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRyYXdHYW1lT3ZlclNjcmVlbihjb250ZXh0LCBjYW52YXNSZWYuY3VycmVudCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVHYW1lU3RhdGUoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgZGVsdGFUaW1lOiBudW1iZXIpIHtcclxuICAgICAgLy8gU2NhbGUgZmFjdG9yIHJlbGF0aXZlIHRvIH42MGZwcyA9IDE2LjY3bXMgcGVyIGZyYW1lXHJcbiAgICAgIGNvbnN0IHNjYWxlID0gZGVsdGFUaW1lIC8gSURFQUxfRlJBTUU7XHJcblxyXG4gICAgICAvLyBHcmF2aXR5XHJcbiAgICAgIGJpcmRWZWxvY2l0eVJlZi5jdXJyZW50ICs9IEdSQVZJVFkgKiBzY2FsZTtcclxuICAgICAgYmlyZFlSZWYuY3VycmVudCArPSBiaXJkVmVsb2NpdHlSZWYuY3VycmVudCAqIHNjYWxlO1xyXG5cclxuICAgICAgLy8gVXBkYXRlIHBpcGUgc3Bhd24gdGltZXJcclxuICAgICAgcGlwZVNwYXduVGltZXJSZWYuY3VycmVudCArPSBkZWx0YVRpbWU7XHJcbiAgICAgIGlmIChwaXBlU3Bhd25UaW1lclJlZi5jdXJyZW50ID49IFBJUEVfU1BBV05fSU5URVJWQUwpIHtcclxuICAgICAgICBwaXBlU3Bhd25UaW1lclJlZi5jdXJyZW50IC09IFBJUEVfU1BBV05fSU5URVJWQUw7XHJcbiAgICAgICAgY3JlYXRlUGlwZShjYW52YXMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBNb3ZlIHBpcGVzICYgY29pbnNcclxuICAgICAgbW92ZVBpcGVzQW5kQ29pbnMoc2NhbGUpO1xyXG5cclxuICAgICAgLy8gUm90YXRlIGNvaW4gKDAgLT4gMSBpcyBhIGZ1bGwgY3ljbGUgaW4gb3VyIHVzYWdlKVxyXG4gICAgICBjb2luUm90YXRpb25SZWYuY3VycmVudCArPSBST1RBVElPTl9TUEVFRCAqIHNjYWxlO1xyXG4gICAgICBpZiAoY29pblJvdGF0aW9uUmVmLmN1cnJlbnQgPj0gMSkge1xyXG4gICAgICAgIGNvaW5Sb3RhdGlvblJlZi5jdXJyZW50ID0gMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2hlY2sgY29sbGlzaW9uc1xyXG4gICAgICBpZiAoY2hlY2tDb2xsaXNpb25zKGNhbnZhcykpIHtcclxuICAgICAgICBnYW1lT3ZlclJlZi5jdXJyZW50ID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoZWNrIGNvaW4gY29sbGVjdGlvblxyXG4gICAgICBjaGVja0NvaW5Db2xsZWN0aW9uKCk7XHJcblxyXG4gICAgICAvLyBVcGRhdGUgc2NvcmUgaWYgd2UgcGFzcyBwaXBlc1xyXG4gICAgICB1cGRhdGVTY29yZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXcoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcclxuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICBkcmF3QmFja2dyb3VuZChjdHgsIGNhbnZhcyk7XHJcbiAgICAgIGRyYXdCaXJkKGN0eCk7XHJcbiAgICAgIGRyYXdQaXBlcyhjdHgpO1xyXG4gICAgICBkcmF3Q29pbnMoY3R4KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3U3RhcnRTY3JlZW4oY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcclxuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICBkcmF3QmFja2dyb3VuZChjdHgsIGNhbnZhcyk7XHJcblxyXG4gICAgICBjdHguZm9udCA9IFwiYm9sZCAzMHB4IEFyaWFsXCI7XHJcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xyXG4gICAgICBjdHguZmlsbFN0eWxlID0gXCIjZmZmZmZmXCI7XHJcbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFwiYmxhY2tcIjtcclxuICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XHJcblxyXG4gICAgICBjdHguZmlsbFRleHQoXHJcbiAgICAgICAgXCJUYXAgdG8gU3RhcnRcIixcclxuICAgICAgICBjYW52YXMud2lkdGggLyAyLFxyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgLyAyXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd0dhbWVPdmVyU2NyZWVuKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNmZmNjMDBcIjtcclxuICAgICAgY3R4LmZvbnQgPSBcImJvbGQgNTBweCBBcmlhbFwiO1xyXG4gICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcclxuICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XHJcbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFwiYmxhY2tcIjtcclxuICAgICAgY3R4LnNoYWRvd0JsdXIgPSAxMDtcclxuXHJcbiAgICAgIGN0eC5maWxsVGV4dChcIkdhbWUgT3ZlciFcIiwgY2FudmFzLndpZHRoIC8gMiwgY2FudmFzLmhlaWdodCAvIDIgLSA0MCk7XHJcblxyXG4gICAgICBjdHguZmlsbFN0eWxlID0gXCIjZmZmZmZmXCI7XHJcbiAgICAgIGN0eC5mb250ID0gXCJib2xkIDMwcHggQXJpYWxcIjtcclxuICAgICAgY3R4LmZpbGxUZXh0KFxyXG4gICAgICAgIFwiVGFwIHRvIFJlc3RhcnRcIixcclxuICAgICAgICBjYW52YXMud2lkdGggLyAyLFxyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgLyAyICsgMjBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3QmFja2dyb3VuZChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkge1xyXG4gICAgICBjdHguZHJhd0ltYWdlKGJhY2tncm91bmQsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd0JpcmQoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcclxuICAgICAgY29uc3QgY3VycmVudEltYWdlID0gYmlyZEltYWdlc1tjdXJyZW50QmlyZEZyYW1lUmVmLmN1cnJlbnRdO1xyXG4gICAgICAvLyBEcmF3IHRoZSBiaXJkIGF0IGEgZml4ZWQgWCAoMTAwKSBhbmQgY3VycmVudCBiaXJkWVxyXG4gICAgICBpZiAoY3VycmVudEltYWdlLmNvbXBsZXRlKSB7XHJcbiAgICAgICAgY3R4LmRyYXdJbWFnZShjdXJyZW50SW1hZ2UsIDEwMCwgYmlyZFlSZWYuY3VycmVudCwgQklSRF9XSURUSCwgQklSRF9IRUlHSFQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd1BpcGVzKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XHJcbiAgICAgIGZvciAoY29uc3QgcGlwZSBvZiBwaXBlc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY3R4LmRyYXdJbWFnZShwaXBlVG9wLCBwaXBlLngsIDAsIFBJUEVfV0lEVEgsIHBpcGUudG9wSGVpZ2h0KTtcclxuICAgICAgICBjdHguZHJhd0ltYWdlKHBpcGVCb3R0b20sIHBpcGUueCwgcGlwZS5ib3R0b21ZLCBQSVBFX1dJRFRILCBwaXBlLmJvdHRvbUhlaWdodCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3Q29pbnMoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcclxuICAgICAgLy8gV2UnbGwgZmxpcCB0aGUgY29pbiBob3Jpem9udGFsbHkgdXNpbmcgc2NhbGVcclxuICAgICAgY29uc3Qgc2NhbGVYID0gTWF0aC5hYnMoTWF0aC5jb3MoY29pblJvdGF0aW9uUmVmLmN1cnJlbnQgKiBNYXRoLlBJICogMikpO1xyXG4gICAgICBjb25zdCBoYWxmU2l6ZSA9IENPSU5fU0laRSAvIDI7XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGNvaW4gb2YgY29pbnNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGlmICghY29pbi5jb2xsZWN0ZWQpIHtcclxuICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICBjdHgudHJhbnNsYXRlKGNvaW4ueCArIGhhbGZTaXplLCBjb2luLnkgKyBoYWxmU2l6ZSk7XHJcbiAgICAgICAgICBjdHguc2NhbGUoc2NhbGVYLCAxKTsgLy8gSG9yaXpvbnRhbCBmbGlwIGVmZmVjdFxyXG4gICAgICAgICAgY3R4LmRyYXdJbWFnZShjb2luSW1hZ2UsIC1oYWxmU2l6ZSwgLWhhbGZTaXplLCBDT0lOX1NJWkUsIENPSU5fU0laRSk7XHJcbiAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBpcGUoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkge1xyXG4gICAgICAvLyBSYW5kb20gdG9wIHBpcGUgaGVpZ2h0XHJcbiAgICAgIGNvbnN0IHBpcGVIZWlnaHQgPSBNYXRoLnJhbmRvbSgpICogKGNhbnZhcy5oZWlnaHQgLSBQSVBFX1NQQUNJTkcgLSAxMDApICsgNTA7XHJcbiAgICAgIGNvbnN0IGJvdHRvbVkgPSBwaXBlSGVpZ2h0ICsgUElQRV9TUEFDSU5HO1xyXG4gICAgICBwaXBlc1JlZi5jdXJyZW50LnB1c2goe1xyXG4gICAgICAgIHg6IGNhbnZhcy53aWR0aCxcclxuICAgICAgICB0b3BIZWlnaHQ6IHBpcGVIZWlnaHQsXHJcbiAgICAgICAgYm90dG9tWSxcclxuICAgICAgICBib3R0b21IZWlnaHQ6IGNhbnZhcy5oZWlnaHQgLSBib3R0b21ZLFxyXG4gICAgICAgIHNjb3JlZDogZmFsc2UsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gNTAlIGNoYW5jZSB0byBzcGF3biBhIGNvaW5cclxuICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPiAwLjUpIHtcclxuICAgICAgICBjb2luc1JlZi5jdXJyZW50LnB1c2goe1xyXG4gICAgICAgICAgeDogY2FudmFzLndpZHRoICsgUElQRV9XSURUSCAvIDIgLSBDT0lOX1NJWkUgLyAyLFxyXG4gICAgICAgICAgeTogcGlwZUhlaWdodCArIFBJUEVfU1BBQ0lORyAvIDIgLSBDT0lOX1NJWkUgLyAyLFxyXG4gICAgICAgICAgd2lkdGg6IENPSU5fU0laRSxcclxuICAgICAgICAgIGhlaWdodDogQ09JTl9TSVpFLFxyXG4gICAgICAgICAgY29sbGVjdGVkOiBmYWxzZSxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1vdmVQaXBlc0FuZENvaW5zKHNjYWxlOiBudW1iZXIpIHtcclxuICAgICAgLy8gTW92ZSB0aGVtIHRvIHRoZSBsZWZ0IGJhc2VkIG9uIHNjYWxlXHJcbiAgICAgIGZvciAoY29uc3QgcGlwZSBvZiBwaXBlc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgcGlwZS54IC09IEhPUklaT05UQUxfU1BFRUQgKiBzY2FsZTtcclxuICAgICAgfVxyXG4gICAgICAvLyBGaWx0ZXIgb3V0IHBpcGVzIHRoYXQgaGF2ZSBzY3JvbGxlZCBvZmZzY3JlZW5cclxuICAgICAgcGlwZXNSZWYuY3VycmVudCA9IHBpcGVzUmVmLmN1cnJlbnQuZmlsdGVyKChwaXBlKSA9PiBwaXBlLnggKyBQSVBFX1dJRFRIID4gMCk7XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGNvaW4gb2YgY29pbnNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGNvaW4ueCAtPSBIT1JJWk9OVEFMX1NQRUVEICogc2NhbGU7XHJcbiAgICAgIH1cclxuICAgICAgLy8gRmlsdGVyIG91dCBjb2lucyB0aGF0IGhhdmUgc2Nyb2xsZWQgb2Zmc2NyZWVuIG9yIGFyZSBjb2xsZWN0ZWRcclxuICAgICAgY29pbnNSZWYuY3VycmVudCA9IGNvaW5zUmVmLmN1cnJlbnQuZmlsdGVyKFxyXG4gICAgICAgIChjb2luKSA9PiBjb2luLnggKyBjb2luLndpZHRoID4gMCAmJiAhY29pbi5jb2xsZWN0ZWRcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjaGVja0NvbGxpc2lvbnMoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCk6IGJvb2xlYW4ge1xyXG4gICAgICAvLyBDaGVjayB0b3AvYm90dG9tIGJvdW5kYXJpZXNcclxuICAgICAgaWYgKGJpcmRZUmVmLmN1cnJlbnQgPCAwIHx8IGJpcmRZUmVmLmN1cnJlbnQgKyBCSVJEX0hFSUdIVCA+IGNhbnZhcy5oZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgYmlyZExlZnQgPSAxMDA7XHJcbiAgICAgIGNvbnN0IGJpcmRSaWdodCA9IGJpcmRMZWZ0ICsgQklSRF9XSURUSDtcclxuICAgICAgY29uc3QgYmlyZFRvcCA9IGJpcmRZUmVmLmN1cnJlbnQ7XHJcbiAgICAgIGNvbnN0IGJpcmRCb3R0b20gPSBiaXJkWVJlZi5jdXJyZW50ICsgQklSRF9IRUlHSFQ7XHJcblxyXG4gICAgICAvLyBQaXBlIGNvbGxpc2lvblxyXG4gICAgICBmb3IgKGNvbnN0IHBpcGUgb2YgcGlwZXNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGNvbnN0IHdpdGhpblBpcGVYID0gYmlyZFJpZ2h0ID4gcGlwZS54ICYmIGJpcmRMZWZ0IDwgcGlwZS54ICsgUElQRV9XSURUSDtcclxuICAgICAgICBjb25zdCB3aXRoaW5QaXBlWSA9IGJpcmRUb3AgPCBwaXBlLnRvcEhlaWdodCB8fCBiaXJkQm90dG9tID4gcGlwZS5ib3R0b21ZO1xyXG4gICAgICAgIGlmICh3aXRoaW5QaXBlWCAmJiB3aXRoaW5QaXBlWSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjaGVja0NvaW5Db2xsZWN0aW9uKCkge1xyXG4gICAgICBjb25zdCBiaXJkTGVmdCA9IDEwMDtcclxuICAgICAgY29uc3QgYmlyZFJpZ2h0ID0gYmlyZExlZnQgKyBCSVJEX1dJRFRIO1xyXG4gICAgICBjb25zdCBiaXJkVG9wID0gYmlyZFlSZWYuY3VycmVudDtcclxuICAgICAgY29uc3QgYmlyZEJvdHRvbSA9IGJpcmRZUmVmLmN1cnJlbnQgKyBCSVJEX0hFSUdIVDtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgY29pbiBvZiBjb2luc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgaWYgKCFjb2luLmNvbGxlY3RlZCkge1xyXG4gICAgICAgICAgY29uc3QgY29pbkxlZnQgPSBjb2luLng7XHJcbiAgICAgICAgICBjb25zdCBjb2luUmlnaHQgPSBjb2luLnggKyBjb2luLndpZHRoO1xyXG4gICAgICAgICAgY29uc3QgY29pblRvcCA9IGNvaW4ueTtcclxuICAgICAgICAgIGNvbnN0IGNvaW5Cb3R0b20gPSBjb2luLnkgKyBjb2luLmhlaWdodDtcclxuXHJcbiAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIGJpcmRSaWdodCA+IGNvaW5MZWZ0ICYmXHJcbiAgICAgICAgICAgIGJpcmRMZWZ0IDwgY29pblJpZ2h0ICYmXHJcbiAgICAgICAgICAgIGJpcmRCb3R0b20gPiBjb2luVG9wICYmXHJcbiAgICAgICAgICAgIGJpcmRUb3AgPCBjb2luQm90dG9tXHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgLy8gQ29sbGVjdCBjb2luXHJcbiAgICAgICAgICAgIGNvaW4uY29sbGVjdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgc2V0Q3VycmVudFNjb3JlKChwcmV2U2NvcmUpID0+IHtcclxuICAgICAgICAgICAgICBjb25zdCBuZXdTY29yZSA9IHByZXZTY29yZSArIDU7XHJcbiAgICAgICAgICAgICAgc2V0SGlnaFNjb3JlKChwcmV2SGlnaFNjb3JlKSA9PiBNYXRoLm1heChwcmV2SGlnaFNjb3JlLCBuZXdTY29yZSkpO1xyXG4gICAgICAgICAgICAgIHJldHVybiBuZXdTY29yZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdXBkYXRlU2NvcmUoKSB7XHJcbiAgICAgIGZvciAoY29uc3QgcGlwZSBvZiBwaXBlc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgLy8gU2NvcmUgKzEgZm9yIHBhc3NpbmcgZWFjaCBwaXBlLCBvbmx5IG9uY2VcclxuICAgICAgICBpZiAoIXBpcGUuc2NvcmVkICYmIHBpcGUueCArIFBJUEVfV0lEVEggPCAxMDApIHtcclxuICAgICAgICAgIHBpcGUuc2NvcmVkID0gdHJ1ZTtcclxuICAgICAgICAgIHNldEN1cnJlbnRTY29yZSgocHJldlNjb3JlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1Njb3JlID0gcHJldlNjb3JlICsgMTtcclxuICAgICAgICAgICAgc2V0SGlnaFNjb3JlKChwcmV2SGlnaFNjb3JlKSA9PiB7XHJcbiAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZEhpZ2hTY29yZSA9IE1hdGgubWF4KHByZXZIaWdoU2NvcmUsIG5ld1Njb3JlKTtcclxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJoaWdoU2NvcmVcIiwgdXBkYXRlZEhpZ2hTY29yZS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZWRIaWdoU2NvcmU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3U2NvcmU7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBUb3VjaCBhbmQgQ2xpY2sgRXZlbnRzIEhhbmRsaW5nXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcclxuICAgICAgaWYgKCFjYW52YXMpIHJldHVybjtcclxuXHJcbiAgICAgIC8vIEhhbmRsZSB0b3VjaCBhbmQgY2xpY2sgZXZlbnRzIHRvIHRyaWdnZXIgZmxhcFxyXG4gICAgICBjb25zdCBoYW5kbGVJbnB1dCA9IChlOiBUb3VjaEV2ZW50IHwgTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTsgLy8gUHJldmVudCBkZWZhdWx0IHRvIGF2b2lkIGR1cGxpY2F0ZSBldmVudHNcclxuICAgICAgICBmbGFwKCk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBBZGQgdG91Y2hzdGFydCBhbmQgbW91c2Vkb3duIGxpc3RlbmVyc1xyXG4gICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgaGFuZGxlSW5wdXQpO1xyXG4gICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBoYW5kbGVJbnB1dCk7XHJcblxyXG4gICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBoYW5kbGVJbnB1dCk7XHJcbiAgICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgaGFuZGxlSW5wdXQpO1xyXG4gICAgICB9O1xyXG4gICAgfSwgW2NhbnZhc1JlZiwgaXNQYXVzZWQsIGF1dG9TdGFydF0pO1xyXG5cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGlmIChyZXF1ZXN0SWRSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJlcXVlc3RJZFJlZi5jdXJyZW50KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9LCBbY2FudmFzUmVmLCBpc1BhdXNlZCwgYXV0b1N0YXJ0XSk7XHJcblxyXG4gIC8vIFByb3ZpZGUgYSBzdGFibGUgcmVmZXJlbmNlIGZvciB1c2VyIGlucHV0ICh0YXAvY2xpY2spXHJcbiAgLy8gUmVtb3ZlZCBoYW5kbGVVc2VySW5wdXQgYXMgaXQncyBubyBsb25nZXIgbmVlZGVkXHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBoaWdoU2NvcmUsXHJcbiAgICBjdXJyZW50U2NvcmUsXHJcbiAgICBmbGFwLCAvLyBFeHBvc2VkIGZsYXAgZnVuY3Rpb25cclxuICB9O1xyXG59XHJcbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZUZsYXBweUJpcmRHYW1lIiwiY2FudmFzUmVmIiwiaXNQYXVzZWQiLCJhdXRvU3RhcnQiLCJyZXF1ZXN0SWRSZWYiLCJoaWdoU2NvcmUiLCJzZXRIaWdoU2NvcmUiLCJjdXJyZW50U2NvcmUiLCJzZXRDdXJyZW50U2NvcmUiLCJiaXJkWVJlZiIsImJpcmRWZWxvY2l0eVJlZiIsInBpcGVzUmVmIiwiY29pbnNSZWYiLCJnYW1lT3ZlclJlZiIsImdhbWVTdGFydGVkUmVmIiwiY29pblJvdGF0aW9uUmVmIiwicGlwZVNwYXduVGltZXJSZWYiLCJsYXN0VGltZVJlZiIsImN1cnJlbnRCaXJkRnJhbWVSZWYiLCJzdG9yZWRIaWdoU2NvcmUiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwicGFyc2VJbnQiLCJjYW52YXMiLCJjdXJyZW50IiwiY3R4IiwiZ2V0Q29udGV4dCIsImxvYWRJbWFnZSIsImltZyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiY29tcGxldGUiLCJvbmxvYWQiLCJvbmVycm9yIiwiRXJyb3IiLCJzcmMiLCJsb2FkQXNzZXRzIiwiYWxsIiwiYmlyZEltYWdlcyIsIm1hcCIsInBpcGVUb3AiLCJwaXBlQm90dG9tIiwiYmFja2dyb3VuZCIsImNvaW5JbWFnZSIsImluaXRpYWxpemVHYW1lIiwiZXJyb3IiLCJjb25zb2xlIiwid2lkdGgiLCJoZWlnaHQiLCJkcmF3U3RhcnRTY3JlZW4iLCJyZXNldEdhbWUiLCJzdGFydEdhbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsImFuaW1hdGUiLCJmbGFwIiwiRkxBUCIsImZsYXBBbmltYXRpb24iLCJzZXRUaW1lb3V0IiwiY3VycmVudFRpbWUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjb250ZXh0IiwiZGVsdGFUaW1lIiwidXBkYXRlR2FtZVN0YXRlIiwiZHJhdyIsImRyYXdHYW1lT3ZlclNjcmVlbiIsInNjYWxlIiwiSURFQUxfRlJBTUUiLCJHUkFWSVRZIiwiUElQRV9TUEFXTl9JTlRFUlZBTCIsImNyZWF0ZVBpcGUiLCJtb3ZlUGlwZXNBbmRDb2lucyIsIlJPVEFUSU9OX1NQRUVEIiwiY2hlY2tDb2xsaXNpb25zIiwiY2hlY2tDb2luQ29sbGVjdGlvbiIsInVwZGF0ZVNjb3JlIiwiY2xlYXJSZWN0IiwiZHJhd0JhY2tncm91bmQiLCJkcmF3QmlyZCIsImRyYXdQaXBlcyIsImRyYXdDb2lucyIsImZvbnQiLCJ0ZXh0QWxpZ24iLCJmaWxsU3R5bGUiLCJzaGFkb3dDb2xvciIsInRleHRCYXNlbGluZSIsImZpbGxUZXh0Iiwic2hhZG93Qmx1ciIsImRyYXdJbWFnZSIsImN1cnJlbnRJbWFnZSIsIkJJUkRfV0lEVEgiLCJCSVJEX0hFSUdIVCIsInBpcGUiLCJ4IiwiUElQRV9XSURUSCIsInRvcEhlaWdodCIsImJvdHRvbVkiLCJib3R0b21IZWlnaHQiLCJzY2FsZVgiLCJNYXRoIiwiYWJzIiwiY29zIiwiUEkiLCJoYWxmU2l6ZSIsIkNPSU5fU0laRSIsImNvaW4iLCJjb2xsZWN0ZWQiLCJzYXZlIiwidHJhbnNsYXRlIiwieSIsInJlc3RvcmUiLCJwaXBlSGVpZ2h0IiwicmFuZG9tIiwiUElQRV9TUEFDSU5HIiwicHVzaCIsInNjb3JlZCIsIkhPUklaT05UQUxfU1BFRUQiLCJmaWx0ZXIiLCJiaXJkTGVmdCIsImJpcmRSaWdodCIsImJpcmRUb3AiLCJiaXJkQm90dG9tIiwid2l0aGluUGlwZVgiLCJ3aXRoaW5QaXBlWSIsImNvaW5MZWZ0IiwiY29pblJpZ2h0IiwiY29pblRvcCIsImNvaW5Cb3R0b20iLCJwcmV2U2NvcmUiLCJuZXdTY29yZSIsInByZXZIaWdoU2NvcmUiLCJtYXgiLCJ1cGRhdGVkSGlnaFNjb3JlIiwic2V0SXRlbSIsInRvU3RyaW5nIiwiaGFuZGxlSW5wdXQiLCJlIiwicHJldmVudERlZmF1bHQiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./public/useFlappyBirdGame.ts\n"));

/***/ })

});