"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./public/useFlappyBirdGame.ts":
/*!*************************************!*\
  !*** ./public/useFlappyBirdGame.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFlappyBirdGame: function() { return /* binding */ useFlappyBirdGame; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n// Constants\nconst GRAVITY = 0.5; // Adjusted for time-based loop\nconst FLAP = -12; // Adjusted for time-based loop\nconst PIPE_WIDTH = 90;\nconst PIPE_SPACING = 250;\nconst BIRD_WIDTH = 50;\nconst BIRD_HEIGHT = 50;\nconst COIN_SIZE = 80;\nconst ROTATION_SPEED = 0.002; // Reduced rotation speed\nconst PIPE_SPAWN_INTERVAL = 1500; // milliseconds\nconst COIN_SPAWN_CHANCE = 0.25; // 25%\nfunction useFlappyBirdGame(canvasRef, isPaused, autoStart) {\n    const requestIdRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // State\n    const [highScore, setHighScore] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [currentScore, setCurrentScore] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    // Refs to track game state\n    const birdYRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const birdVelocityRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const pipesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const coinsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const gameOverRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const gameStartedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const coinRotationStepRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // Time tracking\n    const lastTimeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const pipeSpawnTimerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // Assets\n    const birdImages = [];\n    let pipeTop;\n    let pipeBottom;\n    let background;\n    let coinImage;\n    if (true) {\n        const birdUp = new Image();\n        birdUp.src = \"/assets/redbird-upflap.png\";\n        const birdMid = new Image();\n        birdMid.src = \"/assets/redbird-midflap.png\";\n        const birdDown = new Image();\n        birdDown.src = \"/assets/redbird-downflap.png\";\n        birdImages.push(birdUp, birdMid, birdDown);\n        pipeTop = new Image();\n        pipeTop.src = \"/assets/TopTiny.png\";\n        pipeBottom = new Image();\n        pipeBottom.src = \"/assets/BottomTiny.png\";\n        background = new Image();\n        background.src = \"/assets/background-day.png\";\n        coinImage = new Image();\n        coinImage.src = \"/assets/CoinTiny.png\";\n    }\n    // Current bird frame index\n    const currentBirdFrameRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // Load high score from localStorage\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (true) {\n            const storedHighScore = localStorage.getItem(\"highScore\");\n            if (storedHighScore) {\n                setHighScore(parseInt(storedHighScore, 10));\n            }\n        }\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        // Helper function to load an image fully\n        const loadImage = (img)=>{\n            return new Promise((resolve, reject)=>{\n                if (img.complete) {\n                    resolve();\n                } else {\n                    img.onload = ()=>resolve();\n                    img.onerror = ()=>reject(new Error(\"Failed to load image: \".concat(img.src)));\n                }\n            });\n        };\n        // Load all assets then initialize the game\n        const loadAssets = async ()=>{\n            try {\n                await Promise.all([\n                    ...birdImages.map((img)=>loadImage(img)),\n                    loadImage(pipeTop),\n                    loadImage(pipeBottom),\n                    loadImage(background),\n                    loadImage(coinImage)\n                ]);\n                console.log(\"All assets loaded successfully!\");\n                initializeGame();\n            } catch (error) {\n                console.error(\"Error loading assets:\", error);\n            }\n        };\n        // Set up the canvas once assets are loaded\n        function initializeGame() {\n            if (!canvasRef.current) return;\n            // We'll rely on the parent to set a smaller dimension (e.g. 270Ã—480).\n            // Draw the start screen:\n            if (!ctx) return;\n            drawStartScreen(ctx, canvasRef.current);\n        }\n        loadAssets();\n        function resetGame() {\n            if (!canvasRef.current) return;\n            const { height } = canvasRef.current;\n            birdYRef.current = height / 3;\n            birdVelocityRef.current = 0;\n            pipesRef.current = [];\n            coinsRef.current = [];\n            setCurrentScore(0);\n            gameOverRef.current = false;\n            gameStartedRef.current = false;\n            coinRotationStepRef.current = 0;\n            lastTimeRef.current = 0;\n            pipeSpawnTimerRef.current = 0;\n            currentBirdFrameRef.current = 0;\n        }\n        function handleKeyDown(e) {\n            if (e.key === \" \") {\n                if (!gameStartedRef.current && !gameOverRef.current) {\n                    startGame();\n                } else if (gameOverRef.current) {\n                    startGame();\n                } else {\n                    birdVelocityRef.current = FLAP;\n                    flap();\n                }\n            }\n        }\n        window.addEventListener(\"keydown\", handleKeyDown);\n        function startGame() {\n            resetGame();\n            gameStartedRef.current = true;\n            lastTimeRef.current = 0; // Reset for frame-limiting\n            requestIdRef.current = requestAnimationFrame(animate);\n        }\n        function handleUserInput() {\n            if (!gameStartedRef.current && !gameOverRef.current) {\n                startGame();\n            } else if (gameOverRef.current) {\n                startGame();\n            } else {\n                birdVelocityRef.current = FLAP;\n                flap();\n            }\n        }\n        const flap = ()=>{\n            currentBirdFrameRef.current = 1;\n            setTimeout(()=>{\n                currentBirdFrameRef.current = 2;\n                setTimeout(()=>{\n                    currentBirdFrameRef.current = 0;\n                }, 170);\n            }, 170);\n        };\n        // The main loop with time-based updates\n        function animate(timestamp) {\n            if (isPaused || !gameStartedRef.current) {\n                requestIdRef.current = requestAnimationFrame(animate);\n                return;\n            }\n            if (!canvasRef.current) return;\n            const context = canvasRef.current.getContext(\"2d\");\n            if (!context) return;\n            if (!lastTimeRef.current) {\n                lastTimeRef.current = timestamp;\n            }\n            const deltaTime = timestamp - lastTimeRef.current;\n            // Update game state based on deltaTime\n            updateGameState(deltaTime, canvasRef.current);\n            // Draw everything\n            draw(context, canvasRef.current);\n            if (!gameOverRef.current) {\n                lastTimeRef.current = timestamp;\n                requestIdRef.current = requestAnimationFrame(animate);\n            } else {\n                drawGameOverScreen(context, canvasRef.current);\n            }\n        }\n        function updateGameState(deltaTime, canvas) {\n            // Update bird position based on deltaTime\n            birdVelocityRef.current += GRAVITY;\n            birdYRef.current += birdVelocityRef.current * (deltaTime / 16); // Assuming 60 FPS as base\n            // Update pipe spawn timer\n            pipeSpawnTimerRef.current += deltaTime;\n            if (pipeSpawnTimerRef.current > PIPE_SPAWN_INTERVAL) {\n                createPipe(canvas);\n                pipeSpawnTimerRef.current = 0;\n            }\n            movePipesAndCoins();\n            checkCoinCollection();\n            // Check collisions\n            if (checkCollisions(canvas)) {\n                gameOverRef.current = true;\n                return;\n            }\n            updateScore();\n            // Rotate coin\n            coinRotationStepRef.current += ROTATION_SPEED * (deltaTime / 16);\n            if (coinRotationStepRef.current >= 1) {\n                coinRotationStepRef.current = 0;\n            }\n        }\n        function draw(ctx, canvas) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawBackground(ctx, canvas);\n            drawBird(ctx);\n            drawPipes(ctx);\n            drawCoins(ctx);\n        }\n        function drawStartScreen(ctx, canvas) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawBackground(ctx, canvas);\n            ctx.font = \"bold 22px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.fillStyle = \"#ffffff\";\n            ctx.shadowColor = \"black\";\n            ctx.shadowBlur = 2;\n            ctx.textBaseline = \"middle\";\n            ctx.fillText(\"Press Space or Tap to Start\", canvas.width / 2, canvas.height / 2);\n        }\n        function drawGameOverScreen(ctx, canvas) {\n            ctx.fillStyle = \"#ffcc00\";\n            ctx.font = \"bold 36px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"middle\";\n            ctx.shadowColor = \"black\";\n            ctx.shadowBlur = 6;\n            ctx.fillText(\"Game Over!\", canvas.width / 2, canvas.height / 2 - 30);\n            ctx.fillStyle = \"#ffffff\";\n            ctx.font = \"bold 20px Arial\";\n            ctx.fillText(\"Press Space or Tap to Restart\", canvas.width / 2, canvas.height / 2 + 10);\n        }\n        function drawBackground(ctx, canvas) {\n            ctx.drawImage(background, 0, 0, canvas.width, canvas.height);\n        }\n        function drawBird(ctx) {\n            const currentImage = birdImages[currentBirdFrameRef.current];\n            if (currentImage.complete) {\n                ctx.drawImage(currentImage, 100, birdYRef.current, BIRD_WIDTH, BIRD_HEIGHT);\n            }\n        }\n        function drawPipes(ctx) {\n            for (const pipe of pipesRef.current){\n                ctx.drawImage(pipeTop, pipe.x, 0, PIPE_WIDTH, pipe.topHeight);\n                ctx.drawImage(pipeBottom, pipe.x, pipe.bottomY, PIPE_WIDTH, pipe.bottomHeight);\n            }\n        }\n        function drawCoins(ctx) {\n            const scaleX = Math.abs(Math.cos(coinRotationStepRef.current * Math.PI * 2));\n            const halfSize = COIN_SIZE / 2;\n            for (const coin of coinsRef.current){\n                if (!coin.collected) {\n                    ctx.save();\n                    ctx.translate(coin.x + halfSize, coin.y + halfSize);\n                    ctx.scale(scaleX, 1);\n                    ctx.drawImage(coinImage, -halfSize, -halfSize, COIN_SIZE, COIN_SIZE);\n                    ctx.restore();\n                }\n            }\n        }\n        function createPipe(canvas) {\n            const pipeHeight = Math.random() * (canvas.height - PIPE_SPACING - 100) + 50;\n            const bottomY = pipeHeight + PIPE_SPACING;\n            pipesRef.current.push({\n                x: canvas.width,\n                topHeight: pipeHeight,\n                bottomY,\n                bottomHeight: canvas.height - bottomY,\n                scored: false\n            });\n            // Spawn coin only 25% chance\n            if (Math.random() > 1 - COIN_SPAWN_CHANCE) {\n                coinsRef.current.push({\n                    x: canvas.width + PIPE_WIDTH / 2 - COIN_SIZE / 2,\n                    y: pipeHeight + PIPE_SPACING / 2 - COIN_SIZE / 2,\n                    width: COIN_SIZE,\n                    height: COIN_SIZE,\n                    collected: false\n                });\n            }\n        }\n        function movePipesAndCoins() {\n            for (const pipe of pipesRef.current){\n                pipe.x -= 2;\n            }\n            pipesRef.current = pipesRef.current.filter((pipe)=>pipe.x + PIPE_WIDTH > 0);\n            for (const coin of coinsRef.current){\n                coin.x -= 2;\n            }\n            coinsRef.current = coinsRef.current.filter((coin)=>coin.x + coin.width > 0 && !coin.collected);\n        }\n        function checkCollisions(canvas) {\n            // Bird out of bounds\n            if (birdYRef.current < 0 || birdYRef.current + BIRD_HEIGHT > canvas.height) {\n                return true;\n            }\n            const birdLeft = 100;\n            const birdRight = birdLeft + BIRD_WIDTH;\n            const birdTop = birdYRef.current;\n            const birdBottom = birdYRef.current + BIRD_HEIGHT;\n            // Pipe collision\n            for (const pipe of pipesRef.current){\n                const withinPipeX = birdRight > pipe.x && birdLeft < pipe.x + PIPE_WIDTH;\n                const withinPipeY = birdTop < pipe.topHeight || birdBottom > pipe.bottomY;\n                if (withinPipeX && withinPipeY) return true;\n            }\n            return false;\n        }\n        function checkCoinCollection() {\n            const birdLeft = 100;\n            const birdRight = birdLeft + BIRD_WIDTH;\n            const birdTop = birdYRef.current;\n            const birdBottom = birdYRef.current + BIRD_HEIGHT;\n            for (const coin of coinsRef.current){\n                if (!coin.collected) {\n                    const coinLeft = coin.x;\n                    const coinRight = coin.x + coin.width;\n                    const coinTop = coin.y;\n                    const coinBottom = coin.y + coin.height;\n                    if (birdRight > coinLeft && birdLeft < coinRight && birdBottom > coinTop && birdTop < coinBottom) {\n                        coin.collected = true;\n                        setCurrentScore((prevScore)=>{\n                            const newScore = prevScore + 5;\n                            setHighScore((prevHighScore)=>Math.max(prevHighScore, newScore));\n                            return newScore;\n                        });\n                    }\n                }\n            }\n        }\n        function updateScore() {\n            for (const pipe of pipesRef.current){\n                // Score +1 for passing each pipe once\n                if (!pipe.scored && pipe.x + PIPE_WIDTH < 100) {\n                    setCurrentScore((prevScore)=>{\n                        const newScore = prevScore + 1;\n                        setHighScore((prevHighScore)=>{\n                            const updatedHighScore = Math.max(prevHighScore, newScore);\n                            if (true) {\n                                localStorage.setItem(\"highScore\", updatedHighScore.toString());\n                            }\n                            return updatedHighScore;\n                        });\n                        return newScore;\n                    });\n                    pipe.scored = true;\n                }\n            }\n        }\n        // Cleanup\n        return ()=>{\n            window.removeEventListener(\"keydown\", handleKeyDown);\n            if (requestIdRef.current) {\n                cancelAnimationFrame(requestIdRef.current);\n            }\n        };\n    }, [\n        canvasRef,\n        isPaused,\n        autoStart\n    ]);\n    // Expose handleUserInput\n    const handleUserInput = ()=>{\n        // Dispatch a \"keydown\" event with key \" \"\n        const spaceEvent = new KeyboardEvent(\"keydown\", {\n            key: \" \"\n        });\n        window.dispatchEvent(spaceEvent);\n    };\n    return {\n        highScore,\n        currentScore,\n        handleUserInput\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUMzREcsT0FBTzJFLGFBQWEsQ0FBQ0Y7SUFDdkI7SUFFQSxPQUFPO1FBQ0xsSTtRQUNBRTtRQUNBMkQ7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3B1YmxpYy91c2VGbGFwcHlCaXJkR2FtZS50cz81Yzc4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xyXG5cclxuLy8gVHlwZXMgZm9yIGdhbWUgb2JqZWN0c1xyXG5pbnRlcmZhY2UgUGlwZSB7XHJcbiAgeDogbnVtYmVyO1xyXG4gIHRvcEhlaWdodDogbnVtYmVyO1xyXG4gIGJvdHRvbVk6IG51bWJlcjtcclxuICBib3R0b21IZWlnaHQ6IG51bWJlcjtcclxuICBzY29yZWQ6IGJvb2xlYW47XHJcbn1cclxuXHJcbmludGVyZmFjZSBDb2luIHtcclxuICB4OiBudW1iZXI7XHJcbiAgeTogbnVtYmVyO1xyXG4gIHdpZHRoOiBudW1iZXI7XHJcbiAgaGVpZ2h0OiBudW1iZXI7XHJcbiAgY29sbGVjdGVkOiBib29sZWFuO1xyXG59XHJcblxyXG4vLyBDb25zdGFudHNcclxuY29uc3QgR1JBVklUWSA9IDAuNTsgLy8gQWRqdXN0ZWQgZm9yIHRpbWUtYmFzZWQgbG9vcFxyXG5jb25zdCBGTEFQID0gLTEyOyAvLyBBZGp1c3RlZCBmb3IgdGltZS1iYXNlZCBsb29wXHJcbmNvbnN0IFBJUEVfV0lEVEggPSA5MDtcclxuY29uc3QgUElQRV9TUEFDSU5HID0gMjUwO1xyXG5jb25zdCBCSVJEX1dJRFRIID0gNTA7XHJcbmNvbnN0IEJJUkRfSEVJR0hUID0gNTA7XHJcbmNvbnN0IENPSU5fU0laRSA9IDgwO1xyXG5jb25zdCBST1RBVElPTl9TUEVFRCA9IDAuMDAyOyAvLyBSZWR1Y2VkIHJvdGF0aW9uIHNwZWVkXHJcbmNvbnN0IFBJUEVfU1BBV05fSU5URVJWQUwgPSAxNTAwOyAvLyBtaWxsaXNlY29uZHNcclxuY29uc3QgQ09JTl9TUEFXTl9DSEFOQ0UgPSAwLjI1OyAvLyAyNSVcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VGbGFwcHlCaXJkR2FtZShcclxuICBjYW52YXNSZWY6IFJlYWN0LlJlZk9iamVjdDxIVE1MQ2FudmFzRWxlbWVudD4sXHJcbiAgaXNQYXVzZWQ6IGJvb2xlYW4sXHJcbiAgYXV0b1N0YXJ0OiBib29sZWFuXHJcbikge1xyXG4gIGNvbnN0IHJlcXVlc3RJZFJlZiA9IHVzZVJlZjxudW1iZXIgfCBudWxsPihudWxsKTtcclxuXHJcbiAgLy8gU3RhdGVcclxuICBjb25zdCBbaGlnaFNjb3JlLCBzZXRIaWdoU2NvcmVdID0gdXNlU3RhdGUoMCk7XHJcbiAgY29uc3QgW2N1cnJlbnRTY29yZSwgc2V0Q3VycmVudFNjb3JlXSA9IHVzZVN0YXRlKDApO1xyXG5cclxuICAvLyBSZWZzIHRvIHRyYWNrIGdhbWUgc3RhdGVcclxuICBjb25zdCBiaXJkWVJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xyXG4gIGNvbnN0IGJpcmRWZWxvY2l0eVJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xyXG4gIGNvbnN0IHBpcGVzUmVmID0gdXNlUmVmPFBpcGVbXT4oW10pO1xyXG4gIGNvbnN0IGNvaW5zUmVmID0gdXNlUmVmPENvaW5bXT4oW10pO1xyXG4gIGNvbnN0IGdhbWVPdmVyUmVmID0gdXNlUmVmPGJvb2xlYW4+KGZhbHNlKTtcclxuICBjb25zdCBnYW1lU3RhcnRlZFJlZiA9IHVzZVJlZjxib29sZWFuPihmYWxzZSk7XHJcblxyXG4gIGNvbnN0IGNvaW5Sb3RhdGlvblN0ZXBSZWYgPSB1c2VSZWY8bnVtYmVyPigwKTtcclxuICBcclxuICAvLyBUaW1lIHRyYWNraW5nXHJcbiAgY29uc3QgbGFzdFRpbWVSZWYgPSB1c2VSZWY8bnVtYmVyPigwKTtcclxuICBjb25zdCBwaXBlU3Bhd25UaW1lclJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xyXG5cclxuICAvLyBBc3NldHNcclxuICBjb25zdCBiaXJkSW1hZ2VzOiBIVE1MSW1hZ2VFbGVtZW50W10gPSBbXTtcclxuICBsZXQgcGlwZVRvcDogSFRNTEltYWdlRWxlbWVudDtcclxuICBsZXQgcGlwZUJvdHRvbTogSFRNTEltYWdlRWxlbWVudDtcclxuICBsZXQgYmFja2dyb3VuZDogSFRNTEltYWdlRWxlbWVudDtcclxuICBsZXQgY29pbkltYWdlOiBIVE1MSW1hZ2VFbGVtZW50O1xyXG5cclxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgY29uc3QgYmlyZFVwID0gbmV3IEltYWdlKCk7XHJcbiAgICBiaXJkVXAuc3JjID0gXCIvYXNzZXRzL3JlZGJpcmQtdXBmbGFwLnBuZ1wiO1xyXG5cclxuICAgIGNvbnN0IGJpcmRNaWQgPSBuZXcgSW1hZ2UoKTtcclxuICAgIGJpcmRNaWQuc3JjID0gXCIvYXNzZXRzL3JlZGJpcmQtbWlkZmxhcC5wbmdcIjtcclxuXHJcbiAgICBjb25zdCBiaXJkRG93biA9IG5ldyBJbWFnZSgpO1xyXG4gICAgYmlyZERvd24uc3JjID0gXCIvYXNzZXRzL3JlZGJpcmQtZG93bmZsYXAucG5nXCI7XHJcblxyXG4gICAgYmlyZEltYWdlcy5wdXNoKGJpcmRVcCwgYmlyZE1pZCwgYmlyZERvd24pO1xyXG5cclxuICAgIHBpcGVUb3AgPSBuZXcgSW1hZ2UoKTtcclxuICAgIHBpcGVUb3Auc3JjID0gXCIvYXNzZXRzL1RvcFRpbnkucG5nXCI7XHJcblxyXG4gICAgcGlwZUJvdHRvbSA9IG5ldyBJbWFnZSgpO1xyXG4gICAgcGlwZUJvdHRvbS5zcmMgPSBcIi9hc3NldHMvQm90dG9tVGlueS5wbmdcIjtcclxuXHJcbiAgICBiYWNrZ3JvdW5kID0gbmV3IEltYWdlKCk7XHJcbiAgICBiYWNrZ3JvdW5kLnNyYyA9IFwiL2Fzc2V0cy9iYWNrZ3JvdW5kLWRheS5wbmdcIjtcclxuXHJcbiAgICBjb2luSW1hZ2UgPSBuZXcgSW1hZ2UoKTtcclxuICAgIGNvaW5JbWFnZS5zcmMgPSBcIi9hc3NldHMvQ29pblRpbnkucG5nXCI7XHJcbiAgfVxyXG5cclxuICAvLyBDdXJyZW50IGJpcmQgZnJhbWUgaW5kZXhcclxuICBjb25zdCBjdXJyZW50QmlyZEZyYW1lUmVmID0gdXNlUmVmPG51bWJlcj4oMCk7XHJcblxyXG4gIC8vIExvYWQgaGlnaCBzY29yZSBmcm9tIGxvY2FsU3RvcmFnZVxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICBjb25zdCBzdG9yZWRIaWdoU2NvcmUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImhpZ2hTY29yZVwiKTtcclxuICAgICAgaWYgKHN0b3JlZEhpZ2hTY29yZSkge1xyXG4gICAgICAgIHNldEhpZ2hTY29yZShwYXJzZUludChzdG9yZWRIaWdoU2NvcmUsIDEwKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LCBbXSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcclxuICAgIGlmICghY2FudmFzKSByZXR1cm47XHJcblxyXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuICAgIGlmICghY3R4KSByZXR1cm47XHJcblxyXG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGxvYWQgYW4gaW1hZ2UgZnVsbHlcclxuICAgIGNvbnN0IGxvYWRJbWFnZSA9IChpbWc6IEhUTUxJbWFnZUVsZW1lbnQpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICBpZiAoaW1nLmNvbXBsZXRlKSB7XHJcbiAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKCk7XHJcbiAgICAgICAgICBpbWcub25lcnJvciA9ICgpID0+XHJcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIGltYWdlOiAke2ltZy5zcmN9YCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIExvYWQgYWxsIGFzc2V0cyB0aGVuIGluaXRpYWxpemUgdGhlIGdhbWVcclxuICAgIGNvbnN0IGxvYWRBc3NldHMgPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgLi4uYmlyZEltYWdlcy5tYXAoKGltZykgPT4gbG9hZEltYWdlKGltZykpLFxyXG4gICAgICAgICAgbG9hZEltYWdlKHBpcGVUb3ApLFxyXG4gICAgICAgICAgbG9hZEltYWdlKHBpcGVCb3R0b20pLFxyXG4gICAgICAgICAgbG9hZEltYWdlKGJhY2tncm91bmQpLFxyXG4gICAgICAgICAgbG9hZEltYWdlKGNvaW5JbWFnZSksXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJBbGwgYXNzZXRzIGxvYWRlZCBzdWNjZXNzZnVsbHkhXCIpO1xyXG4gICAgICAgIGluaXRpYWxpemVHYW1lKCk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGxvYWRpbmcgYXNzZXRzOlwiLCBlcnJvcik7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgICAgIC8vIFNldCB1cCB0aGUgY2FudmFzIG9uY2UgYXNzZXRzIGFyZSBsb2FkZWRcclxuICAgICAgICBmdW5jdGlvbiBpbml0aWFsaXplR2FtZSgpIHtcclxuICAgICAgICAgIGlmICghY2FudmFzUmVmLmN1cnJlbnQpIHJldHVybjtcclxuICAgICAgICAgIC8vIFdlJ2xsIHJlbHkgb24gdGhlIHBhcmVudCB0byBzZXQgYSBzbWFsbGVyIGRpbWVuc2lvbiAoZS5nLiAyNzDDlzQ4MCkuXHJcbiAgICAgICAgICAvLyBEcmF3IHRoZSBzdGFydCBzY3JlZW46XHJcbiAgICAgICAgICBpZiAoIWN0eClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgZHJhd1N0YXJ0U2NyZWVuKGN0eCwgY2FudmFzUmVmLmN1cnJlbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICBsb2FkQXNzZXRzKCk7XHJcblxyXG4gICAgZnVuY3Rpb24gcmVzZXRHYW1lKCkge1xyXG4gICAgICBpZiAoIWNhbnZhc1JlZi5jdXJyZW50KSByZXR1cm47XHJcbiAgICAgIGNvbnN0IHsgaGVpZ2h0IH0gPSBjYW52YXNSZWYuY3VycmVudDtcclxuXHJcbiAgICAgIGJpcmRZUmVmLmN1cnJlbnQgPSBoZWlnaHQgLyAzO1xyXG4gICAgICBiaXJkVmVsb2NpdHlSZWYuY3VycmVudCA9IDA7XHJcbiAgICAgIHBpcGVzUmVmLmN1cnJlbnQgPSBbXTtcclxuICAgICAgY29pbnNSZWYuY3VycmVudCA9IFtdO1xyXG4gICAgICBzZXRDdXJyZW50U2NvcmUoMCk7XHJcbiAgICAgIGdhbWVPdmVyUmVmLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgICAgZ2FtZVN0YXJ0ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xyXG4gICAgICBjb2luUm90YXRpb25TdGVwUmVmLmN1cnJlbnQgPSAwO1xyXG4gICAgICBsYXN0VGltZVJlZi5jdXJyZW50ID0gMDtcclxuICAgICAgcGlwZVNwYXduVGltZXJSZWYuY3VycmVudCA9IDA7XHJcbiAgICAgIGN1cnJlbnRCaXJkRnJhbWVSZWYuY3VycmVudCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlS2V5RG93bihlOiBLZXlib2FyZEV2ZW50KSB7XHJcbiAgICAgIGlmIChlLmtleSA9PT0gXCIgXCIpIHtcclxuICAgICAgICBpZiAoIWdhbWVTdGFydGVkUmVmLmN1cnJlbnQgJiYgIWdhbWVPdmVyUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgIHN0YXJ0R2FtZSgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZ2FtZU92ZXJSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgc3RhcnRHYW1lKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGJpcmRWZWxvY2l0eVJlZi5jdXJyZW50ID0gRkxBUDtcclxuICAgICAgICAgIGZsYXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgaGFuZGxlS2V5RG93bik7XHJcblxyXG4gICAgZnVuY3Rpb24gc3RhcnRHYW1lKCkge1xyXG4gICAgICByZXNldEdhbWUoKTtcclxuICAgICAgZ2FtZVN0YXJ0ZWRSZWYuY3VycmVudCA9IHRydWU7XHJcbiAgICAgIGxhc3RUaW1lUmVmLmN1cnJlbnQgPSAwOyAvLyBSZXNldCBmb3IgZnJhbWUtbGltaXRpbmdcclxuICAgICAgcmVxdWVzdElkUmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlVXNlcklucHV0KCkge1xyXG4gICAgICBpZiAoIWdhbWVTdGFydGVkUmVmLmN1cnJlbnQgJiYgIWdhbWVPdmVyUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBzdGFydEdhbWUoKTtcclxuICAgICAgfSBlbHNlIGlmIChnYW1lT3ZlclJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgc3RhcnRHYW1lKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYmlyZFZlbG9jaXR5UmVmLmN1cnJlbnQgPSBGTEFQO1xyXG4gICAgICAgIGZsYXAoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGZsYXAgPSAoKSA9PiB7XHJcbiAgICAgIGN1cnJlbnRCaXJkRnJhbWVSZWYuY3VycmVudCA9IDE7XHJcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIGN1cnJlbnRCaXJkRnJhbWVSZWYuY3VycmVudCA9IDI7XHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICBjdXJyZW50QmlyZEZyYW1lUmVmLmN1cnJlbnQgPSAwO1xyXG4gICAgICAgIH0sIDE3MCk7XHJcbiAgICAgIH0sIDE3MCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFRoZSBtYWluIGxvb3Agd2l0aCB0aW1lLWJhc2VkIHVwZGF0ZXNcclxuICAgIGZ1bmN0aW9uIGFuaW1hdGUodGltZXN0YW1wOiBudW1iZXIpIHtcclxuICAgICAgaWYgKGlzUGF1c2VkIHx8ICFnYW1lU3RhcnRlZFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgcmVxdWVzdElkUmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghY2FudmFzUmVmLmN1cnJlbnQpIHJldHVybjtcclxuXHJcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXNSZWYuY3VycmVudC5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICAgIGlmICghY29udGV4dCkgcmV0dXJuO1xyXG5cclxuICAgICAgaWYgKCFsYXN0VGltZVJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgbGFzdFRpbWVSZWYuY3VycmVudCA9IHRpbWVzdGFtcDtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBkZWx0YVRpbWUgPSB0aW1lc3RhbXAgLSBsYXN0VGltZVJlZi5jdXJyZW50O1xyXG5cclxuICAgICAgLy8gVXBkYXRlIGdhbWUgc3RhdGUgYmFzZWQgb24gZGVsdGFUaW1lXHJcbiAgICAgIHVwZGF0ZUdhbWVTdGF0ZShkZWx0YVRpbWUsIGNhbnZhc1JlZi5jdXJyZW50KTtcclxuXHJcbiAgICAgIC8vIERyYXcgZXZlcnl0aGluZ1xyXG4gICAgICBkcmF3KGNvbnRleHQsIGNhbnZhc1JlZi5jdXJyZW50KTtcclxuXHJcbiAgICAgIGlmICghZ2FtZU92ZXJSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGxhc3RUaW1lUmVmLmN1cnJlbnQgPSB0aW1lc3RhbXA7XHJcbiAgICAgICAgcmVxdWVzdElkUmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZHJhd0dhbWVPdmVyU2NyZWVuKGNvbnRleHQsIGNhbnZhc1JlZi5jdXJyZW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZUdhbWVTdGF0ZShkZWx0YVRpbWU6IG51bWJlciwgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkge1xyXG4gICAgICAvLyBVcGRhdGUgYmlyZCBwb3NpdGlvbiBiYXNlZCBvbiBkZWx0YVRpbWVcclxuICAgICAgYmlyZFZlbG9jaXR5UmVmLmN1cnJlbnQgKz0gR1JBVklUWTtcclxuICAgICAgYmlyZFlSZWYuY3VycmVudCArPSBiaXJkVmVsb2NpdHlSZWYuY3VycmVudCAqIChkZWx0YVRpbWUgLyAxNik7IC8vIEFzc3VtaW5nIDYwIEZQUyBhcyBiYXNlXHJcblxyXG4gICAgICAvLyBVcGRhdGUgcGlwZSBzcGF3biB0aW1lclxyXG4gICAgICBwaXBlU3Bhd25UaW1lclJlZi5jdXJyZW50ICs9IGRlbHRhVGltZTtcclxuICAgICAgaWYgKHBpcGVTcGF3blRpbWVyUmVmLmN1cnJlbnQgPiBQSVBFX1NQQVdOX0lOVEVSVkFMKSB7XHJcbiAgICAgICAgY3JlYXRlUGlwZShjYW52YXMpO1xyXG4gICAgICAgIHBpcGVTcGF3blRpbWVyUmVmLmN1cnJlbnQgPSAwO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBtb3ZlUGlwZXNBbmRDb2lucygpO1xyXG4gICAgICBjaGVja0NvaW5Db2xsZWN0aW9uKCk7XHJcblxyXG4gICAgICAvLyBDaGVjayBjb2xsaXNpb25zXHJcbiAgICAgIGlmIChjaGVja0NvbGxpc2lvbnMoY2FudmFzKSkge1xyXG4gICAgICAgIGdhbWVPdmVyUmVmLmN1cnJlbnQgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdXBkYXRlU2NvcmUoKTtcclxuXHJcbiAgICAgIC8vIFJvdGF0ZSBjb2luXHJcbiAgICAgIGNvaW5Sb3RhdGlvblN0ZXBSZWYuY3VycmVudCArPSBST1RBVElPTl9TUEVFRCAqIChkZWx0YVRpbWUgLyAxNik7XHJcbiAgICAgIGlmIChjb2luUm90YXRpb25TdGVwUmVmLmN1cnJlbnQgPj0gMSkge1xyXG4gICAgICAgIGNvaW5Sb3RhdGlvblN0ZXBSZWYuY3VycmVudCA9IDA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3KGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICAgICAgZHJhd0JhY2tncm91bmQoY3R4LCBjYW52YXMpO1xyXG4gICAgICBkcmF3QmlyZChjdHgpO1xyXG4gICAgICBkcmF3UGlwZXMoY3R4KTtcclxuICAgICAgZHJhd0NvaW5zKGN0eCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd1N0YXJ0U2NyZWVuKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICAgICAgZHJhd0JhY2tncm91bmQoY3R4LCBjYW52YXMpO1xyXG4gICAgICBjdHguZm9udCA9IFwiYm9sZCAyMnB4IEFyaWFsXCI7XHJcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xyXG4gICAgICBjdHguZmlsbFN0eWxlID0gXCIjZmZmZmZmXCI7XHJcbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFwiYmxhY2tcIjtcclxuICAgICAgY3R4LnNoYWRvd0JsdXIgPSAyO1xyXG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcclxuXHJcbiAgICAgIGN0eC5maWxsVGV4dChcclxuICAgICAgICBcIlByZXNzIFNwYWNlIG9yIFRhcCB0byBTdGFydFwiLFxyXG4gICAgICAgIGNhbnZhcy53aWR0aCAvIDIsXHJcbiAgICAgICAgY2FudmFzLmhlaWdodCAvIDJcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3R2FtZU92ZXJTY3JlZW4oY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiI2ZmY2MwMFwiO1xyXG4gICAgICBjdHguZm9udCA9IFwiYm9sZCAzNnB4IEFyaWFsXCI7XHJcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xyXG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcclxuICAgICAgY3R4LnNoYWRvd0NvbG9yID0gXCJibGFja1wiO1xyXG4gICAgICBjdHguc2hhZG93Qmx1ciA9IDY7XHJcblxyXG4gICAgICBjdHguZmlsbFRleHQoXCJHYW1lIE92ZXIhXCIsIGNhbnZhcy53aWR0aCAvIDIsIGNhbnZhcy5oZWlnaHQgLyAyIC0gMzApO1xyXG5cclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiI2ZmZmZmZlwiO1xyXG4gICAgICBjdHguZm9udCA9IFwiYm9sZCAyMHB4IEFyaWFsXCI7XHJcbiAgICAgIGN0eC5maWxsVGV4dChcclxuICAgICAgICBcIlByZXNzIFNwYWNlIG9yIFRhcCB0byBSZXN0YXJ0XCIsXHJcbiAgICAgICAgY2FudmFzLndpZHRoIC8gMixcclxuICAgICAgICBjYW52YXMuaGVpZ2h0IC8gMiArIDEwXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd0JhY2tncm91bmQoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcclxuICAgICAgY3R4LmRyYXdJbWFnZShiYWNrZ3JvdW5kLCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdCaXJkKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XHJcbiAgICAgIGNvbnN0IGN1cnJlbnRJbWFnZSA9IGJpcmRJbWFnZXNbY3VycmVudEJpcmRGcmFtZVJlZi5jdXJyZW50XTtcclxuICAgICAgaWYgKGN1cnJlbnRJbWFnZS5jb21wbGV0ZSkge1xyXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoY3VycmVudEltYWdlLCAxMDAsIGJpcmRZUmVmLmN1cnJlbnQsIEJJUkRfV0lEVEgsIEJJUkRfSEVJR0hUKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdQaXBlcyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xyXG4gICAgICBmb3IgKGNvbnN0IHBpcGUgb2YgcGlwZXNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UocGlwZVRvcCwgcGlwZS54LCAwLCBQSVBFX1dJRFRILCBwaXBlLnRvcEhlaWdodCk7XHJcbiAgICAgICAgY3R4LmRyYXdJbWFnZShcclxuICAgICAgICAgIHBpcGVCb3R0b20sXHJcbiAgICAgICAgICBwaXBlLngsXHJcbiAgICAgICAgICBwaXBlLmJvdHRvbVksXHJcbiAgICAgICAgICBQSVBFX1dJRFRILFxyXG4gICAgICAgICAgcGlwZS5ib3R0b21IZWlnaHRcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd0NvaW5zKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XHJcbiAgICAgIGNvbnN0IHNjYWxlWCA9IE1hdGguYWJzKE1hdGguY29zKGNvaW5Sb3RhdGlvblN0ZXBSZWYuY3VycmVudCAqIE1hdGguUEkgKiAyKSk7XHJcbiAgICAgIGNvbnN0IGhhbGZTaXplID0gQ09JTl9TSVpFIC8gMjtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgY29pbiBvZiBjb2luc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgaWYgKCFjb2luLmNvbGxlY3RlZCkge1xyXG4gICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgIGN0eC50cmFuc2xhdGUoY29pbi54ICsgaGFsZlNpemUsIGNvaW4ueSArIGhhbGZTaXplKTtcclxuICAgICAgICAgIGN0eC5zY2FsZShzY2FsZVgsIDEpO1xyXG4gICAgICAgICAgY3R4LmRyYXdJbWFnZShjb2luSW1hZ2UsIC1oYWxmU2l6ZSwgLWhhbGZTaXplLCBDT0lOX1NJWkUsIENPSU5fU0laRSk7XHJcbiAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBpcGUoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkge1xyXG4gICAgICBjb25zdCBwaXBlSGVpZ2h0ID1cclxuICAgICAgICBNYXRoLnJhbmRvbSgpICogKGNhbnZhcy5oZWlnaHQgLSBQSVBFX1NQQUNJTkcgLSAxMDApICsgNTA7XHJcbiAgICAgIGNvbnN0IGJvdHRvbVkgPSBwaXBlSGVpZ2h0ICsgUElQRV9TUEFDSU5HO1xyXG4gICAgICBwaXBlc1JlZi5jdXJyZW50LnB1c2goe1xyXG4gICAgICAgIHg6IGNhbnZhcy53aWR0aCxcclxuICAgICAgICB0b3BIZWlnaHQ6IHBpcGVIZWlnaHQsXHJcbiAgICAgICAgYm90dG9tWSxcclxuICAgICAgICBib3R0b21IZWlnaHQ6IGNhbnZhcy5oZWlnaHQgLSBib3R0b21ZLFxyXG4gICAgICAgIHNjb3JlZDogZmFsc2UsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gU3Bhd24gY29pbiBvbmx5IDI1JSBjaGFuY2VcclxuICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPiAoMSAtIENPSU5fU1BBV05fQ0hBTkNFKSkge1xyXG4gICAgICAgIGNvaW5zUmVmLmN1cnJlbnQucHVzaCh7XHJcbiAgICAgICAgICB4OiBjYW52YXMud2lkdGggKyBQSVBFX1dJRFRIIC8gMiAtIENPSU5fU0laRSAvIDIsXHJcbiAgICAgICAgICB5OiBwaXBlSGVpZ2h0ICsgUElQRV9TUEFDSU5HIC8gMiAtIENPSU5fU0laRSAvIDIsXHJcbiAgICAgICAgICB3aWR0aDogQ09JTl9TSVpFLFxyXG4gICAgICAgICAgaGVpZ2h0OiBDT0lOX1NJWkUsXHJcbiAgICAgICAgICBjb2xsZWN0ZWQ6IGZhbHNlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbW92ZVBpcGVzQW5kQ29pbnMoKSB7XHJcbiAgICAgIGZvciAoY29uc3QgcGlwZSBvZiBwaXBlc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgcGlwZS54IC09IDI7XHJcbiAgICAgIH1cclxuICAgICAgcGlwZXNSZWYuY3VycmVudCA9IHBpcGVzUmVmLmN1cnJlbnQuZmlsdGVyKFxyXG4gICAgICAgIChwaXBlKSA9PiBwaXBlLnggKyBQSVBFX1dJRFRIID4gMFxyXG4gICAgICApO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBjb2luIG9mIGNvaW5zUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBjb2luLnggLT0gMjtcclxuICAgICAgfVxyXG4gICAgICBjb2luc1JlZi5jdXJyZW50ID0gY29pbnNSZWYuY3VycmVudC5maWx0ZXIoXHJcbiAgICAgICAgKGNvaW4pID0+IGNvaW4ueCArIGNvaW4ud2lkdGggPiAwICYmICFjb2luLmNvbGxlY3RlZFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNoZWNrQ29sbGlzaW9ucyhjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KTogYm9vbGVhbiB7XHJcbiAgICAgIC8vIEJpcmQgb3V0IG9mIGJvdW5kc1xyXG4gICAgICBpZiAoYmlyZFlSZWYuY3VycmVudCA8IDAgfHwgYmlyZFlSZWYuY3VycmVudCArIEJJUkRfSEVJR0hUID4gY2FudmFzLmhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBiaXJkTGVmdCA9IDEwMDtcclxuICAgICAgY29uc3QgYmlyZFJpZ2h0ID0gYmlyZExlZnQgKyBCSVJEX1dJRFRIO1xyXG4gICAgICBjb25zdCBiaXJkVG9wID0gYmlyZFlSZWYuY3VycmVudDtcclxuICAgICAgY29uc3QgYmlyZEJvdHRvbSA9IGJpcmRZUmVmLmN1cnJlbnQgKyBCSVJEX0hFSUdIVDtcclxuXHJcbiAgICAgIC8vIFBpcGUgY29sbGlzaW9uXHJcbiAgICAgIGZvciAoY29uc3QgcGlwZSBvZiBwaXBlc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY29uc3Qgd2l0aGluUGlwZVggPVxyXG4gICAgICAgICAgYmlyZFJpZ2h0ID4gcGlwZS54ICYmIGJpcmRMZWZ0IDwgcGlwZS54ICsgUElQRV9XSURUSDtcclxuICAgICAgICBjb25zdCB3aXRoaW5QaXBlWSA9XHJcbiAgICAgICAgICBiaXJkVG9wIDwgcGlwZS50b3BIZWlnaHQgfHwgYmlyZEJvdHRvbSA+IHBpcGUuYm90dG9tWTtcclxuICAgICAgICBpZiAod2l0aGluUGlwZVggJiYgd2l0aGluUGlwZVkpIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjaGVja0NvaW5Db2xsZWN0aW9uKCkge1xyXG4gICAgICBjb25zdCBiaXJkTGVmdCA9IDEwMDtcclxuICAgICAgY29uc3QgYmlyZFJpZ2h0ID0gYmlyZExlZnQgKyBCSVJEX1dJRFRIO1xyXG4gICAgICBjb25zdCBiaXJkVG9wID0gYmlyZFlSZWYuY3VycmVudDtcclxuICAgICAgY29uc3QgYmlyZEJvdHRvbSA9IGJpcmRZUmVmLmN1cnJlbnQgKyBCSVJEX0hFSUdIVDtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgY29pbiBvZiBjb2luc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgaWYgKCFjb2luLmNvbGxlY3RlZCkge1xyXG4gICAgICAgICAgY29uc3QgY29pbkxlZnQgPSBjb2luLng7XHJcbiAgICAgICAgICBjb25zdCBjb2luUmlnaHQgPSBjb2luLnggKyBjb2luLndpZHRoO1xyXG4gICAgICAgICAgY29uc3QgY29pblRvcCA9IGNvaW4ueTtcclxuICAgICAgICAgIGNvbnN0IGNvaW5Cb3R0b20gPSBjb2luLnkgKyBjb2luLmhlaWdodDtcclxuXHJcbiAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIGJpcmRSaWdodCA+IGNvaW5MZWZ0ICYmXHJcbiAgICAgICAgICAgIGJpcmRMZWZ0IDwgY29pblJpZ2h0ICYmXHJcbiAgICAgICAgICAgIGJpcmRCb3R0b20gPiBjb2luVG9wICYmXHJcbiAgICAgICAgICAgIGJpcmRUb3AgPCBjb2luQm90dG9tXHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgY29pbi5jb2xsZWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBzZXRDdXJyZW50U2NvcmUoKHByZXZTY29yZSkgPT4ge1xyXG4gICAgICAgICAgICAgIGNvbnN0IG5ld1Njb3JlID0gcHJldlNjb3JlICsgNTtcclxuICAgICAgICAgICAgICBzZXRIaWdoU2NvcmUoKHByZXZIaWdoU2NvcmUpID0+IE1hdGgubWF4KHByZXZIaWdoU2NvcmUsIG5ld1Njb3JlKSk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIG5ld1Njb3JlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVTY29yZSgpIHtcclxuICAgICAgZm9yIChjb25zdCBwaXBlIG9mIHBpcGVzUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAvLyBTY29yZSArMSBmb3IgcGFzc2luZyBlYWNoIHBpcGUgb25jZVxyXG4gICAgICAgIGlmICghcGlwZS5zY29yZWQgJiYgcGlwZS54ICsgUElQRV9XSURUSCA8IDEwMCkge1xyXG4gICAgICAgICAgc2V0Q3VycmVudFNjb3JlKChwcmV2U2NvcmUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbmV3U2NvcmUgPSBwcmV2U2NvcmUgKyAxO1xyXG4gICAgICAgICAgICBzZXRIaWdoU2NvcmUoKHByZXZIaWdoU2NvcmUpID0+IHtcclxuICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkSGlnaFNjb3JlID0gTWF0aC5tYXgocHJldkhpZ2hTY29yZSwgbmV3U2NvcmUpO1xyXG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcImhpZ2hTY29yZVwiLCB1cGRhdGVkSGlnaFNjb3JlLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlZEhpZ2hTY29yZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdTY29yZTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgcGlwZS5zY29yZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIENsZWFudXBcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBoYW5kbGVLZXlEb3duKTtcclxuICAgICAgaWYgKHJlcXVlc3RJZFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmVxdWVzdElkUmVmLmN1cnJlbnQpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH0sIFtjYW52YXNSZWYsIGlzUGF1c2VkLCBhdXRvU3RhcnRdKTtcclxuXHJcbiAgLy8gRXhwb3NlIGhhbmRsZVVzZXJJbnB1dFxyXG4gIGNvbnN0IGhhbmRsZVVzZXJJbnB1dCA9ICgpID0+IHtcclxuICAgIC8vIERpc3BhdGNoIGEgXCJrZXlkb3duXCIgZXZlbnQgd2l0aCBrZXkgXCIgXCJcclxuICAgIGNvbnN0IHNwYWNlRXZlbnQgPSBuZXcgS2V5Ym9hcmRFdmVudChcImtleWRvd25cIiwgeyBrZXk6IFwiIFwiIH0pO1xyXG4gICAgd2luZG93LmRpc3BhdGNoRXZlbnQoc3BhY2VFdmVudCk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGhpZ2hTY29yZSxcclxuICAgIGN1cnJlbnRTY29yZSxcclxuICAgIGhhbmRsZVVzZXJJbnB1dCxcclxuICB9O1xyXG59XHJcbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsIkdSQVZJVFkiLCJGTEFQIiwiUElQRV9XSURUSCIsIlBJUEVfU1BBQ0lORyIsIkJJUkRfV0lEVEgiLCJCSVJEX0hFSUdIVCIsIkNPSU5fU0laRSIsIlJPVEFUSU9OX1NQRUVEIiwiUElQRV9TUEFXTl9JTlRFUlZBTCIsIkNPSU5fU1BBV05fQ0hBTkNFIiwidXNlRmxhcHB5QmlyZEdhbWUiLCJjYW52YXNSZWYiLCJpc1BhdXNlZCIsImF1dG9TdGFydCIsInJlcXVlc3RJZFJlZiIsImhpZ2hTY29yZSIsInNldEhpZ2hTY29yZSIsImN1cnJlbnRTY29yZSIsInNldEN1cnJlbnRTY29yZSIsImJpcmRZUmVmIiwiYmlyZFZlbG9jaXR5UmVmIiwicGlwZXNSZWYiLCJjb2luc1JlZiIsImdhbWVPdmVyUmVmIiwiZ2FtZVN0YXJ0ZWRSZWYiLCJjb2luUm90YXRpb25TdGVwUmVmIiwibGFzdFRpbWVSZWYiLCJwaXBlU3Bhd25UaW1lclJlZiIsImJpcmRJbWFnZXMiLCJwaXBlVG9wIiwicGlwZUJvdHRvbSIsImJhY2tncm91bmQiLCJjb2luSW1hZ2UiLCJiaXJkVXAiLCJJbWFnZSIsInNyYyIsImJpcmRNaWQiLCJiaXJkRG93biIsInB1c2giLCJjdXJyZW50QmlyZEZyYW1lUmVmIiwic3RvcmVkSGlnaFNjb3JlIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInBhcnNlSW50IiwiY2FudmFzIiwiY3VycmVudCIsImN0eCIsImdldENvbnRleHQiLCJsb2FkSW1hZ2UiLCJpbWciLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImNvbXBsZXRlIiwib25sb2FkIiwib25lcnJvciIsIkVycm9yIiwibG9hZEFzc2V0cyIsImFsbCIsIm1hcCIsImNvbnNvbGUiLCJsb2ciLCJpbml0aWFsaXplR2FtZSIsImVycm9yIiwiZHJhd1N0YXJ0U2NyZWVuIiwicmVzZXRHYW1lIiwiaGVpZ2h0IiwiaGFuZGxlS2V5RG93biIsImUiLCJrZXkiLCJzdGFydEdhbWUiLCJmbGFwIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImFuaW1hdGUiLCJoYW5kbGVVc2VySW5wdXQiLCJzZXRUaW1lb3V0IiwidGltZXN0YW1wIiwiY29udGV4dCIsImRlbHRhVGltZSIsInVwZGF0ZUdhbWVTdGF0ZSIsImRyYXciLCJkcmF3R2FtZU92ZXJTY3JlZW4iLCJjcmVhdGVQaXBlIiwibW92ZVBpcGVzQW5kQ29pbnMiLCJjaGVja0NvaW5Db2xsZWN0aW9uIiwiY2hlY2tDb2xsaXNpb25zIiwidXBkYXRlU2NvcmUiLCJjbGVhclJlY3QiLCJ3aWR0aCIsImRyYXdCYWNrZ3JvdW5kIiwiZHJhd0JpcmQiLCJkcmF3UGlwZXMiLCJkcmF3Q29pbnMiLCJmb250IiwidGV4dEFsaWduIiwiZmlsbFN0eWxlIiwic2hhZG93Q29sb3IiLCJzaGFkb3dCbHVyIiwidGV4dEJhc2VsaW5lIiwiZmlsbFRleHQiLCJkcmF3SW1hZ2UiLCJjdXJyZW50SW1hZ2UiLCJwaXBlIiwieCIsInRvcEhlaWdodCIsImJvdHRvbVkiLCJib3R0b21IZWlnaHQiLCJzY2FsZVgiLCJNYXRoIiwiYWJzIiwiY29zIiwiUEkiLCJoYWxmU2l6ZSIsImNvaW4iLCJjb2xsZWN0ZWQiLCJzYXZlIiwidHJhbnNsYXRlIiwieSIsInNjYWxlIiwicmVzdG9yZSIsInBpcGVIZWlnaHQiLCJyYW5kb20iLCJzY29yZWQiLCJmaWx0ZXIiLCJiaXJkTGVmdCIsImJpcmRSaWdodCIsImJpcmRUb3AiLCJiaXJkQm90dG9tIiwid2l0aGluUGlwZVgiLCJ3aXRoaW5QaXBlWSIsImNvaW5MZWZ0IiwiY29pblJpZ2h0IiwiY29pblRvcCIsImNvaW5Cb3R0b20iLCJwcmV2U2NvcmUiLCJuZXdTY29yZSIsInByZXZIaWdoU2NvcmUiLCJtYXgiLCJ1cGRhdGVkSGlnaFNjb3JlIiwic2V0SXRlbSIsInRvU3RyaW5nIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwic3BhY2VFdmVudCIsIktleWJvYXJkRXZlbnQiLCJkaXNwYXRjaEV2ZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./public/useFlappyBirdGame.ts\n"));

/***/ })

});