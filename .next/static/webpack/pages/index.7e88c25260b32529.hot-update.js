"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./public/useFlappyBirdGame.ts":
/*!*************************************!*\
  !*** ./public/useFlappyBirdGame.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFlappyBirdGame: function() { return /* binding */ useFlappyBirdGame; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n// Constants\nconst GRAVITY = 0.25;\nconst FLAP = -7.5;\nconst PIPE_WIDTH = 90;\nconst PIPE_SPACING = 250;\nconst BIRD_WIDTH = 50;\nconst BIRD_HEIGHT = 50;\nconst COIN_SIZE = 100;\nconst ROTATION_SPEED = 0.005;\n// How often to spawn pipes in terms of frames (~1.66s if 60fps)\nconst PIPE_SPAWN_FRAMES = 100;\n// Frame rate limiter: target ~30 FPS\nconst targetFps = 60;\nconst frameDuration = 1000 / targetFps; // ~33.3 ms per frame\nfunction useFlappyBirdGame(canvasRef, isPaused, autoStart) {\n    const requestIdRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // State\n    const [highScore, setHighScore] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [currentScore, setCurrentScore] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    // Refs to track game state\n    const birdYRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const birdVelocityRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const pipesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const coinsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const gameOverRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const gameStartedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const coinRotationStepRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const framesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // Assets (loaded once if window is defined)\n    let birdImages = [];\n    let pipeTop;\n    let pipeBottom;\n    let background;\n    let coinImage;\n    // Store the last timestamp to limit FPS\n    const lastTimeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    if (true) {\n        const birdUp = new Image();\n        birdUp.src = \"/assets/redbird-upflap.png\";\n        const birdMid = new Image();\n        birdMid.src = \"/assets/redbird-midflap.png\";\n        const birdDown = new Image();\n        birdDown.src = \"/assets/redbird-downflap.png\";\n        birdImages = [\n            birdUp,\n            birdMid,\n            birdDown\n        ];\n        pipeTop = new Image();\n        pipeTop.src = \"/assets/TopTiny.png\";\n        pipeBottom = new Image();\n        pipeBottom.src = \"/assets/BottomTiny.png\";\n        background = new Image();\n        background.src = \"/assets/background-day.png\";\n        coinImage = new Image();\n        coinImage.src = \"/assets/CoinTiny.png\";\n    }\n    // Current bird frame index\n    const currentBirdFrameRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // Load high score from localStorage on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (true) {\n            const storedHighScore = localStorage.getItem(\"highScore\");\n            if (storedHighScore) {\n                setHighScore(parseInt(storedHighScore, 10));\n            }\n        }\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        // Helper function to load an image fully (promisify)\n        const loadImage = (img)=>{\n            return new Promise((resolve, reject)=>{\n                if (img.complete) {\n                    resolve();\n                } else {\n                    img.onload = ()=>resolve();\n                    img.onerror = ()=>reject(new Error(\"Failed to load image: \".concat(img.src)));\n                }\n            });\n        };\n        // Load all assets then init\n        const loadAssets = async ()=>{\n            try {\n                await Promise.all([\n                    ...birdImages.map((img)=>loadImage(img)),\n                    loadImage(pipeTop),\n                    loadImage(pipeBottom),\n                    loadImage(background),\n                    loadImage(coinImage)\n                ]);\n                console.log(\"All assets loaded successfully!\");\n                initializeGame();\n            } catch (error) {\n                console.error(\"Error loading assets:\", error);\n            }\n        };\n        loadAssets();\n        function resetGame() {\n            if (!canvasRef.current) return;\n            const { height } = canvasRef.current;\n            birdYRef.current = height / 3;\n            birdVelocityRef.current = 0;\n            pipesRef.current = [];\n            coinsRef.current = [];\n            setCurrentScore(0);\n            gameOverRef.current = false;\n            gameStartedRef.current = false;\n            coinRotationStepRef.current = 0;\n            framesRef.current = 0;\n            currentBirdFrameRef.current = 0;\n        }\n        function handleKeyDown(e) {\n            if (e.key === \" \") {\n                // If not started and not over, start. If over, restart. Otherwise flap.\n                if (!gameStartedRef.current && !gameOverRef.current) {\n                    startGame();\n                } else if (gameOverRef.current) {\n                    startGame();\n                } else {\n                    birdVelocityRef.current = FLAP;\n                    flap();\n                }\n            }\n        }\n        window.addEventListener(\"keydown\", handleKeyDown);\n        function handleResize() {\n            if (!canvasRef.current) return;\n            canvasRef.current.width = 360;\n            canvasRef.current.height = 640;\n            // If we're not started and not over, draw start screen\n            if (!gameStartedRef.current && !gameOverRef.current && ctx) {\n                drawStartScreen(ctx, canvasRef.current);\n            }\n        }\n        window.addEventListener(\"resize\", handleResize);\n        // Initialize\n        const initializeGame = ()=>{\n            if (!canvasRef.current) return;\n            canvasRef.current.width = 360;\n            canvasRef.current.height = 640;\n            drawStartScreen(ctx, canvasRef.current);\n        };\n        initializeGame();\n        function startGame() {\n            resetGame();\n            gameStartedRef.current = true;\n            // Start the animation loop\n            lastTimeRef.current = 0; // Reset lastTime\n            requestIdRef.current = requestAnimationFrame(animate);\n        }\n        // Expose a function (for mobile clicks) that does same logic as space bar\n        function handleUserInput() {\n            if (!gameStartedRef.current && !gameOverRef.current) {\n                startGame();\n            } else if (gameOverRef.current) {\n                startGame();\n            } else {\n                birdVelocityRef.current = FLAP;\n                flap();\n            }\n        }\n        // Flap animation sequence\n        const flap = ()=>{\n            currentBirdFrameRef.current = 1;\n            setTimeout(()=>{\n                currentBirdFrameRef.current = 2;\n                setTimeout(()=>{\n                    currentBirdFrameRef.current = 0;\n                }, 170);\n            }, 170);\n        };\n        // Main loop with frame rate limiting\n        function animate(timestamp) {\n            if (isPaused || !gameStartedRef.current) {\n                requestIdRef.current = requestAnimationFrame(animate);\n                return;\n            }\n            if (!canvasRef.current) return;\n            const context = canvasRef.current.getContext(\"2d\");\n            if (!context) return;\n            // Calculate time since last frame\n            const delta = timestamp - lastTimeRef.current;\n            if (delta < frameDuration) {\n                // Not enough time has elapsed for a new frame => skip\n                requestIdRef.current = requestAnimationFrame(animate);\n                return;\n            }\n            // Update lastTime to current\n            lastTimeRef.current = timestamp;\n            // Update logic\n            updateGameState(canvasRef.current);\n            draw(context, canvasRef.current);\n            if (!gameOverRef.current) {\n                requestIdRef.current = requestAnimationFrame(animate);\n            } else {\n                drawGameOverScreen(context, canvasRef.current);\n            }\n        }\n        function updateGameState(canvas) {\n            framesRef.current++;\n            // Gravity\n            birdVelocityRef.current += GRAVITY;\n            birdYRef.current += birdVelocityRef.current;\n            // Spawn pipes\n            if (framesRef.current % PIPE_SPAWN_FRAMES === 0) {\n                createPipe(canvas);\n            }\n            movePipesAndCoins();\n            checkCoinCollection();\n            // Check collisions\n            if (checkCollisions(canvas)) {\n                gameOverRef.current = true;\n                return;\n            }\n            updateScore();\n            // Rotate coin\n            coinRotationStepRef.current += ROTATION_SPEED;\n            if (coinRotationStepRef.current >= 1) {\n                coinRotationStepRef.current = 0;\n            }\n        }\n        function draw(ctx, canvas) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawBackground(ctx, canvas);\n            drawBird(ctx);\n            drawPipes(ctx);\n            drawCoins(ctx);\n        }\n        function drawStartScreen(ctx, canvas) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawBackground(ctx, canvas);\n            ctx.font = \"bold 30px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.fillStyle = \"#ffffff\";\n            ctx.shadowColor = \"black\";\n            ctx.textBaseline = \"middle\";\n            // Combined message (Space or Tap)\n            ctx.fillText(\"Press Space or Tap to Start\", canvas.width / 2, canvas.height / 2);\n        }\n        function drawGameOverScreen(ctx, canvas) {\n            ctx.fillStyle = \"#ffcc00\";\n            ctx.font = \"bold 50px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"middle\";\n            ctx.shadowColor = \"black\";\n            ctx.shadowBlur = 10;\n            ctx.fillText(\"Game Over!\", canvas.width / 2, canvas.height / 2 - 40);\n            ctx.fillStyle = \"#ffffff\";\n            ctx.font = \"bold 30px Arial\";\n            ctx.fillText(\"Press Space or Tap to Restart\", canvas.width / 2, canvas.height / 2 + 20);\n        }\n        function drawBackground(ctx, canvas) {\n            ctx.drawImage(background, 0, 0, canvas.width, canvas.height);\n        }\n        function drawBird(ctx) {\n            const currentImage = birdImages[currentBirdFrameRef.current];\n            if (currentImage.complete) {\n                ctx.drawImage(currentImage, 100, birdYRef.current, BIRD_WIDTH, BIRD_HEIGHT);\n            }\n        }\n        function drawPipes(ctx) {\n            for (const pipe of pipesRef.current){\n                ctx.drawImage(pipeTop, pipe.x, 0, PIPE_WIDTH, pipe.topHeight);\n                ctx.drawImage(pipeBottom, pipe.x, pipe.bottomY, PIPE_WIDTH, pipe.bottomHeight);\n            }\n        }\n        function drawCoins(ctx) {\n            const scaleX = Math.abs(Math.cos(coinRotationStepRef.current * Math.PI * 2));\n            const halfSize = COIN_SIZE / 2;\n            for (const coin of coinsRef.current){\n                if (!coin.collected) {\n                    ctx.save();\n                    ctx.translate(coin.x + halfSize, coin.y + halfSize);\n                    ctx.scale(scaleX, 1); // \"flip\" horizontally as it rotates\n                    ctx.drawImage(coinImage, -halfSize, -halfSize, COIN_SIZE, COIN_SIZE);\n                    ctx.restore();\n                }\n            }\n        }\n        function createPipe(canvas) {\n            const pipeHeight = Math.random() * (canvas.height - PIPE_SPACING - 100) + 50;\n            const bottomY = pipeHeight + PIPE_SPACING;\n            pipesRef.current.push({\n                x: canvas.width,\n                topHeight: pipeHeight,\n                bottomY,\n                bottomHeight: canvas.height - bottomY,\n                scored: false\n            });\n            // 50% chance to spawn a coin\n            if (Math.random() > 0.5) {\n                coinsRef.current.push({\n                    x: canvas.width + PIPE_WIDTH / 2 - COIN_SIZE / 2,\n                    y: pipeHeight + PIPE_SPACING / 2 - COIN_SIZE / 2,\n                    width: COIN_SIZE,\n                    height: COIN_SIZE,\n                    collected: false\n                });\n            }\n        }\n        function movePipesAndCoins() {\n            for (const pipe of pipesRef.current){\n                pipe.x -= 2;\n            }\n            pipesRef.current = pipesRef.current.filter((pipe)=>pipe.x + PIPE_WIDTH > 0);\n            for (const coin of coinsRef.current){\n                coin.x -= 2;\n            }\n            coinsRef.current = coinsRef.current.filter((coin)=>coin.x + coin.width > 0 && !coin.collected);\n        }\n        function checkCollisions(canvas) {\n            // Check top/bottom boundaries\n            if (birdYRef.current < 0 || birdYRef.current + BIRD_HEIGHT > canvas.height) {\n                return true;\n            }\n            const birdLeft = 100;\n            const birdRight = birdLeft + BIRD_WIDTH;\n            const birdTop = birdYRef.current;\n            const birdBottom = birdYRef.current + BIRD_HEIGHT;\n            // Pipe collision\n            for (const pipe of pipesRef.current){\n                const withinPipeX = birdRight > pipe.x && birdLeft < pipe.x + PIPE_WIDTH;\n                const withinPipeY = birdTop < pipe.topHeight || birdBottom > pipe.bottomY;\n                if (withinPipeX && withinPipeY) return true;\n            }\n            return false;\n        }\n        function checkCoinCollection() {\n            const birdLeft = 100;\n            const birdRight = birdLeft + BIRD_WIDTH;\n            const birdTop = birdYRef.current;\n            const birdBottom = birdYRef.current + BIRD_HEIGHT;\n            for (const coin of coinsRef.current){\n                if (!coin.collected) {\n                    const coinLeft = coin.x;\n                    const coinRight = coin.x + coin.width;\n                    const coinTop = coin.y;\n                    const coinBottom = coin.y + coin.height;\n                    if (birdRight > coinLeft && birdLeft < coinRight && birdBottom > coinTop && birdTop < coinBottom) {\n                        coin.collected = true;\n                        setCurrentScore((prevScore)=>{\n                            const newScore = prevScore + 5;\n                            setHighScore((prevHighScore)=>Math.max(prevHighScore, newScore));\n                            return newScore;\n                        });\n                    }\n                }\n            }\n        }\n        function updateScore() {\n            for (const pipe of pipesRef.current){\n                // Score +1 for passing each pipe, only once\n                if (!pipe.scored && pipe.x + PIPE_WIDTH < 100) {\n                    setCurrentScore((prevScore)=>{\n                        const newScore = prevScore + 1;\n                        setHighScore((prevHighScore)=>{\n                            const updatedHighScore = Math.max(prevHighScore, newScore);\n                            if (true) {\n                                localStorage.setItem(\"highScore\", updatedHighScore.toString());\n                            }\n                            return updatedHighScore;\n                        });\n                        return newScore;\n                    });\n                    pipe.scored = true;\n                }\n            }\n        }\n        return ()=>{\n            window.removeEventListener(\"keydown\", handleKeyDown);\n            window.removeEventListener(\"resize\", handleResize);\n            if (requestIdRef.current) {\n                cancelAnimationFrame(requestIdRef.current);\n            }\n        };\n    }, [\n        canvasRef,\n        isPaused,\n        autoStart\n    ]);\n    // Expose handleUserInput so the parent can attach onClick / onTouch\n    const handleUserInput = ()=>{\n    /* This gets overridden once the effect is fully loaded, \r\n       but we define it here to avoid undefined references. */ };\n    return {\n        highScore,\n        currentScore,\n        // We'll return a stable function that re-dispatches a spacebar event\n        handleUserInput: ()=>{\n            const spaceEvent = new KeyboardEvent(\"keydown\", {\n                key: \" \"\n            });\n            window.dispatchEvent(spaceEvent);\n        }\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RCxPQUFPMEUsbUJBQW1CLENBQUMsV0FBVy9FO1lBQ3RDSyxPQUFPMEUsbUJBQW1CLENBQUMsVUFBVXhFO1lBQ3JDLElBQUkxRCxhQUFhOEIsT0FBTyxFQUFFO2dCQUN4QnFHLHFCQUFxQm5JLGFBQWE4QixPQUFPO1lBQzNDO1FBQ0Y7SUFDRixHQUFHO1FBQUNqQztRQUFXQztRQUFVQztLQUFVO0lBRW5DLG9FQUFvRTtJQUNwRSxNQUFNZ0Usa0JBQWtCO0lBQ3RCOzREQUN3RCxHQUMxRDtJQUVBLE9BQU87UUFDTDlEO1FBQ0FFO1FBQ0EscUVBQXFFO1FBQ3JFNEQsaUJBQWlCO1lBQ2YsTUFBTXFFLGFBQWEsSUFBSUMsY0FBYyxXQUFXO2dCQUFFaEYsS0FBSztZQUFJO1lBQzNERyxPQUFPOEUsYUFBYSxDQUFDRjtRQUN2QjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcHVibGljL3VzZUZsYXBweUJpcmRHYW1lLnRzPzVjNzgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XHJcblxyXG4vLyBUeXBlcyBmb3IgZ2FtZSBvYmplY3RzXHJcbmludGVyZmFjZSBQaXBlIHtcclxuICB4OiBudW1iZXI7XHJcbiAgdG9wSGVpZ2h0OiBudW1iZXI7XHJcbiAgYm90dG9tWTogbnVtYmVyO1xyXG4gIGJvdHRvbUhlaWdodDogbnVtYmVyO1xyXG4gIHNjb3JlZDogYm9vbGVhbjtcclxufVxyXG5cclxuaW50ZXJmYWNlIENvaW4ge1xyXG4gIHg6IG51bWJlcjtcclxuICB5OiBudW1iZXI7XHJcbiAgd2lkdGg6IG51bWJlcjtcclxuICBoZWlnaHQ6IG51bWJlcjtcclxuICBjb2xsZWN0ZWQ6IGJvb2xlYW47XHJcbn1cclxuXHJcbi8vIENvbnN0YW50c1xyXG5jb25zdCBHUkFWSVRZID0gMC4yNTtcclxuY29uc3QgRkxBUCA9IC03LjU7XHJcbmNvbnN0IFBJUEVfV0lEVEggPSA5MDtcclxuY29uc3QgUElQRV9TUEFDSU5HID0gMjUwO1xyXG5jb25zdCBCSVJEX1dJRFRIID0gNTA7XHJcbmNvbnN0IEJJUkRfSEVJR0hUID0gNTA7XHJcbmNvbnN0IENPSU5fU0laRSA9IDEwMDtcclxuY29uc3QgUk9UQVRJT05fU1BFRUQgPSAwLjAwNTtcclxuXHJcbi8vIEhvdyBvZnRlbiB0byBzcGF3biBwaXBlcyBpbiB0ZXJtcyBvZiBmcmFtZXMgKH4xLjY2cyBpZiA2MGZwcylcclxuY29uc3QgUElQRV9TUEFXTl9GUkFNRVMgPSAxMDA7XHJcblxyXG4vLyBGcmFtZSByYXRlIGxpbWl0ZXI6IHRhcmdldCB+MzAgRlBTXHJcbmNvbnN0IHRhcmdldEZwcyA9IDYwO1xyXG5jb25zdCBmcmFtZUR1cmF0aW9uID0gMTAwMCAvIHRhcmdldEZwczsgLy8gfjMzLjMgbXMgcGVyIGZyYW1lXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlRmxhcHB5QmlyZEdhbWUoXHJcbiAgY2FudmFzUmVmOiBSZWFjdC5SZWZPYmplY3Q8SFRNTENhbnZhc0VsZW1lbnQ+LFxyXG4gIGlzUGF1c2VkOiBib29sZWFuLFxyXG4gIGF1dG9TdGFydDogYm9vbGVhblxyXG4pIHtcclxuICBjb25zdCByZXF1ZXN0SWRSZWYgPSB1c2VSZWY8bnVtYmVyIHwgbnVsbD4obnVsbCk7XHJcblxyXG4gIC8vIFN0YXRlXHJcbiAgY29uc3QgW2hpZ2hTY29yZSwgc2V0SGlnaFNjb3JlXSA9IHVzZVN0YXRlKDApO1xyXG4gIGNvbnN0IFtjdXJyZW50U2NvcmUsIHNldEN1cnJlbnRTY29yZV0gPSB1c2VTdGF0ZSgwKTtcclxuXHJcbiAgLy8gUmVmcyB0byB0cmFjayBnYW1lIHN0YXRlXHJcbiAgY29uc3QgYmlyZFlSZWYgPSB1c2VSZWY8bnVtYmVyPigwKTtcclxuICBjb25zdCBiaXJkVmVsb2NpdHlSZWYgPSB1c2VSZWY8bnVtYmVyPigwKTtcclxuICBjb25zdCBwaXBlc1JlZiA9IHVzZVJlZjxQaXBlW10+KFtdKTtcclxuICBjb25zdCBjb2luc1JlZiA9IHVzZVJlZjxDb2luW10+KFtdKTtcclxuICBjb25zdCBnYW1lT3ZlclJlZiA9IHVzZVJlZjxib29sZWFuPihmYWxzZSk7XHJcbiAgY29uc3QgZ2FtZVN0YXJ0ZWRSZWYgPSB1c2VSZWY8Ym9vbGVhbj4oZmFsc2UpO1xyXG5cclxuICBjb25zdCBjb2luUm90YXRpb25TdGVwUmVmID0gdXNlUmVmPG51bWJlcj4oMCk7XHJcbiAgY29uc3QgZnJhbWVzUmVmID0gdXNlUmVmPG51bWJlcj4oMCk7XHJcblxyXG4gIC8vIEFzc2V0cyAobG9hZGVkIG9uY2UgaWYgd2luZG93IGlzIGRlZmluZWQpXHJcbiAgbGV0IGJpcmRJbWFnZXM6IEhUTUxJbWFnZUVsZW1lbnRbXSA9IFtdO1xyXG4gIGxldCBwaXBlVG9wOiBIVE1MSW1hZ2VFbGVtZW50O1xyXG4gIGxldCBwaXBlQm90dG9tOiBIVE1MSW1hZ2VFbGVtZW50O1xyXG4gIGxldCBiYWNrZ3JvdW5kOiBIVE1MSW1hZ2VFbGVtZW50O1xyXG4gIGxldCBjb2luSW1hZ2U6IEhUTUxJbWFnZUVsZW1lbnQ7XHJcblxyXG4gIC8vIFN0b3JlIHRoZSBsYXN0IHRpbWVzdGFtcCB0byBsaW1pdCBGUFNcclxuICBjb25zdCBsYXN0VGltZVJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xyXG5cclxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgY29uc3QgYmlyZFVwID0gbmV3IEltYWdlKCk7XHJcbiAgICBiaXJkVXAuc3JjID0gXCIvYXNzZXRzL3JlZGJpcmQtdXBmbGFwLnBuZ1wiO1xyXG5cclxuICAgIGNvbnN0IGJpcmRNaWQgPSBuZXcgSW1hZ2UoKTtcclxuICAgIGJpcmRNaWQuc3JjID0gXCIvYXNzZXRzL3JlZGJpcmQtbWlkZmxhcC5wbmdcIjtcclxuXHJcbiAgICBjb25zdCBiaXJkRG93biA9IG5ldyBJbWFnZSgpO1xyXG4gICAgYmlyZERvd24uc3JjID0gXCIvYXNzZXRzL3JlZGJpcmQtZG93bmZsYXAucG5nXCI7XHJcblxyXG4gICAgYmlyZEltYWdlcyA9IFtiaXJkVXAsIGJpcmRNaWQsIGJpcmREb3duXTtcclxuXHJcbiAgICBwaXBlVG9wID0gbmV3IEltYWdlKCk7XHJcbiAgICBwaXBlVG9wLnNyYyA9IFwiL2Fzc2V0cy9Ub3BUaW55LnBuZ1wiO1xyXG5cclxuICAgIHBpcGVCb3R0b20gPSBuZXcgSW1hZ2UoKTtcclxuICAgIHBpcGVCb3R0b20uc3JjID0gXCIvYXNzZXRzL0JvdHRvbVRpbnkucG5nXCI7XHJcblxyXG4gICAgYmFja2dyb3VuZCA9IG5ldyBJbWFnZSgpO1xyXG4gICAgYmFja2dyb3VuZC5zcmMgPSBcIi9hc3NldHMvYmFja2dyb3VuZC1kYXkucG5nXCI7XHJcblxyXG4gICAgY29pbkltYWdlID0gbmV3IEltYWdlKCk7XHJcbiAgICBjb2luSW1hZ2Uuc3JjID0gXCIvYXNzZXRzL0NvaW5UaW55LnBuZ1wiO1xyXG4gIH1cclxuXHJcbiAgLy8gQ3VycmVudCBiaXJkIGZyYW1lIGluZGV4XHJcbiAgY29uc3QgY3VycmVudEJpcmRGcmFtZVJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xyXG5cclxuICAvLyBMb2FkIGhpZ2ggc2NvcmUgZnJvbSBsb2NhbFN0b3JhZ2Ugb24gbW91bnRcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgY29uc3Qgc3RvcmVkSGlnaFNjb3JlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJoaWdoU2NvcmVcIik7XHJcbiAgICAgIGlmIChzdG9yZWRIaWdoU2NvcmUpIHtcclxuICAgICAgICBzZXRIaWdoU2NvcmUocGFyc2VJbnQoc3RvcmVkSGlnaFNjb3JlLCAxMCkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSwgW10pO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XHJcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICBpZiAoIWN0eCkgcmV0dXJuO1xyXG5cclxuICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBsb2FkIGFuIGltYWdlIGZ1bGx5IChwcm9taXNpZnkpXHJcbiAgICBjb25zdCBsb2FkSW1hZ2UgPSAoaW1nOiBIVE1MSW1hZ2VFbGVtZW50KTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgaWYgKGltZy5jb21wbGV0ZSkge1xyXG4gICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpbWcub25sb2FkID0gKCkgPT4gcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgaW1nLm9uZXJyb3IgPSAoKSA9PlxyXG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBpbWFnZTogJHtpbWcuc3JjfWApKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBMb2FkIGFsbCBhc3NldHMgdGhlbiBpbml0XHJcbiAgICBjb25zdCBsb2FkQXNzZXRzID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgICAgICAgIC4uLmJpcmRJbWFnZXMubWFwKChpbWcpID0+IGxvYWRJbWFnZShpbWcpKSxcclxuICAgICAgICAgIGxvYWRJbWFnZShwaXBlVG9wKSxcclxuICAgICAgICAgIGxvYWRJbWFnZShwaXBlQm90dG9tKSxcclxuICAgICAgICAgIGxvYWRJbWFnZShiYWNrZ3JvdW5kKSxcclxuICAgICAgICAgIGxvYWRJbWFnZShjb2luSW1hZ2UpLFxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQWxsIGFzc2V0cyBsb2FkZWQgc3VjY2Vzc2Z1bGx5IVwiKTtcclxuICAgICAgICBpbml0aWFsaXplR2FtZSgpO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsb2FkaW5nIGFzc2V0czpcIiwgZXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGxvYWRBc3NldHMoKTtcclxuXHJcbiAgICBmdW5jdGlvbiByZXNldEdhbWUoKSB7XHJcbiAgICAgIGlmICghY2FudmFzUmVmLmN1cnJlbnQpIHJldHVybjtcclxuICAgICAgY29uc3QgeyBoZWlnaHQgfSA9IGNhbnZhc1JlZi5jdXJyZW50O1xyXG5cclxuICAgICAgYmlyZFlSZWYuY3VycmVudCA9IGhlaWdodCAvIDM7XHJcbiAgICAgIGJpcmRWZWxvY2l0eVJlZi5jdXJyZW50ID0gMDtcclxuICAgICAgcGlwZXNSZWYuY3VycmVudCA9IFtdO1xyXG4gICAgICBjb2luc1JlZi5jdXJyZW50ID0gW107XHJcbiAgICAgIHNldEN1cnJlbnRTY29yZSgwKTtcclxuICAgICAgZ2FtZU92ZXJSZWYuY3VycmVudCA9IGZhbHNlO1xyXG4gICAgICBnYW1lU3RhcnRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICAgIGNvaW5Sb3RhdGlvblN0ZXBSZWYuY3VycmVudCA9IDA7XHJcbiAgICAgIGZyYW1lc1JlZi5jdXJyZW50ID0gMDtcclxuICAgICAgY3VycmVudEJpcmRGcmFtZVJlZi5jdXJyZW50ID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVLZXlEb3duKGU6IEtleWJvYXJkRXZlbnQpIHtcclxuICAgICAgaWYgKGUua2V5ID09PSBcIiBcIikge1xyXG4gICAgICAgIC8vIElmIG5vdCBzdGFydGVkIGFuZCBub3Qgb3Zlciwgc3RhcnQuIElmIG92ZXIsIHJlc3RhcnQuIE90aGVyd2lzZSBmbGFwLlxyXG4gICAgICAgIGlmICghZ2FtZVN0YXJ0ZWRSZWYuY3VycmVudCAmJiAhZ2FtZU92ZXJSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgc3RhcnRHYW1lKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChnYW1lT3ZlclJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICBzdGFydEdhbWUoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYmlyZFZlbG9jaXR5UmVmLmN1cnJlbnQgPSBGTEFQO1xyXG4gICAgICAgICAgZmxhcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBoYW5kbGVLZXlEb3duKTtcclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVSZXNpemUoKSB7XHJcbiAgICAgIGlmICghY2FudmFzUmVmLmN1cnJlbnQpIHJldHVybjtcclxuICAgICAgY2FudmFzUmVmLmN1cnJlbnQud2lkdGggPSAzNjA7XHJcbiAgICAgIGNhbnZhc1JlZi5jdXJyZW50LmhlaWdodCA9IDY0MDtcclxuXHJcbiAgICAgIC8vIElmIHdlJ3JlIG5vdCBzdGFydGVkIGFuZCBub3Qgb3ZlciwgZHJhdyBzdGFydCBzY3JlZW5cclxuICAgICAgaWYgKCFnYW1lU3RhcnRlZFJlZi5jdXJyZW50ICYmICFnYW1lT3ZlclJlZi5jdXJyZW50ICYmIGN0eCkge1xyXG4gICAgICAgIGRyYXdTdGFydFNjcmVlbihjdHgsIGNhbnZhc1JlZi5jdXJyZW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgaGFuZGxlUmVzaXplKTtcclxuXHJcbiAgICAvLyBJbml0aWFsaXplXHJcbiAgICBjb25zdCBpbml0aWFsaXplR2FtZSA9ICgpID0+IHtcclxuICAgICAgaWYgKCFjYW52YXNSZWYuY3VycmVudCkgcmV0dXJuO1xyXG4gICAgICBjYW52YXNSZWYuY3VycmVudC53aWR0aCA9IDM2MDtcclxuICAgICAgY2FudmFzUmVmLmN1cnJlbnQuaGVpZ2h0ID0gNjQwO1xyXG4gICAgICBkcmF3U3RhcnRTY3JlZW4oY3R4LCBjYW52YXNSZWYuY3VycmVudCk7XHJcbiAgICB9O1xyXG5cclxuICAgIGluaXRpYWxpemVHYW1lKCk7XHJcblxyXG4gICAgZnVuY3Rpb24gc3RhcnRHYW1lKCkge1xyXG4gICAgICByZXNldEdhbWUoKTtcclxuICAgICAgZ2FtZVN0YXJ0ZWRSZWYuY3VycmVudCA9IHRydWU7XHJcbiAgICAgIC8vIFN0YXJ0IHRoZSBhbmltYXRpb24gbG9vcFxyXG4gICAgICBsYXN0VGltZVJlZi5jdXJyZW50ID0gMDsgLy8gUmVzZXQgbGFzdFRpbWVcclxuICAgICAgcmVxdWVzdElkUmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRXhwb3NlIGEgZnVuY3Rpb24gKGZvciBtb2JpbGUgY2xpY2tzKSB0aGF0IGRvZXMgc2FtZSBsb2dpYyBhcyBzcGFjZSBiYXJcclxuICAgIGZ1bmN0aW9uIGhhbmRsZVVzZXJJbnB1dCgpIHtcclxuICAgICAgaWYgKCFnYW1lU3RhcnRlZFJlZi5jdXJyZW50ICYmICFnYW1lT3ZlclJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgc3RhcnRHYW1lKCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoZ2FtZU92ZXJSZWYuY3VycmVudCkge1xyXG4gICAgICAgIHN0YXJ0R2FtZSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGJpcmRWZWxvY2l0eVJlZi5jdXJyZW50ID0gRkxBUDtcclxuICAgICAgICBmbGFwKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBGbGFwIGFuaW1hdGlvbiBzZXF1ZW5jZVxyXG4gICAgY29uc3QgZmxhcCA9ICgpID0+IHtcclxuICAgICAgY3VycmVudEJpcmRGcmFtZVJlZi5jdXJyZW50ID0gMTtcclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgY3VycmVudEJpcmRGcmFtZVJlZi5jdXJyZW50ID0gMjtcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgIGN1cnJlbnRCaXJkRnJhbWVSZWYuY3VycmVudCA9IDA7XHJcbiAgICAgICAgfSwgMTcwKTtcclxuICAgICAgfSwgMTcwKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gTWFpbiBsb29wIHdpdGggZnJhbWUgcmF0ZSBsaW1pdGluZ1xyXG4gICAgZnVuY3Rpb24gYW5pbWF0ZSh0aW1lc3RhbXA6IG51bWJlcikge1xyXG4gICAgICBpZiAoaXNQYXVzZWQgfHwgIWdhbWVTdGFydGVkUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICByZXF1ZXN0SWRSZWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFjYW52YXNSZWYuY3VycmVudCkgcmV0dXJuO1xyXG4gICAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzUmVmLmN1cnJlbnQuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgICBpZiAoIWNvbnRleHQpIHJldHVybjtcclxuXHJcbiAgICAgIC8vIENhbGN1bGF0ZSB0aW1lIHNpbmNlIGxhc3QgZnJhbWVcclxuICAgICAgY29uc3QgZGVsdGEgPSB0aW1lc3RhbXAgLSBsYXN0VGltZVJlZi5jdXJyZW50O1xyXG4gICAgICBpZiAoZGVsdGEgPCBmcmFtZUR1cmF0aW9uKSB7XHJcbiAgICAgICAgLy8gTm90IGVub3VnaCB0aW1lIGhhcyBlbGFwc2VkIGZvciBhIG5ldyBmcmFtZSA9PiBza2lwXHJcbiAgICAgICAgcmVxdWVzdElkUmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIFVwZGF0ZSBsYXN0VGltZSB0byBjdXJyZW50XHJcbiAgICAgIGxhc3RUaW1lUmVmLmN1cnJlbnQgPSB0aW1lc3RhbXA7XHJcblxyXG4gICAgICAvLyBVcGRhdGUgbG9naWNcclxuICAgICAgdXBkYXRlR2FtZVN0YXRlKGNhbnZhc1JlZi5jdXJyZW50KTtcclxuICAgICAgZHJhdyhjb250ZXh0LCBjYW52YXNSZWYuY3VycmVudCk7XHJcblxyXG4gICAgICBpZiAoIWdhbWVPdmVyUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICByZXF1ZXN0SWRSZWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBkcmF3R2FtZU92ZXJTY3JlZW4oY29udGV4dCwgY2FudmFzUmVmLmN1cnJlbnQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdXBkYXRlR2FtZVN0YXRlKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcclxuICAgICAgZnJhbWVzUmVmLmN1cnJlbnQrKztcclxuXHJcbiAgICAgIC8vIEdyYXZpdHlcclxuICAgICAgYmlyZFZlbG9jaXR5UmVmLmN1cnJlbnQgKz0gR1JBVklUWTtcclxuICAgICAgYmlyZFlSZWYuY3VycmVudCArPSBiaXJkVmVsb2NpdHlSZWYuY3VycmVudDtcclxuXHJcbiAgICAgIC8vIFNwYXduIHBpcGVzXHJcbiAgICAgIGlmIChmcmFtZXNSZWYuY3VycmVudCAlIFBJUEVfU1BBV05fRlJBTUVTID09PSAwKSB7XHJcbiAgICAgICAgY3JlYXRlUGlwZShjYW52YXMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBtb3ZlUGlwZXNBbmRDb2lucygpO1xyXG4gICAgICBjaGVja0NvaW5Db2xsZWN0aW9uKCk7XHJcblxyXG4gICAgICAvLyBDaGVjayBjb2xsaXNpb25zXHJcbiAgICAgIGlmIChjaGVja0NvbGxpc2lvbnMoY2FudmFzKSkge1xyXG4gICAgICAgIGdhbWVPdmVyUmVmLmN1cnJlbnQgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdXBkYXRlU2NvcmUoKTtcclxuXHJcbiAgICAgIC8vIFJvdGF0ZSBjb2luXHJcbiAgICAgIGNvaW5Sb3RhdGlvblN0ZXBSZWYuY3VycmVudCArPSBST1RBVElPTl9TUEVFRDtcclxuICAgICAgaWYgKGNvaW5Sb3RhdGlvblN0ZXBSZWYuY3VycmVudCA+PSAxKSB7XHJcbiAgICAgICAgY29pblJvdGF0aW9uU3RlcFJlZi5jdXJyZW50ID0gMDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXcoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcclxuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICBkcmF3QmFja2dyb3VuZChjdHgsIGNhbnZhcyk7XHJcbiAgICAgIGRyYXdCaXJkKGN0eCk7XHJcbiAgICAgIGRyYXdQaXBlcyhjdHgpO1xyXG4gICAgICBkcmF3Q29pbnMoY3R4KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3U3RhcnRTY3JlZW4oY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcclxuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICBkcmF3QmFja2dyb3VuZChjdHgsIGNhbnZhcyk7XHJcbiAgICAgIGN0eC5mb250ID0gXCJib2xkIDMwcHggQXJpYWxcIjtcclxuICAgICAgY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNmZmZmZmZcIjtcclxuICAgICAgY3R4LnNoYWRvd0NvbG9yID0gXCJibGFja1wiO1xyXG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcclxuICAgICAgLy8gQ29tYmluZWQgbWVzc2FnZSAoU3BhY2Ugb3IgVGFwKVxyXG4gICAgICBjdHguZmlsbFRleHQoXHJcbiAgICAgICAgXCJQcmVzcyBTcGFjZSBvciBUYXAgdG8gU3RhcnRcIixcclxuICAgICAgICBjYW52YXMud2lkdGggLyAyLFxyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgLyAyXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd0dhbWVPdmVyU2NyZWVuKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNmZmNjMDBcIjtcclxuICAgICAgY3R4LmZvbnQgPSBcImJvbGQgNTBweCBBcmlhbFwiO1xyXG4gICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcclxuICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XHJcbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFwiYmxhY2tcIjtcclxuICAgICAgY3R4LnNoYWRvd0JsdXIgPSAxMDtcclxuXHJcbiAgICAgIGN0eC5maWxsVGV4dChcIkdhbWUgT3ZlciFcIiwgY2FudmFzLndpZHRoIC8gMiwgY2FudmFzLmhlaWdodCAvIDIgLSA0MCk7XHJcblxyXG4gICAgICBjdHguZmlsbFN0eWxlID0gXCIjZmZmZmZmXCI7XHJcbiAgICAgIGN0eC5mb250ID0gXCJib2xkIDMwcHggQXJpYWxcIjtcclxuICAgICAgY3R4LmZpbGxUZXh0KFxyXG4gICAgICAgIFwiUHJlc3MgU3BhY2Ugb3IgVGFwIHRvIFJlc3RhcnRcIixcclxuICAgICAgICBjYW52YXMud2lkdGggLyAyLFxyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgLyAyICsgMjBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3QmFja2dyb3VuZChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkge1xyXG4gICAgICBjdHguZHJhd0ltYWdlKGJhY2tncm91bmQsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd0JpcmQoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcclxuICAgICAgY29uc3QgY3VycmVudEltYWdlID0gYmlyZEltYWdlc1tjdXJyZW50QmlyZEZyYW1lUmVmLmN1cnJlbnRdO1xyXG4gICAgICBpZiAoY3VycmVudEltYWdlLmNvbXBsZXRlKSB7XHJcbiAgICAgICAgY3R4LmRyYXdJbWFnZShjdXJyZW50SW1hZ2UsIDEwMCwgYmlyZFlSZWYuY3VycmVudCwgQklSRF9XSURUSCwgQklSRF9IRUlHSFQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd1BpcGVzKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XHJcbiAgICAgIGZvciAoY29uc3QgcGlwZSBvZiBwaXBlc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY3R4LmRyYXdJbWFnZShwaXBlVG9wLCBwaXBlLngsIDAsIFBJUEVfV0lEVEgsIHBpcGUudG9wSGVpZ2h0KTtcclxuICAgICAgICBjdHguZHJhd0ltYWdlKHBpcGVCb3R0b20sIHBpcGUueCwgcGlwZS5ib3R0b21ZLCBQSVBFX1dJRFRILCBwaXBlLmJvdHRvbUhlaWdodCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3Q29pbnMoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcclxuICAgICAgY29uc3Qgc2NhbGVYID0gTWF0aC5hYnMoTWF0aC5jb3MoY29pblJvdGF0aW9uU3RlcFJlZi5jdXJyZW50ICogTWF0aC5QSSAqIDIpKTtcclxuICAgICAgY29uc3QgaGFsZlNpemUgPSBDT0lOX1NJWkUgLyAyO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBjb2luIG9mIGNvaW5zUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBpZiAoIWNvaW4uY29sbGVjdGVkKSB7XHJcbiAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgY3R4LnRyYW5zbGF0ZShjb2luLnggKyBoYWxmU2l6ZSwgY29pbi55ICsgaGFsZlNpemUpO1xyXG4gICAgICAgICAgY3R4LnNjYWxlKHNjYWxlWCwgMSk7IC8vIFwiZmxpcFwiIGhvcml6b250YWxseSBhcyBpdCByb3RhdGVzXHJcbiAgICAgICAgICBjdHguZHJhd0ltYWdlKGNvaW5JbWFnZSwgLWhhbGZTaXplLCAtaGFsZlNpemUsIENPSU5fU0laRSwgQ09JTl9TSVpFKTtcclxuICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlUGlwZShjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgIGNvbnN0IHBpcGVIZWlnaHQgPVxyXG4gICAgICAgIE1hdGgucmFuZG9tKCkgKiAoY2FudmFzLmhlaWdodCAtIFBJUEVfU1BBQ0lORyAtIDEwMCkgKyA1MDtcclxuICAgICAgY29uc3QgYm90dG9tWSA9IHBpcGVIZWlnaHQgKyBQSVBFX1NQQUNJTkc7XHJcbiAgICAgIHBpcGVzUmVmLmN1cnJlbnQucHVzaCh7XHJcbiAgICAgICAgeDogY2FudmFzLndpZHRoLFxyXG4gICAgICAgIHRvcEhlaWdodDogcGlwZUhlaWdodCxcclxuICAgICAgICBib3R0b21ZLFxyXG4gICAgICAgIGJvdHRvbUhlaWdodDogY2FudmFzLmhlaWdodCAtIGJvdHRvbVksXHJcbiAgICAgICAgc2NvcmVkOiBmYWxzZSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyA1MCUgY2hhbmNlIHRvIHNwYXduIGEgY29pblxyXG4gICAgICBpZiAoTWF0aC5yYW5kb20oKSA+IDAuNSkge1xyXG4gICAgICAgIGNvaW5zUmVmLmN1cnJlbnQucHVzaCh7XHJcbiAgICAgICAgICB4OiBjYW52YXMud2lkdGggKyBQSVBFX1dJRFRIIC8gMiAtIENPSU5fU0laRSAvIDIsXHJcbiAgICAgICAgICB5OiBwaXBlSGVpZ2h0ICsgUElQRV9TUEFDSU5HIC8gMiAtIENPSU5fU0laRSAvIDIsXHJcbiAgICAgICAgICB3aWR0aDogQ09JTl9TSVpFLFxyXG4gICAgICAgICAgaGVpZ2h0OiBDT0lOX1NJWkUsXHJcbiAgICAgICAgICBjb2xsZWN0ZWQ6IGZhbHNlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbW92ZVBpcGVzQW5kQ29pbnMoKSB7XHJcbiAgICAgIGZvciAoY29uc3QgcGlwZSBvZiBwaXBlc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgcGlwZS54IC09IDI7XHJcbiAgICAgIH1cclxuICAgICAgcGlwZXNSZWYuY3VycmVudCA9IHBpcGVzUmVmLmN1cnJlbnQuZmlsdGVyKFxyXG4gICAgICAgIChwaXBlKSA9PiBwaXBlLnggKyBQSVBFX1dJRFRIID4gMFxyXG4gICAgICApO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBjb2luIG9mIGNvaW5zUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBjb2luLnggLT0gMjtcclxuICAgICAgfVxyXG4gICAgICBjb2luc1JlZi5jdXJyZW50ID0gY29pbnNSZWYuY3VycmVudC5maWx0ZXIoXHJcbiAgICAgICAgKGNvaW4pID0+IGNvaW4ueCArIGNvaW4ud2lkdGggPiAwICYmICFjb2luLmNvbGxlY3RlZFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNoZWNrQ29sbGlzaW9ucyhjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KTogYm9vbGVhbiB7XHJcbiAgICAgIC8vIENoZWNrIHRvcC9ib3R0b20gYm91bmRhcmllc1xyXG4gICAgICBpZiAoYmlyZFlSZWYuY3VycmVudCA8IDAgfHwgYmlyZFlSZWYuY3VycmVudCArIEJJUkRfSEVJR0hUID4gY2FudmFzLmhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBiaXJkTGVmdCA9IDEwMDtcclxuICAgICAgY29uc3QgYmlyZFJpZ2h0ID0gYmlyZExlZnQgKyBCSVJEX1dJRFRIO1xyXG4gICAgICBjb25zdCBiaXJkVG9wID0gYmlyZFlSZWYuY3VycmVudDtcclxuICAgICAgY29uc3QgYmlyZEJvdHRvbSA9IGJpcmRZUmVmLmN1cnJlbnQgKyBCSVJEX0hFSUdIVDtcclxuXHJcbiAgICAgIC8vIFBpcGUgY29sbGlzaW9uXHJcbiAgICAgIGZvciAoY29uc3QgcGlwZSBvZiBwaXBlc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY29uc3Qgd2l0aGluUGlwZVggPVxyXG4gICAgICAgICAgYmlyZFJpZ2h0ID4gcGlwZS54ICYmIGJpcmRMZWZ0IDwgcGlwZS54ICsgUElQRV9XSURUSDtcclxuICAgICAgICBjb25zdCB3aXRoaW5QaXBlWSA9XHJcbiAgICAgICAgICBiaXJkVG9wIDwgcGlwZS50b3BIZWlnaHQgfHwgYmlyZEJvdHRvbSA+IHBpcGUuYm90dG9tWTtcclxuICAgICAgICBpZiAod2l0aGluUGlwZVggJiYgd2l0aGluUGlwZVkpIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjaGVja0NvaW5Db2xsZWN0aW9uKCkge1xyXG4gICAgICBjb25zdCBiaXJkTGVmdCA9IDEwMDtcclxuICAgICAgY29uc3QgYmlyZFJpZ2h0ID0gYmlyZExlZnQgKyBCSVJEX1dJRFRIO1xyXG4gICAgICBjb25zdCBiaXJkVG9wID0gYmlyZFlSZWYuY3VycmVudDtcclxuICAgICAgY29uc3QgYmlyZEJvdHRvbSA9IGJpcmRZUmVmLmN1cnJlbnQgKyBCSVJEX0hFSUdIVDtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgY29pbiBvZiBjb2luc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgaWYgKCFjb2luLmNvbGxlY3RlZCkge1xyXG4gICAgICAgICAgY29uc3QgY29pbkxlZnQgPSBjb2luLng7XHJcbiAgICAgICAgICBjb25zdCBjb2luUmlnaHQgPSBjb2luLnggKyBjb2luLndpZHRoO1xyXG4gICAgICAgICAgY29uc3QgY29pblRvcCA9IGNvaW4ueTtcclxuICAgICAgICAgIGNvbnN0IGNvaW5Cb3R0b20gPSBjb2luLnkgKyBjb2luLmhlaWdodDtcclxuXHJcbiAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIGJpcmRSaWdodCA+IGNvaW5MZWZ0ICYmXHJcbiAgICAgICAgICAgIGJpcmRMZWZ0IDwgY29pblJpZ2h0ICYmXHJcbiAgICAgICAgICAgIGJpcmRCb3R0b20gPiBjb2luVG9wICYmXHJcbiAgICAgICAgICAgIGJpcmRUb3AgPCBjb2luQm90dG9tXHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgY29pbi5jb2xsZWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBzZXRDdXJyZW50U2NvcmUoKHByZXZTY29yZSkgPT4ge1xyXG4gICAgICAgICAgICAgIGNvbnN0IG5ld1Njb3JlID0gcHJldlNjb3JlICsgNTtcclxuICAgICAgICAgICAgICBzZXRIaWdoU2NvcmUoKHByZXZIaWdoU2NvcmUpID0+IE1hdGgubWF4KHByZXZIaWdoU2NvcmUsIG5ld1Njb3JlKSk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIG5ld1Njb3JlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVTY29yZSgpIHtcclxuICAgICAgZm9yIChjb25zdCBwaXBlIG9mIHBpcGVzUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAvLyBTY29yZSArMSBmb3IgcGFzc2luZyBlYWNoIHBpcGUsIG9ubHkgb25jZVxyXG4gICAgICAgIGlmICghcGlwZS5zY29yZWQgJiYgcGlwZS54ICsgUElQRV9XSURUSCA8IDEwMCkge1xyXG4gICAgICAgICAgc2V0Q3VycmVudFNjb3JlKChwcmV2U2NvcmUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbmV3U2NvcmUgPSBwcmV2U2NvcmUgKyAxO1xyXG4gICAgICAgICAgICBzZXRIaWdoU2NvcmUoKHByZXZIaWdoU2NvcmUpID0+IHtcclxuICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkSGlnaFNjb3JlID0gTWF0aC5tYXgocHJldkhpZ2hTY29yZSwgbmV3U2NvcmUpO1xyXG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcImhpZ2hTY29yZVwiLCB1cGRhdGVkSGlnaFNjb3JlLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlZEhpZ2hTY29yZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdTY29yZTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgcGlwZS5zY29yZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBoYW5kbGVLZXlEb3duKTtcclxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgaGFuZGxlUmVzaXplKTtcclxuICAgICAgaWYgKHJlcXVlc3RJZFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmVxdWVzdElkUmVmLmN1cnJlbnQpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH0sIFtjYW52YXNSZWYsIGlzUGF1c2VkLCBhdXRvU3RhcnRdKTtcclxuXHJcbiAgLy8gRXhwb3NlIGhhbmRsZVVzZXJJbnB1dCBzbyB0aGUgcGFyZW50IGNhbiBhdHRhY2ggb25DbGljayAvIG9uVG91Y2hcclxuICBjb25zdCBoYW5kbGVVc2VySW5wdXQgPSAoKSA9PiB7XHJcbiAgICAvKiBUaGlzIGdldHMgb3ZlcnJpZGRlbiBvbmNlIHRoZSBlZmZlY3QgaXMgZnVsbHkgbG9hZGVkLCBcclxuICAgICAgIGJ1dCB3ZSBkZWZpbmUgaXQgaGVyZSB0byBhdm9pZCB1bmRlZmluZWQgcmVmZXJlbmNlcy4gKi9cclxuICB9O1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgaGlnaFNjb3JlLFxyXG4gICAgY3VycmVudFNjb3JlLFxyXG4gICAgLy8gV2UnbGwgcmV0dXJuIGEgc3RhYmxlIGZ1bmN0aW9uIHRoYXQgcmUtZGlzcGF0Y2hlcyBhIHNwYWNlYmFyIGV2ZW50XHJcbiAgICBoYW5kbGVVc2VySW5wdXQ6ICgpID0+IHtcclxuICAgICAgY29uc3Qgc3BhY2VFdmVudCA9IG5ldyBLZXlib2FyZEV2ZW50KFwia2V5ZG93blwiLCB7IGtleTogXCIgXCIgfSk7XHJcbiAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KHNwYWNlRXZlbnQpO1xyXG4gICAgfSxcclxuICB9O1xyXG59XHJcbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsIkdSQVZJVFkiLCJGTEFQIiwiUElQRV9XSURUSCIsIlBJUEVfU1BBQ0lORyIsIkJJUkRfV0lEVEgiLCJCSVJEX0hFSUdIVCIsIkNPSU5fU0laRSIsIlJPVEFUSU9OX1NQRUVEIiwiUElQRV9TUEFXTl9GUkFNRVMiLCJ0YXJnZXRGcHMiLCJmcmFtZUR1cmF0aW9uIiwidXNlRmxhcHB5QmlyZEdhbWUiLCJjYW52YXNSZWYiLCJpc1BhdXNlZCIsImF1dG9TdGFydCIsInJlcXVlc3RJZFJlZiIsImhpZ2hTY29yZSIsInNldEhpZ2hTY29yZSIsImN1cnJlbnRTY29yZSIsInNldEN1cnJlbnRTY29yZSIsImJpcmRZUmVmIiwiYmlyZFZlbG9jaXR5UmVmIiwicGlwZXNSZWYiLCJjb2luc1JlZiIsImdhbWVPdmVyUmVmIiwiZ2FtZVN0YXJ0ZWRSZWYiLCJjb2luUm90YXRpb25TdGVwUmVmIiwiZnJhbWVzUmVmIiwiYmlyZEltYWdlcyIsInBpcGVUb3AiLCJwaXBlQm90dG9tIiwiYmFja2dyb3VuZCIsImNvaW5JbWFnZSIsImxhc3RUaW1lUmVmIiwiYmlyZFVwIiwiSW1hZ2UiLCJzcmMiLCJiaXJkTWlkIiwiYmlyZERvd24iLCJjdXJyZW50QmlyZEZyYW1lUmVmIiwic3RvcmVkSGlnaFNjb3JlIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInBhcnNlSW50IiwiY2FudmFzIiwiY3VycmVudCIsImN0eCIsImdldENvbnRleHQiLCJsb2FkSW1hZ2UiLCJpbWciLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImNvbXBsZXRlIiwib25sb2FkIiwib25lcnJvciIsIkVycm9yIiwibG9hZEFzc2V0cyIsImFsbCIsIm1hcCIsImNvbnNvbGUiLCJsb2ciLCJpbml0aWFsaXplR2FtZSIsImVycm9yIiwicmVzZXRHYW1lIiwiaGVpZ2h0IiwiaGFuZGxlS2V5RG93biIsImUiLCJrZXkiLCJzdGFydEdhbWUiLCJmbGFwIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsImhhbmRsZVJlc2l6ZSIsIndpZHRoIiwiZHJhd1N0YXJ0U2NyZWVuIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiYW5pbWF0ZSIsImhhbmRsZVVzZXJJbnB1dCIsInNldFRpbWVvdXQiLCJ0aW1lc3RhbXAiLCJjb250ZXh0IiwiZGVsdGEiLCJ1cGRhdGVHYW1lU3RhdGUiLCJkcmF3IiwiZHJhd0dhbWVPdmVyU2NyZWVuIiwiY3JlYXRlUGlwZSIsIm1vdmVQaXBlc0FuZENvaW5zIiwiY2hlY2tDb2luQ29sbGVjdGlvbiIsImNoZWNrQ29sbGlzaW9ucyIsInVwZGF0ZVNjb3JlIiwiY2xlYXJSZWN0IiwiZHJhd0JhY2tncm91bmQiLCJkcmF3QmlyZCIsImRyYXdQaXBlcyIsImRyYXdDb2lucyIsImZvbnQiLCJ0ZXh0QWxpZ24iLCJmaWxsU3R5bGUiLCJzaGFkb3dDb2xvciIsInRleHRCYXNlbGluZSIsImZpbGxUZXh0Iiwic2hhZG93Qmx1ciIsImRyYXdJbWFnZSIsImN1cnJlbnRJbWFnZSIsInBpcGUiLCJ4IiwidG9wSGVpZ2h0IiwiYm90dG9tWSIsImJvdHRvbUhlaWdodCIsInNjYWxlWCIsIk1hdGgiLCJhYnMiLCJjb3MiLCJQSSIsImhhbGZTaXplIiwiY29pbiIsImNvbGxlY3RlZCIsInNhdmUiLCJ0cmFuc2xhdGUiLCJ5Iiwic2NhbGUiLCJyZXN0b3JlIiwicGlwZUhlaWdodCIsInJhbmRvbSIsInB1c2giLCJzY29yZWQiLCJmaWx0ZXIiLCJiaXJkTGVmdCIsImJpcmRSaWdodCIsImJpcmRUb3AiLCJiaXJkQm90dG9tIiwid2l0aGluUGlwZVgiLCJ3aXRoaW5QaXBlWSIsImNvaW5MZWZ0IiwiY29pblJpZ2h0IiwiY29pblRvcCIsImNvaW5Cb3R0b20iLCJwcmV2U2NvcmUiLCJuZXdTY29yZSIsInByZXZIaWdoU2NvcmUiLCJtYXgiLCJ1cGRhdGVkSGlnaFNjb3JlIiwic2V0SXRlbSIsInRvU3RyaW5nIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwic3BhY2VFdmVudCIsIktleWJvYXJkRXZlbnQiLCJkaXNwYXRjaEV2ZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./public/useFlappyBirdGame.ts\n"));

/***/ })

});