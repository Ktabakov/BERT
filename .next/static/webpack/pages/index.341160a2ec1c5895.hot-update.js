"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./public/useFlappyBirdGame.ts":
/*!*************************************!*\
  !*** ./public/useFlappyBirdGame.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFlappyBirdGame: function() { return /* binding */ useFlappyBirdGame; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n// Constants\nconst GRAVITY = 0.25;\nconst FLAP = -7.5;\nconst PIPE_WIDTH = 90;\nconst PIPE_SPACING = 250;\nconst BIRD_WIDTH = 50;\nconst BIRD_HEIGHT = 50;\nconst COIN_SIZE = 100;\nconst ROTATION_SPEED = 0.005;\n// How often to spawn pipes in terms of frames\n// ~100 frames at ~60fps is ~1.66 seconds. Adjust as needed\nconst PIPE_SPAWN_FRAMES = 100;\nfunction useFlappyBirdGame(canvasRef, isPaused, autoStart) {\n    const requestIdRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    // State refs\n    const [highScore, setHighScore] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [currentScore, setCurrentScore] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const birdYRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const birdVelocityRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const pipesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const coinsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const gameOverRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const gameStartedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const coinRotationStepRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const framesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0); // Count frames\n    // Assets\n    let birdImage;\n    let pipeTop;\n    let pipeBottom;\n    let background;\n    let coinImage;\n    if (true) {\n        birdImage = new Image();\n        birdImage.src = \"/assets/flappybird.png\";\n        pipeTop = new Image();\n        pipeTop.src = \"/assets/top.png\";\n        pipeBottom = new Image();\n        pipeBottom.src = \"/assets/bottom.png\";\n        background = new Image();\n        background.src = \"/assets/flappybirdbg1.png\";\n        coinImage = new Image();\n        coinImage.src = \"/assets/Coin.png\";\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        function resetGame() {\n            const c = canvasRef.current;\n            if (!c) return;\n            const { width, height } = c;\n            birdYRef.current = height / 3;\n            birdVelocityRef.current = 0;\n            pipesRef.current = [];\n            coinsRef.current = [];\n            setCurrentScore(0);\n            gameOverRef.current = false;\n            gameStartedRef.current = false;\n            coinRotationStepRef.current = 0;\n            framesRef.current = 0;\n        }\n        function handleKeyDown(e) {\n            if (e.key === \" \") {\n                if (!gameStartedRef.current && !gameOverRef.current) {\n                    startGame();\n                } else if (gameOverRef.current) {\n                    startGame();\n                } else {\n                    birdVelocityRef.current = FLAP;\n                }\n            }\n        }\n        background.onload = ()=>{\n            console.log(\"Background image loaded!\");\n            const canvas = canvasRef.current;\n            if (canvas) {\n                const ctx = canvas.getContext(\"2d\");\n                if (ctx) initializeGame();\n            }\n        };\n        window.addEventListener(\"keydown\", handleKeyDown);\n        function handleResize() {\n            const c = canvasRef.current;\n            if (!c) return;\n            c.width = 360;\n            c.height = 640;\n            if (!gameStartedRef.current && !gameOverRef.current && ctx) {\n                drawStartScreen(ctx, c);\n            }\n        }\n        window.addEventListener(\"resize\", handleResize);\n        // Initialize the game\n        const initializeGame = ()=>{\n            canvas.width = 360;\n            canvas.height = 640;\n            drawStartScreen(ctx, canvas);\n        };\n        initializeGame();\n        function startGame() {\n            resetGame();\n            gameStartedRef.current = true;\n            animate(); // Start the loop\n        }\n        function animate() {\n            if (isPaused || !gameStartedRef.current) {\n                // If paused or not started, just request next frame without updating state\n                requestIdRef.current = requestAnimationFrame(animate);\n                return;\n            }\n            const c = canvasRef.current;\n            if (!c) return;\n            const context = c.getContext(\"2d\");\n            if (!context) return;\n            updateGameState(c);\n            draw(context, c);\n            if (!gameOverRef.current) {\n                requestIdRef.current = requestAnimationFrame(animate);\n            } else {\n                drawGameOverScreen(context, c);\n            }\n        }\n        function updateGameState(canvas) {\n            framesRef.current++;\n            // Gravity\n            birdVelocityRef.current += GRAVITY;\n            birdYRef.current += birdVelocityRef.current;\n            // Spawn pipes every PIPE_SPAWN_FRAMES frames\n            if (framesRef.current % PIPE_SPAWN_FRAMES === 0) {\n                createPipe(canvas);\n            }\n            movePipesAndCoins();\n            checkCoinCollection();\n            // Check collisions after movement\n            if (checkCollisions(canvas)) {\n                gameOverRef.current = true;\n                return;\n            }\n            updateScore();\n            // Rotate coin a bit each frame\n            coinRotationStepRef.current += ROTATION_SPEED;\n            if (coinRotationStepRef.current >= 1) coinRotationStepRef.current = 0;\n        }\n        function draw(ctx, canvas) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawBackground(ctx, canvas);\n            drawBird(ctx);\n            drawPipes(ctx);\n            drawCoins(ctx);\n        }\n        function drawStartScreen(ctx, canvas) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawBackground(ctx, canvas);\n            ctx.font = \"bold 30px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.shadowColor = \"black\";\n            ctx.textBaseline = \"middle\";\n            ctx.fillText(\"Press Space to Start\", canvas.width / 2, canvas.height / 2);\n        }\n        function drawGameOverScreen(ctx, canvas) {\n            ctx.fillStyle = \"#ffcc00\";\n            ctx.font = \"bold 50px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"middle\";\n            ctx.shadowColor = \"black\";\n            ctx.shadowBlur = 10;\n            ctx.fillText(\"Game Over!\", canvas.width / 2, canvas.height / 2 - 40);\n            ctx.fillStyle = \"#ffffff\";\n            ctx.font = \"bold 30px Arial\";\n            ctx.fillText(\"Press Space to Restart\", canvas.width / 2, canvas.height / 2 + 20);\n            ctx.fillStyle = \"#ffff00\";\n            ctx.font = \"30px Arial\";\n        }\n        function drawBackground(ctx, canvas) {\n            ctx.drawImage(background, 0, 0, canvas.width, canvas.height);\n        }\n        function drawBird(ctx) {\n            ctx.drawImage(birdImage, 100, birdYRef.current, BIRD_WIDTH, BIRD_HEIGHT);\n        }\n        function drawPipes(ctx) {\n            for (const pipe of pipesRef.current){\n                ctx.drawImage(pipeTop, pipe.x, 0, PIPE_WIDTH, pipe.topHeight);\n                ctx.drawImage(pipeBottom, pipe.x, pipe.bottomY, PIPE_WIDTH, pipe.bottomHeight);\n            }\n        }\n        function drawCoins(ctx) {\n            const scaleX = Math.abs(Math.cos(coinRotationStepRef.current * Math.PI * 2));\n            const halfSize = COIN_SIZE / 2;\n            for (const coin of coinsRef.current){\n                if (!coin.collected) {\n                    ctx.save();\n                    ctx.translate(coin.x + halfSize, coin.y + halfSize);\n                    ctx.scale(scaleX, 1);\n                    ctx.drawImage(coinImage, -halfSize, -halfSize, COIN_SIZE, COIN_SIZE);\n                    ctx.restore();\n                }\n            }\n        }\n        function createPipe(canvas) {\n            const pipeHeight = Math.random() * (canvas.height - PIPE_SPACING - 100) + 50;\n            const bottomY = pipeHeight + PIPE_SPACING;\n            pipesRef.current.push({\n                x: canvas.width,\n                topHeight: pipeHeight,\n                bottomY,\n                bottomHeight: canvas.height - bottomY,\n                scored: false\n            });\n            // 50% chance to spawn a coin\n            if (Math.random() > 0.5) {\n                coinsRef.current.push({\n                    x: canvas.width + PIPE_WIDTH / 2 - COIN_SIZE / 2,\n                    y: pipeHeight + PIPE_SPACING / 2 - COIN_SIZE / 2,\n                    width: COIN_SIZE,\n                    height: COIN_SIZE,\n                    collected: false\n                });\n            }\n        }\n        function movePipesAndCoins() {\n            for (const pipe of pipesRef.current){\n                pipe.x -= 2;\n            }\n            pipesRef.current = pipesRef.current.filter((pipe)=>pipe.x + PIPE_WIDTH > 0);\n            for (const coin of coinsRef.current){\n                coin.x -= 2;\n            }\n            coinsRef.current = coinsRef.current.filter((coin)=>coin.x + coin.width > 0 && !coin.collected);\n        }\n        function checkCollisions(canvas) {\n            if (birdYRef.current < 0 || birdYRef.current + BIRD_HEIGHT > canvas.height) {\n                return true;\n            }\n            const birdLeft = 100;\n            const birdRight = birdLeft + BIRD_WIDTH;\n            const birdTop = birdYRef.current;\n            const birdBottom = birdYRef.current + BIRD_HEIGHT;\n            for (const pipe of pipesRef.current){\n                const withinPipeX = birdRight > pipe.x && birdLeft < pipe.x + PIPE_WIDTH;\n                const withinPipeY = birdTop < pipe.topHeight || birdBottom > pipe.bottomY;\n                if (withinPipeX && withinPipeY) return true;\n            }\n            return false;\n        }\n        function checkCoinCollection() {\n            const birdLeft = 100;\n            const birdRight = birdLeft + BIRD_WIDTH;\n            const birdTop = birdYRef.current;\n            const birdBottom = birdYRef.current + BIRD_HEIGHT;\n            for (const coin of coinsRef.current){\n                if (!coin.collected) {\n                    const coinLeft = coin.x;\n                    const coinRight = coin.x + coin.width;\n                    const coinTop = coin.y;\n                    const coinBottom = coin.y + coin.height;\n                    if (birdRight > coinLeft && birdLeft < coinRight && birdBottom > coinTop && birdTop < coinBottom) {\n                        coin.collected = true;\n                        setCurrentScore((prevScore)=>{\n                            const newScore = prevScore + 5;\n                            setHighScore((prevHighScore)=>Math.max(prevHighScore, newScore));\n                            return newScore;\n                        });\n                    }\n                }\n            }\n        }\n        function updateScore() {\n            for (const pipe of pipesRef.current){\n                if (!pipe.scored && pipe.x + PIPE_WIDTH < 100) {\n                    setCurrentScore((prevScore)=>{\n                        const newScore = prevScore + 1;\n                        setHighScore((prevHighScore)=>Math.max(prevHighScore, newScore));\n                        return newScore;\n                    });\n                    pipe.scored = true;\n                }\n            }\n        }\n        return ()=>{\n            window.removeEventListener(\"keydown\", handleKeyDown);\n            window.removeEventListener(\"resize\", handleResize);\n            if (requestIdRef.current) {\n                cancelAnimationFrame(requestIdRef.current);\n            }\n        };\n    }, [\n        canvasRef,\n        isPaused,\n        autoStart\n    ]);\n    return {\n        highScore,\n        currentScore\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UUFDRjtJQUNGLEdBQUc7UUFBQ3hCO1FBQVdDO1FBQVVDO0tBQVU7SUFFbkMsT0FBTztRQUFFRTtRQUFXRTtJQUFhO0FBQ25DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3B1YmxpYy91c2VGbGFwcHlCaXJkR2FtZS50cz81Yzc4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xyXG5cclxuLy8gVHlwZXMgZm9yIGdhbWUgb2JqZWN0c1xyXG5pbnRlcmZhY2UgUGlwZSB7XHJcbiAgeDogbnVtYmVyO1xyXG4gIHRvcEhlaWdodDogbnVtYmVyO1xyXG4gIGJvdHRvbVk6IG51bWJlcjtcclxuICBib3R0b21IZWlnaHQ6IG51bWJlcjtcclxuICBzY29yZWQ6IGJvb2xlYW47XHJcbn1cclxuXHJcbmludGVyZmFjZSBDb2luIHtcclxuICB4OiBudW1iZXI7XHJcbiAgeTogbnVtYmVyO1xyXG4gIHdpZHRoOiBudW1iZXI7XHJcbiAgaGVpZ2h0OiBudW1iZXI7XHJcbiAgY29sbGVjdGVkOiBib29sZWFuO1xyXG59XHJcblxyXG4vLyBDb25zdGFudHNcclxuY29uc3QgR1JBVklUWSA9IDAuMjU7XHJcbmNvbnN0IEZMQVAgPSAtNy41O1xyXG5jb25zdCBQSVBFX1dJRFRIID0gOTA7XHJcbmNvbnN0IFBJUEVfU1BBQ0lORyA9IDI1MDtcclxuY29uc3QgQklSRF9XSURUSCA9IDUwO1xyXG5jb25zdCBCSVJEX0hFSUdIVCA9IDUwO1xyXG5jb25zdCBDT0lOX1NJWkUgPSAxMDA7XHJcbmNvbnN0IFJPVEFUSU9OX1NQRUVEID0gMC4wMDU7XHJcblxyXG4vLyBIb3cgb2Z0ZW4gdG8gc3Bhd24gcGlwZXMgaW4gdGVybXMgb2YgZnJhbWVzXHJcbi8vIH4xMDAgZnJhbWVzIGF0IH42MGZwcyBpcyB+MS42NiBzZWNvbmRzLiBBZGp1c3QgYXMgbmVlZGVkXHJcbmNvbnN0IFBJUEVfU1BBV05fRlJBTUVTID0gMTAwO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUZsYXBweUJpcmRHYW1lKGNhbnZhc1JlZjogUmVhY3QuUmVmT2JqZWN0PEhUTUxDYW52YXNFbGVtZW50PiwgaXNQYXVzZWQ6IGJvb2xlYW4sIGF1dG9TdGFydDogYm9vbGVhbikge1xyXG4gIGNvbnN0IHJlcXVlc3RJZFJlZiA9IHVzZVJlZjxudW1iZXI+KCk7XHJcbiAgXHJcbiAgLy8gU3RhdGUgcmVmc1xyXG4gIGNvbnN0IFtoaWdoU2NvcmUsIHNldEhpZ2hTY29yZV0gPSB1c2VTdGF0ZSgwKTtcclxuICBjb25zdCBbY3VycmVudFNjb3JlLCBzZXRDdXJyZW50U2NvcmVdID0gdXNlU3RhdGUoMCk7XHJcblxyXG4gIGNvbnN0IGJpcmRZUmVmID0gdXNlUmVmPG51bWJlcj4oMCk7XHJcbiAgY29uc3QgYmlyZFZlbG9jaXR5UmVmID0gdXNlUmVmPG51bWJlcj4oMCk7XHJcbiAgY29uc3QgcGlwZXNSZWYgPSB1c2VSZWY8UGlwZVtdPihbXSk7XHJcbiAgY29uc3QgY29pbnNSZWYgPSB1c2VSZWY8Q29pbltdPihbXSk7XHJcbiAgY29uc3QgZ2FtZU92ZXJSZWYgPSB1c2VSZWY8Ym9vbGVhbj4oZmFsc2UpO1xyXG4gIGNvbnN0IGdhbWVTdGFydGVkUmVmID0gdXNlUmVmPGJvb2xlYW4+KGZhbHNlKTtcclxuXHJcbiAgY29uc3QgY29pblJvdGF0aW9uU3RlcFJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xyXG4gIGNvbnN0IGZyYW1lc1JlZiA9IHVzZVJlZjxudW1iZXI+KDApOyAvLyBDb3VudCBmcmFtZXNcclxuXHJcbiAgLy8gQXNzZXRzXHJcbiAgbGV0IGJpcmRJbWFnZTogSFRNTEltYWdlRWxlbWVudDtcclxuICBsZXQgcGlwZVRvcDogSFRNTEltYWdlRWxlbWVudDtcclxuICBsZXQgcGlwZUJvdHRvbTogSFRNTEltYWdlRWxlbWVudDtcclxuICBsZXQgYmFja2dyb3VuZDogSFRNTEltYWdlRWxlbWVudDtcclxuICBsZXQgY29pbkltYWdlOiBIVE1MSW1hZ2VFbGVtZW50O1xyXG5cclxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgYmlyZEltYWdlID0gbmV3IEltYWdlKCk7XHJcbiAgICBiaXJkSW1hZ2Uuc3JjID0gXCIvYXNzZXRzL2ZsYXBweWJpcmQucG5nXCI7XHJcblxyXG4gICAgcGlwZVRvcCA9IG5ldyBJbWFnZSgpO1xyXG4gICAgcGlwZVRvcC5zcmMgPSBcIi9hc3NldHMvdG9wLnBuZ1wiO1xyXG5cclxuICAgIHBpcGVCb3R0b20gPSBuZXcgSW1hZ2UoKTtcclxuICAgIHBpcGVCb3R0b20uc3JjID0gXCIvYXNzZXRzL2JvdHRvbS5wbmdcIjtcclxuXHJcbiAgICBiYWNrZ3JvdW5kID0gbmV3IEltYWdlKCk7XHJcbiAgICBiYWNrZ3JvdW5kLnNyYyA9IFwiL2Fzc2V0cy9mbGFwcHliaXJkYmcxLnBuZ1wiO1xyXG5cclxuICAgIGNvaW5JbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG4gICAgY29pbkltYWdlLnNyYyA9IFwiL2Fzc2V0cy9Db2luLnBuZ1wiO1xyXG4gIH1cclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xyXG4gICAgaWYgKCFjYW52YXMpIHJldHVybjtcclxuXHJcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgaWYgKCFjdHgpIHJldHVybjtcclxuXHJcbiAgICBmdW5jdGlvbiByZXNldEdhbWUoKSB7XHJcbiAgICAgIGNvbnN0IGMgPSBjYW52YXNSZWYuY3VycmVudDtcclxuICAgICAgaWYgKCFjKSByZXR1cm47XHJcbiAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gYztcclxuXHJcbiAgICAgIGJpcmRZUmVmLmN1cnJlbnQgPSBoZWlnaHQgLyAzO1xyXG4gICAgICBiaXJkVmVsb2NpdHlSZWYuY3VycmVudCA9IDA7XHJcbiAgICAgIHBpcGVzUmVmLmN1cnJlbnQgPSBbXTtcclxuICAgICAgY29pbnNSZWYuY3VycmVudCA9IFtdO1xyXG4gICAgICBzZXRDdXJyZW50U2NvcmUoMCk7XHJcbiAgICAgIGdhbWVPdmVyUmVmLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgICAgZ2FtZVN0YXJ0ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xyXG4gICAgICBjb2luUm90YXRpb25TdGVwUmVmLmN1cnJlbnQgPSAwO1xyXG4gICAgICBmcmFtZXNSZWYuY3VycmVudCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlS2V5RG93bihlOiBLZXlib2FyZEV2ZW50KSB7XHJcbiAgICAgIGlmIChlLmtleSA9PT0gXCIgXCIpIHtcclxuICAgICAgICBpZiAoIWdhbWVTdGFydGVkUmVmLmN1cnJlbnQgJiYgIWdhbWVPdmVyUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgIHN0YXJ0R2FtZSgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZ2FtZU92ZXJSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgc3RhcnRHYW1lKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGJpcmRWZWxvY2l0eVJlZi5jdXJyZW50ID0gRkxBUDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBiYWNrZ3JvdW5kLm9ubG9hZCA9ICgpID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIkJhY2tncm91bmQgaW1hZ2UgbG9hZGVkIVwiKTtcclxuICAgICAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcclxuICAgICAgICBpZiAoY2FudmFzKSB7XHJcbiAgICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgICAgICAgaWYgKGN0eCkgaW5pdGlhbGl6ZUdhbWUoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGhhbmRsZUtleURvd24pO1xyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZVJlc2l6ZSgpIHtcclxuICAgICAgY29uc3QgYyA9IGNhbnZhc1JlZi5jdXJyZW50O1xyXG4gICAgICBpZiAoIWMpIHJldHVybjtcclxuICAgICAgYy53aWR0aCA9IDM2MDtcclxuICAgICAgYy5oZWlnaHQgPSA2NDA7XHJcblxyXG4gICAgICBpZiAoIWdhbWVTdGFydGVkUmVmLmN1cnJlbnQgJiYgIWdhbWVPdmVyUmVmLmN1cnJlbnQgJiYgY3R4KSB7XHJcbiAgICAgICAgZHJhd1N0YXJ0U2NyZWVuKGN0eCwgYyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGhhbmRsZVJlc2l6ZSk7XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgZ2FtZVxyXG4gICAgY29uc3QgaW5pdGlhbGl6ZUdhbWUgPSAoKSA9PiB7XHJcbiAgICAgICAgY2FudmFzLndpZHRoID0gMzYwO1xyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSA2NDA7XHJcbiAgICAgICAgZHJhd1N0YXJ0U2NyZWVuKGN0eCwgY2FudmFzKTtcclxuICAgIH07XHJcblxyXG4gICAgaW5pdGlhbGl6ZUdhbWUoKTtcclxuXHJcbiAgICBmdW5jdGlvbiBzdGFydEdhbWUoKSB7XHJcbiAgICAgIHJlc2V0R2FtZSgpO1xyXG4gICAgICBnYW1lU3RhcnRlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcclxuICAgICAgYW5pbWF0ZSgpOyAvLyBTdGFydCB0aGUgbG9vcFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFuaW1hdGUoKSB7XHJcbiAgICAgIGlmIChpc1BhdXNlZCB8fCAhZ2FtZVN0YXJ0ZWRSZWYuY3VycmVudCkge1xyXG4gICAgICAgIC8vIElmIHBhdXNlZCBvciBub3Qgc3RhcnRlZCwganVzdCByZXF1ZXN0IG5leHQgZnJhbWUgd2l0aG91dCB1cGRhdGluZyBzdGF0ZVxyXG4gICAgICAgIHJlcXVlc3RJZFJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgYyA9IGNhbnZhc1JlZi5jdXJyZW50O1xyXG4gICAgICBpZiAoIWMpIHJldHVybjtcclxuICAgICAgY29uc3QgY29udGV4dCA9IGMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgICBpZiAoIWNvbnRleHQpIHJldHVybjtcclxuXHJcbiAgICAgIHVwZGF0ZUdhbWVTdGF0ZShjKTtcclxuICAgICAgZHJhdyhjb250ZXh0LCBjKTtcclxuXHJcbiAgICAgIGlmICghZ2FtZU92ZXJSZWYuY3VycmVudCkge1xyXG4gICAgICAgIHJlcXVlc3RJZFJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRyYXdHYW1lT3ZlclNjcmVlbihjb250ZXh0LCBjKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZUdhbWVTdGF0ZShjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgIGZyYW1lc1JlZi5jdXJyZW50Kys7XHJcblxyXG4gICAgICAvLyBHcmF2aXR5XHJcbiAgICAgIGJpcmRWZWxvY2l0eVJlZi5jdXJyZW50ICs9IEdSQVZJVFk7XHJcbiAgICAgIGJpcmRZUmVmLmN1cnJlbnQgKz0gYmlyZFZlbG9jaXR5UmVmLmN1cnJlbnQ7XHJcblxyXG4gICAgICAvLyBTcGF3biBwaXBlcyBldmVyeSBQSVBFX1NQQVdOX0ZSQU1FUyBmcmFtZXNcclxuICAgICAgaWYgKGZyYW1lc1JlZi5jdXJyZW50ICUgUElQRV9TUEFXTl9GUkFNRVMgPT09IDApIHtcclxuICAgICAgICBjcmVhdGVQaXBlKGNhbnZhcyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG1vdmVQaXBlc0FuZENvaW5zKCk7XHJcbiAgICAgIGNoZWNrQ29pbkNvbGxlY3Rpb24oKTtcclxuXHJcbiAgICAgIC8vIENoZWNrIGNvbGxpc2lvbnMgYWZ0ZXIgbW92ZW1lbnRcclxuICAgICAgaWYgKGNoZWNrQ29sbGlzaW9ucyhjYW52YXMpKSB7XHJcbiAgICAgICAgZ2FtZU92ZXJSZWYuY3VycmVudCA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB1cGRhdGVTY29yZSgpO1xyXG5cclxuICAgICAgLy8gUm90YXRlIGNvaW4gYSBiaXQgZWFjaCBmcmFtZVxyXG4gICAgICBjb2luUm90YXRpb25TdGVwUmVmLmN1cnJlbnQgKz0gUk9UQVRJT05fU1BFRUQ7XHJcbiAgICAgIGlmIChjb2luUm90YXRpb25TdGVwUmVmLmN1cnJlbnQgPj0gMSkgY29pblJvdGF0aW9uU3RlcFJlZi5jdXJyZW50ID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3KGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICAgICAgZHJhd0JhY2tncm91bmQoY3R4LCBjYW52YXMpO1xyXG4gICAgICBkcmF3QmlyZChjdHgpO1xyXG4gICAgICBkcmF3UGlwZXMoY3R4KTtcclxuICAgICAgZHJhd0NvaW5zKGN0eCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd1N0YXJ0U2NyZWVuKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICAgICAgZHJhd0JhY2tncm91bmQoY3R4LCBjYW52YXMpO1xyXG4gICAgICBjdHguZm9udCA9IFwiYm9sZCAzMHB4IEFyaWFsXCI7XHJcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xyXG4gICAgICBjdHguc2hhZG93Q29sb3IgPSAnYmxhY2snO1xyXG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XHJcbiAgICAgIGN0eC5maWxsVGV4dChcIlByZXNzIFNwYWNlIHRvIFN0YXJ0XCIsIGNhbnZhcy53aWR0aCAvIDIsIGNhbnZhcy5oZWlnaHQgLyAyKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3R2FtZU92ZXJTY3JlZW4oY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcclxuICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjZmZjYzAwJztcclxuICAgICAgY3R4LmZvbnQgPSAnYm9sZCA1MHB4IEFyaWFsJztcclxuICAgICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xyXG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XHJcbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9ICdibGFjayc7XHJcbiAgICAgIGN0eC5zaGFkb3dCbHVyID0gMTA7XHJcblxyXG4gICAgICBjdHguZmlsbFRleHQoJ0dhbWUgT3ZlciEnLCBjYW52YXMud2lkdGggLyAyLCBjYW52YXMuaGVpZ2h0IC8gMiAtIDQwKTtcclxuXHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAnI2ZmZmZmZic7XHJcbiAgICAgIGN0eC5mb250ID0gJ2JvbGQgMzBweCBBcmlhbCc7XHJcbiAgICAgIGN0eC5maWxsVGV4dCgnUHJlc3MgU3BhY2UgdG8gUmVzdGFydCcsIGNhbnZhcy53aWR0aCAvIDIsIGNhbnZhcy5oZWlnaHQgLyAyICsgMjApO1xyXG5cclxuICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjZmZmZjAwJztcclxuICAgICAgY3R4LmZvbnQgPSAnMzBweCBBcmlhbCc7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd0JhY2tncm91bmQoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcclxuICAgICAgY3R4LmRyYXdJbWFnZShiYWNrZ3JvdW5kLCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdCaXJkKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XHJcbiAgICAgIGN0eC5kcmF3SW1hZ2UoYmlyZEltYWdlLCAxMDAsIGJpcmRZUmVmLmN1cnJlbnQsIEJJUkRfV0lEVEgsIEJJUkRfSEVJR0hUKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3UGlwZXMoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcclxuICAgICAgZm9yIChjb25zdCBwaXBlIG9mIHBpcGVzUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBjdHguZHJhd0ltYWdlKHBpcGVUb3AsIHBpcGUueCwgMCwgUElQRV9XSURUSCwgcGlwZS50b3BIZWlnaHQpO1xyXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UocGlwZUJvdHRvbSwgcGlwZS54LCBwaXBlLmJvdHRvbVksIFBJUEVfV0lEVEgsIHBpcGUuYm90dG9tSGVpZ2h0KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdDb2lucyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xyXG4gICAgICBjb25zdCBzY2FsZVggPSBNYXRoLmFicyhNYXRoLmNvcyhjb2luUm90YXRpb25TdGVwUmVmLmN1cnJlbnQgKiBNYXRoLlBJICogMikpO1xyXG4gICAgICBjb25zdCBoYWxmU2l6ZSA9IENPSU5fU0laRSAvIDI7XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGNvaW4gb2YgY29pbnNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGlmICghY29pbi5jb2xsZWN0ZWQpIHtcclxuICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICBjdHgudHJhbnNsYXRlKGNvaW4ueCArIGhhbGZTaXplLCBjb2luLnkgKyBoYWxmU2l6ZSk7XHJcbiAgICAgICAgICBjdHguc2NhbGUoc2NhbGVYLCAxKTtcclxuICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoY29pbkltYWdlLCAtaGFsZlNpemUsIC1oYWxmU2l6ZSwgQ09JTl9TSVpFLCBDT0lOX1NJWkUpO1xyXG4gICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVQaXBlKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcclxuICAgICAgY29uc3QgcGlwZUhlaWdodCA9IE1hdGgucmFuZG9tKCkgKiAoY2FudmFzLmhlaWdodCAtIFBJUEVfU1BBQ0lORyAtIDEwMCkgKyA1MDtcclxuICAgICAgY29uc3QgYm90dG9tWSA9IHBpcGVIZWlnaHQgKyBQSVBFX1NQQUNJTkc7XHJcbiAgICAgIHBpcGVzUmVmLmN1cnJlbnQucHVzaCh7XHJcbiAgICAgICAgeDogY2FudmFzLndpZHRoLFxyXG4gICAgICAgIHRvcEhlaWdodDogcGlwZUhlaWdodCxcclxuICAgICAgICBib3R0b21ZLFxyXG4gICAgICAgIGJvdHRvbUhlaWdodDogY2FudmFzLmhlaWdodCAtIGJvdHRvbVksXHJcbiAgICAgICAgc2NvcmVkOiBmYWxzZVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIDUwJSBjaGFuY2UgdG8gc3Bhd24gYSBjb2luXHJcbiAgICAgIGlmIChNYXRoLnJhbmRvbSgpID4gMC41KSB7XHJcbiAgICAgICAgY29pbnNSZWYuY3VycmVudC5wdXNoKHtcclxuICAgICAgICAgIHg6IGNhbnZhcy53aWR0aCArIFBJUEVfV0lEVEggLyAyIC0gQ09JTl9TSVpFIC8gMixcclxuICAgICAgICAgIHk6IHBpcGVIZWlnaHQgKyBQSVBFX1NQQUNJTkcgLyAyIC0gQ09JTl9TSVpFIC8gMixcclxuICAgICAgICAgIHdpZHRoOiBDT0lOX1NJWkUsXHJcbiAgICAgICAgICBoZWlnaHQ6IENPSU5fU0laRSxcclxuICAgICAgICAgIGNvbGxlY3RlZDogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1vdmVQaXBlc0FuZENvaW5zKCkge1xyXG4gICAgICBmb3IgKGNvbnN0IHBpcGUgb2YgcGlwZXNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIHBpcGUueCAtPSAyO1xyXG4gICAgICB9XHJcbiAgICAgIHBpcGVzUmVmLmN1cnJlbnQgPSBwaXBlc1JlZi5jdXJyZW50LmZpbHRlcihwaXBlID0+IHBpcGUueCArIFBJUEVfV0lEVEggPiAwKTtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgY29pbiBvZiBjb2luc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY29pbi54IC09IDI7XHJcbiAgICAgIH1cclxuICAgICAgY29pbnNSZWYuY3VycmVudCA9IGNvaW5zUmVmLmN1cnJlbnQuZmlsdGVyKGNvaW4gPT4gY29pbi54ICsgY29pbi53aWR0aCA+IDAgJiYgIWNvaW4uY29sbGVjdGVkKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjaGVja0NvbGxpc2lvbnMoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCk6IGJvb2xlYW4ge1xyXG4gICAgICBpZiAoYmlyZFlSZWYuY3VycmVudCA8IDAgfHwgYmlyZFlSZWYuY3VycmVudCArIEJJUkRfSEVJR0hUID4gY2FudmFzLmhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBiaXJkTGVmdCA9IDEwMDtcclxuICAgICAgY29uc3QgYmlyZFJpZ2h0ID0gYmlyZExlZnQgKyBCSVJEX1dJRFRIO1xyXG4gICAgICBjb25zdCBiaXJkVG9wID0gYmlyZFlSZWYuY3VycmVudDtcclxuICAgICAgY29uc3QgYmlyZEJvdHRvbSA9IGJpcmRZUmVmLmN1cnJlbnQgKyBCSVJEX0hFSUdIVDtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgcGlwZSBvZiBwaXBlc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY29uc3Qgd2l0aGluUGlwZVggPSBiaXJkUmlnaHQgPiBwaXBlLnggJiYgYmlyZExlZnQgPCBwaXBlLnggKyBQSVBFX1dJRFRIO1xyXG4gICAgICAgIGNvbnN0IHdpdGhpblBpcGVZID0gYmlyZFRvcCA8IHBpcGUudG9wSGVpZ2h0IHx8IGJpcmRCb3R0b20gPiBwaXBlLmJvdHRvbVk7XHJcbiAgICAgICAgaWYgKHdpdGhpblBpcGVYICYmIHdpdGhpblBpcGVZKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNoZWNrQ29pbkNvbGxlY3Rpb24oKSB7XHJcbiAgICAgIGNvbnN0IGJpcmRMZWZ0ID0gMTAwO1xyXG4gICAgICBjb25zdCBiaXJkUmlnaHQgPSBiaXJkTGVmdCArIEJJUkRfV0lEVEg7XHJcbiAgICAgIGNvbnN0IGJpcmRUb3AgPSBiaXJkWVJlZi5jdXJyZW50O1xyXG4gICAgICBjb25zdCBiaXJkQm90dG9tID0gYmlyZFlSZWYuY3VycmVudCArIEJJUkRfSEVJR0hUO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBjb2luIG9mIGNvaW5zUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBpZiAoIWNvaW4uY29sbGVjdGVkKSB7XHJcbiAgICAgICAgICBjb25zdCBjb2luTGVmdCA9IGNvaW4ueDtcclxuICAgICAgICAgIGNvbnN0IGNvaW5SaWdodCA9IGNvaW4ueCArIGNvaW4ud2lkdGg7XHJcbiAgICAgICAgICBjb25zdCBjb2luVG9wID0gY29pbi55O1xyXG4gICAgICAgICAgY29uc3QgY29pbkJvdHRvbSA9IGNvaW4ueSArIGNvaW4uaGVpZ2h0O1xyXG5cclxuICAgICAgICAgIGlmIChiaXJkUmlnaHQgPiBjb2luTGVmdCAmJiBiaXJkTGVmdCA8IGNvaW5SaWdodCAmJiBiaXJkQm90dG9tID4gY29pblRvcCAmJiBiaXJkVG9wIDwgY29pbkJvdHRvbSkge1xyXG4gICAgICAgICAgICBjb2luLmNvbGxlY3RlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHNldEN1cnJlbnRTY29yZSgocHJldlNjb3JlKSA9PiB7XHJcbiAgICAgICAgICAgICAgY29uc3QgbmV3U2NvcmUgPSBwcmV2U2NvcmUgKyA1OyAgICAgIFxyXG4gICAgICAgICAgICAgIHNldEhpZ2hTY29yZSgocHJldkhpZ2hTY29yZSkgPT4gTWF0aC5tYXgocHJldkhpZ2hTY29yZSwgbmV3U2NvcmUpKTsgICAgICAgXHJcbiAgICAgICAgICAgICAgcmV0dXJuIG5ld1Njb3JlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVTY29yZSgpIHtcclxuICAgICAgZm9yIChjb25zdCBwaXBlIG9mIHBpcGVzUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBpZiAoIXBpcGUuc2NvcmVkICYmIHBpcGUueCArIFBJUEVfV0lEVEggPCAxMDApIHtcclxuICAgICAgICAgIHNldEN1cnJlbnRTY29yZSgocHJldlNjb3JlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1Njb3JlID0gcHJldlNjb3JlICsgMTsgICAgICBcclxuICAgICAgICAgICAgc2V0SGlnaFNjb3JlKChwcmV2SGlnaFNjb3JlKSA9PiBNYXRoLm1heChwcmV2SGlnaFNjb3JlLCBuZXdTY29yZSkpOyAgICAgICBcclxuICAgICAgICAgICAgcmV0dXJuIG5ld1Njb3JlO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBwaXBlLnNjb3JlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGhhbmRsZUtleURvd24pO1xyXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBoYW5kbGVSZXNpemUpO1xyXG4gICAgICBpZiAocmVxdWVzdElkUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyZXF1ZXN0SWRSZWYuY3VycmVudCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfSwgW2NhbnZhc1JlZiwgaXNQYXVzZWQsIGF1dG9TdGFydF0pO1xyXG5cclxuICByZXR1cm4geyBoaWdoU2NvcmUsIGN1cnJlbnRTY29yZSB9O1xyXG59XHJcbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsIkdSQVZJVFkiLCJGTEFQIiwiUElQRV9XSURUSCIsIlBJUEVfU1BBQ0lORyIsIkJJUkRfV0lEVEgiLCJCSVJEX0hFSUdIVCIsIkNPSU5fU0laRSIsIlJPVEFUSU9OX1NQRUVEIiwiUElQRV9TUEFXTl9GUkFNRVMiLCJ1c2VGbGFwcHlCaXJkR2FtZSIsImNhbnZhc1JlZiIsImlzUGF1c2VkIiwiYXV0b1N0YXJ0IiwicmVxdWVzdElkUmVmIiwiaGlnaFNjb3JlIiwic2V0SGlnaFNjb3JlIiwiY3VycmVudFNjb3JlIiwic2V0Q3VycmVudFNjb3JlIiwiYmlyZFlSZWYiLCJiaXJkVmVsb2NpdHlSZWYiLCJwaXBlc1JlZiIsImNvaW5zUmVmIiwiZ2FtZU92ZXJSZWYiLCJnYW1lU3RhcnRlZFJlZiIsImNvaW5Sb3RhdGlvblN0ZXBSZWYiLCJmcmFtZXNSZWYiLCJiaXJkSW1hZ2UiLCJwaXBlVG9wIiwicGlwZUJvdHRvbSIsImJhY2tncm91bmQiLCJjb2luSW1hZ2UiLCJJbWFnZSIsInNyYyIsImNhbnZhcyIsImN1cnJlbnQiLCJjdHgiLCJnZXRDb250ZXh0IiwicmVzZXRHYW1lIiwiYyIsIndpZHRoIiwiaGVpZ2h0IiwiaGFuZGxlS2V5RG93biIsImUiLCJrZXkiLCJzdGFydEdhbWUiLCJvbmxvYWQiLCJjb25zb2xlIiwibG9nIiwiaW5pdGlhbGl6ZUdhbWUiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwiaGFuZGxlUmVzaXplIiwiZHJhd1N0YXJ0U2NyZWVuIiwiYW5pbWF0ZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNvbnRleHQiLCJ1cGRhdGVHYW1lU3RhdGUiLCJkcmF3IiwiZHJhd0dhbWVPdmVyU2NyZWVuIiwiY3JlYXRlUGlwZSIsIm1vdmVQaXBlc0FuZENvaW5zIiwiY2hlY2tDb2luQ29sbGVjdGlvbiIsImNoZWNrQ29sbGlzaW9ucyIsInVwZGF0ZVNjb3JlIiwiY2xlYXJSZWN0IiwiZHJhd0JhY2tncm91bmQiLCJkcmF3QmlyZCIsImRyYXdQaXBlcyIsImRyYXdDb2lucyIsImZvbnQiLCJ0ZXh0QWxpZ24iLCJzaGFkb3dDb2xvciIsInRleHRCYXNlbGluZSIsImZpbGxUZXh0IiwiZmlsbFN0eWxlIiwic2hhZG93Qmx1ciIsImRyYXdJbWFnZSIsInBpcGUiLCJ4IiwidG9wSGVpZ2h0IiwiYm90dG9tWSIsImJvdHRvbUhlaWdodCIsInNjYWxlWCIsIk1hdGgiLCJhYnMiLCJjb3MiLCJQSSIsImhhbGZTaXplIiwiY29pbiIsImNvbGxlY3RlZCIsInNhdmUiLCJ0cmFuc2xhdGUiLCJ5Iiwic2NhbGUiLCJyZXN0b3JlIiwicGlwZUhlaWdodCIsInJhbmRvbSIsInB1c2giLCJzY29yZWQiLCJmaWx0ZXIiLCJiaXJkTGVmdCIsImJpcmRSaWdodCIsImJpcmRUb3AiLCJiaXJkQm90dG9tIiwid2l0aGluUGlwZVgiLCJ3aXRoaW5QaXBlWSIsImNvaW5MZWZ0IiwiY29pblJpZ2h0IiwiY29pblRvcCIsImNvaW5Cb3R0b20iLCJwcmV2U2NvcmUiLCJuZXdTY29yZSIsInByZXZIaWdoU2NvcmUiLCJtYXgiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./public/useFlappyBirdGame.ts\n"));

/***/ })

});