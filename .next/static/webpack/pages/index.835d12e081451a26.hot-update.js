"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./public/useFlappyBirdGame.ts":
/*!*************************************!*\
  !*** ./public/useFlappyBirdGame.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFlappyBirdGame: function() { return /* binding */ useFlappyBirdGame; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n// useFlappyBirdGame.ts\n\n// Constants\nconst GRAVITY = 800; // pixels per second squared\nconst FLAP_VELOCITY = -450; // pixels per second\nconst PIPE_SPEED = 200; // pixels per second\nconst PIPE_SPAWN_INTERVAL = 1500; // milliseconds\nconst PIPE_WIDTH = 90;\nconst PIPE_GAP = 200; // Vertical gap between pipes\nconst BIRD_X = 100; // Fixed X position\nconst BIRD_WIDTH = 50;\nconst BIRD_HEIGHT = 50;\nconst COIN_SPEED = 200; // pixels per second\nconst COIN_SPAWN_CHANCE = 0.25; // 25%\nconst COIN_SIZE = 80;\nconst ROTATION_SPEED = 2 * Math.PI; // radians per second (full rotation per second)\n/**\r\n * Custom hook to manage Flappy Bird game logic.\r\n * @param canvasRef Reference to the canvas element.\r\n * @param isPaused Boolean indicating if the game is paused.\r\n * @param autoStart Boolean indicating if the game should start automatically.\r\n * @returns High score, current score, and a handler for user input.\r\n */ function useFlappyBirdGame(canvasRef, isPaused, autoStart) {\n    // State\n    const [highScore, setHighScore] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [currentScore, setCurrentScore] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    // Refs to track game state\n    const birdYRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const birdVelocityRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const pipesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const coinsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const gameOverRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const gameStartedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // Rotation angle for coins\n    const coinRotationRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // Time tracking\n    const lastTimeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const pipeSpawnTimerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // Request ID for animation frame\n    const requestIdRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // Asset images\n    const birdImagesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const pipeTopImgRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const pipeBottomImgRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const backgroundImgRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const coinImgRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // Current bird frame index for flap animation\n    const currentBirdFrameRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(1); // Start with mid-flap\n    // Load high score from localStorage on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (true) {\n            const storedHighScore = localStorage.getItem(\"highScore\");\n            if (storedHighScore) {\n                setHighScore(parseInt(storedHighScore, 10));\n            }\n        }\n    }, []);\n    // Initialize game and load assets\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (false) {}\n        // Initialize bird images\n        const birdUp = new Image();\n        birdUp.src = \"/assets/redbird-upflap.png\";\n        const birdMid = new Image();\n        birdMid.src = \"/assets/redbird-midflap.png\";\n        const birdDown = new Image();\n        birdDown.src = \"/assets/redbird-downflap.png\";\n        birdImagesRef.current = [\n            birdUp,\n            birdMid,\n            birdDown\n        ];\n        // Initialize pipe images\n        const pipeTopImg = new Image();\n        pipeTopImg.src = \"/assets/TopTiny.png\";\n        pipeTopImgRef.current = pipeTopImg;\n        const pipeBottomImg = new Image();\n        pipeBottomImg.src = \"/assets/BottomTiny.png\";\n        pipeBottomImgRef.current = pipeBottomImg;\n        // Initialize background and coin images\n        const backgroundImg = new Image();\n        backgroundImg.src = \"/assets/background-day.png\";\n        backgroundImgRef.current = backgroundImg;\n        const coinImg = new Image();\n        coinImg.src = \"/assets/CoinTiny.png\";\n        coinImgRef.current = coinImg;\n        // Helper function to load an image fully\n        const loadImage = (img)=>{\n            return new Promise((resolve, reject)=>{\n                if (img.complete) {\n                    resolve();\n                } else {\n                    img.onload = ()=>resolve();\n                    img.onerror = ()=>reject(new Error(\"Failed to load image: \".concat(img.src)));\n                }\n            });\n        };\n        // Load all assets then initialize the game\n        const loadAssets = async ()=>{\n            try {\n                await Promise.all([\n                    ...birdImagesRef.current.map((img)=>loadImage(img)),\n                    pipeTopImgRef.current ? loadImage(pipeTopImgRef.current) : Promise.resolve(),\n                    pipeBottomImgRef.current ? loadImage(pipeBottomImgRef.current) : Promise.resolve(),\n                    backgroundImgRef.current ? loadImage(backgroundImgRef.current) : Promise.resolve(),\n                    coinImgRef.current ? loadImage(coinImgRef.current) : Promise.resolve()\n                ]);\n                console.log(\"All assets loaded successfully!\");\n                initializeGame();\n                if (autoStart) {\n                    startGame();\n                }\n            } catch (error) {\n                console.error(\"Error loading assets:\", error);\n            }\n        };\n        loadAssets();\n        // Cleanup function\n        return ()=>{\n            if (requestIdRef.current) {\n                cancelAnimationFrame(requestIdRef.current);\n            }\n        };\n    }, [\n        autoStart,\n        initializeGame,\n        startGame\n    ]);\n    // Function to initialize the game\n    const initializeGame = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        // Set canvas dimensions\n        canvas.width = 360;\n        canvas.height = 640;\n        // Draw start screen\n        drawStartScreen(ctx, canvas);\n    }, [\n        canvasRef\n    ]);\n    // Function to reset game state\n    const resetGame = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const { height } = canvas;\n        birdYRef.current = height / 3;\n        birdVelocityRef.current = 0;\n        pipesRef.current = [];\n        coinsRef.current = [];\n        setCurrentScore(0);\n        gameOverRef.current = false;\n        gameStartedRef.current = false;\n        coinRotationRef.current = 0;\n        lastTimeRef.current = 0;\n        pipeSpawnTimerRef.current = 0;\n        currentBirdFrameRef.current = 1; // mid-flap\n    }, [\n        canvasRef\n    ]);\n    // Function to start the game\n    const startGame = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        resetGame();\n        gameStartedRef.current = true;\n        lastTimeRef.current = performance.now();\n        requestIdRef.current = requestAnimationFrame(animate);\n    }, [\n        resetGame,\n        animate\n    ]);\n    // Function to handle user input\n    const handleUserInput = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (!gameStartedRef.current && !gameOverRef.current) {\n            startGame();\n        } else if (gameOverRef.current) {\n            startGame();\n        } else {\n            birdVelocityRef.current = FLAP_VELOCITY;\n            flapAnimation();\n        }\n    }, [\n        startGame,\n        flapAnimation\n    ]);\n    // Function to handle keydown events\n    const handleKeyDown = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        if (e.key === \" \") {\n            handleUserInput();\n        }\n    }, [\n        handleUserInput\n    ]);\n    // Add keydown event listener\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        window.addEventListener(\"keydown\", handleKeyDown);\n        return ()=>window.removeEventListener(\"keydown\", handleKeyDown);\n    }, [\n        handleKeyDown\n    ]);\n    // Flap animation\n    const flapAnimation = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const flapFrames = [\n            0,\n            1,\n            2,\n            1\n        ];\n        let currentFrame = 0;\n        const flapInterval = 100; // milliseconds between frames\n        const flap = ()=>{\n            if (currentFrame < flapFrames.length) {\n                currentBirdFrameRef.current = flapFrames[currentFrame];\n                currentFrame++;\n                setTimeout(flap, flapInterval);\n            } else {\n                currentBirdFrameRef.current = 1; // reset to mid-flap\n            }\n        };\n        flap();\n    }, []);\n    /**\r\n   * The main game loop using requestAnimationFrame.\r\n   * @param timestamp Current timestamp\r\n   */ const animate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((timestamp)=>{\n        if (isPaused || !gameStartedRef.current) {\n            requestIdRef.current = requestAnimationFrame(animate);\n            return;\n        }\n        if (!lastTimeRef.current) {\n            lastTimeRef.current = timestamp;\n        }\n        let deltaTime = (timestamp - lastTimeRef.current) / 1000; // in seconds\n        // Cap deltaTime to 0.05 seconds to prevent big jumps\n        deltaTime = Math.min(deltaTime, 0.05);\n        lastTimeRef.current = timestamp;\n        // Update game state\n        updateGameState(deltaTime);\n        // Draw everything\n        const canvas = canvasRef.current;\n        if (canvas) {\n            const ctx = canvas.getContext(\"2d\");\n            if (ctx) {\n                draw(ctx, canvas);\n            }\n        }\n        if (!gameOverRef.current) {\n            requestIdRef.current = requestAnimationFrame(animate);\n        } else {\n            // Draw game over screen\n            const canvas = canvasRef.current;\n            if (canvas) {\n                const ctx = canvas.getContext(\"2d\");\n                if (ctx) {\n                    drawGameOverScreen(ctx, canvas);\n                }\n            }\n        }\n    }, [\n        isPaused,\n        updateGameState,\n        draw,\n        drawGameOverScreen\n    ]);\n    /**\r\n   * Update the game state based on elapsed time.\r\n   * @param deltaTime Time elapsed since last frame (in seconds)\r\n   */ const updateGameState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((deltaTime)=>{\n        // Apply gravity to the bird\n        birdVelocityRef.current += GRAVITY * deltaTime;\n        birdYRef.current += birdVelocityRef.current * deltaTime;\n        // Update pipe spawn timer and spawn pipes at intervals\n        pipeSpawnTimerRef.current += deltaTime;\n        if (pipeSpawnTimerRef.current > PIPE_SPAWN_INTERVAL / 1000) {\n            createPipe();\n            pipeSpawnTimerRef.current = 0;\n        }\n        // Move pipes based on PIPE_SPEED and deltaTime\n        const pipeMoveDelta = PIPE_SPEED * deltaTime;\n        pipesRef.current = pipesRef.current.map((pipe)=>({\n                ...pipe,\n                x: pipe.x - pipeMoveDelta\n            }));\n        // Remove offscreen pipes\n        pipesRef.current = pipesRef.current.filter((pipe)=>pipe.x + PIPE_WIDTH > 0);\n        // Move coins based on COIN_SPEED and deltaTime\n        const coinMoveDelta = COIN_SPEED * deltaTime;\n        coinsRef.current = coinsRef.current.map((coin)=>({\n                ...coin,\n                x: coin.x - coinMoveDelta\n            }));\n        // Remove offscreen or collected coins\n        coinsRef.current = coinsRef.current.filter((coin)=>coin.x + coin.width > 0 && !coin.collected);\n        // Rotate coins for visual effect\n        coinRotationRef.current += ROTATION_SPEED * deltaTime;\n        if (coinRotationRef.current >= 2 * Math.PI) {\n            coinRotationRef.current -= 2 * Math.PI;\n        }\n        // Check for collisions\n        if (checkCollisions()) {\n            gameOverRef.current = true;\n            return;\n        }\n        // Check if bird collects any coins\n        checkCoinCollection();\n        // Update the score based on pipe passing\n        updateScore();\n    }, [\n        createPipe,\n        checkCollisions,\n        checkCoinCollection,\n        updateScore\n    ]);\n    /**\r\n   * Render all game elements onto the canvas.\r\n   * @param ctx CanvasRenderingContext2D\r\n   * @param canvas Canvas element\r\n   */ const draw = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((ctx, canvas)=>{\n        var _backgroundImgRef_current;\n        // Clear the canvas\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        // Draw background\n        if ((_backgroundImgRef_current = backgroundImgRef.current) === null || _backgroundImgRef_current === void 0 ? void 0 : _backgroundImgRef_current.complete) {\n            ctx.drawImage(backgroundImgRef.current, 0, 0, canvas.width, canvas.height);\n        }\n        // Draw pipes\n        for (const pipe of pipesRef.current){\n            var _pipeTopImgRef_current, _pipeBottomImgRef_current;\n            // Top pipe\n            if ((_pipeTopImgRef_current = pipeTopImgRef.current) === null || _pipeTopImgRef_current === void 0 ? void 0 : _pipeTopImgRef_current.complete) {\n                ctx.drawImage(pipeTopImgRef.current, pipe.x, 0, PIPE_WIDTH, pipe.gapY);\n            }\n            // Bottom pipe\n            if ((_pipeBottomImgRef_current = pipeBottomImgRef.current) === null || _pipeBottomImgRef_current === void 0 ? void 0 : _pipeBottomImgRef_current.complete) {\n                ctx.drawImage(pipeBottomImgRef.current, pipe.x, pipe.gapY + PIPE_GAP, PIPE_WIDTH, canvas.height - (pipe.gapY + PIPE_GAP));\n            }\n        }\n        // Draw coins\n        for (const coin of coinsRef.current){\n            var _coinImgRef_current;\n            if (!coin.collected && ((_coinImgRef_current = coinImgRef.current) === null || _coinImgRef_current === void 0 ? void 0 : _coinImgRef_current.complete)) {\n                ctx.save();\n                ctx.translate(coin.x + coin.width / 2, coin.y + coin.height / 2);\n                ctx.rotate(coinRotationRef.current);\n                ctx.drawImage(coinImgRef.current, -coin.width / 2, -coin.height / 2, coin.width, coin.height);\n                ctx.restore();\n            }\n        }\n        // Draw bird\n        const currentBirdFrame = birdImagesRef.current[currentBirdFrameRef.current];\n        if (currentBirdFrame === null || currentBirdFrame === void 0 ? void 0 : currentBirdFrame.complete) {\n            ctx.drawImage(currentBirdFrame, BIRD_X, birdYRef.current, BIRD_WIDTH, BIRD_HEIGHT);\n        }\n    }, []);\n    /**\r\n   * Render the start screen.\r\n   * @param ctx CanvasRenderingContext2D\r\n   * @param canvas Canvas element\r\n   */ const drawStartScreen = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((ctx, canvas)=>{\n        var _backgroundImgRef_current;\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        // Draw background\n        if ((_backgroundImgRef_current = backgroundImgRef.current) === null || _backgroundImgRef_current === void 0 ? void 0 : _backgroundImgRef_current.complete) {\n            ctx.drawImage(backgroundImgRef.current, 0, 0, canvas.width, canvas.height);\n        }\n        // Draw start text\n        ctx.fillStyle = \"white\";\n        ctx.font = \"bold 30px Arial\";\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        ctx.fillText(\"Press Space or Tap to Start\", canvas.width / 2, canvas.height / 2);\n    }, []);\n    /**\r\n   * Render the game over screen.\r\n   * @param ctx CanvasRenderingContext2D\r\n   * @param canvas Canvas element\r\n   */ const drawGameOverScreen = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((ctx, canvas)=>{\n        // Draw semi-transparent overlay\n        ctx.fillStyle = \"rgba(0, 0, 0, 0.5)\";\n        ctx.fillRect(0, canvas.height / 2 - 100, canvas.width, 200);\n        // Draw Game Over text\n        ctx.fillStyle = \"#ffcc00\";\n        ctx.font = \"bold 50px Arial\";\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        ctx.fillText(\"Game Over!\", canvas.width / 2, canvas.height / 2 - 40);\n        // Draw restart prompt\n        ctx.fillStyle = \"white\";\n        ctx.font = \"bold 30px Arial\";\n        ctx.fillText(\"Press Space or Tap to Restart\", canvas.width / 2, canvas.height / 2 + 20);\n    }, []);\n    /**\r\n   * Create a new pipe with a random gap position and possibly spawn a coin.\r\n   */ const createPipe = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const gapY = Math.random() * (canvas.height - PIPE_GAP - 200) + 100; // Ensure gap is not too close to top or bottom\n        pipesRef.current.push({\n            x: canvas.width,\n            gapY,\n            scored: false\n        });\n        // 25% chance to spawn a coin\n        if (Math.random() < COIN_SPAWN_CHANCE) {\n            coinsRef.current.push({\n                x: canvas.width + PIPE_WIDTH / 2 - COIN_SIZE / 2,\n                y: gapY + PIPE_GAP / 2 - COIN_SIZE / 2,\n                width: COIN_SIZE,\n                height: COIN_SIZE,\n                collected: false\n            });\n        }\n    }, []);\n    /**\r\n   * Check for collisions between the bird and pipes or boundaries.\r\n   * @returns Boolean indicating if a collision occurred\r\n   */ const checkCollisions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        // Assuming canvas height is fixed at 640\n        if (birdYRef.current < 0 || birdYRef.current + BIRD_HEIGHT > 640) {\n            return true;\n        }\n        const birdLeft = BIRD_X;\n        const birdRight = BIRD_X + BIRD_WIDTH;\n        const birdTop = birdYRef.current;\n        const birdBottom = birdYRef.current + BIRD_HEIGHT;\n        // Check collision with each pipe\n        for (const pipe of pipesRef.current){\n            const pipeLeft = pipe.x;\n            const pipeRight = pipe.x + PIPE_WIDTH;\n            // If bird is within pipe's horizontal bounds\n            if (birdRight > pipeLeft && birdLeft < pipeRight) {\n                // Check if bird is within the gap\n                if (birdTop < pipe.gapY || birdBottom > pipe.gapY + PIPE_GAP) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }, []);\n    /**\r\n   * Check if the bird has collected any coins.\r\n   */ const checkCoinCollection = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const birdLeft = BIRD_X;\n        const birdRight = BIRD_X + BIRD_WIDTH;\n        const birdTop = birdYRef.current;\n        const birdBottom = birdYRef.current + BIRD_HEIGHT;\n        for (const coin of coinsRef.current){\n            if (!coin.collected) {\n                const coinLeft = coin.x;\n                const coinRight = coin.x + coin.width;\n                const coinTop = coin.y;\n                const coinBottom = coin.y + coin.height;\n                if (birdRight > coinLeft && birdLeft < coinRight && birdBottom > coinTop && birdTop < coinBottom) {\n                    coin.collected = true;\n                    setCurrentScore((prevScore)=>{\n                        const newScore = prevScore + 5;\n                        setHighScore((prevHighScore)=>{\n                            const updatedHighScore = Math.max(prevHighScore, newScore);\n                            if (true) {\n                                localStorage.setItem(\"highScore\", updatedHighScore.toString());\n                            }\n                            return updatedHighScore;\n                        });\n                        return newScore;\n                    });\n                }\n            }\n        }\n    }, []);\n    /**\r\n   * Update the score when the bird passes a pipe.\r\n   */ const updateScore = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        for (const pipe of pipesRef.current){\n            // Score +1 for passing each pipe once\n            if (!pipe.scored && pipe.x + PIPE_WIDTH < BIRD_X) {\n                setCurrentScore((prevScore)=>{\n                    const newScore = prevScore + 1;\n                    setHighScore((prevHighScore)=>{\n                        const updatedHighScore = Math.max(prevHighScore, newScore);\n                        if (true) {\n                            localStorage.setItem(\"highScore\", updatedHighScore.toString());\n                        }\n                        return updatedHighScore;\n                    });\n                    return newScore;\n                });\n                pipe.scored = true;\n            }\n        }\n    }, []);\n    /**\r\n   * Cleanup on unmount.\r\n   */ (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>{\n            if (requestIdRef.current) {\n                cancelAnimationFrame(requestIdRef.current);\n            }\n        };\n    }, []);\n    return {\n        highScore,\n        currentScore,\n        handleUserInput\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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R0FFQyxHQUNELE1BQU05QixjQUFjakgsa0RBQVdBLENBQUM7UUFDOUIsS0FBSyxNQUFNeUcsUUFBUS9FLFNBQVN1QixPQUFPLENBQUU7WUFDbkMsc0NBQXNDO1lBQ3RDLElBQUksQ0FBQ3dELEtBQUswQixNQUFNLElBQUkxQixLQUFLQyxDQUFDLEdBQUdyRyxhQUFhRSxRQUFRO2dCQUNoRGdCLGdCQUFnQixDQUFDdUg7b0JBQ2YsTUFBTUMsV0FBV0QsWUFBWTtvQkFDN0J6SCxhQUFhLENBQUMySDt3QkFDWixNQUFNQyxtQkFBbUJuSSxLQUFLb0ksR0FBRyxDQUFDRixlQUFlRDt3QkFDakQsSUFBSSxJQUE2QixFQUFFOzRCQUNqQ3RHLGFBQWEwRyxPQUFPLENBQUMsYUFBYUYsaUJBQWlCRyxRQUFRO3dCQUM3RDt3QkFDQSxPQUFPSDtvQkFDVDtvQkFDQSxPQUFPRjtnQkFDVDtnQkFDQXRDLEtBQUswQixNQUFNLEdBQUc7WUFDaEI7UUFDRjtJQUNGLEdBQUcsRUFBRTtJQUVMOztHQUVDLEdBQ0R0SSxnREFBU0EsQ0FBQztRQUNSLE9BQU87WUFDTCxJQUFJb0MsYUFBYWdCLE9BQU8sRUFBRTtnQkFDeEJzQixxQkFBcUJ0QyxhQUFhZ0IsT0FBTztZQUMzQztRQUNGO0lBQ0YsR0FBRyxFQUFFO0lBRUwsT0FBTztRQUNMN0I7UUFDQUU7UUFDQTZEO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wdWJsaWMvdXNlRmxhcHB5QmlyZEdhbWUudHM/NWM3OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB1c2VGbGFwcHlCaXJkR2FtZS50c1xyXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSBcInJlYWN0XCI7XHJcblxyXG4vLyBUeXBlcyBmb3IgZ2FtZSBvYmplY3RzXHJcbmludGVyZmFjZSBQaXBlIHtcclxuICB4OiBudW1iZXI7XHJcbiAgZ2FwWTogbnVtYmVyO1xyXG4gIHNjb3JlZDogYm9vbGVhbjtcclxufVxyXG5cclxuaW50ZXJmYWNlIENvaW4ge1xyXG4gIHg6IG51bWJlcjtcclxuICB5OiBudW1iZXI7XHJcbiAgd2lkdGg6IG51bWJlcjtcclxuICBoZWlnaHQ6IG51bWJlcjtcclxuICBjb2xsZWN0ZWQ6IGJvb2xlYW47XHJcbn1cclxuXHJcbi8vIENvbnN0YW50c1xyXG5jb25zdCBHUkFWSVRZID0gODAwOyAvLyBwaXhlbHMgcGVyIHNlY29uZCBzcXVhcmVkXHJcbmNvbnN0IEZMQVBfVkVMT0NJVFkgPSAtNDUwOyAvLyBwaXhlbHMgcGVyIHNlY29uZFxyXG5jb25zdCBQSVBFX1NQRUVEID0gMjAwOyAvLyBwaXhlbHMgcGVyIHNlY29uZFxyXG5jb25zdCBQSVBFX1NQQVdOX0lOVEVSVkFMID0gMTUwMDsgLy8gbWlsbGlzZWNvbmRzXHJcbmNvbnN0IFBJUEVfV0lEVEggPSA5MDtcclxuY29uc3QgUElQRV9HQVAgPSAyMDA7IC8vIFZlcnRpY2FsIGdhcCBiZXR3ZWVuIHBpcGVzXHJcbmNvbnN0IEJJUkRfWCA9IDEwMDsgLy8gRml4ZWQgWCBwb3NpdGlvblxyXG5jb25zdCBCSVJEX1dJRFRIID0gNTA7XHJcbmNvbnN0IEJJUkRfSEVJR0hUID0gNTA7XHJcbmNvbnN0IENPSU5fU1BFRUQgPSAyMDA7IC8vIHBpeGVscyBwZXIgc2Vjb25kXHJcbmNvbnN0IENPSU5fU1BBV05fQ0hBTkNFID0gMC4yNTsgLy8gMjUlXHJcbmNvbnN0IENPSU5fU0laRSA9IDgwO1xyXG5jb25zdCBST1RBVElPTl9TUEVFRCA9IDIgKiBNYXRoLlBJOyAvLyByYWRpYW5zIHBlciBzZWNvbmQgKGZ1bGwgcm90YXRpb24gcGVyIHNlY29uZClcclxuXHJcbi8qKlxyXG4gKiBDdXN0b20gaG9vayB0byBtYW5hZ2UgRmxhcHB5IEJpcmQgZ2FtZSBsb2dpYy5cclxuICogQHBhcmFtIGNhbnZhc1JlZiBSZWZlcmVuY2UgdG8gdGhlIGNhbnZhcyBlbGVtZW50LlxyXG4gKiBAcGFyYW0gaXNQYXVzZWQgQm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBnYW1lIGlzIHBhdXNlZC5cclxuICogQHBhcmFtIGF1dG9TdGFydCBCb29sZWFuIGluZGljYXRpbmcgaWYgdGhlIGdhbWUgc2hvdWxkIHN0YXJ0IGF1dG9tYXRpY2FsbHkuXHJcbiAqIEByZXR1cm5zIEhpZ2ggc2NvcmUsIGN1cnJlbnQgc2NvcmUsIGFuZCBhIGhhbmRsZXIgZm9yIHVzZXIgaW5wdXQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlRmxhcHB5QmlyZEdhbWUoXHJcbiAgY2FudmFzUmVmOiBSZWFjdC5SZWZPYmplY3Q8SFRNTENhbnZhc0VsZW1lbnQ+LFxyXG4gIGlzUGF1c2VkOiBib29sZWFuLFxyXG4gIGF1dG9TdGFydDogYm9vbGVhblxyXG4pIHtcclxuICAvLyBTdGF0ZVxyXG4gIGNvbnN0IFtoaWdoU2NvcmUsIHNldEhpZ2hTY29yZV0gPSB1c2VTdGF0ZTxudW1iZXI+KDApO1xyXG4gIGNvbnN0IFtjdXJyZW50U2NvcmUsIHNldEN1cnJlbnRTY29yZV0gPSB1c2VTdGF0ZTxudW1iZXI+KDApO1xyXG5cclxuICAvLyBSZWZzIHRvIHRyYWNrIGdhbWUgc3RhdGVcclxuICBjb25zdCBiaXJkWVJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xyXG4gIGNvbnN0IGJpcmRWZWxvY2l0eVJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xyXG4gIGNvbnN0IHBpcGVzUmVmID0gdXNlUmVmPFBpcGVbXT4oW10pO1xyXG4gIGNvbnN0IGNvaW5zUmVmID0gdXNlUmVmPENvaW5bXT4oW10pO1xyXG4gIGNvbnN0IGdhbWVPdmVyUmVmID0gdXNlUmVmPGJvb2xlYW4+KGZhbHNlKTtcclxuICBjb25zdCBnYW1lU3RhcnRlZFJlZiA9IHVzZVJlZjxib29sZWFuPihmYWxzZSk7XHJcblxyXG4gIC8vIFJvdGF0aW9uIGFuZ2xlIGZvciBjb2luc1xyXG4gIGNvbnN0IGNvaW5Sb3RhdGlvblJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xyXG5cclxuICAvLyBUaW1lIHRyYWNraW5nXHJcbiAgY29uc3QgbGFzdFRpbWVSZWYgPSB1c2VSZWY8bnVtYmVyPigwKTtcclxuICBjb25zdCBwaXBlU3Bhd25UaW1lclJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xyXG5cclxuICAvLyBSZXF1ZXN0IElEIGZvciBhbmltYXRpb24gZnJhbWVcclxuICBjb25zdCByZXF1ZXN0SWRSZWYgPSB1c2VSZWY8bnVtYmVyIHwgbnVsbD4obnVsbCk7XHJcblxyXG4gIC8vIEFzc2V0IGltYWdlc1xyXG4gIGNvbnN0IGJpcmRJbWFnZXNSZWYgPSB1c2VSZWY8SFRNTEltYWdlRWxlbWVudFtdPihbXSk7XHJcbiAgY29uc3QgcGlwZVRvcEltZ1JlZiA9IHVzZVJlZjxIVE1MSW1hZ2VFbGVtZW50IHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgcGlwZUJvdHRvbUltZ1JlZiA9IHVzZVJlZjxIVE1MSW1hZ2VFbGVtZW50IHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgYmFja2dyb3VuZEltZ1JlZiA9IHVzZVJlZjxIVE1MSW1hZ2VFbGVtZW50IHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgY29pbkltZ1JlZiA9IHVzZVJlZjxIVE1MSW1hZ2VFbGVtZW50IHwgbnVsbD4obnVsbCk7XHJcblxyXG4gIC8vIEN1cnJlbnQgYmlyZCBmcmFtZSBpbmRleCBmb3IgZmxhcCBhbmltYXRpb25cclxuICBjb25zdCBjdXJyZW50QmlyZEZyYW1lUmVmID0gdXNlUmVmPG51bWJlcj4oMSk7IC8vIFN0YXJ0IHdpdGggbWlkLWZsYXBcclxuXHJcbiAgLy8gTG9hZCBoaWdoIHNjb3JlIGZyb20gbG9jYWxTdG9yYWdlIG9uIG1vdW50XHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgIGNvbnN0IHN0b3JlZEhpZ2hTY29yZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwiaGlnaFNjb3JlXCIpO1xyXG4gICAgICBpZiAoc3RvcmVkSGlnaFNjb3JlKSB7XHJcbiAgICAgICAgc2V0SGlnaFNjb3JlKHBhcnNlSW50KHN0b3JlZEhpZ2hTY29yZSwgMTApKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sIFtdKTtcclxuXHJcbiAgLy8gSW5pdGlhbGl6ZSBnYW1lIGFuZCBsb2FkIGFzc2V0c1xyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuO1xyXG5cclxuICAgIC8vIEluaXRpYWxpemUgYmlyZCBpbWFnZXNcclxuICAgIGNvbnN0IGJpcmRVcCA9IG5ldyBJbWFnZSgpO1xyXG4gICAgYmlyZFVwLnNyYyA9IFwiL2Fzc2V0cy9yZWRiaXJkLXVwZmxhcC5wbmdcIjtcclxuXHJcbiAgICBjb25zdCBiaXJkTWlkID0gbmV3IEltYWdlKCk7XHJcbiAgICBiaXJkTWlkLnNyYyA9IFwiL2Fzc2V0cy9yZWRiaXJkLW1pZGZsYXAucG5nXCI7XHJcblxyXG4gICAgY29uc3QgYmlyZERvd24gPSBuZXcgSW1hZ2UoKTtcclxuICAgIGJpcmREb3duLnNyYyA9IFwiL2Fzc2V0cy9yZWRiaXJkLWRvd25mbGFwLnBuZ1wiO1xyXG5cclxuICAgIGJpcmRJbWFnZXNSZWYuY3VycmVudCA9IFtiaXJkVXAsIGJpcmRNaWQsIGJpcmREb3duXTtcclxuXHJcbiAgICAvLyBJbml0aWFsaXplIHBpcGUgaW1hZ2VzXHJcbiAgICBjb25zdCBwaXBlVG9wSW1nID0gbmV3IEltYWdlKCk7XHJcbiAgICBwaXBlVG9wSW1nLnNyYyA9IFwiL2Fzc2V0cy9Ub3BUaW55LnBuZ1wiO1xyXG4gICAgcGlwZVRvcEltZ1JlZi5jdXJyZW50ID0gcGlwZVRvcEltZztcclxuXHJcbiAgICBjb25zdCBwaXBlQm90dG9tSW1nID0gbmV3IEltYWdlKCk7XHJcbiAgICBwaXBlQm90dG9tSW1nLnNyYyA9IFwiL2Fzc2V0cy9Cb3R0b21UaW55LnBuZ1wiO1xyXG4gICAgcGlwZUJvdHRvbUltZ1JlZi5jdXJyZW50ID0gcGlwZUJvdHRvbUltZztcclxuXHJcbiAgICAvLyBJbml0aWFsaXplIGJhY2tncm91bmQgYW5kIGNvaW4gaW1hZ2VzXHJcbiAgICBjb25zdCBiYWNrZ3JvdW5kSW1nID0gbmV3IEltYWdlKCk7XHJcbiAgICBiYWNrZ3JvdW5kSW1nLnNyYyA9IFwiL2Fzc2V0cy9iYWNrZ3JvdW5kLWRheS5wbmdcIjtcclxuICAgIGJhY2tncm91bmRJbWdSZWYuY3VycmVudCA9IGJhY2tncm91bmRJbWc7XHJcblxyXG4gICAgY29uc3QgY29pbkltZyA9IG5ldyBJbWFnZSgpO1xyXG4gICAgY29pbkltZy5zcmMgPSBcIi9hc3NldHMvQ29pblRpbnkucG5nXCI7XHJcbiAgICBjb2luSW1nUmVmLmN1cnJlbnQgPSBjb2luSW1nO1xyXG5cclxuICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBsb2FkIGFuIGltYWdlIGZ1bGx5XHJcbiAgICBjb25zdCBsb2FkSW1hZ2UgPSAoaW1nOiBIVE1MSW1hZ2VFbGVtZW50KTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgaWYgKGltZy5jb21wbGV0ZSkge1xyXG4gICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpbWcub25sb2FkID0gKCkgPT4gcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgaW1nLm9uZXJyb3IgPSAoKSA9PlxyXG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBpbWFnZTogJHtpbWcuc3JjfWApKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBMb2FkIGFsbCBhc3NldHMgdGhlbiBpbml0aWFsaXplIHRoZSBnYW1lXHJcbiAgICBjb25zdCBsb2FkQXNzZXRzID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgICAgICAgIC4uLmJpcmRJbWFnZXNSZWYuY3VycmVudC5tYXAoKGltZykgPT4gbG9hZEltYWdlKGltZykpLFxyXG4gICAgICAgICAgcGlwZVRvcEltZ1JlZi5jdXJyZW50ID8gbG9hZEltYWdlKHBpcGVUb3BJbWdSZWYuY3VycmVudCkgOiBQcm9taXNlLnJlc29sdmUoKSxcclxuICAgICAgICAgIHBpcGVCb3R0b21JbWdSZWYuY3VycmVudCA/IGxvYWRJbWFnZShwaXBlQm90dG9tSW1nUmVmLmN1cnJlbnQpIDogUHJvbWlzZS5yZXNvbHZlKCksXHJcbiAgICAgICAgICBiYWNrZ3JvdW5kSW1nUmVmLmN1cnJlbnQgPyBsb2FkSW1hZ2UoYmFja2dyb3VuZEltZ1JlZi5jdXJyZW50KSA6IFByb21pc2UucmVzb2x2ZSgpLFxyXG4gICAgICAgICAgY29pbkltZ1JlZi5jdXJyZW50ID8gbG9hZEltYWdlKGNvaW5JbWdSZWYuY3VycmVudCkgOiBQcm9taXNlLnJlc29sdmUoKSxcclxuICAgICAgICBdKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIkFsbCBhc3NldHMgbG9hZGVkIHN1Y2Nlc3NmdWxseSFcIik7XHJcbiAgICAgICAgaW5pdGlhbGl6ZUdhbWUoKTtcclxuICAgICAgICBpZiAoYXV0b1N0YXJ0KSB7XHJcbiAgICAgICAgICBzdGFydEdhbWUoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGxvYWRpbmcgYXNzZXRzOlwiLCBlcnJvcik7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgbG9hZEFzc2V0cygpO1xyXG5cclxuICAgIC8vIENsZWFudXAgZnVuY3Rpb25cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGlmIChyZXF1ZXN0SWRSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJlcXVlc3RJZFJlZi5jdXJyZW50KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9LCBbYXV0b1N0YXJ0LCBpbml0aWFsaXplR2FtZSwgc3RhcnRHYW1lXSk7XHJcblxyXG4gIC8vIEZ1bmN0aW9uIHRvIGluaXRpYWxpemUgdGhlIGdhbWVcclxuICBjb25zdCBpbml0aWFsaXplR2FtZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xyXG4gICAgaWYgKCFjYW52YXMpIHJldHVybjtcclxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICBpZiAoIWN0eCkgcmV0dXJuO1xyXG5cclxuICAgIC8vIFNldCBjYW52YXMgZGltZW5zaW9uc1xyXG4gICAgY2FudmFzLndpZHRoID0gMzYwO1xyXG4gICAgY2FudmFzLmhlaWdodCA9IDY0MDtcclxuXHJcbiAgICAvLyBEcmF3IHN0YXJ0IHNjcmVlblxyXG4gICAgZHJhd1N0YXJ0U2NyZWVuKGN0eCwgY2FudmFzKTtcclxuICB9LCBbY2FudmFzUmVmXSk7XHJcblxyXG4gIC8vIEZ1bmN0aW9uIHRvIHJlc2V0IGdhbWUgc3RhdGVcclxuICBjb25zdCByZXNldEdhbWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcclxuICAgIGlmICghY2FudmFzKSByZXR1cm47XHJcbiAgICBjb25zdCB7IGhlaWdodCB9ID0gY2FudmFzO1xyXG5cclxuICAgIGJpcmRZUmVmLmN1cnJlbnQgPSBoZWlnaHQgLyAzO1xyXG4gICAgYmlyZFZlbG9jaXR5UmVmLmN1cnJlbnQgPSAwO1xyXG4gICAgcGlwZXNSZWYuY3VycmVudCA9IFtdO1xyXG4gICAgY29pbnNSZWYuY3VycmVudCA9IFtdO1xyXG4gICAgc2V0Q3VycmVudFNjb3JlKDApO1xyXG4gICAgZ2FtZU92ZXJSZWYuY3VycmVudCA9IGZhbHNlO1xyXG4gICAgZ2FtZVN0YXJ0ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xyXG4gICAgY29pblJvdGF0aW9uUmVmLmN1cnJlbnQgPSAwO1xyXG4gICAgbGFzdFRpbWVSZWYuY3VycmVudCA9IDA7XHJcbiAgICBwaXBlU3Bhd25UaW1lclJlZi5jdXJyZW50ID0gMDtcclxuICAgIGN1cnJlbnRCaXJkRnJhbWVSZWYuY3VycmVudCA9IDE7IC8vIG1pZC1mbGFwXHJcbiAgfSwgW2NhbnZhc1JlZl0pO1xyXG5cclxuICAvLyBGdW5jdGlvbiB0byBzdGFydCB0aGUgZ2FtZVxyXG4gIGNvbnN0IHN0YXJ0R2FtZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgIHJlc2V0R2FtZSgpO1xyXG4gICAgZ2FtZVN0YXJ0ZWRSZWYuY3VycmVudCA9IHRydWU7XHJcbiAgICBsYXN0VGltZVJlZi5jdXJyZW50ID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICByZXF1ZXN0SWRSZWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcclxuICB9LCBbcmVzZXRHYW1lLCBhbmltYXRlXSk7XHJcblxyXG4gIC8vIEZ1bmN0aW9uIHRvIGhhbmRsZSB1c2VyIGlucHV0XHJcbiAgY29uc3QgaGFuZGxlVXNlcklucHV0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgaWYgKCFnYW1lU3RhcnRlZFJlZi5jdXJyZW50ICYmICFnYW1lT3ZlclJlZi5jdXJyZW50KSB7XHJcbiAgICAgIHN0YXJ0R2FtZSgpO1xyXG4gICAgfSBlbHNlIGlmIChnYW1lT3ZlclJlZi5jdXJyZW50KSB7XHJcbiAgICAgIHN0YXJ0R2FtZSgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYmlyZFZlbG9jaXR5UmVmLmN1cnJlbnQgPSBGTEFQX1ZFTE9DSVRZO1xyXG4gICAgICBmbGFwQW5pbWF0aW9uKCk7XHJcbiAgICB9XHJcbiAgfSwgW3N0YXJ0R2FtZSwgZmxhcEFuaW1hdGlvbl0pO1xyXG5cclxuICAvLyBGdW5jdGlvbiB0byBoYW5kbGUga2V5ZG93biBldmVudHNcclxuICBjb25zdCBoYW5kbGVLZXlEb3duID0gdXNlQ2FsbGJhY2soXHJcbiAgICAoZTogS2V5Ym9hcmRFdmVudCkgPT4ge1xyXG4gICAgICBpZiAoZS5rZXkgPT09IFwiIFwiKSB7XHJcbiAgICAgICAgaGFuZGxlVXNlcklucHV0KCk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBbaGFuZGxlVXNlcklucHV0XVxyXG4gICk7XHJcblxyXG4gIC8vIEFkZCBrZXlkb3duIGV2ZW50IGxpc3RlbmVyXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBoYW5kbGVLZXlEb3duKTtcclxuICAgIHJldHVybiAoKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgaGFuZGxlS2V5RG93bik7XHJcbiAgfSwgW2hhbmRsZUtleURvd25dKTtcclxuXHJcbiAgLy8gRmxhcCBhbmltYXRpb25cclxuICBjb25zdCBmbGFwQW5pbWF0aW9uID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgY29uc3QgZmxhcEZyYW1lcyA9IFswLCAxLCAyLCAxXTtcclxuICAgIGxldCBjdXJyZW50RnJhbWUgPSAwO1xyXG4gICAgY29uc3QgZmxhcEludGVydmFsID0gMTAwOyAvLyBtaWxsaXNlY29uZHMgYmV0d2VlbiBmcmFtZXNcclxuXHJcbiAgICBjb25zdCBmbGFwID0gKCkgPT4ge1xyXG4gICAgICBpZiAoY3VycmVudEZyYW1lIDwgZmxhcEZyYW1lcy5sZW5ndGgpIHtcclxuICAgICAgICBjdXJyZW50QmlyZEZyYW1lUmVmLmN1cnJlbnQgPSBmbGFwRnJhbWVzW2N1cnJlbnRGcmFtZV07XHJcbiAgICAgICAgY3VycmVudEZyYW1lKys7XHJcbiAgICAgICAgc2V0VGltZW91dChmbGFwLCBmbGFwSW50ZXJ2YWwpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGN1cnJlbnRCaXJkRnJhbWVSZWYuY3VycmVudCA9IDE7IC8vIHJlc2V0IHRvIG1pZC1mbGFwXHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZmxhcCgpO1xyXG4gIH0sIFtdKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIG1haW4gZ2FtZSBsb29wIHVzaW5nIHJlcXVlc3RBbmltYXRpb25GcmFtZS5cclxuICAgKiBAcGFyYW0gdGltZXN0YW1wIEN1cnJlbnQgdGltZXN0YW1wXHJcbiAgICovXHJcbiAgY29uc3QgYW5pbWF0ZSA9IHVzZUNhbGxiYWNrKFxyXG4gICAgKHRpbWVzdGFtcDogbnVtYmVyKSA9PiB7XHJcbiAgICAgIGlmIChpc1BhdXNlZCB8fCAhZ2FtZVN0YXJ0ZWRSZWYuY3VycmVudCkge1xyXG4gICAgICAgIHJlcXVlc3RJZFJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFsYXN0VGltZVJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgbGFzdFRpbWVSZWYuY3VycmVudCA9IHRpbWVzdGFtcDtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IGRlbHRhVGltZSA9ICh0aW1lc3RhbXAgLSBsYXN0VGltZVJlZi5jdXJyZW50KSAvIDEwMDA7IC8vIGluIHNlY29uZHNcclxuICAgICAgLy8gQ2FwIGRlbHRhVGltZSB0byAwLjA1IHNlY29uZHMgdG8gcHJldmVudCBiaWcganVtcHNcclxuICAgICAgZGVsdGFUaW1lID0gTWF0aC5taW4oZGVsdGFUaW1lLCAwLjA1KTtcclxuICAgICAgbGFzdFRpbWVSZWYuY3VycmVudCA9IHRpbWVzdGFtcDtcclxuXHJcbiAgICAgIC8vIFVwZGF0ZSBnYW1lIHN0YXRlXHJcbiAgICAgIHVwZGF0ZUdhbWVTdGF0ZShkZWx0YVRpbWUpO1xyXG5cclxuICAgICAgLy8gRHJhdyBldmVyeXRoaW5nXHJcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xyXG4gICAgICBpZiAoY2FudmFzKSB7XHJcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuICAgICAgICBpZiAoY3R4KSB7XHJcbiAgICAgICAgICBkcmF3KGN0eCwgY2FudmFzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghZ2FtZU92ZXJSZWYuY3VycmVudCkge1xyXG4gICAgICAgIHJlcXVlc3RJZFJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIERyYXcgZ2FtZSBvdmVyIHNjcmVlblxyXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xyXG4gICAgICAgIGlmIChjYW52YXMpIHtcclxuICAgICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICAgICAgICBpZiAoY3R4KSB7XHJcbiAgICAgICAgICAgIGRyYXdHYW1lT3ZlclNjcmVlbihjdHgsIGNhbnZhcyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgW2lzUGF1c2VkLCB1cGRhdGVHYW1lU3RhdGUsIGRyYXcsIGRyYXdHYW1lT3ZlclNjcmVlbl1cclxuICApO1xyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgdGhlIGdhbWUgc3RhdGUgYmFzZWQgb24gZWxhcHNlZCB0aW1lLlxyXG4gICAqIEBwYXJhbSBkZWx0YVRpbWUgVGltZSBlbGFwc2VkIHNpbmNlIGxhc3QgZnJhbWUgKGluIHNlY29uZHMpXHJcbiAgICovXHJcbiAgY29uc3QgdXBkYXRlR2FtZVN0YXRlID0gdXNlQ2FsbGJhY2soXHJcbiAgICAoZGVsdGFUaW1lOiBudW1iZXIpID0+IHtcclxuICAgICAgLy8gQXBwbHkgZ3Jhdml0eSB0byB0aGUgYmlyZFxyXG4gICAgICBiaXJkVmVsb2NpdHlSZWYuY3VycmVudCArPSBHUkFWSVRZICogZGVsdGFUaW1lO1xyXG4gICAgICBiaXJkWVJlZi5jdXJyZW50ICs9IGJpcmRWZWxvY2l0eVJlZi5jdXJyZW50ICogZGVsdGFUaW1lO1xyXG5cclxuICAgICAgLy8gVXBkYXRlIHBpcGUgc3Bhd24gdGltZXIgYW5kIHNwYXduIHBpcGVzIGF0IGludGVydmFsc1xyXG4gICAgICBwaXBlU3Bhd25UaW1lclJlZi5jdXJyZW50ICs9IGRlbHRhVGltZTtcclxuICAgICAgaWYgKHBpcGVTcGF3blRpbWVyUmVmLmN1cnJlbnQgPiBQSVBFX1NQQVdOX0lOVEVSVkFMIC8gMTAwMCkge1xyXG4gICAgICAgIGNyZWF0ZVBpcGUoKTtcclxuICAgICAgICBwaXBlU3Bhd25UaW1lclJlZi5jdXJyZW50ID0gMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTW92ZSBwaXBlcyBiYXNlZCBvbiBQSVBFX1NQRUVEIGFuZCBkZWx0YVRpbWVcclxuICAgICAgY29uc3QgcGlwZU1vdmVEZWx0YSA9IFBJUEVfU1BFRUQgKiBkZWx0YVRpbWU7XHJcbiAgICAgIHBpcGVzUmVmLmN1cnJlbnQgPSBwaXBlc1JlZi5jdXJyZW50Lm1hcCgocGlwZSkgPT4gKHtcclxuICAgICAgICAuLi5waXBlLFxyXG4gICAgICAgIHg6IHBpcGUueCAtIHBpcGVNb3ZlRGVsdGEsXHJcbiAgICAgIH0pKTtcclxuXHJcbiAgICAgIC8vIFJlbW92ZSBvZmZzY3JlZW4gcGlwZXNcclxuICAgICAgcGlwZXNSZWYuY3VycmVudCA9IHBpcGVzUmVmLmN1cnJlbnQuZmlsdGVyKChwaXBlKSA9PiBwaXBlLnggKyBQSVBFX1dJRFRIID4gMCk7XHJcblxyXG4gICAgICAvLyBNb3ZlIGNvaW5zIGJhc2VkIG9uIENPSU5fU1BFRUQgYW5kIGRlbHRhVGltZVxyXG4gICAgICBjb25zdCBjb2luTW92ZURlbHRhID0gQ09JTl9TUEVFRCAqIGRlbHRhVGltZTtcclxuICAgICAgY29pbnNSZWYuY3VycmVudCA9IGNvaW5zUmVmLmN1cnJlbnQubWFwKChjb2luKSA9PiAoe1xyXG4gICAgICAgIC4uLmNvaW4sXHJcbiAgICAgICAgeDogY29pbi54IC0gY29pbk1vdmVEZWx0YSxcclxuICAgICAgfSkpO1xyXG5cclxuICAgICAgLy8gUmVtb3ZlIG9mZnNjcmVlbiBvciBjb2xsZWN0ZWQgY29pbnNcclxuICAgICAgY29pbnNSZWYuY3VycmVudCA9IGNvaW5zUmVmLmN1cnJlbnQuZmlsdGVyKFxyXG4gICAgICAgIChjb2luKSA9PiBjb2luLnggKyBjb2luLndpZHRoID4gMCAmJiAhY29pbi5jb2xsZWN0ZWRcclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIFJvdGF0ZSBjb2lucyBmb3IgdmlzdWFsIGVmZmVjdFxyXG4gICAgICBjb2luUm90YXRpb25SZWYuY3VycmVudCArPSBST1RBVElPTl9TUEVFRCAqIGRlbHRhVGltZTtcclxuICAgICAgaWYgKGNvaW5Sb3RhdGlvblJlZi5jdXJyZW50ID49IDIgKiBNYXRoLlBJKSB7XHJcbiAgICAgICAgY29pblJvdGF0aW9uUmVmLmN1cnJlbnQgLT0gMiAqIE1hdGguUEk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoZWNrIGZvciBjb2xsaXNpb25zXHJcbiAgICAgIGlmIChjaGVja0NvbGxpc2lvbnMoKSkge1xyXG4gICAgICAgIGdhbWVPdmVyUmVmLmN1cnJlbnQgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2hlY2sgaWYgYmlyZCBjb2xsZWN0cyBhbnkgY29pbnNcclxuICAgICAgY2hlY2tDb2luQ29sbGVjdGlvbigpO1xyXG5cclxuICAgICAgLy8gVXBkYXRlIHRoZSBzY29yZSBiYXNlZCBvbiBwaXBlIHBhc3NpbmdcclxuICAgICAgdXBkYXRlU2NvcmUoKTtcclxuICAgIH0sXHJcbiAgICBbY3JlYXRlUGlwZSwgY2hlY2tDb2xsaXNpb25zLCBjaGVja0NvaW5Db2xsZWN0aW9uLCB1cGRhdGVTY29yZV1cclxuICApO1xyXG5cclxuICAvKipcclxuICAgKiBSZW5kZXIgYWxsIGdhbWUgZWxlbWVudHMgb250byB0aGUgY2FudmFzLlxyXG4gICAqIEBwYXJhbSBjdHggQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEXHJcbiAgICogQHBhcmFtIGNhbnZhcyBDYW52YXMgZWxlbWVudFxyXG4gICAqL1xyXG4gIGNvbnN0IGRyYXcgPSB1c2VDYWxsYmFjayhcclxuICAgIChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkgPT4ge1xyXG4gICAgICAvLyBDbGVhciB0aGUgY2FudmFzXHJcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuXHJcbiAgICAgIC8vIERyYXcgYmFja2dyb3VuZFxyXG4gICAgICBpZiAoYmFja2dyb3VuZEltZ1JlZi5jdXJyZW50Py5jb21wbGV0ZSkge1xyXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoYmFja2dyb3VuZEltZ1JlZi5jdXJyZW50LCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBEcmF3IHBpcGVzXHJcbiAgICAgIGZvciAoY29uc3QgcGlwZSBvZiBwaXBlc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgLy8gVG9wIHBpcGVcclxuICAgICAgICBpZiAocGlwZVRvcEltZ1JlZi5jdXJyZW50Py5jb21wbGV0ZSkge1xyXG4gICAgICAgICAgY3R4LmRyYXdJbWFnZShwaXBlVG9wSW1nUmVmLmN1cnJlbnQsIHBpcGUueCwgMCwgUElQRV9XSURUSCwgcGlwZS5nYXBZKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEJvdHRvbSBwaXBlXHJcbiAgICAgICAgaWYgKHBpcGVCb3R0b21JbWdSZWYuY3VycmVudD8uY29tcGxldGUpIHtcclxuICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoXHJcbiAgICAgICAgICAgIHBpcGVCb3R0b21JbWdSZWYuY3VycmVudCxcclxuICAgICAgICAgICAgcGlwZS54LFxyXG4gICAgICAgICAgICBwaXBlLmdhcFkgKyBQSVBFX0dBUCxcclxuICAgICAgICAgICAgUElQRV9XSURUSCxcclxuICAgICAgICAgICAgY2FudmFzLmhlaWdodCAtIChwaXBlLmdhcFkgKyBQSVBFX0dBUClcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBEcmF3IGNvaW5zXHJcbiAgICAgIGZvciAoY29uc3QgY29pbiBvZiBjb2luc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgaWYgKCFjb2luLmNvbGxlY3RlZCAmJiBjb2luSW1nUmVmLmN1cnJlbnQ/LmNvbXBsZXRlKSB7XHJcbiAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgY3R4LnRyYW5zbGF0ZShjb2luLnggKyBjb2luLndpZHRoIC8gMiwgY29pbi55ICsgY29pbi5oZWlnaHQgLyAyKTtcclxuICAgICAgICAgIGN0eC5yb3RhdGUoY29pblJvdGF0aW9uUmVmLmN1cnJlbnQpO1xyXG4gICAgICAgICAgY3R4LmRyYXdJbWFnZShcclxuICAgICAgICAgICAgY29pbkltZ1JlZi5jdXJyZW50LFxyXG4gICAgICAgICAgICAtY29pbi53aWR0aCAvIDIsXHJcbiAgICAgICAgICAgIC1jb2luLmhlaWdodCAvIDIsXHJcbiAgICAgICAgICAgIGNvaW4ud2lkdGgsXHJcbiAgICAgICAgICAgIGNvaW4uaGVpZ2h0XHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIERyYXcgYmlyZFxyXG4gICAgICBjb25zdCBjdXJyZW50QmlyZEZyYW1lID0gYmlyZEltYWdlc1JlZi5jdXJyZW50W2N1cnJlbnRCaXJkRnJhbWVSZWYuY3VycmVudF07XHJcbiAgICAgIGlmIChjdXJyZW50QmlyZEZyYW1lPy5jb21wbGV0ZSkge1xyXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoXHJcbiAgICAgICAgICBjdXJyZW50QmlyZEZyYW1lLFxyXG4gICAgICAgICAgQklSRF9YLFxyXG4gICAgICAgICAgYmlyZFlSZWYuY3VycmVudCxcclxuICAgICAgICAgIEJJUkRfV0lEVEgsXHJcbiAgICAgICAgICBCSVJEX0hFSUdIVFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBbXVxyXG4gICk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbmRlciB0aGUgc3RhcnQgc2NyZWVuLlxyXG4gICAqIEBwYXJhbSBjdHggQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEXHJcbiAgICogQHBhcmFtIGNhbnZhcyBDYW52YXMgZWxlbWVudFxyXG4gICAqL1xyXG4gIGNvbnN0IGRyYXdTdGFydFNjcmVlbiA9IHVzZUNhbGxiYWNrKFxyXG4gICAgKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSA9PiB7XHJcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuXHJcbiAgICAgIC8vIERyYXcgYmFja2dyb3VuZFxyXG4gICAgICBpZiAoYmFja2dyb3VuZEltZ1JlZi5jdXJyZW50Py5jb21wbGV0ZSkge1xyXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoYmFja2dyb3VuZEltZ1JlZi5jdXJyZW50LCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBEcmF3IHN0YXJ0IHRleHRcclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IFwid2hpdGVcIjtcclxuICAgICAgY3R4LmZvbnQgPSBcImJvbGQgMzBweCBBcmlhbFwiO1xyXG4gICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcclxuICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XHJcbiAgICAgIGN0eC5maWxsVGV4dChcIlByZXNzIFNwYWNlIG9yIFRhcCB0byBTdGFydFwiLCBjYW52YXMud2lkdGggLyAyLCBjYW52YXMuaGVpZ2h0IC8gMik7XHJcbiAgICB9LFxyXG4gICAgW11cclxuICApO1xyXG5cclxuICAvKipcclxuICAgKiBSZW5kZXIgdGhlIGdhbWUgb3ZlciBzY3JlZW4uXHJcbiAgICogQHBhcmFtIGN0eCBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcclxuICAgKiBAcGFyYW0gY2FudmFzIENhbnZhcyBlbGVtZW50XHJcbiAgICovXHJcbiAgY29uc3QgZHJhd0dhbWVPdmVyU2NyZWVuID0gdXNlQ2FsbGJhY2soXHJcbiAgICAoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpID0+IHtcclxuICAgICAgLy8gRHJhdyBzZW1pLXRyYW5zcGFyZW50IG92ZXJsYXlcclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IFwicmdiYSgwLCAwLCAwLCAwLjUpXCI7XHJcbiAgICAgIGN0eC5maWxsUmVjdCgwLCBjYW52YXMuaGVpZ2h0IC8gMiAtIDEwMCwgY2FudmFzLndpZHRoLCAyMDApO1xyXG5cclxuICAgICAgLy8gRHJhdyBHYW1lIE92ZXIgdGV4dFxyXG4gICAgICBjdHguZmlsbFN0eWxlID0gXCIjZmZjYzAwXCI7XHJcbiAgICAgIGN0eC5mb250ID0gXCJib2xkIDUwcHggQXJpYWxcIjtcclxuICAgICAgY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XHJcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xyXG4gICAgICBjdHguZmlsbFRleHQoXCJHYW1lIE92ZXIhXCIsIGNhbnZhcy53aWR0aCAvIDIsIGNhbnZhcy5oZWlnaHQgLyAyIC0gNDApO1xyXG5cclxuICAgICAgLy8gRHJhdyByZXN0YXJ0IHByb21wdFxyXG4gICAgICBjdHguZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xyXG4gICAgICBjdHguZm9udCA9IFwiYm9sZCAzMHB4IEFyaWFsXCI7XHJcbiAgICAgIGN0eC5maWxsVGV4dChcIlByZXNzIFNwYWNlIG9yIFRhcCB0byBSZXN0YXJ0XCIsIGNhbnZhcy53aWR0aCAvIDIsIGNhbnZhcy5oZWlnaHQgLyAyICsgMjApO1xyXG4gICAgfSxcclxuICAgIFtdXHJcbiAgKTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IHBpcGUgd2l0aCBhIHJhbmRvbSBnYXAgcG9zaXRpb24gYW5kIHBvc3NpYmx5IHNwYXduIGEgY29pbi5cclxuICAgKi9cclxuICBjb25zdCBjcmVhdGVQaXBlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XHJcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuO1xyXG4gICAgY29uc3QgZ2FwWSA9IE1hdGgucmFuZG9tKCkgKiAoY2FudmFzLmhlaWdodCAtIFBJUEVfR0FQIC0gMjAwKSArIDEwMDsgLy8gRW5zdXJlIGdhcCBpcyBub3QgdG9vIGNsb3NlIHRvIHRvcCBvciBib3R0b21cclxuICAgIHBpcGVzUmVmLmN1cnJlbnQucHVzaCh7XHJcbiAgICAgIHg6IGNhbnZhcy53aWR0aCxcclxuICAgICAgZ2FwWSxcclxuICAgICAgc2NvcmVkOiBmYWxzZSxcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIDI1JSBjaGFuY2UgdG8gc3Bhd24gYSBjb2luXHJcbiAgICBpZiAoTWF0aC5yYW5kb20oKSA8IENPSU5fU1BBV05fQ0hBTkNFKSB7XHJcbiAgICAgIGNvaW5zUmVmLmN1cnJlbnQucHVzaCh7XHJcbiAgICAgICAgeDogY2FudmFzLndpZHRoICsgUElQRV9XSURUSCAvIDIgLSBDT0lOX1NJWkUgLyAyLFxyXG4gICAgICAgIHk6IGdhcFkgKyBQSVBFX0dBUCAvIDIgLSBDT0lOX1NJWkUgLyAyLFxyXG4gICAgICAgIHdpZHRoOiBDT0lOX1NJWkUsXHJcbiAgICAgICAgaGVpZ2h0OiBDT0lOX1NJWkUsXHJcbiAgICAgICAgY29sbGVjdGVkOiBmYWxzZSxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSwgW10pO1xyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBmb3IgY29sbGlzaW9ucyBiZXR3ZWVuIHRoZSBiaXJkIGFuZCBwaXBlcyBvciBib3VuZGFyaWVzLlxyXG4gICAqIEByZXR1cm5zIEJvb2xlYW4gaW5kaWNhdGluZyBpZiBhIGNvbGxpc2lvbiBvY2N1cnJlZFxyXG4gICAqL1xyXG4gIGNvbnN0IGNoZWNrQ29sbGlzaW9ucyA9IHVzZUNhbGxiYWNrKCgpOiBib29sZWFuID0+IHtcclxuICAgIC8vIEFzc3VtaW5nIGNhbnZhcyBoZWlnaHQgaXMgZml4ZWQgYXQgNjQwXHJcbiAgICBpZiAoYmlyZFlSZWYuY3VycmVudCA8IDAgfHwgYmlyZFlSZWYuY3VycmVudCArIEJJUkRfSEVJR0hUID4gNjQwKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGJpcmRMZWZ0ID0gQklSRF9YO1xyXG4gICAgY29uc3QgYmlyZFJpZ2h0ID0gQklSRF9YICsgQklSRF9XSURUSDtcclxuICAgIGNvbnN0IGJpcmRUb3AgPSBiaXJkWVJlZi5jdXJyZW50O1xyXG4gICAgY29uc3QgYmlyZEJvdHRvbSA9IGJpcmRZUmVmLmN1cnJlbnQgKyBCSVJEX0hFSUdIVDtcclxuXHJcbiAgICAvLyBDaGVjayBjb2xsaXNpb24gd2l0aCBlYWNoIHBpcGVcclxuICAgIGZvciAoY29uc3QgcGlwZSBvZiBwaXBlc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgIGNvbnN0IHBpcGVMZWZ0ID0gcGlwZS54O1xyXG4gICAgICBjb25zdCBwaXBlUmlnaHQgPSBwaXBlLnggKyBQSVBFX1dJRFRIO1xyXG5cclxuICAgICAgLy8gSWYgYmlyZCBpcyB3aXRoaW4gcGlwZSdzIGhvcml6b250YWwgYm91bmRzXHJcbiAgICAgIGlmIChiaXJkUmlnaHQgPiBwaXBlTGVmdCAmJiBiaXJkTGVmdCA8IHBpcGVSaWdodCkge1xyXG4gICAgICAgIC8vIENoZWNrIGlmIGJpcmQgaXMgd2l0aGluIHRoZSBnYXBcclxuICAgICAgICBpZiAoYmlyZFRvcCA8IHBpcGUuZ2FwWSB8fCBiaXJkQm90dG9tID4gcGlwZS5nYXBZICsgUElQRV9HQVApIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9LCBbXSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIHRoZSBiaXJkIGhhcyBjb2xsZWN0ZWQgYW55IGNvaW5zLlxyXG4gICAqL1xyXG4gIGNvbnN0IGNoZWNrQ29pbkNvbGxlY3Rpb24gPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICBjb25zdCBiaXJkTGVmdCA9IEJJUkRfWDtcclxuICAgIGNvbnN0IGJpcmRSaWdodCA9IEJJUkRfWCArIEJJUkRfV0lEVEg7XHJcbiAgICBjb25zdCBiaXJkVG9wID0gYmlyZFlSZWYuY3VycmVudDtcclxuICAgIGNvbnN0IGJpcmRCb3R0b20gPSBiaXJkWVJlZi5jdXJyZW50ICsgQklSRF9IRUlHSFQ7XHJcblxyXG4gICAgZm9yIChjb25zdCBjb2luIG9mIGNvaW5zUmVmLmN1cnJlbnQpIHtcclxuICAgICAgaWYgKCFjb2luLmNvbGxlY3RlZCkge1xyXG4gICAgICAgIGNvbnN0IGNvaW5MZWZ0ID0gY29pbi54O1xyXG4gICAgICAgIGNvbnN0IGNvaW5SaWdodCA9IGNvaW4ueCArIGNvaW4ud2lkdGg7XHJcbiAgICAgICAgY29uc3QgY29pblRvcCA9IGNvaW4ueTtcclxuICAgICAgICBjb25zdCBjb2luQm90dG9tID0gY29pbi55ICsgY29pbi5oZWlnaHQ7XHJcblxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIGJpcmRSaWdodCA+IGNvaW5MZWZ0ICYmXHJcbiAgICAgICAgICBiaXJkTGVmdCA8IGNvaW5SaWdodCAmJlxyXG4gICAgICAgICAgYmlyZEJvdHRvbSA+IGNvaW5Ub3AgJiZcclxuICAgICAgICAgIGJpcmRUb3AgPCBjb2luQm90dG9tXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICBjb2luLmNvbGxlY3RlZCA9IHRydWU7XHJcbiAgICAgICAgICBzZXRDdXJyZW50U2NvcmUoKHByZXZTY29yZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdTY29yZSA9IHByZXZTY29yZSArIDU7XHJcbiAgICAgICAgICAgIHNldEhpZ2hTY29yZSgocHJldkhpZ2hTY29yZSkgPT4ge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRIaWdoU2NvcmUgPSBNYXRoLm1heChwcmV2SGlnaFNjb3JlLCBuZXdTY29yZSk7XHJcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwiaGlnaFNjb3JlXCIsIHVwZGF0ZWRIaWdoU2NvcmUudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVkSGlnaFNjb3JlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld1Njb3JlO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSwgW10pO1xyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgdGhlIHNjb3JlIHdoZW4gdGhlIGJpcmQgcGFzc2VzIGEgcGlwZS5cclxuICAgKi9cclxuICBjb25zdCB1cGRhdGVTY29yZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgIGZvciAoY29uc3QgcGlwZSBvZiBwaXBlc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgIC8vIFNjb3JlICsxIGZvciBwYXNzaW5nIGVhY2ggcGlwZSBvbmNlXHJcbiAgICAgIGlmICghcGlwZS5zY29yZWQgJiYgcGlwZS54ICsgUElQRV9XSURUSCA8IEJJUkRfWCkge1xyXG4gICAgICAgIHNldEN1cnJlbnRTY29yZSgocHJldlNjb3JlKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBuZXdTY29yZSA9IHByZXZTY29yZSArIDE7XHJcbiAgICAgICAgICBzZXRIaWdoU2NvcmUoKHByZXZIaWdoU2NvcmUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZEhpZ2hTY29yZSA9IE1hdGgubWF4KHByZXZIaWdoU2NvcmUsIG5ld1Njb3JlKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcImhpZ2hTY29yZVwiLCB1cGRhdGVkSGlnaFNjb3JlLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVkSGlnaFNjb3JlO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICByZXR1cm4gbmV3U2NvcmU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcGlwZS5zY29yZWQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSwgW10pO1xyXG5cclxuICAvKipcclxuICAgKiBDbGVhbnVwIG9uIHVubW91bnQuXHJcbiAgICovXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGlmIChyZXF1ZXN0SWRSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJlcXVlc3RJZFJlZi5jdXJyZW50KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9LCBbXSk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBoaWdoU2NvcmUsXHJcbiAgICBjdXJyZW50U2NvcmUsXHJcbiAgICBoYW5kbGVVc2VySW5wdXQsXHJcbiAgfTtcclxufVxyXG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsIkdSQVZJVFkiLCJGTEFQX1ZFTE9DSVRZIiwiUElQRV9TUEVFRCIsIlBJUEVfU1BBV05fSU5URVJWQUwiLCJQSVBFX1dJRFRIIiwiUElQRV9HQVAiLCJCSVJEX1giLCJCSVJEX1dJRFRIIiwiQklSRF9IRUlHSFQiLCJDT0lOX1NQRUVEIiwiQ09JTl9TUEFXTl9DSEFOQ0UiLCJDT0lOX1NJWkUiLCJST1RBVElPTl9TUEVFRCIsIk1hdGgiLCJQSSIsInVzZUZsYXBweUJpcmRHYW1lIiwiY2FudmFzUmVmIiwiaXNQYXVzZWQiLCJhdXRvU3RhcnQiLCJoaWdoU2NvcmUiLCJzZXRIaWdoU2NvcmUiLCJjdXJyZW50U2NvcmUiLCJzZXRDdXJyZW50U2NvcmUiLCJiaXJkWVJlZiIsImJpcmRWZWxvY2l0eVJlZiIsInBpcGVzUmVmIiwiY29pbnNSZWYiLCJnYW1lT3ZlclJlZiIsImdhbWVTdGFydGVkUmVmIiwiY29pblJvdGF0aW9uUmVmIiwibGFzdFRpbWVSZWYiLCJwaXBlU3Bhd25UaW1lclJlZiIsInJlcXVlc3RJZFJlZiIsImJpcmRJbWFnZXNSZWYiLCJwaXBlVG9wSW1nUmVmIiwicGlwZUJvdHRvbUltZ1JlZiIsImJhY2tncm91bmRJbWdSZWYiLCJjb2luSW1nUmVmIiwiY3VycmVudEJpcmRGcmFtZVJlZiIsInN0b3JlZEhpZ2hTY29yZSIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJwYXJzZUludCIsImJpcmRVcCIsIkltYWdlIiwic3JjIiwiYmlyZE1pZCIsImJpcmREb3duIiwiY3VycmVudCIsInBpcGVUb3BJbWciLCJwaXBlQm90dG9tSW1nIiwiYmFja2dyb3VuZEltZyIsImNvaW5JbWciLCJsb2FkSW1hZ2UiLCJpbWciLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImNvbXBsZXRlIiwib25sb2FkIiwib25lcnJvciIsIkVycm9yIiwibG9hZEFzc2V0cyIsImFsbCIsIm1hcCIsImNvbnNvbGUiLCJsb2ciLCJpbml0aWFsaXplR2FtZSIsInN0YXJ0R2FtZSIsImVycm9yIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJjYW52YXMiLCJjdHgiLCJnZXRDb250ZXh0Iiwid2lkdGgiLCJoZWlnaHQiLCJkcmF3U3RhcnRTY3JlZW4iLCJyZXNldEdhbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImFuaW1hdGUiLCJoYW5kbGVVc2VySW5wdXQiLCJmbGFwQW5pbWF0aW9uIiwiaGFuZGxlS2V5RG93biIsImUiLCJrZXkiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImZsYXBGcmFtZXMiLCJjdXJyZW50RnJhbWUiLCJmbGFwSW50ZXJ2YWwiLCJmbGFwIiwibGVuZ3RoIiwic2V0VGltZW91dCIsInRpbWVzdGFtcCIsImRlbHRhVGltZSIsIm1pbiIsInVwZGF0ZUdhbWVTdGF0ZSIsImRyYXciLCJkcmF3R2FtZU92ZXJTY3JlZW4iLCJjcmVhdGVQaXBlIiwicGlwZU1vdmVEZWx0YSIsInBpcGUiLCJ4IiwiZmlsdGVyIiwiY29pbk1vdmVEZWx0YSIsImNvaW4iLCJjb2xsZWN0ZWQiLCJjaGVja0NvbGxpc2lvbnMiLCJjaGVja0NvaW5Db2xsZWN0aW9uIiwidXBkYXRlU2NvcmUiLCJjbGVhclJlY3QiLCJkcmF3SW1hZ2UiLCJnYXBZIiwic2F2ZSIsInRyYW5zbGF0ZSIsInkiLCJyb3RhdGUiLCJyZXN0b3JlIiwiY3VycmVudEJpcmRGcmFtZSIsImZpbGxTdHlsZSIsImZvbnQiLCJ0ZXh0QWxpZ24iLCJ0ZXh0QmFzZWxpbmUiLCJmaWxsVGV4dCIsImZpbGxSZWN0IiwicmFuZG9tIiwicHVzaCIsInNjb3JlZCIsImJpcmRMZWZ0IiwiYmlyZFJpZ2h0IiwiYmlyZFRvcCIsImJpcmRCb3R0b20iLCJwaXBlTGVmdCIsInBpcGVSaWdodCIsImNvaW5MZWZ0IiwiY29pblJpZ2h0IiwiY29pblRvcCIsImNvaW5Cb3R0b20iLCJwcmV2U2NvcmUiLCJuZXdTY29yZSIsInByZXZIaWdoU2NvcmUiLCJ1cGRhdGVkSGlnaFNjb3JlIiwibWF4Iiwic2V0SXRlbSIsInRvU3RyaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./public/useFlappyBirdGame.ts\n"));

/***/ })

});