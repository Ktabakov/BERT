"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./public/useFlappyBirdGame.ts":
/*!*************************************!*\
  !*** ./public/useFlappyBirdGame.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFlappyBirdGame: function() { return /* binding */ useFlappyBirdGame; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n// src/hooks/useFlappyBirdGame.ts\n\n// Constants\nconst GRAVITY = 0.7;\nconst FLAP = -11;\nconst PIPE_WIDTH = 90;\nconst PIPE_SPACING = 230;\nconst BIRD_WIDTH = 50;\nconst BIRD_HEIGHT = 50;\nconst COIN_SIZE = 100;\n// How long between pipe spawns (in milliseconds)\nconst PIPE_SPAWN_INTERVAL = 1000;\n// Horizontal speed (pixels per \"60fps\" frame). We'll scale it by (deltaTime/16.67).\nconst HORIZONTAL_SPEED = 4;\n// Rotation speed of coin (complete flip from scale 1 to 0 to 1). 1 = full cycle.\nconst ROTATION_SPEED = 0.01;\n// A small constant representing the \"ideal frame\" for scaling calculations (about 60fps).\nconst IDEAL_FRAME = 16.67; // ms\n/**\r\n * Custom Hook: useFlappyBirdGame\r\n * Handles Flappy Bird game logic, including:\r\n * - Canvas setup\r\n * - Bird movement / flapping\r\n * - Pipe & coin spawning\r\n * - Score tracking\r\n * - Mobile/desktop input handling\r\n */ function useFlappyBirdGame(canvasRef, isPaused, autoStart) {\n    // -----------------------------\n    // 1. TOP-LEVEL HOOKS & REFS\n    // -----------------------------\n    // React State\n    const [highScore, setHighScore] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [currentScore, setCurrentScore] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    // Game Refs\n    const requestIdRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const birdYRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const birdVelocityRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const pipesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const coinsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const gameOverRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const gameStartedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // Coin rotation & pipe spawn timer\n    const coinRotationRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const pipeSpawnTimerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // Timestamp for time-based movement\n    const lastTimeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // Bird animation frames\n    const birdImagesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const pipeTopRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const pipeBottomRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const backgroundRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const coinImageRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // Current Bird Frame\n    const currentBirdFrameRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // For debouncing taps on mobile\n    const lastTapRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const DEBOUNCE_TIME = 300; // ms\n    // -----------------------------\n    // 2. IMAGE PRELOAD (only on client)\n    // -----------------------------\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (false) {} // Ensure this runs only on client\n        const birdUp = new Image();\n        birdUp.src = \"/assets/redbird-upflap.png\";\n        const birdMid = new Image();\n        birdMid.src = \"/assets/redbird-midflap.png\";\n        const birdDown = new Image();\n        birdDown.src = \"/assets/redbird-downflap.png\";\n        birdImagesRef.current = [\n            birdUp,\n            birdMid,\n            birdDown\n        ];\n        const pipeTop = new Image();\n        pipeTop.src = \"/assets/TopTiny.png\";\n        pipeTopRef.current = pipeTop;\n        const pipeBottom = new Image();\n        pipeBottom.src = \"/assets/BottomTiny.png\";\n        pipeBottomRef.current = pipeBottom;\n        const background = new Image();\n        background.src = \"/assets/background-day.png\";\n        backgroundRef.current = background;\n        const coinImage = new Image();\n        coinImage.src = \"/assets/CoinTiny.png\";\n        coinImageRef.current = coinImage;\n    }, []);\n    // -------------------------------------------\n    // 3. LOAD HIGH SCORE ON HOOK INIT\n    // -------------------------------------------\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (true) {\n            const storedHighScore = localStorage.getItem(\"highScore\");\n            if (storedHighScore) {\n                setHighScore(parseInt(storedHighScore, 10));\n            }\n        }\n    }, []);\n    // -------------------------------------------\n    // 4. MAIN useEffect: SETUP & TEARDOWN\n    // -------------------------------------------\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        // Utility: Ensure an image is fully loaded\n        const loadImage = (img)=>{\n            return new Promise((resolve, reject)=>{\n                if (img.complete) {\n                    resolve();\n                } else {\n                    img.onload = ()=>resolve();\n                    img.onerror = ()=>reject(new Error(\"Failed to load \".concat(img.src)));\n                }\n            });\n        };\n        // Load images, then initialize\n        const loadAssets = async ()=>{\n            try {\n                await Promise.all([\n                    ...birdImagesRef.current.map((img)=>loadImage(img)),\n                    pipeTopRef.current ? loadImage(pipeTopRef.current) : Promise.resolve(),\n                    pipeBottomRef.current ? loadImage(pipeBottomRef.current) : Promise.resolve(),\n                    backgroundRef.current ? loadImage(backgroundRef.current) : Promise.resolve(),\n                    coinImageRef.current ? loadImage(coinImageRef.current) : Promise.resolve()\n                ]);\n                initializeGame();\n            } catch (err) {\n                console.error(\"Error loading assets:\", err);\n            }\n        };\n        loadAssets();\n        // ---------------------------\n        // 4A: INITIALIZE / RESET GAME\n        // ---------------------------\n        function initializeGame() {\n            if (!canvasRef.current || !ctx) return;\n            canvasRef.current.width = 360;\n            canvasRef.current.height = 640;\n            drawStartScreen(ctx, canvasRef.current);\n        }\n        function resetGame() {\n            if (!canvasRef.current) return;\n            const { height } = canvasRef.current;\n            birdYRef.current = height / 3;\n            birdVelocityRef.current = 0;\n            pipesRef.current = [];\n            coinsRef.current = [];\n            setCurrentScore(0);\n            gameOverRef.current = false;\n            gameStartedRef.current = false;\n            coinRotationRef.current = 0;\n            pipeSpawnTimerRef.current = 0;\n            currentBirdFrameRef.current = 0;\n        }\n        // Desktop keyboard input\n        function handleKeyDown(e) {\n            if (e.key === \" \") {\n                handleUserInputWithDebounce();\n            }\n        }\n        window.addEventListener(\"keydown\", handleKeyDown);\n        // Handle resizing\n        function handleResize() {\n            if (!canvasRef.current) return;\n            canvasRef.current.width = 360;\n            canvasRef.current.height = 640;\n            if (!gameStartedRef.current && !gameOverRef.current && ctx) {\n                drawStartScreen(ctx, canvasRef.current);\n            }\n        }\n        window.addEventListener(\"resize\", handleResize);\n        // Start game\n        function startGame() {\n            resetGame();\n            gameStartedRef.current = true;\n            lastTimeRef.current = performance.now(); // reset our time-based reference\n            requestIdRef.current = requestAnimationFrame(animate);\n        }\n        // Debounced handleUserInput\n        function handleUserInputWithDebounce() {\n            const now = Date.now();\n            if (now - lastTapRef.current < DEBOUNCE_TIME) {\n                return; // Ignore if within debounce time\n            }\n            lastTapRef.current = now;\n            if (!gameStartedRef.current && !gameOverRef.current) {\n                startGame();\n            } else if (gameOverRef.current) {\n                startGame();\n            } else {\n                birdVelocityRef.current = FLAP;\n                flapAnimation();\n            }\n        }\n        // Quick flap animation\n        function flapAnimation() {\n            currentBirdFrameRef.current = 1;\n            setTimeout(()=>{\n                currentBirdFrameRef.current = 2;\n                setTimeout(()=>{\n                    currentBirdFrameRef.current = 0;\n                }, 170);\n            }, 170);\n        }\n        // Main game loop\n        function animate(currentTime) {\n            if (!gameStartedRef.current) {\n                // If game hasn't started, just schedule the next frame\n                requestIdRef.current = requestAnimationFrame(animate);\n                return;\n            }\n            if (isPaused) {\n                // If paused, just schedule the next frame\n                requestIdRef.current = requestAnimationFrame(animate);\n                return;\n            }\n            if (!canvasRef.current) return;\n            const context = canvasRef.current.getContext(\"2d\");\n            if (!context) return;\n            const now = currentTime !== null && currentTime !== void 0 ? currentTime : performance.now();\n            const deltaTime = now - lastTimeRef.current;\n            lastTimeRef.current = now;\n            updateGameState(canvasRef.current, deltaTime);\n            draw(context, canvasRef.current);\n            if (!gameOverRef.current) {\n                requestIdRef.current = requestAnimationFrame(animate);\n            } else {\n                drawGameOverScreen(context, canvasRef.current);\n            }\n        }\n        function updateGameState(canvas, deltaTime) {\n            const scale = deltaTime / IDEAL_FRAME;\n            // Gravity\n            birdVelocityRef.current += GRAVITY * scale;\n            birdYRef.current += birdVelocityRef.current * scale;\n            // Pipe spawn\n            pipeSpawnTimerRef.current += deltaTime;\n            if (pipeSpawnTimerRef.current >= PIPE_SPAWN_INTERVAL) {\n                pipeSpawnTimerRef.current -= PIPE_SPAWN_INTERVAL;\n                createPipe(canvas);\n            }\n            // Move pipes & coins\n            movePipesAndCoins(scale);\n            // Rotate coin\n            coinRotationRef.current += ROTATION_SPEED * scale;\n            if (coinRotationRef.current >= 1) {\n                coinRotationRef.current = 0;\n            }\n            // Collisions\n            if (checkCollisions(canvas)) {\n                gameOverRef.current = true;\n                return;\n            }\n            // Coin collection\n            checkCoinCollection();\n            // Score\n            updateScore();\n        }\n        // ---------------------------------------\n        // 4C: DRAW FUNCTIONS\n        // ---------------------------------------\n        function draw(ctx, canvas) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawBackground(ctx, canvas);\n            drawBird(ctx);\n            drawPipes(ctx);\n            drawCoins(ctx);\n        }\n        function drawStartScreen(ctx, canvas) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawBackground(ctx, canvas);\n            ctx.font = \"bold 30px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.fillStyle = \"#ffffff\";\n            ctx.shadowColor = \"black\";\n            ctx.textBaseline = \"middle\";\n            ctx.fillText(\"Tap or Press Space to Start\", canvas.width / 2, canvas.height / 2);\n        }\n        function drawGameOverScreen(ctx, canvas) {\n            ctx.fillStyle = \"#ffcc00\";\n            ctx.font = \"bold 50px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"middle\";\n            ctx.shadowColor = \"black\";\n            ctx.shadowBlur = 10;\n            ctx.fillText(\"Game Over!\", canvas.width / 2, canvas.height / 2 - 40);\n            ctx.fillStyle = \"#ffffff\";\n            ctx.font = \"bold 30px Arial\";\n            ctx.fillText(\"Tap or Press Space to Restart\", canvas.width / 2, canvas.height / 2 + 20);\n        }\n        function drawBackground(ctx, canvas) {\n            if (backgroundRef.current && backgroundRef.current.complete) {\n                ctx.drawImage(backgroundRef.current, 0, 0, canvas.width, canvas.height);\n            }\n        }\n        function drawBird(ctx) {\n            const currentImage = birdImagesRef.current[currentBirdFrameRef.current];\n            if (currentImage && currentImage.complete) {\n                ctx.drawImage(currentImage, 100, birdYRef.current, BIRD_WIDTH, BIRD_HEIGHT);\n            }\n        }\n        function drawPipes(ctx) {\n            pipesRef.current.forEach((pipe)=>{\n                if (pipeTopRef.current && pipeTopRef.current.complete) {\n                    ctx.drawImage(pipeTopRef.current, pipe.x, 0, PIPE_WIDTH, pipe.topHeight);\n                }\n                if (pipeBottomRef.current && pipeBottomRef.current.complete) {\n                    ctx.drawImage(pipeBottomRef.current, pipe.x, pipe.bottomY, PIPE_WIDTH, pipe.bottomHeight);\n                }\n            });\n        }\n        function drawCoins(ctx) {\n            if (!coinImageRef.current || !coinImageRef.current.complete) return;\n            const scaleX = Math.abs(Math.cos(coinRotationRef.current * Math.PI * 2));\n            const halfSize = COIN_SIZE / 2;\n            coinsRef.current.forEach((coin)=>{\n                if (!coin.collected) {\n                    if (!coinImageRef.current) return;\n                    ctx.save();\n                    ctx.translate(coin.x + halfSize, coin.y + halfSize);\n                    ctx.scale(scaleX, 1);\n                    ctx.drawImage(coinImageRef.current, -halfSize, -halfSize, COIN_SIZE, COIN_SIZE);\n                    ctx.restore();\n                }\n            });\n        }\n        // ---------------------------------------\n        // 4D: GAME LOGIC FUNCTIONS\n        // ---------------------------------------\n        function createPipe(canvas) {\n            const pipeHeight = Math.random() * (canvas.height - PIPE_SPACING - 100) + 50;\n            const bottomY = pipeHeight + PIPE_SPACING;\n            pipesRef.current.push({\n                x: canvas.width,\n                topHeight: pipeHeight,\n                bottomY,\n                bottomHeight: canvas.height - bottomY,\n                scored: false\n            });\n            // 50% chance for coin\n            if (Math.random() > 0.5) {\n                coinsRef.current.push({\n                    x: canvas.width + PIPE_WIDTH / 2 - COIN_SIZE / 2,\n                    y: pipeHeight + PIPE_SPACING / 2 - COIN_SIZE / 2,\n                    width: COIN_SIZE,\n                    height: COIN_SIZE,\n                    collected: false\n                });\n            }\n        }\n        function movePipesAndCoins(scale) {\n            // Move pipes to the left\n            pipesRef.current.forEach((pipe)=>{\n                pipe.x -= HORIZONTAL_SPEED * scale;\n            });\n            pipesRef.current = pipesRef.current.filter((p)=>p.x + PIPE_WIDTH > 0);\n            // Move coins\n            coinsRef.current.forEach((coin)=>{\n                coin.x -= HORIZONTAL_SPEED * scale;\n            });\n            coinsRef.current = coinsRef.current.filter((c)=>c.x + c.width > 0 && !c.collected);\n        }\n        function checkCollisions(canvas) {\n            // Bird vs boundaries\n            if (birdYRef.current < 0 || birdYRef.current + BIRD_HEIGHT > canvas.height) {\n                return true;\n            }\n            const birdLeft = 100;\n            const birdRight = birdLeft + BIRD_WIDTH;\n            const birdTop = birdYRef.current;\n            const birdBottom = birdYRef.current + BIRD_HEIGHT;\n            // Bird vs pipes\n            for (const pipe of pipesRef.current){\n                const withinPipeX = birdRight > pipe.x && birdLeft < pipe.x + PIPE_WIDTH;\n                const withinPipeY = birdTop < pipe.topHeight || birdBottom > pipe.bottomY;\n                if (withinPipeX && withinPipeY) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function checkCoinCollection() {\n            const birdLeft = 100;\n            const birdRight = birdLeft + BIRD_WIDTH;\n            const birdTop = birdYRef.current;\n            const birdBottom = birdYRef.current + BIRD_HEIGHT;\n            coinsRef.current.forEach((coin)=>{\n                if (!coin.collected) {\n                    const coinLeft = coin.x;\n                    const coinRight = coin.x + coin.width;\n                    const coinTop = coin.y;\n                    const coinBottom = coin.y + coin.height;\n                    if (birdRight > coinLeft && birdLeft < coinRight && birdBottom > coinTop && birdTop < coinBottom) {\n                        // Collect coin\n                        coin.collected = true;\n                        setCurrentScore((prevScore)=>{\n                            const newScore = prevScore + 5;\n                            setHighScore((prevHighScore)=>Math.max(prevHighScore, newScore));\n                            return newScore;\n                        });\n                    }\n                }\n            });\n        }\n        function updateScore() {\n            pipesRef.current.forEach((pipe)=>{\n                // Score +1 for passing each pipe, only once\n                if (!pipe.scored && pipe.x + PIPE_WIDTH < 100) {\n                    pipe.scored = true;\n                    setCurrentScore((prevScore)=>{\n                        const newScore = prevScore + 1;\n                        setHighScore((prevHighScore)=>{\n                            const updatedHighScore = Math.max(prevHighScore, newScore);\n                            if (true) {\n                                localStorage.setItem(\"highScore\", updatedHighScore.toString());\n                            }\n                            return updatedHighScore;\n                        });\n                        return newScore;\n                    });\n                }\n            });\n        }\n        // ---------------------------------------\n        // 4E: CLEANUP FUNCTION\n        // ---------------------------------------\n        return ()=>{\n            window.removeEventListener(\"keydown\", handleKeyDown);\n            window.removeEventListener(\"resize\", handleResize);\n            if (requestIdRef.current) {\n                cancelAnimationFrame(requestIdRef.current);\n            }\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        canvasRef,\n        isPaused,\n        autoStart\n    ]);\n    // ---------------------------------------\n    // 5. HANDLE USER INPUT WITH DEBOUNCING\n    // ---------------------------------------\n    const handleUserInput = ()=>{\n        const now = Date.now();\n        if (now - lastTapRef.current < DEBOUNCE_TIME) {\n            return; // Ignore if within debounce time\n        }\n        lastTapRef.current = now;\n        if (!gameStartedRef.current && !gameOverRef.current) {\n            startGame();\n        } else if (gameOverRef.current) {\n            startGame();\n        } else {\n            birdVelocityRef.current = FLAP;\n            flapAnimation();\n        }\n    };\n    // ---------------------------------------\n    // 6. FLAP ANIMATION FUNCTION\n    // ---------------------------------------\n    const flapAnimation = ()=>{\n        currentBirdFrameRef.current = 1;\n        setTimeout(()=>{\n            currentBirdFrameRef.current = 2;\n            setTimeout(()=>{\n                currentBirdFrameRef.current = 0;\n            }, 170);\n        }, 170);\n    };\n    // ---------------------------------------\n    // 7. START GAME FUNCTION\n    // ---------------------------------------\n    const startGame = ()=>{\n        resetGame();\n        gameStartedRef.current = true;\n        lastTimeRef.current = performance.now(); // reset our time-based reference\n        requestIdRef.current = requestAnimationFrame(animate);\n    };\n    function resetGame() {\n        if (!canvasRef.current) return;\n        const { height } = canvasRef.current;\n        birdYRef.current = height / 3;\n        birdVelocityRef.current = 0;\n        pipesRef.current = [];\n        coinsRef.current = [];\n        setCurrentScore(0);\n        gameOverRef.current = false;\n        gameStartedRef.current = false;\n        coinRotationRef.current = 0;\n        pipeSpawnTimerRef.current = 0;\n        currentBirdFrameRef.current = 0;\n    }\n    // ---------------------------------------\n    // 8. GAME LOOP FUNCTION\n    // ---------------------------------------\n    const animate = (currentTime)=>{\n        if (!gameStartedRef.current) {\n            // If game hasn't started, just schedule the next frame\n            requestIdRef.current = requestAnimationFrame(animate);\n            return;\n        }\n        if (isPaused) {\n            // If paused, just schedule the next frame\n            requestIdRef.current = requestAnimationFrame(animate);\n            return;\n        }\n        if (!canvasRef.current) return;\n        const context = canvasRef.current.getContext(\"2d\");\n        if (!context) return;\n        const now = currentTime !== null && currentTime !== void 0 ? currentTime : performance.now();\n        const deltaTime = now - lastTimeRef.current;\n        lastTimeRef.current = now;\n        updateGameState(canvasRef.current, deltaTime);\n        draw(context, canvasRef.current);\n        if (!gameOverRef.current) {\n            requestIdRef.current = requestAnimationFrame(animate);\n        } else {\n            drawGameOverScreen(context, canvasRef.current);\n        }\n    };\n    function updateGameState(canvas, deltaTime) {\n        // Scale factor relative to ~60fps = 16.67ms per frame\n        const scale = deltaTime / IDEAL_FRAME;\n        // Gravity\n        birdVelocityRef.current += GRAVITY * scale;\n        birdYRef.current += birdVelocityRef.current * scale;\n        // Update pipe spawn timer\n        pipeSpawnTimerRef.current += deltaTime;\n        if (pipeSpawnTimerRef.current >= PIPE_SPAWN_INTERVAL) {\n            pipeSpawnTimerRef.current -= PIPE_SPAWN_INTERVAL;\n            createPipe(canvas);\n        }\n        // Move pipes & coins\n        movePipesAndCoins(scale);\n        // Rotate coin (0 -> 1 is a full cycle in our usage)\n        coinRotationRef.current += ROTATION_SPEED * scale;\n        if (coinRotationRef.current >= 1) {\n            coinRotationRef.current = 0;\n        }\n        // Check collisions\n        if (checkCollisions(canvas)) {\n            gameOverRef.current = true;\n            return;\n        }\n        // Check coin collection\n        checkCoinCollection();\n        // Update score if we pass pipes\n        updateScore();\n    }\n    // ---------------------------------------\n    // 9. DRAW FUNCTIONS\n    // ---------------------------------------\n    const draw = (ctx, canvas)=>{\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        drawBackground(ctx, canvas);\n        drawBird(ctx);\n        drawPipes(ctx);\n        drawCoins(ctx);\n    };\n    const drawStartScreen = (ctx, canvas)=>{\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        drawBackground(ctx, canvas);\n        ctx.font = \"bold 30px Arial\";\n        ctx.textAlign = \"center\";\n        ctx.fillStyle = \"#ffffff\";\n        ctx.shadowColor = \"black\";\n        ctx.textBaseline = \"middle\";\n        ctx.fillText(\"Tap or Press Space to Start\", canvas.width / 2, canvas.height / 2);\n    };\n    const drawGameOverScreen = (ctx, canvas)=>{\n        ctx.fillStyle = \"#ffcc00\";\n        ctx.font = \"bold 50px Arial\";\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        ctx.shadowColor = \"black\";\n        ctx.shadowBlur = 10;\n        ctx.fillText(\"Game Over!\", canvas.width / 2, canvas.height / 2 - 40);\n        ctx.fillStyle = \"#ffffff\";\n        ctx.font = \"bold 30px Arial\";\n        ctx.fillText(\"Tap or Press Space to Restart\", canvas.width / 2, canvas.height / 2 + 20);\n    };\n    const drawBackground = (ctx, canvas)=>{\n        if (backgroundRef.current && backgroundRef.current.complete) {\n            ctx.drawImage(backgroundRef.current, 0, 0, canvas.width, canvas.height);\n        }\n    };\n    const drawBird = (ctx)=>{\n        const currentImage = birdImagesRef.current[currentBirdFrameRef.current];\n        if (currentImage && currentImage.complete) {\n            ctx.drawImage(currentImage, 100, birdYRef.current, BIRD_WIDTH, BIRD_HEIGHT);\n        }\n    };\n    const drawPipes = (ctx)=>{\n        pipesRef.current.forEach((pipe)=>{\n            if (pipeTopRef.current && pipeTopRef.current.complete) {\n                ctx.drawImage(pipeTopRef.current, pipe.x, 0, PIPE_WIDTH, pipe.topHeight);\n            }\n            if (pipeBottomRef.current && pipeBottomRef.current.complete) {\n                ctx.drawImage(pipeBottomRef.current, pipe.x, pipe.bottomY, PIPE_WIDTH, pipe.bottomHeight);\n            }\n        });\n    };\n    const drawCoins = (ctx)=>{\n        if (!coinImageRef.current || !coinImageRef.current.complete) return;\n        const scaleX = Math.abs(Math.cos(coinRotationRef.current * Math.PI * 2));\n        const halfSize = COIN_SIZE / 2;\n        coinsRef.current.forEach((coin)=>{\n            if (!coinImageRef.current) return;\n            if (!coin.collected) {\n                ctx.save();\n                ctx.translate(coin.x + halfSize, coin.y + halfSize);\n                ctx.scale(scaleX, 1);\n                ctx.drawImage(coinImageRef.current, -halfSize, -halfSize, COIN_SIZE, COIN_SIZE);\n                ctx.restore();\n            }\n        });\n    };\n    // ---------------------------------------\n    // 10. GAME LOGIC FUNCTIONS\n    // ---------------------------------------\n    const createPipe = (canvas)=>{\n        const pipeHeight = Math.random() * (canvas.height - PIPE_SPACING - 100) + 50;\n        const bottomY = pipeHeight + PIPE_SPACING;\n        pipesRef.current.push({\n            x: canvas.width,\n            topHeight: pipeHeight,\n            bottomY,\n            bottomHeight: canvas.height - bottomY,\n            scored: false\n        });\n        // 50% chance for coin\n        if (Math.random() > 0.5) {\n            coinsRef.current.push({\n                x: canvas.width + PIPE_WIDTH / 2 - COIN_SIZE / 2,\n                y: pipeHeight + PIPE_SPACING / 2 - COIN_SIZE / 2,\n                width: COIN_SIZE,\n                height: COIN_SIZE,\n                collected: false\n            });\n        }\n    };\n    const movePipesAndCoins = (scale)=>{\n        // Move pipes to the left\n        pipesRef.current.forEach((pipe)=>{\n            pipe.x -= HORIZONTAL_SPEED * scale;\n        });\n        pipesRef.current = pipesRef.current.filter((p)=>p.x + PIPE_WIDTH > 0);\n        // Move coins\n        coinsRef.current.forEach((coin)=>{\n            coin.x -= HORIZONTAL_SPEED * scale;\n        });\n        coinsRef.current = coinsRef.current.filter((c)=>c.x + c.width > 0 && !c.collected);\n    };\n    const checkCollisions = (canvas)=>{\n        // Bird vs boundaries\n        if (birdYRef.current < 0 || birdYRef.current + BIRD_HEIGHT > canvas.height) {\n            return true;\n        }\n        const birdLeft = 100;\n        const birdRight = birdLeft + BIRD_WIDTH;\n        const birdTop = birdYRef.current;\n        const birdBottom = birdYRef.current + BIRD_HEIGHT;\n        // Bird vs pipes\n        for (const pipe of pipesRef.current){\n            const withinPipeX = birdRight > pipe.x && birdLeft < pipe.x + PIPE_WIDTH;\n            const withinPipeY = birdTop < pipe.topHeight || birdBottom > pipe.bottomY;\n            if (withinPipeX && withinPipeY) {\n                return true;\n            }\n        }\n        return false;\n    };\n    const checkCoinCollection = ()=>{\n        const birdLeft = 100;\n        const birdRight = birdLeft + BIRD_WIDTH;\n        const birdTop = birdYRef.current;\n        const birdBottom = birdYRef.current + BIRD_HEIGHT;\n        coinsRef.current.forEach((coin)=>{\n            if (!coin.collected) {\n                const coinLeft = coin.x;\n                const coinRight = coin.x + coin.width;\n                const coinTop = coin.y;\n                const coinBottom = coin.y + coin.height;\n                if (birdRight > coinLeft && birdLeft < coinRight && birdBottom > coinTop && birdTop < coinBottom) {\n                    // Collect coin\n                    coin.collected = true;\n                    setCurrentScore((prevScore)=>{\n                        const newScore = prevScore + 5;\n                        setHighScore((prevHighScore)=>Math.max(prevHighScore, newScore));\n                        return newScore;\n                    });\n                }\n            }\n        });\n    };\n    const updateScore = ()=>{\n        pipesRef.current.forEach((pipe)=>{\n            // Score +1 for passing each pipe, only once\n            if (!pipe.scored && pipe.x + PIPE_WIDTH < 100) {\n                pipe.scored = true;\n                setCurrentScore((prevScore)=>{\n                    const newScore = prevScore + 1;\n                    setHighScore((prevHighScore)=>{\n                        const updatedHighScore = Math.max(prevHighScore, newScore);\n                        if (true) {\n                            localStorage.setItem(\"highScore\", updatedHighScore.toString());\n                        }\n                        return updatedHighScore;\n                    });\n                    return newScore;\n                });\n            }\n        });\n    };\n    // ---------------------------------------\n    // 11. RETURN GAME STATS AND INPUT Handler\n    // ---------------------------------------\n    return {\n        highScore,\n        currentScore,\n        handleUserInput\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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K0IsR0FBRyxDQUFDRCxlQUFlRDt3QkFDeEQsT0FBT0E7b0JBQ1Q7Z0JBQ0Y7WUFDRjtRQUNGO0lBQ0Y7SUFFQSxNQUFNbkQsY0FBYztRQUNsQjlFLFNBQVNvQixPQUFPLENBQUN5RSxPQUFPLENBQUMsQ0FBQ0M7WUFDeEIsNENBQTRDO1lBQzVDLElBQUksQ0FBQ0EsS0FBS29CLE1BQU0sSUFBSXBCLEtBQUtDLENBQUMsR0FBR25ILGFBQWEsS0FBSztnQkFDN0NrSCxLQUFLb0IsTUFBTSxHQUFHO2dCQUNkdEgsZ0JBQWdCLENBQUNvSTtvQkFDZixNQUFNQyxXQUFXRCxZQUFZO29CQUM3QnRJLGFBQWEsQ0FBQ3dJO3dCQUNaLE1BQU1FLG1CQUFtQmhDLEtBQUsrQixHQUFHLENBQUNELGVBQWVEO3dCQUNqRCxJQUFJLElBQTZCLEVBQUU7NEJBQ2pDdkcsYUFBYTJHLE9BQU8sQ0FBQyxhQUFhRCxpQkFBaUJFLFFBQVE7d0JBQzdEO3dCQUNBLE9BQU9GO29CQUNUO29CQUNBLE9BQU9IO2dCQUNUO1lBQ0Y7UUFDRjtJQUNGO0lBRUEsMENBQTBDO0lBQzFDLDBDQUEwQztJQUMxQywwQ0FBMEM7SUFDMUMsT0FBTztRQUNMeEk7UUFDQUU7UUFDQThJO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wdWJsaWMvdXNlRmxhcHB5QmlyZEdhbWUudHM/NWM3OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaG9va3MvdXNlRmxhcHB5QmlyZEdhbWUudHNcclxuXHJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xyXG5cclxuLy8gVHlwZXMgZm9yIGdhbWUgb2JqZWN0c1xyXG5pbnRlcmZhY2UgUGlwZSB7XHJcbiAgeDogbnVtYmVyO1xyXG4gIHRvcEhlaWdodDogbnVtYmVyO1xyXG4gIGJvdHRvbVk6IG51bWJlcjtcclxuICBib3R0b21IZWlnaHQ6IG51bWJlcjtcclxuICBzY29yZWQ6IGJvb2xlYW47XHJcbn1cclxuXHJcbmludGVyZmFjZSBDb2luIHtcclxuICB4OiBudW1iZXI7XHJcbiAgeTogbnVtYmVyO1xyXG4gIHdpZHRoOiBudW1iZXI7XHJcbiAgaGVpZ2h0OiBudW1iZXI7XHJcbiAgY29sbGVjdGVkOiBib29sZWFuO1xyXG59XHJcblxyXG4vLyBDb25zdGFudHNcclxuY29uc3QgR1JBVklUWSA9IDAuNztcclxuY29uc3QgRkxBUCA9IC0xMTtcclxuY29uc3QgUElQRV9XSURUSCA9IDkwO1xyXG5jb25zdCBQSVBFX1NQQUNJTkcgPSAyMzA7XHJcbmNvbnN0IEJJUkRfV0lEVEggPSA1MDtcclxuY29uc3QgQklSRF9IRUlHSFQgPSA1MDtcclxuY29uc3QgQ09JTl9TSVpFID0gMTAwO1xyXG5cclxuLy8gSG93IGxvbmcgYmV0d2VlbiBwaXBlIHNwYXducyAoaW4gbWlsbGlzZWNvbmRzKVxyXG5jb25zdCBQSVBFX1NQQVdOX0lOVEVSVkFMID0gMTAwMDtcclxuXHJcbi8vIEhvcml6b250YWwgc3BlZWQgKHBpeGVscyBwZXIgXCI2MGZwc1wiIGZyYW1lKS4gV2UnbGwgc2NhbGUgaXQgYnkgKGRlbHRhVGltZS8xNi42NykuXHJcbmNvbnN0IEhPUklaT05UQUxfU1BFRUQgPSA0O1xyXG5cclxuLy8gUm90YXRpb24gc3BlZWQgb2YgY29pbiAoY29tcGxldGUgZmxpcCBmcm9tIHNjYWxlIDEgdG8gMCB0byAxKS4gMSA9IGZ1bGwgY3ljbGUuXHJcbmNvbnN0IFJPVEFUSU9OX1NQRUVEID0gMC4wMTtcclxuXHJcbi8vIEEgc21hbGwgY29uc3RhbnQgcmVwcmVzZW50aW5nIHRoZSBcImlkZWFsIGZyYW1lXCIgZm9yIHNjYWxpbmcgY2FsY3VsYXRpb25zIChhYm91dCA2MGZwcykuXHJcbmNvbnN0IElERUFMX0ZSQU1FID0gMTYuNjc7IC8vIG1zXHJcblxyXG4vKipcclxuICogQ3VzdG9tIEhvb2s6IHVzZUZsYXBweUJpcmRHYW1lXHJcbiAqIEhhbmRsZXMgRmxhcHB5IEJpcmQgZ2FtZSBsb2dpYywgaW5jbHVkaW5nOlxyXG4gKiAtIENhbnZhcyBzZXR1cFxyXG4gKiAtIEJpcmQgbW92ZW1lbnQgLyBmbGFwcGluZ1xyXG4gKiAtIFBpcGUgJiBjb2luIHNwYXduaW5nXHJcbiAqIC0gU2NvcmUgdHJhY2tpbmdcclxuICogLSBNb2JpbGUvZGVza3RvcCBpbnB1dCBoYW5kbGluZ1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUZsYXBweUJpcmRHYW1lKFxyXG4gIGNhbnZhc1JlZjogUmVhY3QuUmVmT2JqZWN0PEhUTUxDYW52YXNFbGVtZW50PixcclxuICBpc1BhdXNlZDogYm9vbGVhbixcclxuICBhdXRvU3RhcnQ6IGJvb2xlYW5cclxuKSB7XHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvLyAxLiBUT1AtTEVWRUwgSE9PS1MgJiBSRUZTXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgLy8gUmVhY3QgU3RhdGVcclxuICBjb25zdCBbaGlnaFNjb3JlLCBzZXRIaWdoU2NvcmVdID0gdXNlU3RhdGUoMCk7XHJcbiAgY29uc3QgW2N1cnJlbnRTY29yZSwgc2V0Q3VycmVudFNjb3JlXSA9IHVzZVN0YXRlKDApO1xyXG5cclxuICAvLyBHYW1lIFJlZnNcclxuICBjb25zdCByZXF1ZXN0SWRSZWYgPSB1c2VSZWY8bnVtYmVyIHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgYmlyZFlSZWYgPSB1c2VSZWY8bnVtYmVyPigwKTtcclxuICBjb25zdCBiaXJkVmVsb2NpdHlSZWYgPSB1c2VSZWY8bnVtYmVyPigwKTtcclxuICBjb25zdCBwaXBlc1JlZiA9IHVzZVJlZjxQaXBlW10+KFtdKTtcclxuICBjb25zdCBjb2luc1JlZiA9IHVzZVJlZjxDb2luW10+KFtdKTtcclxuICBjb25zdCBnYW1lT3ZlclJlZiA9IHVzZVJlZjxib29sZWFuPihmYWxzZSk7XHJcbiAgY29uc3QgZ2FtZVN0YXJ0ZWRSZWYgPSB1c2VSZWY8Ym9vbGVhbj4oZmFsc2UpO1xyXG5cclxuICAvLyBDb2luIHJvdGF0aW9uICYgcGlwZSBzcGF3biB0aW1lclxyXG4gIGNvbnN0IGNvaW5Sb3RhdGlvblJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xyXG4gIGNvbnN0IHBpcGVTcGF3blRpbWVyUmVmID0gdXNlUmVmPG51bWJlcj4oMCk7XHJcblxyXG4gIC8vIFRpbWVzdGFtcCBmb3IgdGltZS1iYXNlZCBtb3ZlbWVudFxyXG4gIGNvbnN0IGxhc3RUaW1lUmVmID0gdXNlUmVmPG51bWJlcj4oMCk7XHJcblxyXG4gIC8vIEJpcmQgYW5pbWF0aW9uIGZyYW1lc1xyXG4gIGNvbnN0IGJpcmRJbWFnZXNSZWYgPSB1c2VSZWY8SFRNTEltYWdlRWxlbWVudFtdPihbXSk7XHJcbiAgY29uc3QgcGlwZVRvcFJlZiA9IHVzZVJlZjxIVE1MSW1hZ2VFbGVtZW50IHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgcGlwZUJvdHRvbVJlZiA9IHVzZVJlZjxIVE1MSW1hZ2VFbGVtZW50IHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgYmFja2dyb3VuZFJlZiA9IHVzZVJlZjxIVE1MSW1hZ2VFbGVtZW50IHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgY29pbkltYWdlUmVmID0gdXNlUmVmPEhUTUxJbWFnZUVsZW1lbnQgfCBudWxsPihudWxsKTtcclxuXHJcbiAgLy8gQ3VycmVudCBCaXJkIEZyYW1lXHJcbiAgY29uc3QgY3VycmVudEJpcmRGcmFtZVJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xyXG5cclxuICAvLyBGb3IgZGVib3VuY2luZyB0YXBzIG9uIG1vYmlsZVxyXG4gIGNvbnN0IGxhc3RUYXBSZWYgPSB1c2VSZWY8bnVtYmVyPigwKTtcclxuICBjb25zdCBERUJPVU5DRV9USU1FID0gMzAwOyAvLyBtc1xyXG5cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIDIuIElNQUdFIFBSRUxPQUQgKG9ubHkgb24gY2xpZW50KVxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm47IC8vIEVuc3VyZSB0aGlzIHJ1bnMgb25seSBvbiBjbGllbnRcclxuXHJcbiAgICBjb25zdCBiaXJkVXAgPSBuZXcgSW1hZ2UoKTtcclxuICAgIGJpcmRVcC5zcmMgPSBcIi9hc3NldHMvcmVkYmlyZC11cGZsYXAucG5nXCI7XHJcblxyXG4gICAgY29uc3QgYmlyZE1pZCA9IG5ldyBJbWFnZSgpO1xyXG4gICAgYmlyZE1pZC5zcmMgPSBcIi9hc3NldHMvcmVkYmlyZC1taWRmbGFwLnBuZ1wiO1xyXG5cclxuICAgIGNvbnN0IGJpcmREb3duID0gbmV3IEltYWdlKCk7XHJcbiAgICBiaXJkRG93bi5zcmMgPSBcIi9hc3NldHMvcmVkYmlyZC1kb3duZmxhcC5wbmdcIjtcclxuXHJcbiAgICBiaXJkSW1hZ2VzUmVmLmN1cnJlbnQgPSBbYmlyZFVwLCBiaXJkTWlkLCBiaXJkRG93bl07XHJcblxyXG4gICAgY29uc3QgcGlwZVRvcCA9IG5ldyBJbWFnZSgpO1xyXG4gICAgcGlwZVRvcC5zcmMgPSBcIi9hc3NldHMvVG9wVGlueS5wbmdcIjtcclxuICAgIHBpcGVUb3BSZWYuY3VycmVudCA9IHBpcGVUb3A7XHJcblxyXG4gICAgY29uc3QgcGlwZUJvdHRvbSA9IG5ldyBJbWFnZSgpO1xyXG4gICAgcGlwZUJvdHRvbS5zcmMgPSBcIi9hc3NldHMvQm90dG9tVGlueS5wbmdcIjtcclxuICAgIHBpcGVCb3R0b21SZWYuY3VycmVudCA9IHBpcGVCb3R0b207XHJcblxyXG4gICAgY29uc3QgYmFja2dyb3VuZCA9IG5ldyBJbWFnZSgpO1xyXG4gICAgYmFja2dyb3VuZC5zcmMgPSBcIi9hc3NldHMvYmFja2dyb3VuZC1kYXkucG5nXCI7XHJcbiAgICBiYWNrZ3JvdW5kUmVmLmN1cnJlbnQgPSBiYWNrZ3JvdW5kO1xyXG5cclxuICAgIGNvbnN0IGNvaW5JbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG4gICAgY29pbkltYWdlLnNyYyA9IFwiL2Fzc2V0cy9Db2luVGlueS5wbmdcIjtcclxuICAgIGNvaW5JbWFnZVJlZi5jdXJyZW50ID0gY29pbkltYWdlO1xyXG4gIH0sIFtdKTtcclxuXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIDMuIExPQUQgSElHSCBTQ09SRSBPTiBIT09LIElOSVRcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgIGNvbnN0IHN0b3JlZEhpZ2hTY29yZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwiaGlnaFNjb3JlXCIpO1xyXG4gICAgICBpZiAoc3RvcmVkSGlnaFNjb3JlKSB7XHJcbiAgICAgICAgc2V0SGlnaFNjb3JlKHBhcnNlSW50KHN0b3JlZEhpZ2hTY29yZSwgMTApKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sIFtdKTtcclxuXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIDQuIE1BSU4gdXNlRWZmZWN0OiBTRVRVUCAmIFRFQVJET1dOXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcclxuICAgIGlmICghY2FudmFzKSByZXR1cm47XHJcblxyXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuICAgIGlmICghY3R4KSByZXR1cm47XHJcblxyXG4gICAgLy8gVXRpbGl0eTogRW5zdXJlIGFuIGltYWdlIGlzIGZ1bGx5IGxvYWRlZFxyXG4gICAgY29uc3QgbG9hZEltYWdlID0gKGltZzogSFRNTEltYWdlRWxlbWVudCk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIGlmIChpbWcuY29tcGxldGUpIHtcclxuICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHJlc29sdmUoKTtcclxuICAgICAgICAgIGltZy5vbmVycm9yID0gKCkgPT4gcmVqZWN0KG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgJHtpbWcuc3JjfWApKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBMb2FkIGltYWdlcywgdGhlbiBpbml0aWFsaXplXHJcbiAgICBjb25zdCBsb2FkQXNzZXRzID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgICAgICAgIC4uLmJpcmRJbWFnZXNSZWYuY3VycmVudC5tYXAoKGltZykgPT4gbG9hZEltYWdlKGltZykpLFxyXG4gICAgICAgICAgcGlwZVRvcFJlZi5jdXJyZW50ID8gbG9hZEltYWdlKHBpcGVUb3BSZWYuY3VycmVudCkgOiBQcm9taXNlLnJlc29sdmUoKSxcclxuICAgICAgICAgIHBpcGVCb3R0b21SZWYuY3VycmVudCA/IGxvYWRJbWFnZShwaXBlQm90dG9tUmVmLmN1cnJlbnQpIDogUHJvbWlzZS5yZXNvbHZlKCksXHJcbiAgICAgICAgICBiYWNrZ3JvdW5kUmVmLmN1cnJlbnQgPyBsb2FkSW1hZ2UoYmFja2dyb3VuZFJlZi5jdXJyZW50KSA6IFByb21pc2UucmVzb2x2ZSgpLFxyXG4gICAgICAgICAgY29pbkltYWdlUmVmLmN1cnJlbnQgPyBsb2FkSW1hZ2UoY29pbkltYWdlUmVmLmN1cnJlbnQpIDogUHJvbWlzZS5yZXNvbHZlKCksXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgaW5pdGlhbGl6ZUdhbWUoKTtcclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGxvYWRpbmcgYXNzZXRzOlwiLCBlcnIpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgbG9hZEFzc2V0cygpO1xyXG5cclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gNEE6IElOSVRJQUxJWkUgLyBSRVNFVCBHQU1FXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIGZ1bmN0aW9uIGluaXRpYWxpemVHYW1lKCkge1xyXG4gICAgICBpZiAoIWNhbnZhc1JlZi5jdXJyZW50IHx8ICFjdHgpIHJldHVybjtcclxuICAgICAgY2FudmFzUmVmLmN1cnJlbnQud2lkdGggPSAzNjA7XHJcbiAgICAgIGNhbnZhc1JlZi5jdXJyZW50LmhlaWdodCA9IDY0MDtcclxuICAgICAgZHJhd1N0YXJ0U2NyZWVuKGN0eCwgY2FudmFzUmVmLmN1cnJlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlc2V0R2FtZSgpIHtcclxuICAgICAgaWYgKCFjYW52YXNSZWYuY3VycmVudCkgcmV0dXJuO1xyXG4gICAgICBjb25zdCB7IGhlaWdodCB9ID0gY2FudmFzUmVmLmN1cnJlbnQ7XHJcbiAgICAgIGJpcmRZUmVmLmN1cnJlbnQgPSBoZWlnaHQgLyAzO1xyXG4gICAgICBiaXJkVmVsb2NpdHlSZWYuY3VycmVudCA9IDA7XHJcbiAgICAgIHBpcGVzUmVmLmN1cnJlbnQgPSBbXTtcclxuICAgICAgY29pbnNSZWYuY3VycmVudCA9IFtdO1xyXG4gICAgICBzZXRDdXJyZW50U2NvcmUoMCk7XHJcbiAgICAgIGdhbWVPdmVyUmVmLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgICAgZ2FtZVN0YXJ0ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xyXG4gICAgICBjb2luUm90YXRpb25SZWYuY3VycmVudCA9IDA7XHJcbiAgICAgIHBpcGVTcGF3blRpbWVyUmVmLmN1cnJlbnQgPSAwO1xyXG4gICAgICBjdXJyZW50QmlyZEZyYW1lUmVmLmN1cnJlbnQgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERlc2t0b3Aga2V5Ym9hcmQgaW5wdXRcclxuICAgIGZ1bmN0aW9uIGhhbmRsZUtleURvd24oZTogS2V5Ym9hcmRFdmVudCkge1xyXG4gICAgICBpZiAoZS5rZXkgPT09IFwiIFwiKSB7XHJcbiAgICAgICAgaGFuZGxlVXNlcklucHV0V2l0aERlYm91bmNlKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBoYW5kbGVLZXlEb3duKTtcclxuXHJcbiAgICAvLyBIYW5kbGUgcmVzaXppbmdcclxuICAgIGZ1bmN0aW9uIGhhbmRsZVJlc2l6ZSgpIHtcclxuICAgICAgaWYgKCFjYW52YXNSZWYuY3VycmVudCkgcmV0dXJuO1xyXG4gICAgICBjYW52YXNSZWYuY3VycmVudC53aWR0aCA9IDM2MDtcclxuICAgICAgY2FudmFzUmVmLmN1cnJlbnQuaGVpZ2h0ID0gNjQwO1xyXG4gICAgICBpZiAoIWdhbWVTdGFydGVkUmVmLmN1cnJlbnQgJiYgIWdhbWVPdmVyUmVmLmN1cnJlbnQgJiYgY3R4KSB7XHJcbiAgICAgICAgZHJhd1N0YXJ0U2NyZWVuKGN0eCwgY2FudmFzUmVmLmN1cnJlbnQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBoYW5kbGVSZXNpemUpO1xyXG5cclxuICAgIC8vIFN0YXJ0IGdhbWVcclxuICAgIGZ1bmN0aW9uIHN0YXJ0R2FtZSgpIHtcclxuICAgICAgcmVzZXRHYW1lKCk7XHJcbiAgICAgIGdhbWVTdGFydGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xyXG4gICAgICBsYXN0VGltZVJlZi5jdXJyZW50ID0gcGVyZm9ybWFuY2Uubm93KCk7IC8vIHJlc2V0IG91ciB0aW1lLWJhc2VkIHJlZmVyZW5jZVxyXG4gICAgICByZXF1ZXN0SWRSZWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEZWJvdW5jZWQgaGFuZGxlVXNlcklucHV0XHJcbiAgICBmdW5jdGlvbiBoYW5kbGVVc2VySW5wdXRXaXRoRGVib3VuY2UoKSB7XHJcbiAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICAgIGlmIChub3cgLSBsYXN0VGFwUmVmLmN1cnJlbnQgPCBERUJPVU5DRV9USU1FKSB7XHJcbiAgICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgaWYgd2l0aGluIGRlYm91bmNlIHRpbWVcclxuICAgICAgfVxyXG4gICAgICBsYXN0VGFwUmVmLmN1cnJlbnQgPSBub3c7XHJcblxyXG4gICAgICBpZiAoIWdhbWVTdGFydGVkUmVmLmN1cnJlbnQgJiYgIWdhbWVPdmVyUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBzdGFydEdhbWUoKTtcclxuICAgICAgfSBlbHNlIGlmIChnYW1lT3ZlclJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgc3RhcnRHYW1lKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYmlyZFZlbG9jaXR5UmVmLmN1cnJlbnQgPSBGTEFQO1xyXG4gICAgICAgIGZsYXBBbmltYXRpb24oKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFF1aWNrIGZsYXAgYW5pbWF0aW9uXHJcbiAgICBmdW5jdGlvbiBmbGFwQW5pbWF0aW9uKCkge1xyXG4gICAgICBjdXJyZW50QmlyZEZyYW1lUmVmLmN1cnJlbnQgPSAxO1xyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBjdXJyZW50QmlyZEZyYW1lUmVmLmN1cnJlbnQgPSAyO1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgY3VycmVudEJpcmRGcmFtZVJlZi5jdXJyZW50ID0gMDtcclxuICAgICAgICB9LCAxNzApO1xyXG4gICAgICB9LCAxNzApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE1haW4gZ2FtZSBsb29wXHJcbiAgICBmdW5jdGlvbiBhbmltYXRlKGN1cnJlbnRUaW1lPzogbnVtYmVyKSB7XHJcbiAgICAgIGlmICghZ2FtZVN0YXJ0ZWRSZWYuY3VycmVudCkge1xyXG4gICAgICAgIC8vIElmIGdhbWUgaGFzbid0IHN0YXJ0ZWQsIGp1c3Qgc2NoZWR1bGUgdGhlIG5leHQgZnJhbWVcclxuICAgICAgICByZXF1ZXN0SWRSZWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGlzUGF1c2VkKSB7XHJcbiAgICAgICAgLy8gSWYgcGF1c2VkLCBqdXN0IHNjaGVkdWxlIHRoZSBuZXh0IGZyYW1lXHJcbiAgICAgICAgcmVxdWVzdElkUmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghY2FudmFzUmVmLmN1cnJlbnQpIHJldHVybjtcclxuICAgICAgY29uc3QgY29udGV4dCA9IGNhbnZhc1JlZi5jdXJyZW50LmdldENvbnRleHQoXCIyZFwiKTtcclxuICAgICAgaWYgKCFjb250ZXh0KSByZXR1cm47XHJcblxyXG4gICAgICBjb25zdCBub3cgPSBjdXJyZW50VGltZSA/PyBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgY29uc3QgZGVsdGFUaW1lID0gbm93IC0gbGFzdFRpbWVSZWYuY3VycmVudDtcclxuICAgICAgbGFzdFRpbWVSZWYuY3VycmVudCA9IG5vdztcclxuXHJcbiAgICAgIHVwZGF0ZUdhbWVTdGF0ZShjYW52YXNSZWYuY3VycmVudCwgZGVsdGFUaW1lKTtcclxuICAgICAgZHJhdyhjb250ZXh0LCBjYW52YXNSZWYuY3VycmVudCk7XHJcblxyXG4gICAgICBpZiAoIWdhbWVPdmVyUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICByZXF1ZXN0SWRSZWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBkcmF3R2FtZU92ZXJTY3JlZW4oY29udGV4dCwgY2FudmFzUmVmLmN1cnJlbnQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdXBkYXRlR2FtZVN0YXRlKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIGRlbHRhVGltZTogbnVtYmVyKSB7XHJcbiAgICAgIGNvbnN0IHNjYWxlID0gZGVsdGFUaW1lIC8gSURFQUxfRlJBTUU7XHJcblxyXG4gICAgICAvLyBHcmF2aXR5XHJcbiAgICAgIGJpcmRWZWxvY2l0eVJlZi5jdXJyZW50ICs9IEdSQVZJVFkgKiBzY2FsZTtcclxuICAgICAgYmlyZFlSZWYuY3VycmVudCArPSBiaXJkVmVsb2NpdHlSZWYuY3VycmVudCAqIHNjYWxlO1xyXG5cclxuICAgICAgLy8gUGlwZSBzcGF3blxyXG4gICAgICBwaXBlU3Bhd25UaW1lclJlZi5jdXJyZW50ICs9IGRlbHRhVGltZTtcclxuICAgICAgaWYgKHBpcGVTcGF3blRpbWVyUmVmLmN1cnJlbnQgPj0gUElQRV9TUEFXTl9JTlRFUlZBTCkge1xyXG4gICAgICAgIHBpcGVTcGF3blRpbWVyUmVmLmN1cnJlbnQgLT0gUElQRV9TUEFXTl9JTlRFUlZBTDtcclxuICAgICAgICBjcmVhdGVQaXBlKGNhbnZhcyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE1vdmUgcGlwZXMgJiBjb2luc1xyXG4gICAgICBtb3ZlUGlwZXNBbmRDb2lucyhzY2FsZSk7XHJcblxyXG4gICAgICAvLyBSb3RhdGUgY29pblxyXG4gICAgICBjb2luUm90YXRpb25SZWYuY3VycmVudCArPSBST1RBVElPTl9TUEVFRCAqIHNjYWxlO1xyXG4gICAgICBpZiAoY29pblJvdGF0aW9uUmVmLmN1cnJlbnQgPj0gMSkge1xyXG4gICAgICAgIGNvaW5Sb3RhdGlvblJlZi5jdXJyZW50ID0gMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ29sbGlzaW9uc1xyXG4gICAgICBpZiAoY2hlY2tDb2xsaXNpb25zKGNhbnZhcykpIHtcclxuICAgICAgICBnYW1lT3ZlclJlZi5jdXJyZW50ID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENvaW4gY29sbGVjdGlvblxyXG4gICAgICBjaGVja0NvaW5Db2xsZWN0aW9uKCk7XHJcblxyXG4gICAgICAvLyBTY29yZVxyXG4gICAgICB1cGRhdGVTY29yZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gNEM6IERSQVcgRlVOQ1RJT05TXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIGZ1bmN0aW9uIGRyYXcoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcclxuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICBkcmF3QmFja2dyb3VuZChjdHgsIGNhbnZhcyk7XHJcbiAgICAgIGRyYXdCaXJkKGN0eCk7XHJcbiAgICAgIGRyYXdQaXBlcyhjdHgpO1xyXG4gICAgICBkcmF3Q29pbnMoY3R4KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3U3RhcnRTY3JlZW4oY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcclxuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICBkcmF3QmFja2dyb3VuZChjdHgsIGNhbnZhcyk7XHJcblxyXG4gICAgICBjdHguZm9udCA9IFwiYm9sZCAzMHB4IEFyaWFsXCI7XHJcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xyXG4gICAgICBjdHguZmlsbFN0eWxlID0gXCIjZmZmZmZmXCI7XHJcbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFwiYmxhY2tcIjtcclxuICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XHJcblxyXG4gICAgICBjdHguZmlsbFRleHQoXCJUYXAgb3IgUHJlc3MgU3BhY2UgdG8gU3RhcnRcIiwgY2FudmFzLndpZHRoIC8gMiwgY2FudmFzLmhlaWdodCAvIDIpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdHYW1lT3ZlclNjcmVlbihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkge1xyXG4gICAgICBjdHguZmlsbFN0eWxlID0gXCIjZmZjYzAwXCI7XHJcbiAgICAgIGN0eC5mb250ID0gXCJib2xkIDUwcHggQXJpYWxcIjtcclxuICAgICAgY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XHJcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xyXG4gICAgICBjdHguc2hhZG93Q29sb3IgPSBcImJsYWNrXCI7XHJcbiAgICAgIGN0eC5zaGFkb3dCbHVyID0gMTA7XHJcblxyXG4gICAgICBjdHguZmlsbFRleHQoXCJHYW1lIE92ZXIhXCIsIGNhbnZhcy53aWR0aCAvIDIsIGNhbnZhcy5oZWlnaHQgLyAyIC0gNDApO1xyXG5cclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiI2ZmZmZmZlwiO1xyXG4gICAgICBjdHguZm9udCA9IFwiYm9sZCAzMHB4IEFyaWFsXCI7XHJcbiAgICAgIGN0eC5maWxsVGV4dChcclxuICAgICAgICBcIlRhcCBvciBQcmVzcyBTcGFjZSB0byBSZXN0YXJ0XCIsXHJcbiAgICAgICAgY2FudmFzLndpZHRoIC8gMixcclxuICAgICAgICBjYW52YXMuaGVpZ2h0IC8gMiArIDIwXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd0JhY2tncm91bmQoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcclxuICAgICAgaWYgKGJhY2tncm91bmRSZWYuY3VycmVudCAmJiBiYWNrZ3JvdW5kUmVmLmN1cnJlbnQuY29tcGxldGUpIHtcclxuICAgICAgICBjdHguZHJhd0ltYWdlKGJhY2tncm91bmRSZWYuY3VycmVudCwgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdCaXJkKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XHJcbiAgICAgIGNvbnN0IGN1cnJlbnRJbWFnZSA9IGJpcmRJbWFnZXNSZWYuY3VycmVudFtjdXJyZW50QmlyZEZyYW1lUmVmLmN1cnJlbnRdO1xyXG4gICAgICBpZiAoY3VycmVudEltYWdlICYmIGN1cnJlbnRJbWFnZS5jb21wbGV0ZSkge1xyXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoY3VycmVudEltYWdlLCAxMDAsIGJpcmRZUmVmLmN1cnJlbnQsIEJJUkRfV0lEVEgsIEJJUkRfSEVJR0hUKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdQaXBlcyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xyXG4gICAgICBwaXBlc1JlZi5jdXJyZW50LmZvckVhY2goKHBpcGUpID0+IHtcclxuICAgICAgICBpZiAocGlwZVRvcFJlZi5jdXJyZW50ICYmIHBpcGVUb3BSZWYuY3VycmVudC5jb21wbGV0ZSkge1xyXG4gICAgICAgICAgY3R4LmRyYXdJbWFnZShwaXBlVG9wUmVmLmN1cnJlbnQsIHBpcGUueCwgMCwgUElQRV9XSURUSCwgcGlwZS50b3BIZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGlwZUJvdHRvbVJlZi5jdXJyZW50ICYmIHBpcGVCb3R0b21SZWYuY3VycmVudC5jb21wbGV0ZSkge1xyXG4gICAgICAgICAgY3R4LmRyYXdJbWFnZShwaXBlQm90dG9tUmVmLmN1cnJlbnQsIHBpcGUueCwgcGlwZS5ib3R0b21ZLCBQSVBFX1dJRFRILCBwaXBlLmJvdHRvbUhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3Q29pbnMoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcclxuICAgICAgaWYgKCFjb2luSW1hZ2VSZWYuY3VycmVudCB8fCAhY29pbkltYWdlUmVmLmN1cnJlbnQuY29tcGxldGUpIHJldHVybjtcclxuICAgICAgY29uc3Qgc2NhbGVYID0gTWF0aC5hYnMoTWF0aC5jb3MoY29pblJvdGF0aW9uUmVmLmN1cnJlbnQgKiBNYXRoLlBJICogMikpO1xyXG4gICAgICBjb25zdCBoYWxmU2l6ZSA9IENPSU5fU0laRSAvIDI7XHJcbiAgICAgIGNvaW5zUmVmLmN1cnJlbnQuZm9yRWFjaCgoY29pbikgPT4ge1xyXG4gICAgICAgIGlmICghY29pbi5jb2xsZWN0ZWQpIHtcclxuICAgICAgICAgIGlmICghY29pbkltYWdlUmVmLmN1cnJlbnQpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICBjdHgudHJhbnNsYXRlKGNvaW4ueCArIGhhbGZTaXplLCBjb2luLnkgKyBoYWxmU2l6ZSk7XHJcbiAgICAgICAgICBjdHguc2NhbGUoc2NhbGVYLCAxKTtcclxuICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoY29pbkltYWdlUmVmLmN1cnJlbnQsIC1oYWxmU2l6ZSwgLWhhbGZTaXplLCBDT0lOX1NJWkUsIENPSU5fU0laRSk7XHJcbiAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyA0RDogR0FNRSBMT0dJQyBGVU5DVElPTlNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgZnVuY3Rpb24gY3JlYXRlUGlwZShjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgIGNvbnN0IHBpcGVIZWlnaHQgPSBNYXRoLnJhbmRvbSgpICogKGNhbnZhcy5oZWlnaHQgLSBQSVBFX1NQQUNJTkcgLSAxMDApICsgNTA7XHJcbiAgICAgIGNvbnN0IGJvdHRvbVkgPSBwaXBlSGVpZ2h0ICsgUElQRV9TUEFDSU5HO1xyXG4gICAgICBwaXBlc1JlZi5jdXJyZW50LnB1c2goe1xyXG4gICAgICAgIHg6IGNhbnZhcy53aWR0aCxcclxuICAgICAgICB0b3BIZWlnaHQ6IHBpcGVIZWlnaHQsXHJcbiAgICAgICAgYm90dG9tWSxcclxuICAgICAgICBib3R0b21IZWlnaHQ6IGNhbnZhcy5oZWlnaHQgLSBib3R0b21ZLFxyXG4gICAgICAgIHNjb3JlZDogZmFsc2UsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gNTAlIGNoYW5jZSBmb3IgY29pblxyXG4gICAgICBpZiAoTWF0aC5yYW5kb20oKSA+IDAuNSkge1xyXG4gICAgICAgIGNvaW5zUmVmLmN1cnJlbnQucHVzaCh7XHJcbiAgICAgICAgICB4OiBjYW52YXMud2lkdGggKyBQSVBFX1dJRFRIIC8gMiAtIENPSU5fU0laRSAvIDIsXHJcbiAgICAgICAgICB5OiBwaXBlSGVpZ2h0ICsgUElQRV9TUEFDSU5HIC8gMiAtIENPSU5fU0laRSAvIDIsXHJcbiAgICAgICAgICB3aWR0aDogQ09JTl9TSVpFLFxyXG4gICAgICAgICAgaGVpZ2h0OiBDT0lOX1NJWkUsXHJcbiAgICAgICAgICBjb2xsZWN0ZWQ6IGZhbHNlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbW92ZVBpcGVzQW5kQ29pbnMoc2NhbGU6IG51bWJlcikge1xyXG4gICAgICAvLyBNb3ZlIHBpcGVzIHRvIHRoZSBsZWZ0XHJcbiAgICAgIHBpcGVzUmVmLmN1cnJlbnQuZm9yRWFjaCgocGlwZSkgPT4ge1xyXG4gICAgICAgIHBpcGUueCAtPSBIT1JJWk9OVEFMX1NQRUVEICogc2NhbGU7XHJcbiAgICAgIH0pO1xyXG4gICAgICBwaXBlc1JlZi5jdXJyZW50ID0gcGlwZXNSZWYuY3VycmVudC5maWx0ZXIoKHApID0+IHAueCArIFBJUEVfV0lEVEggPiAwKTtcclxuXHJcbiAgICAgIC8vIE1vdmUgY29pbnNcclxuICAgICAgY29pbnNSZWYuY3VycmVudC5mb3JFYWNoKChjb2luKSA9PiB7XHJcbiAgICAgICAgY29pbi54IC09IEhPUklaT05UQUxfU1BFRUQgKiBzY2FsZTtcclxuICAgICAgfSk7XHJcbiAgICAgIGNvaW5zUmVmLmN1cnJlbnQgPSBjb2luc1JlZi5jdXJyZW50LmZpbHRlcihcclxuICAgICAgICAoYykgPT4gYy54ICsgYy53aWR0aCA+IDAgJiYgIWMuY29sbGVjdGVkXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2hlY2tDb2xsaXNpb25zKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpOiBib29sZWFuIHtcclxuICAgICAgLy8gQmlyZCB2cyBib3VuZGFyaWVzXHJcbiAgICAgIGlmIChiaXJkWVJlZi5jdXJyZW50IDwgMCB8fCBiaXJkWVJlZi5jdXJyZW50ICsgQklSRF9IRUlHSFQgPiBjYW52YXMuaGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGJpcmRMZWZ0ID0gMTAwO1xyXG4gICAgICBjb25zdCBiaXJkUmlnaHQgPSBiaXJkTGVmdCArIEJJUkRfV0lEVEg7XHJcbiAgICAgIGNvbnN0IGJpcmRUb3AgPSBiaXJkWVJlZi5jdXJyZW50O1xyXG4gICAgICBjb25zdCBiaXJkQm90dG9tID0gYmlyZFlSZWYuY3VycmVudCArIEJJUkRfSEVJR0hUO1xyXG5cclxuICAgICAgLy8gQmlyZCB2cyBwaXBlc1xyXG4gICAgICBmb3IgKGNvbnN0IHBpcGUgb2YgcGlwZXNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGNvbnN0IHdpdGhpblBpcGVYID0gYmlyZFJpZ2h0ID4gcGlwZS54ICYmIGJpcmRMZWZ0IDwgcGlwZS54ICsgUElQRV9XSURUSDtcclxuICAgICAgICBjb25zdCB3aXRoaW5QaXBlWSA9IGJpcmRUb3AgPCBwaXBlLnRvcEhlaWdodCB8fCBiaXJkQm90dG9tID4gcGlwZS5ib3R0b21ZO1xyXG4gICAgICAgIGlmICh3aXRoaW5QaXBlWCAmJiB3aXRoaW5QaXBlWSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjaGVja0NvaW5Db2xsZWN0aW9uKCkge1xyXG4gICAgICBjb25zdCBiaXJkTGVmdCA9IDEwMDtcclxuICAgICAgY29uc3QgYmlyZFJpZ2h0ID0gYmlyZExlZnQgKyBCSVJEX1dJRFRIO1xyXG4gICAgICBjb25zdCBiaXJkVG9wID0gYmlyZFlSZWYuY3VycmVudDtcclxuICAgICAgY29uc3QgYmlyZEJvdHRvbSA9IGJpcmRZUmVmLmN1cnJlbnQgKyBCSVJEX0hFSUdIVDtcclxuXHJcbiAgICAgIGNvaW5zUmVmLmN1cnJlbnQuZm9yRWFjaCgoY29pbikgPT4ge1xyXG4gICAgICAgIGlmICghY29pbi5jb2xsZWN0ZWQpIHtcclxuICAgICAgICAgIGNvbnN0IGNvaW5MZWZ0ID0gY29pbi54O1xyXG4gICAgICAgICAgY29uc3QgY29pblJpZ2h0ID0gY29pbi54ICsgY29pbi53aWR0aDtcclxuICAgICAgICAgIGNvbnN0IGNvaW5Ub3AgPSBjb2luLnk7XHJcbiAgICAgICAgICBjb25zdCBjb2luQm90dG9tID0gY29pbi55ICsgY29pbi5oZWlnaHQ7XHJcblxyXG4gICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICBiaXJkUmlnaHQgPiBjb2luTGVmdCAmJlxyXG4gICAgICAgICAgICBiaXJkTGVmdCA8IGNvaW5SaWdodCAmJlxyXG4gICAgICAgICAgICBiaXJkQm90dG9tID4gY29pblRvcCAmJlxyXG4gICAgICAgICAgICBiaXJkVG9wIDwgY29pbkJvdHRvbVxyXG4gICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIC8vIENvbGxlY3QgY29pblxyXG4gICAgICAgICAgICBjb2luLmNvbGxlY3RlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHNldEN1cnJlbnRTY29yZSgocHJldlNjb3JlKSA9PiB7XHJcbiAgICAgICAgICAgICAgY29uc3QgbmV3U2NvcmUgPSBwcmV2U2NvcmUgKyA1O1xyXG4gICAgICAgICAgICAgIHNldEhpZ2hTY29yZSgocHJldkhpZ2hTY29yZSkgPT4gTWF0aC5tYXgocHJldkhpZ2hTY29yZSwgbmV3U2NvcmUpKTtcclxuICAgICAgICAgICAgICByZXR1cm4gbmV3U2NvcmU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdXBkYXRlU2NvcmUoKSB7XHJcbiAgICAgIHBpcGVzUmVmLmN1cnJlbnQuZm9yRWFjaCgocGlwZSkgPT4ge1xyXG4gICAgICAgIC8vIFNjb3JlICsxIGZvciBwYXNzaW5nIGVhY2ggcGlwZSwgb25seSBvbmNlXHJcbiAgICAgICAgaWYgKCFwaXBlLnNjb3JlZCAmJiBwaXBlLnggKyBQSVBFX1dJRFRIIDwgMTAwKSB7XHJcbiAgICAgICAgICBwaXBlLnNjb3JlZCA9IHRydWU7XHJcbiAgICAgICAgICBzZXRDdXJyZW50U2NvcmUoKHByZXZTY29yZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdTY29yZSA9IHByZXZTY29yZSArIDE7XHJcbiAgICAgICAgICAgIHNldEhpZ2hTY29yZSgocHJldkhpZ2hTY29yZSkgPT4ge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRIaWdoU2NvcmUgPSBNYXRoLm1heChwcmV2SGlnaFNjb3JlLCBuZXdTY29yZSk7XHJcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwiaGlnaFNjb3JlXCIsIHVwZGF0ZWRIaWdoU2NvcmUudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVkSGlnaFNjb3JlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld1Njb3JlO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIDRFOiBDTEVBTlVQIEZVTkNUSU9OXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBoYW5kbGVLZXlEb3duKTtcclxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgaGFuZGxlUmVzaXplKTtcclxuICAgICAgaWYgKHJlcXVlc3RJZFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmVxdWVzdElkUmVmLmN1cnJlbnQpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xyXG4gIH0sIFtjYW52YXNSZWYsIGlzUGF1c2VkLCBhdXRvU3RhcnRdKTtcclxuXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gNS4gSEFORExFIFVTRVIgSU5QVVQgV0lUSCBERUJPVU5DSU5HXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgY29uc3QgaGFuZGxlVXNlcklucHV0ID0gKCkgPT4ge1xyXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuICAgIGlmIChub3cgLSBsYXN0VGFwUmVmLmN1cnJlbnQgPCBERUJPVU5DRV9USU1FKSB7XHJcbiAgICAgIHJldHVybjsgLy8gSWdub3JlIGlmIHdpdGhpbiBkZWJvdW5jZSB0aW1lXHJcbiAgICB9XHJcbiAgICBsYXN0VGFwUmVmLmN1cnJlbnQgPSBub3c7XHJcblxyXG4gICAgaWYgKCFnYW1lU3RhcnRlZFJlZi5jdXJyZW50ICYmICFnYW1lT3ZlclJlZi5jdXJyZW50KSB7XHJcbiAgICAgIHN0YXJ0R2FtZSgpO1xyXG4gICAgfSBlbHNlIGlmIChnYW1lT3ZlclJlZi5jdXJyZW50KSB7XHJcbiAgICAgIHN0YXJ0R2FtZSgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYmlyZFZlbG9jaXR5UmVmLmN1cnJlbnQgPSBGTEFQO1xyXG4gICAgICBmbGFwQW5pbWF0aW9uKCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gNi4gRkxBUCBBTklNQVRJT04gRlVOQ1RJT05cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICBjb25zdCBmbGFwQW5pbWF0aW9uID0gKCkgPT4ge1xyXG4gICAgY3VycmVudEJpcmRGcmFtZVJlZi5jdXJyZW50ID0gMTtcclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICBjdXJyZW50QmlyZEZyYW1lUmVmLmN1cnJlbnQgPSAyO1xyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBjdXJyZW50QmlyZEZyYW1lUmVmLmN1cnJlbnQgPSAwO1xyXG4gICAgICB9LCAxNzApO1xyXG4gICAgfSwgMTcwKTtcclxuICB9O1xyXG5cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvLyA3LiBTVEFSVCBHQU1FIEZVTkNUSU9OXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgY29uc3Qgc3RhcnRHYW1lID0gKCkgPT4ge1xyXG4gICAgcmVzZXRHYW1lKCk7XHJcbiAgICBnYW1lU3RhcnRlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcclxuICAgIGxhc3RUaW1lUmVmLmN1cnJlbnQgPSBwZXJmb3JtYW5jZS5ub3coKTsgLy8gcmVzZXQgb3VyIHRpbWUtYmFzZWQgcmVmZXJlbmNlXHJcbiAgICByZXF1ZXN0SWRSZWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcclxuICB9O1xyXG5cclxuXHJcbiAgZnVuY3Rpb24gcmVzZXRHYW1lKCkge1xyXG4gICAgaWYgKCFjYW52YXNSZWYuY3VycmVudCkgcmV0dXJuO1xyXG4gICAgY29uc3QgeyBoZWlnaHQgfSA9IGNhbnZhc1JlZi5jdXJyZW50O1xyXG4gICAgYmlyZFlSZWYuY3VycmVudCA9IGhlaWdodCAvIDM7XHJcbiAgICBiaXJkVmVsb2NpdHlSZWYuY3VycmVudCA9IDA7XHJcbiAgICBwaXBlc1JlZi5jdXJyZW50ID0gW107XHJcbiAgICBjb2luc1JlZi5jdXJyZW50ID0gW107XHJcbiAgICBzZXRDdXJyZW50U2NvcmUoMCk7XHJcbiAgICBnYW1lT3ZlclJlZi5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICBnYW1lU3RhcnRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICBjb2luUm90YXRpb25SZWYuY3VycmVudCA9IDA7XHJcbiAgICBwaXBlU3Bhd25UaW1lclJlZi5jdXJyZW50ID0gMDtcclxuICAgIGN1cnJlbnRCaXJkRnJhbWVSZWYuY3VycmVudCA9IDA7XHJcbiAgfVxyXG4gIFxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIDguIEdBTUUgTE9PUCBGVU5DVElPTlxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIGNvbnN0IGFuaW1hdGUgPSAoY3VycmVudFRpbWU/OiBudW1iZXIpID0+IHtcclxuICAgIGlmICghZ2FtZVN0YXJ0ZWRSZWYuY3VycmVudCkge1xyXG4gICAgICAvLyBJZiBnYW1lIGhhc24ndCBzdGFydGVkLCBqdXN0IHNjaGVkdWxlIHRoZSBuZXh0IGZyYW1lXHJcbiAgICAgIHJlcXVlc3RJZFJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoaXNQYXVzZWQpIHtcclxuICAgICAgLy8gSWYgcGF1c2VkLCBqdXN0IHNjaGVkdWxlIHRoZSBuZXh0IGZyYW1lXHJcbiAgICAgIHJlcXVlc3RJZFJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoIWNhbnZhc1JlZi5jdXJyZW50KSByZXR1cm47XHJcbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzUmVmLmN1cnJlbnQuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgaWYgKCFjb250ZXh0KSByZXR1cm47XHJcblxyXG4gICAgY29uc3Qgbm93ID0gY3VycmVudFRpbWUgPz8gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICBjb25zdCBkZWx0YVRpbWUgPSBub3cgLSBsYXN0VGltZVJlZi5jdXJyZW50O1xyXG4gICAgbGFzdFRpbWVSZWYuY3VycmVudCA9IG5vdztcclxuXHJcbiAgICB1cGRhdGVHYW1lU3RhdGUoY2FudmFzUmVmLmN1cnJlbnQsIGRlbHRhVGltZSk7XHJcbiAgICBkcmF3KGNvbnRleHQsIGNhbnZhc1JlZi5jdXJyZW50KTtcclxuXHJcbiAgICBpZiAoIWdhbWVPdmVyUmVmLmN1cnJlbnQpIHtcclxuICAgICAgcmVxdWVzdElkUmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkcmF3R2FtZU92ZXJTY3JlZW4oY29udGV4dCwgY2FudmFzUmVmLmN1cnJlbnQpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIHVwZGF0ZUdhbWVTdGF0ZShjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCBkZWx0YVRpbWU6IG51bWJlcikge1xyXG4gICAgLy8gU2NhbGUgZmFjdG9yIHJlbGF0aXZlIHRvIH42MGZwcyA9IDE2LjY3bXMgcGVyIGZyYW1lXHJcbiAgICBjb25zdCBzY2FsZSA9IGRlbHRhVGltZSAvIElERUFMX0ZSQU1FO1xyXG5cclxuICAgIC8vIEdyYXZpdHlcclxuICAgIGJpcmRWZWxvY2l0eVJlZi5jdXJyZW50ICs9IEdSQVZJVFkgKiBzY2FsZTtcclxuICAgIGJpcmRZUmVmLmN1cnJlbnQgKz0gYmlyZFZlbG9jaXR5UmVmLmN1cnJlbnQgKiBzY2FsZTtcclxuXHJcbiAgICAvLyBVcGRhdGUgcGlwZSBzcGF3biB0aW1lclxyXG4gICAgcGlwZVNwYXduVGltZXJSZWYuY3VycmVudCArPSBkZWx0YVRpbWU7XHJcbiAgICBpZiAocGlwZVNwYXduVGltZXJSZWYuY3VycmVudCA+PSBQSVBFX1NQQVdOX0lOVEVSVkFMKSB7XHJcbiAgICAgIHBpcGVTcGF3blRpbWVyUmVmLmN1cnJlbnQgLT0gUElQRV9TUEFXTl9JTlRFUlZBTDtcclxuICAgICAgY3JlYXRlUGlwZShjYW52YXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE1vdmUgcGlwZXMgJiBjb2luc1xyXG4gICAgbW92ZVBpcGVzQW5kQ29pbnMoc2NhbGUpO1xyXG5cclxuICAgIC8vIFJvdGF0ZSBjb2luICgwIC0+IDEgaXMgYSBmdWxsIGN5Y2xlIGluIG91ciB1c2FnZSlcclxuICAgIGNvaW5Sb3RhdGlvblJlZi5jdXJyZW50ICs9IFJPVEFUSU9OX1NQRUVEICogc2NhbGU7XHJcbiAgICBpZiAoY29pblJvdGF0aW9uUmVmLmN1cnJlbnQgPj0gMSkge1xyXG4gICAgICBjb2luUm90YXRpb25SZWYuY3VycmVudCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgY29sbGlzaW9uc1xyXG4gICAgaWYgKGNoZWNrQ29sbGlzaW9ucyhjYW52YXMpKSB7XHJcbiAgICAgIGdhbWVPdmVyUmVmLmN1cnJlbnQgPSB0cnVlO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgY29pbiBjb2xsZWN0aW9uXHJcbiAgICBjaGVja0NvaW5Db2xsZWN0aW9uKCk7XHJcblxyXG4gICAgLy8gVXBkYXRlIHNjb3JlIGlmIHdlIHBhc3MgcGlwZXNcclxuICAgIHVwZGF0ZVNjb3JlKCk7XHJcbiAgfVxyXG5cclxuXHJcblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIDkuIERSQVcgRlVOQ1RJT05TXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgY29uc3QgZHJhdyA9IChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkgPT4ge1xyXG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgZHJhd0JhY2tncm91bmQoY3R4LCBjYW52YXMpO1xyXG4gICAgZHJhd0JpcmQoY3R4KTtcclxuICAgIGRyYXdQaXBlcyhjdHgpO1xyXG4gICAgZHJhd0NvaW5zKGN0eCk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgZHJhd1N0YXJ0U2NyZWVuID0gKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSA9PiB7XHJcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcbiAgICBkcmF3QmFja2dyb3VuZChjdHgsIGNhbnZhcyk7XHJcblxyXG4gICAgY3R4LmZvbnQgPSBcImJvbGQgMzBweCBBcmlhbFwiO1xyXG4gICAgY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XHJcbiAgICBjdHguZmlsbFN0eWxlID0gXCIjZmZmZmZmXCI7XHJcbiAgICBjdHguc2hhZG93Q29sb3IgPSBcImJsYWNrXCI7XHJcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcclxuXHJcbiAgICBjdHguZmlsbFRleHQoXCJUYXAgb3IgUHJlc3MgU3BhY2UgdG8gU3RhcnRcIiwgY2FudmFzLndpZHRoIC8gMiwgY2FudmFzLmhlaWdodCAvIDIpO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGRyYXdHYW1lT3ZlclNjcmVlbiA9IChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkgPT4ge1xyXG4gICAgY3R4LmZpbGxTdHlsZSA9IFwiI2ZmY2MwMFwiO1xyXG4gICAgY3R4LmZvbnQgPSBcImJvbGQgNTBweCBBcmlhbFwiO1xyXG4gICAgY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XHJcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcclxuICAgIGN0eC5zaGFkb3dDb2xvciA9IFwiYmxhY2tcIjtcclxuICAgIGN0eC5zaGFkb3dCbHVyID0gMTA7XHJcblxyXG4gICAgY3R4LmZpbGxUZXh0KFwiR2FtZSBPdmVyIVwiLCBjYW52YXMud2lkdGggLyAyLCBjYW52YXMuaGVpZ2h0IC8gMiAtIDQwKTtcclxuXHJcbiAgICBjdHguZmlsbFN0eWxlID0gXCIjZmZmZmZmXCI7XHJcbiAgICBjdHguZm9udCA9IFwiYm9sZCAzMHB4IEFyaWFsXCI7XHJcbiAgICBjdHguZmlsbFRleHQoXHJcbiAgICAgIFwiVGFwIG9yIFByZXNzIFNwYWNlIHRvIFJlc3RhcnRcIixcclxuICAgICAgY2FudmFzLndpZHRoIC8gMixcclxuICAgICAgY2FudmFzLmhlaWdodCAvIDIgKyAyMFxyXG4gICAgKTtcclxuICB9O1xyXG5cclxuICBjb25zdCBkcmF3QmFja2dyb3VuZCA9IChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkgPT4ge1xyXG4gICAgaWYgKGJhY2tncm91bmRSZWYuY3VycmVudCAmJiBiYWNrZ3JvdW5kUmVmLmN1cnJlbnQuY29tcGxldGUpIHtcclxuICAgICAgY3R4LmRyYXdJbWFnZShiYWNrZ3JvdW5kUmVmLmN1cnJlbnQsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgZHJhd0JpcmQgPSAoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpID0+IHtcclxuICAgIGNvbnN0IGN1cnJlbnRJbWFnZSA9IGJpcmRJbWFnZXNSZWYuY3VycmVudFtjdXJyZW50QmlyZEZyYW1lUmVmLmN1cnJlbnRdO1xyXG4gICAgaWYgKGN1cnJlbnRJbWFnZSAmJiBjdXJyZW50SW1hZ2UuY29tcGxldGUpIHtcclxuICAgICAgY3R4LmRyYXdJbWFnZShjdXJyZW50SW1hZ2UsIDEwMCwgYmlyZFlSZWYuY3VycmVudCwgQklSRF9XSURUSCwgQklSRF9IRUlHSFQpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IGRyYXdQaXBlcyA9IChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkgPT4ge1xyXG4gICAgcGlwZXNSZWYuY3VycmVudC5mb3JFYWNoKChwaXBlKSA9PiB7XHJcbiAgICAgIGlmIChwaXBlVG9wUmVmLmN1cnJlbnQgJiYgcGlwZVRvcFJlZi5jdXJyZW50LmNvbXBsZXRlKSB7XHJcbiAgICAgICAgY3R4LmRyYXdJbWFnZShwaXBlVG9wUmVmLmN1cnJlbnQsIHBpcGUueCwgMCwgUElQRV9XSURUSCwgcGlwZS50b3BIZWlnaHQpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChwaXBlQm90dG9tUmVmLmN1cnJlbnQgJiYgcGlwZUJvdHRvbVJlZi5jdXJyZW50LmNvbXBsZXRlKSB7XHJcbiAgICAgICAgY3R4LmRyYXdJbWFnZShwaXBlQm90dG9tUmVmLmN1cnJlbnQsIHBpcGUueCwgcGlwZS5ib3R0b21ZLCBQSVBFX1dJRFRILCBwaXBlLmJvdHRvbUhlaWdodCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGRyYXdDb2lucyA9IChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkgPT4ge1xyXG4gICAgaWYgKCFjb2luSW1hZ2VSZWYuY3VycmVudCB8fCAhY29pbkltYWdlUmVmLmN1cnJlbnQuY29tcGxldGUpIHJldHVybjtcclxuICAgIGNvbnN0IHNjYWxlWCA9IE1hdGguYWJzKE1hdGguY29zKGNvaW5Sb3RhdGlvblJlZi5jdXJyZW50ICogTWF0aC5QSSAqIDIpKTtcclxuICAgIGNvbnN0IGhhbGZTaXplID0gQ09JTl9TSVpFIC8gMjtcclxuICAgIGNvaW5zUmVmLmN1cnJlbnQuZm9yRWFjaCgoY29pbikgPT4ge1xyXG4gICAgICBpZiAoIWNvaW5JbWFnZVJlZi5jdXJyZW50KVxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgaWYgKCFjb2luLmNvbGxlY3RlZCkge1xyXG4gICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgY3R4LnRyYW5zbGF0ZShjb2luLnggKyBoYWxmU2l6ZSwgY29pbi55ICsgaGFsZlNpemUpO1xyXG4gICAgICAgIGN0eC5zY2FsZShzY2FsZVgsIDEpO1xyXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoY29pbkltYWdlUmVmLmN1cnJlbnQsIC1oYWxmU2l6ZSwgLWhhbGZTaXplLCBDT0lOX1NJWkUsIENPSU5fU0laRSk7XHJcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gMTAuIEdBTUUgTE9HSUMgRlVOQ1RJT05TXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgY29uc3QgY3JlYXRlUGlwZSA9IChjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSA9PiB7XHJcbiAgICBjb25zdCBwaXBlSGVpZ2h0ID0gTWF0aC5yYW5kb20oKSAqIChjYW52YXMuaGVpZ2h0IC0gUElQRV9TUEFDSU5HIC0gMTAwKSArIDUwO1xyXG4gICAgY29uc3QgYm90dG9tWSA9IHBpcGVIZWlnaHQgKyBQSVBFX1NQQUNJTkc7XHJcbiAgICBwaXBlc1JlZi5jdXJyZW50LnB1c2goe1xyXG4gICAgICB4OiBjYW52YXMud2lkdGgsXHJcbiAgICAgIHRvcEhlaWdodDogcGlwZUhlaWdodCxcclxuICAgICAgYm90dG9tWSxcclxuICAgICAgYm90dG9tSGVpZ2h0OiBjYW52YXMuaGVpZ2h0IC0gYm90dG9tWSxcclxuICAgICAgc2NvcmVkOiBmYWxzZSxcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIDUwJSBjaGFuY2UgZm9yIGNvaW5cclxuICAgIGlmIChNYXRoLnJhbmRvbSgpID4gMC41KSB7XHJcbiAgICAgIGNvaW5zUmVmLmN1cnJlbnQucHVzaCh7XHJcbiAgICAgICAgeDogY2FudmFzLndpZHRoICsgUElQRV9XSURUSCAvIDIgLSBDT0lOX1NJWkUgLyAyLFxyXG4gICAgICAgIHk6IHBpcGVIZWlnaHQgKyBQSVBFX1NQQUNJTkcgLyAyIC0gQ09JTl9TSVpFIC8gMixcclxuICAgICAgICB3aWR0aDogQ09JTl9TSVpFLFxyXG4gICAgICAgIGhlaWdodDogQ09JTl9TSVpFLFxyXG4gICAgICAgIGNvbGxlY3RlZDogZmFsc2UsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IG1vdmVQaXBlc0FuZENvaW5zID0gKHNjYWxlOiBudW1iZXIpID0+IHtcclxuICAgIC8vIE1vdmUgcGlwZXMgdG8gdGhlIGxlZnRcclxuICAgIHBpcGVzUmVmLmN1cnJlbnQuZm9yRWFjaCgocGlwZSkgPT4ge1xyXG4gICAgICBwaXBlLnggLT0gSE9SSVpPTlRBTF9TUEVFRCAqIHNjYWxlO1xyXG4gICAgfSk7XHJcbiAgICBwaXBlc1JlZi5jdXJyZW50ID0gcGlwZXNSZWYuY3VycmVudC5maWx0ZXIoKHApID0+IHAueCArIFBJUEVfV0lEVEggPiAwKTtcclxuXHJcbiAgICAvLyBNb3ZlIGNvaW5zXHJcbiAgICBjb2luc1JlZi5jdXJyZW50LmZvckVhY2goKGNvaW4pID0+IHtcclxuICAgICAgY29pbi54IC09IEhPUklaT05UQUxfU1BFRUQgKiBzY2FsZTtcclxuICAgIH0pO1xyXG4gICAgY29pbnNSZWYuY3VycmVudCA9IGNvaW5zUmVmLmN1cnJlbnQuZmlsdGVyKFxyXG4gICAgICAoYykgPT4gYy54ICsgYy53aWR0aCA+IDAgJiYgIWMuY29sbGVjdGVkXHJcbiAgICApO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGNoZWNrQ29sbGlzaW9ucyA9IChjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KTogYm9vbGVhbiA9PiB7XHJcbiAgICAvLyBCaXJkIHZzIGJvdW5kYXJpZXNcclxuICAgIGlmIChiaXJkWVJlZi5jdXJyZW50IDwgMCB8fCBiaXJkWVJlZi5jdXJyZW50ICsgQklSRF9IRUlHSFQgPiBjYW52YXMuaGVpZ2h0KSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGJpcmRMZWZ0ID0gMTAwO1xyXG4gICAgY29uc3QgYmlyZFJpZ2h0ID0gYmlyZExlZnQgKyBCSVJEX1dJRFRIO1xyXG4gICAgY29uc3QgYmlyZFRvcCA9IGJpcmRZUmVmLmN1cnJlbnQ7XHJcbiAgICBjb25zdCBiaXJkQm90dG9tID0gYmlyZFlSZWYuY3VycmVudCArIEJJUkRfSEVJR0hUO1xyXG5cclxuICAgIC8vIEJpcmQgdnMgcGlwZXNcclxuICAgIGZvciAoY29uc3QgcGlwZSBvZiBwaXBlc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgIGNvbnN0IHdpdGhpblBpcGVYID0gYmlyZFJpZ2h0ID4gcGlwZS54ICYmIGJpcmRMZWZ0IDwgcGlwZS54ICsgUElQRV9XSURUSDtcclxuICAgICAgY29uc3Qgd2l0aGluUGlwZVkgPSBiaXJkVG9wIDwgcGlwZS50b3BIZWlnaHQgfHwgYmlyZEJvdHRvbSA+IHBpcGUuYm90dG9tWTtcclxuICAgICAgaWYgKHdpdGhpblBpcGVYICYmIHdpdGhpblBpcGVZKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9O1xyXG5cclxuICBjb25zdCBjaGVja0NvaW5Db2xsZWN0aW9uID0gKCkgPT4ge1xyXG4gICAgY29uc3QgYmlyZExlZnQgPSAxMDA7XHJcbiAgICBjb25zdCBiaXJkUmlnaHQgPSBiaXJkTGVmdCArIEJJUkRfV0lEVEg7XHJcbiAgICBjb25zdCBiaXJkVG9wID0gYmlyZFlSZWYuY3VycmVudDtcclxuICAgIGNvbnN0IGJpcmRCb3R0b20gPSBiaXJkWVJlZi5jdXJyZW50ICsgQklSRF9IRUlHSFQ7XHJcblxyXG4gICAgY29pbnNSZWYuY3VycmVudC5mb3JFYWNoKChjb2luKSA9PiB7XHJcbiAgICAgIGlmICghY29pbi5jb2xsZWN0ZWQpIHtcclxuICAgICAgICBjb25zdCBjb2luTGVmdCA9IGNvaW4ueDtcclxuICAgICAgICBjb25zdCBjb2luUmlnaHQgPSBjb2luLnggKyBjb2luLndpZHRoO1xyXG4gICAgICAgIGNvbnN0IGNvaW5Ub3AgPSBjb2luLnk7XHJcbiAgICAgICAgY29uc3QgY29pbkJvdHRvbSA9IGNvaW4ueSArIGNvaW4uaGVpZ2h0O1xyXG5cclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICBiaXJkUmlnaHQgPiBjb2luTGVmdCAmJlxyXG4gICAgICAgICAgYmlyZExlZnQgPCBjb2luUmlnaHQgJiZcclxuICAgICAgICAgIGJpcmRCb3R0b20gPiBjb2luVG9wICYmXHJcbiAgICAgICAgICBiaXJkVG9wIDwgY29pbkJvdHRvbVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgLy8gQ29sbGVjdCBjb2luXHJcbiAgICAgICAgICBjb2luLmNvbGxlY3RlZCA9IHRydWU7XHJcbiAgICAgICAgICBzZXRDdXJyZW50U2NvcmUoKHByZXZTY29yZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdTY29yZSA9IHByZXZTY29yZSArIDU7XHJcbiAgICAgICAgICAgIHNldEhpZ2hTY29yZSgocHJldkhpZ2hTY29yZSkgPT4gTWF0aC5tYXgocHJldkhpZ2hTY29yZSwgbmV3U2NvcmUpKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld1Njb3JlO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICBjb25zdCB1cGRhdGVTY29yZSA9ICgpID0+IHtcclxuICAgIHBpcGVzUmVmLmN1cnJlbnQuZm9yRWFjaCgocGlwZSkgPT4ge1xyXG4gICAgICAvLyBTY29yZSArMSBmb3IgcGFzc2luZyBlYWNoIHBpcGUsIG9ubHkgb25jZVxyXG4gICAgICBpZiAoIXBpcGUuc2NvcmVkICYmIHBpcGUueCArIFBJUEVfV0lEVEggPCAxMDApIHtcclxuICAgICAgICBwaXBlLnNjb3JlZCA9IHRydWU7XHJcbiAgICAgICAgc2V0Q3VycmVudFNjb3JlKChwcmV2U2NvcmUpID0+IHtcclxuICAgICAgICAgIGNvbnN0IG5ld1Njb3JlID0gcHJldlNjb3JlICsgMTtcclxuICAgICAgICAgIHNldEhpZ2hTY29yZSgocHJldkhpZ2hTY29yZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkSGlnaFNjb3JlID0gTWF0aC5tYXgocHJldkhpZ2hTY29yZSwgbmV3U2NvcmUpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwiaGlnaFNjb3JlXCIsIHVwZGF0ZWRIaWdoU2NvcmUudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZWRIaWdoU2NvcmU7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHJldHVybiBuZXdTY29yZTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gMTEuIFJFVFVSTiBHQU1FIFNUQVRTIEFORCBJTlBVVCBIYW5kbGVyXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgcmV0dXJuIHtcclxuICAgIGhpZ2hTY29yZSxcclxuICAgIGN1cnJlbnRTY29yZSxcclxuICAgIGhhbmRsZVVzZXJJbnB1dCwgLy8gRXhwb3NlZCB0byB0aGUgY29tcG9uZW50XHJcbiAgfTtcclxufVxyXG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJHUkFWSVRZIiwiRkxBUCIsIlBJUEVfV0lEVEgiLCJQSVBFX1NQQUNJTkciLCJCSVJEX1dJRFRIIiwiQklSRF9IRUlHSFQiLCJDT0lOX1NJWkUiLCJQSVBFX1NQQVdOX0lOVEVSVkFMIiwiSE9SSVpPTlRBTF9TUEVFRCIsIlJPVEFUSU9OX1NQRUVEIiwiSURFQUxfRlJBTUUiLCJ1c2VGbGFwcHlCaXJkR2FtZSIsImNhbnZhc1JlZiIsImlzUGF1c2VkIiwiYXV0b1N0YXJ0IiwiaGlnaFNjb3JlIiwic2V0SGlnaFNjb3JlIiwiY3VycmVudFNjb3JlIiwic2V0Q3VycmVudFNjb3JlIiwicmVxdWVzdElkUmVmIiwiYmlyZFlSZWYiLCJiaXJkVmVsb2NpdHlSZWYiLCJwaXBlc1JlZiIsImNvaW5zUmVmIiwiZ2FtZU92ZXJSZWYiLCJnYW1lU3RhcnRlZFJlZiIsImNvaW5Sb3RhdGlvblJlZiIsInBpcGVTcGF3blRpbWVyUmVmIiwibGFzdFRpbWVSZWYiLCJiaXJkSW1hZ2VzUmVmIiwicGlwZVRvcFJlZiIsInBpcGVCb3R0b21SZWYiLCJiYWNrZ3JvdW5kUmVmIiwiY29pbkltYWdlUmVmIiwiY3VycmVudEJpcmRGcmFtZVJlZiIsImxhc3RUYXBSZWYiLCJERUJPVU5DRV9USU1FIiwiYmlyZFVwIiwiSW1hZ2UiLCJzcmMiLCJiaXJkTWlkIiwiYmlyZERvd24iLCJjdXJyZW50IiwicGlwZVRvcCIsInBpcGVCb3R0b20iLCJiYWNrZ3JvdW5kIiwiY29pbkltYWdlIiwic3RvcmVkSGlnaFNjb3JlIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInBhcnNlSW50IiwiY2FudmFzIiwiY3R4IiwiZ2V0Q29udGV4dCIsImxvYWRJbWFnZSIsImltZyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiY29tcGxldGUiLCJvbmxvYWQiLCJvbmVycm9yIiwiRXJyb3IiLCJsb2FkQXNzZXRzIiwiYWxsIiwibWFwIiwiaW5pdGlhbGl6ZUdhbWUiLCJlcnIiLCJjb25zb2xlIiwiZXJyb3IiLCJ3aWR0aCIsImhlaWdodCIsImRyYXdTdGFydFNjcmVlbiIsInJlc2V0R2FtZSIsImhhbmRsZUtleURvd24iLCJlIiwia2V5IiwiaGFuZGxlVXNlcklucHV0V2l0aERlYm91bmNlIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsImhhbmRsZVJlc2l6ZSIsInN0YXJ0R2FtZSIsInBlcmZvcm1hbmNlIiwibm93IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiYW5pbWF0ZSIsIkRhdGUiLCJmbGFwQW5pbWF0aW9uIiwic2V0VGltZW91dCIsImN1cnJlbnRUaW1lIiwiY29udGV4dCIsImRlbHRhVGltZSIsInVwZGF0ZUdhbWVTdGF0ZSIsImRyYXciLCJkcmF3R2FtZU92ZXJTY3JlZW4iLCJzY2FsZSIsImNyZWF0ZVBpcGUiLCJtb3ZlUGlwZXNBbmRDb2lucyIsImNoZWNrQ29sbGlzaW9ucyIsImNoZWNrQ29pbkNvbGxlY3Rpb24iLCJ1cGRhdGVTY29yZSIsImNsZWFyUmVjdCIsImRyYXdCYWNrZ3JvdW5kIiwiZHJhd0JpcmQiLCJkcmF3UGlwZXMiLCJkcmF3Q29pbnMiLCJmb250IiwidGV4dEFsaWduIiwiZmlsbFN0eWxlIiwic2hhZG93Q29sb3IiLCJ0ZXh0QmFzZWxpbmUiLCJmaWxsVGV4dCIsInNoYWRvd0JsdXIiLCJkcmF3SW1hZ2UiLCJjdXJyZW50SW1hZ2UiLCJmb3JFYWNoIiwicGlwZSIsIngiLCJ0b3BIZWlnaHQiLCJib3R0b21ZIiwiYm90dG9tSGVpZ2h0Iiwic2NhbGVYIiwiTWF0aCIsImFicyIsImNvcyIsIlBJIiwiaGFsZlNpemUiLCJjb2luIiwiY29sbGVjdGVkIiwic2F2ZSIsInRyYW5zbGF0ZSIsInkiLCJyZXN0b3JlIiwicGlwZUhlaWdodCIsInJhbmRvbSIsInB1c2giLCJzY29yZWQiLCJmaWx0ZXIiLCJwIiwiYyIsImJpcmRMZWZ0IiwiYmlyZFJpZ2h0IiwiYmlyZFRvcCIsImJpcmRCb3R0b20iLCJ3aXRoaW5QaXBlWCIsIndpdGhpblBpcGVZIiwiY29pbkxlZnQiLCJjb2luUmlnaHQiLCJjb2luVG9wIiwiY29pbkJvdHRvbSIsInByZXZTY29yZSIsIm5ld1Njb3JlIiwicHJldkhpZ2hTY29yZSIsIm1heCIsInVwZGF0ZWRIaWdoU2NvcmUiLCJzZXRJdGVtIiwidG9TdHJpbmciLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJoYW5kbGVVc2VySW5wdXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./public/useFlappyBirdGame.ts\n"));

/***/ })

});