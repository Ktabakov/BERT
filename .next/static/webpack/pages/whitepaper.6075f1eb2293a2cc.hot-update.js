"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/whitepaper",{

/***/ "./public/walletActions.ts":
/*!*********************************!*\
  !*** ./public/walletActions.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateCountdown: function() { return /* binding */ calculateCountdown; },\n/* harmony export */   claimTokens: function() { return /* binding */ claimTokens; },\n/* harmony export */   send: function() { return /* binding */ send; }\n/* harmony export */ });\n/* harmony import */ var _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @hyperionbt/helios */ \"./node_modules/@hyperionbt/helios/helios.js\");\n/* harmony import */ var _common_network__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/network */ \"./common/network.ts\");\n/* harmony import */ var _contracts_vesting_hl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../contracts/vesting.hl */ \"./contracts/vesting.hl\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n// walletActions.ts\n\n\n // Ensure correct path to your contract\nconst optimize = false;\nconst API_KEY = \"preprodJExO0MAMRgfpXz9Il4IqB2u9ddoylZBT\"; // Replace with your key\nfunction getTokenAmountFromUtxos(utxos, assetClass) {\n    let totalAmount = BigInt(0);\n    utxos.forEach((utxo)=>{\n        // Assuming utxo.value is in the right format\n        const tokens = utxo.value.assets.getTokens(assetClass.mintingPolicyHash);\n        tokens.forEach((param)=>{\n            let [tokenName, amount] = param;\n            totalAmount += BigInt(amount.value); // Add the amount to the total\n        });\n    });\n    return totalAmount;\n}\nfunction calculateReward(remainingSupply, totalSupply, baseReward) {\n    const halvingThreshold = totalSupply * 0.1; // 10% of total supply as the halving threshold\n    // Determine the number of halving steps\n    const halvingSteps = Math.floor((totalSupply - remainingSupply) / halvingThreshold);\n    // Calculate the reward after applying halving steps\n    const reward = Math.floor(baseReward / (1 + halvingSteps));\n    // Ensure the reward doesn't drop below 1\n    return reward < 1 ? 1 : reward;\n}\nfunction pickUtxos(utxos, targetAmount, assetClass) {\n    const selected = [];\n    let totalAmount = 0n;\n    // Keep track of the indices we've already picked\n    const usedIndices = new Set();\n    while(totalAmount < targetAmount){\n        // Generate a random index within the bounds of the UTXOs array\n        const randomIndex = Math.floor(Math.random() * utxos.length);\n        // If we've already selected this index, skip it\n        if (usedIndices.has(randomIndex)) {\n            continue;\n        }\n        // Mark the index as used\n        usedIndices.add(randomIndex);\n        // Add the UTXO to the selected list\n        const selectedUtxo = utxos[randomIndex];\n        selected.push(selectedUtxo);\n        const tokens = selectedUtxo.value.assets.getTokens(assetClass.mintingPolicyHash);\n        tokens.forEach((param)=>{\n            let [tokenName, amount] = param;\n            totalAmount += BigInt(amount.value); // Add the amount to the total\n        });\n    }\n    return {\n        selected,\n        totalAmount\n    };\n}\n// Calculate the reward based on the time elapsed since contract deployment\nfunction calculateRewardInTime(TimeBeginContract) {\n    TimeBeginContract = TimeBeginContract / 1000;\n    const HALVING_PERIOD = 2592000; // 1 month in seconds (60 * 60 * 24 * 30)\n    const MAX_HALVINGS = 5; // Limit halvings to 5 times\n    const BASE_REWARD = 1000; // Initial reward in tokens\n    // Get current time in seconds\n    const TimeNow = Math.floor(Date.now() / 1000);\n    // Calculate the elapsed time in seconds\n    const timeElapsed = TimeNow - TimeBeginContract;\n    // Determine halving steps based on elapsed time, but limit to MAX_HALVINGS\n    let halvingSteps = Math.floor(timeElapsed / HALVING_PERIOD);\n    halvingSteps = Math.min(halvingSteps, MAX_HALVINGS); // Cap halvings at MAX_HALVINGS\n    // Ensure the number of halving steps doesn't exceed the maximum allowed\n    const effectiveHalvings = Math.min(halvingSteps, MAX_HALVINGS);\n    console.log(\"Halvings\" + effectiveHalvings);\n    // Directly calculate reward based on halving steps using a bit shift\n    const reward = BASE_REWARD / 2 ** effectiveHalvings;\n    // Return the reward, ensuring it doesn't fall below a minimum value\n    return reward < 1 ? 1 : reward;\n}\nfunction calculateCountdown(TimeBeginContract) {\n    console.log(\"TimeBeginContract\" + TimeBeginContract);\n    const TimeNow = Math.floor(Date.now());\n    console.log(\"TIME now in MS\" + TimeNow);\n    const CYCLE_DURATION = 540 // 9 minutes \n    ;\n    const offsetInMs = 89680;\n    const elapsedTime = TimeNow - offsetInMs - TimeBeginContract;\n    console.log(\"elapesedTime\" + elapsedTime);\n    const elapsedTimeInSeconds = elapsedTime / 1000;\n    const positionInCycle = elapsedTimeInSeconds % CYCLE_DURATION;\n    console.log(positionInCycle);\n    return positionInCycle;\n}\n// Function to filter and pick a random TxInput with sufficient value\nfunction pickRandomTxInputWithSufficientValue(txInputs, dynamicReward, assetClass) {\n    // Filter TxInputs that have sufficient token value\n    const eligibleTxInputs = txInputs.filter((txInput)=>{\n        // Extract the tokens and check their value\n        const tokens = txInput.output.value.assets.getTokens(assetClass.mintingPolicyHash);\n        let tokenAmount = BigInt(0);\n        tokens.forEach((param)=>{\n            let [tokenName, amount] = param;\n            tokenAmount += BigInt(amount.value); // Add the amount to the token total\n        });\n        return tokenAmount >= dynamicReward; // Check if the total token value meets or exceeds the reward\n    });\n    // If there are no eligible TxInputs, throw an error\n    if (eligibleTxInputs.length === 0) {\n        throw new Error(\"No eligible TxInput found with sufficient token value.\");\n    }\n    // Pick a random TxInput from the eligible list\n    const randomIndex = Math.floor(Math.random() * eligibleTxInputs.length);\n    const selectedTxInput = eligibleTxInputs[randomIndex];\n    // Calculate the token value of the selected TxInput\n    const tokens = selectedTxInput.output.value.assets.getTokens(assetClass.mintingPolicyHash);\n    let tokenAmount = BigInt(0);\n    tokens.forEach((param)=>{\n        let [tokenName, amount] = param;\n        tokenAmount += BigInt(amount.value); // Add the amount to the token total\n    });\n    const remainingUtxos = txInputs.filter((txInput)=>txInput !== selectedTxInput);\n    // Return the selected TxInput and its token value\n    return {\n        txInput: selectedTxInput,\n        tokenAmount,\n        remainingUtxos\n    };\n}\nasync function claimTokens(walletAPI, setIsLoading, setTx) {\n    setIsLoading(true);\n    if (!walletAPI) {\n        throw console.error(\"walletAPI is not set\");\n    }\n    try {\n        const cip30WalletAPI = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Cip30Wallet(walletAPI);\n        const bfrost = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.BlockfrostV0(_common_network__WEBPACK_IMPORTED_MODULE_0__.network, API_KEY);\n        const walletHelper = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.WalletHelper(cip30WalletAPI);\n        // Read in the network parameter file\n        const networkParamsJson = await (0,_common_network__WEBPACK_IMPORTED_MODULE_0__.getNetworkParams)(_common_network__WEBPACK_IMPORTED_MODULE_0__.network);\n        const networkParams = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.NetworkParams(networkParamsJson);\n        const policyId = \"e16c2dc8ae937e8d3790c7fd7168d7b994621ba14ca11415f39fed72\";\n        const name = Buffer.from(\"MIN\", \"utf8\").toString(\"hex\");\n        // const policyId = \"\";\n        // const name = Buffer.from(\"\", 'utf8').toString('hex');\n        const mph = _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.MintingPolicyHash.fromHex(policyId);\n        const assetClass = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.AssetClass({\n            mph: mph,\n            tokenName: name // Convert to hex string\n        });\n        console.log(assetClass);\n        const tokenAmount = BigInt(100);\n        const tokenVal = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Value(tokenAmount);\n        const utxos = await walletHelper.pickUtxos(tokenVal);\n        // Get change address\n        const benefitiary = await walletHelper.changeAddress;\n        // Load in the vesting validator script (program)\n        const gameReward = new _contracts_vesting_hl__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n        // Compile the vesting validator\n        const compiledProgram = gameReward.compile(optimize);\n        console.log(\"Wallet address: \" + benefitiary);\n        const scriptAddress = _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Address.fromHashes(compiledProgram.validatorHash);\n        //remove\n        console.log(scriptAddress.toBech32());\n        console.log(\"Script Address:\" + scriptAddress);\n        console.dir(scriptAddress, {\n            depth: null\n        });\n        const txInputs = await bfrost.getUtxos(scriptAddress);\n        var filteredUtxos = txInputs.filter((x)=>x.value.assets.getTokens(assetClass.mintingPolicyHash));\n        // const BASE_REWARD: number = 1000;  // Base reward\n        // const TOTAL_SUPPLY = 10000; // Total token supply\n        const CLAIM_WINDOW = 60; // 1 minute \n        console.log(\"filtereduTXOs\" + filteredUtxos);\n        const TimeBeginContract = Math.floor(new Date(Date.UTC(2024, 11, 8, 13, 45, 0)).getTime());\n        //const remainingSupply = getTokenAmountFromUtxos(filteredUtxos, assetClass);\n        const dynamicReward = calculateRewardInTime(TimeBeginContract);\n        const positionInCycle = calculateCountdown(TimeBeginContract);\n        console.log(positionInCycle);\n        window.onerror = ()=>positionInCycle < CLAIM_WINDOW;\n        //const dynamicReward = calculateReward(Number(remainingSupply), TOTAL_SUPPLY, BASE_REWARD);\n        const testValueBenefitiary = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Assets([\n            [\n                assetClass,\n                BigInt(dynamicReward)\n            ]\n        ]);\n        //const result = pickRandomTxInputWithSufficientValue(filteredUtxos, BigInt(dynamicReward), assetClass);\n        //console.log(\"randomUTXO:\" + result.txInput)\n        //const amountToSendBack = result.tokenAmount - BigInt(dynamicReward);\n        // console.log(\"amountToSendBack\" + amountToSendBack)\n        // console.log(\"UtxoAmount\" + result.tokenAmount)\n        // console.log(\"The rest\" + result.remainingUtxos)\n        //console.log(filteredUtxos)\n        // const remoteWallet = new RemoteWallet(false, [scriptAddress], [], txInputs);\n        // const walletHelperScript = new WalletHelper(remoteWallet);\n        const sortedUtxos = pickUtxos(filteredUtxos, BigInt(dynamicReward), assetClass);\n        sortedUtxos.selected.forEach((element)=>{\n            console.log(element);\n        });\n        //const totalAmountUtxo = getTokenAmountFromUtxos(sortedUtxos.selected, assetClass);\n        const amountToSendBack = sortedUtxos.totalAmount - BigInt(dynamicReward);\n        const firstPartToSendBack = amountToSendBack / 2n; // First part is half of the total amount\n        const secondPartToSendBack = amountToSendBack - firstPartToSendBack; // Second part is the remainder\n        console.log(\"First \" + firstPartToSendBack);\n        console.log(\"Sevond \" + secondPartToSendBack);\n        console.log(dynamicReward);\n        const valueContract1 = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Assets([\n            [\n                assetClass,\n                firstPartToSendBack\n            ]\n        ]);\n        const valueContract2 = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Assets([\n            [\n                assetClass,\n                secondPartToSendBack\n            ]\n        ]);\n        const gameDatum = new gameReward.types.Datum(benefitiary.pubKeyHash);\n        console.log(\"We have a datum!\" + gameDatum);\n        // Create the vesting claim redeemer\n        const redeember = new gameReward.types.Redeemer.Claim(benefitiary.pubKeyHash)._toUplcData();\n        //console.log(filteredUtxos);\n        const tx = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Tx();\n        //tx.addInputs(utxos[0]);\n        tx.addInputs(sortedUtxos.selected, redeember);\n        tx.attachScript(compiledProgram);\n        var userClaimOutput = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.TxOutput(benefitiary, new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Value(undefined, testValueBenefitiary));\n        tx.addOutput(userClaimOutput);\n        //Shiiit, fix. Someone could rediredt the rest of the tokens\n        // const addressStr = \"addr_test1qrarqhmklnhwcw3q0zm6sgm3g3l7pua0y36sql9k5ru8dsucglsked5f5yrcf9e9xgxjgmt7xk52knh8h0dgayc00arqlh7g60\";\n        // const address = Address.fromBech32(addressStr);\n        // tx.addOutput(new TxOutput(\n        //   address,\n        //   new Value(undefined, testValueContract) // The amount being claimed\n        // ));\n        if (amountToSendBack != BigInt(0)) {\n            var scriptUtxo1 = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.TxOutput(scriptAddress, new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Value(undefined, valueContract1), _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Datum.inline(gameDatum) // Contract requires datum\n            );\n            tx.addOutput(scriptUtxo1);\n            var scriptUtxo2 = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.TxOutput(scriptAddress, new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Value(undefined, valueContract2), _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Datum.inline(gameDatum) // Contract requires datum\n            );\n            tx.addOutput(scriptUtxo2);\n        }\n        //var inputFees = await walletHelper.pickUtxos(new Value(tokenAmountFees));\n        //tx.addInputs(inputFees[0]);\n        console.log(\"We attatched everything!\");\n        await tx.finalize(networkParams, benefitiary, utxos[1]);\n        // Sign the unsigned tx to get the witness\n        const signatures = await cip30WalletAPI.signTx(tx);\n        tx.addSignatures(signatures);\n        const txHash = await cip30WalletAPI.submitTx(tx);\n        setTx({\n            txId: txHash.hex\n        });\n        setIsLoading(false);\n    } catch (err) {\n        setIsLoading(false);\n        throw console.error(\"submit tx failed\", err);\n    }\n}\nasync function send(walletAPI, setIsLoading, setTx) {\n    setIsLoading(true);\n    if (!walletAPI) {\n        throw console.error(\"walletAPI is not set\");\n    }\n    try {\n        const cip30WalletAPI = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Cip30Wallet(walletAPI);\n        // const blockfrost = new BlockFrostIPFS({\n        //   network: network,\n        //   projectId: \"preprodJExO0MAMRgfpXz9Il4IqB2u9ddoylZBT\",\n        // });\n        const bfrost = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.BlockfrostV0(_common_network__WEBPACK_IMPORTED_MODULE_0__.network, API_KEY);\n        const walletHelper = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.WalletHelper(cip30WalletAPI);\n        const policyId = \"e16c2dc8ae937e8d3790c7fd7168d7b994621ba14ca11415f39fed72\";\n        const name = Buffer.from(\"MIN\", \"utf8\").toString(\"hex\");\n        // const policyId = \"\";\n        // const name = Buffer.from(\"\", 'utf8').toString('hex');\n        const mph = _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.MintingPolicyHash.fromHex(policyId);\n        const assetClass = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.AssetClass({\n            mph: mph,\n            tokenName: name // Convert to hex string\n        });\n        console.log(assetClass);\n        const minAda = 1000000; // minimum lovelace to send\n        const minAdaVal = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Value(BigInt(minAda));\n        //  const benefitiaryValue = new Value(BigInt(10000), new Assets([\n        //   [mph, [[name, BigInt(10000)]]]\n        // ]))\n        const testValueScript = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Assets([\n            [\n                assetClass,\n                BigInt(5000)\n            ]\n        ]);\n        // Get wallet UTXOs\n        const utxos = await walletHelper.pickUtxos(new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Value(undefined, testValueScript));\n        console.log(utxos);\n        // Get change address\n        const benefitiary = await walletHelper.changeAddress;\n        // Load in the vesting validator script (program)\n        const gameReward = new _contracts_vesting_hl__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n        // Compile the vesting validator\n        const compiledProgram = gameReward.compile(optimize);\n        console.log(\"Wallet address: \" + benefitiary);\n        const scriptAddress = _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Address.fromHashes(compiledProgram.validatorHash);\n        //remove\n        console.log(scriptAddress.toBech32());\n        console.log(\"Script Address:\" + scriptAddress);\n        // Construct the vesting datum\n        const gameDatum = new gameReward.types.Datum(benefitiary.pubKeyHash);\n        //const redeember = (new gameReward.types.Redeemer.Claim())._toUplcData();\n        const tx = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Tx();\n        tx.addInputs(utxos[0]);\n        tx.addOutput(new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.TxOutput(scriptAddress, new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Value(undefined, testValueScript), _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Datum.inline(gameDatum)));\n        // tx.addOutput(new TxOutput(\n        //   benefitiary,\n        //   minAdaVal,\n        // ));\n        console.log(\"We attatched everything!\");\n        // Read in the network parameter file\n        const networkParamsJson = await (0,_common_network__WEBPACK_IMPORTED_MODULE_0__.getNetworkParams)(_common_network__WEBPACK_IMPORTED_MODULE_0__.network);\n        const networkParams = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.NetworkParams(networkParamsJson);\n        // Send any change back to the buyer\n        await tx.finalize(networkParams, benefitiary, utxos[1]);\n        // Sign the unsigned tx to get the witness\n        const signatures = await cip30WalletAPI.signTx(tx);\n        tx.addSignatures(signatures);\n        console.log(\"signed\");\n        // Submit the signed tx\n        const txHash = await cip30WalletAPI.submitTx(tx);\n        setTx({\n            txId: txHash.hex\n        });\n        setIsLoading(false);\n    } catch (err) {\n        setIsLoading(false);\n        throw console.error(\"submit tx failed\", err);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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MEIsb0JBQW9CLE1BQU03RSxpRUFBZ0JBLENBQUNELG9EQUFPQTtRQUN4RCxNQUFNK0UsZ0JBQWdCLElBQUkzRiw2REFBYUEsQ0FBQzBGO1FBRXhDLG9DQUFvQztRQUNwQyxNQUFNNEMsR0FBR1MsUUFBUSxDQUFDcEQsZUFBZVMsYUFBYWxGLEtBQUssQ0FBQyxFQUFFO1FBRXRELDBDQUEwQztRQUMxQyxNQUFNOEgsYUFBYSxNQUFNekQsZUFBZTBELE1BQU0sQ0FBQ1g7UUFDL0NBLEdBQUdZLGFBQWEsQ0FBQ0Y7UUFFakJqRixRQUFRQyxHQUFHLENBQUM7UUFDWix1QkFBdUI7UUFDdkIsTUFBTW1GLFNBQVMsTUFBTTVELGVBQWU2RCxRQUFRLENBQUNkO1FBRTdDakQsTUFBTTtZQUFFZ0UsTUFBTUYsT0FBT0csR0FBRztRQUFDO1FBQ3pCbEUsYUFBYTtJQUVmLEVBQUUsT0FBT21FLEtBQUs7UUFDVm5FLGFBQWE7UUFDYixNQUFNckIsUUFBUXVCLEtBQUssQ0FBQyxvQkFBb0JpRTtJQUM1QztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3B1YmxpYy93YWxsZXRBY3Rpb25zLnRzPzViMDgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gd2FsbGV0QWN0aW9ucy50c1xyXG5pbXBvcnQgeyBcclxuICAgIE5ldHdvcmtQYXJhbXMsXHJcbiAgICBWYWx1ZSxcclxuICAgIFR4T3V0cHV0LFxyXG4gICAgVHgsXHJcbiAgICBUeElucHV0LFxyXG4gICAgQ2lwMzBXYWxsZXQsXHJcbiAgICBEYXR1bSxcclxuICAgIEFzc2V0cyxcclxuICAgIEJsb2NrZnJvc3RWMCxcclxuICAgIFdhbGxldEhlbHBlcixcclxuICAgIE1pbnRpbmdQb2xpY3lIYXNoLFxyXG4gICAgQXNzZXRDbGFzcyxcclxuICAgIEFkZHJlc3NcclxuICB9IGZyb20gXCJAaHlwZXJpb25idC9oZWxpb3NcIjtcclxuICBpbXBvcnQgeyBuZXR3b3JrLCBnZXROZXR3b3JrUGFyYW1zIH0gZnJvbSAnLi4vY29tbW9uL25ldHdvcmsnO1xyXG4gIGltcG9ydCBHYW1lUmV3YXJkIGZyb20gJy4uL2NvbnRyYWN0cy92ZXN0aW5nLmhsJzsgLy8gRW5zdXJlIGNvcnJlY3QgcGF0aCB0byB5b3VyIGNvbnRyYWN0XHJcbiAgXHJcbiAgY29uc3Qgb3B0aW1pemUgPSBmYWxzZTtcclxuICBjb25zdCBBUElfS0VZID0gJ3ByZXByb2RKRXhPME1BTVJnZnBYejlJbDRJcUIydTlkZG95bFpCVCc7IC8vIFJlcGxhY2Ugd2l0aCB5b3VyIGtleVxyXG4gXHJcbmZ1bmN0aW9uIGdldFRva2VuQW1vdW50RnJvbVV0eG9zKHV0eG9zOiBUeElucHV0W10sIGFzc2V0Q2xhc3M6IEFzc2V0Q2xhc3MpOiBiaWdpbnQge1xyXG4gICAgbGV0IHRvdGFsQW1vdW50ID0gQmlnSW50KDApO1xyXG4gIFxyXG4gICAgdXR4b3MuZm9yRWFjaCgodXR4bzogVHhJbnB1dCkgPT4ge1xyXG4gICAgICAgIC8vIEFzc3VtaW5nIHV0eG8udmFsdWUgaXMgaW4gdGhlIHJpZ2h0IGZvcm1hdFxyXG4gICAgICAgIGNvbnN0IHRva2VucyA9IHV0eG8udmFsdWUuYXNzZXRzLmdldFRva2Vucyhhc3NldENsYXNzLm1pbnRpbmdQb2xpY3lIYXNoKTtcclxuICAgICAgICB0b2tlbnMuZm9yRWFjaCgoW3Rva2VuTmFtZSwgYW1vdW50XSkgPT4ge1xyXG4gICAgICAgICAgdG90YWxBbW91bnQgKz0gQmlnSW50KGFtb3VudC52YWx1ZSk7IC8vIEFkZCB0aGUgYW1vdW50IHRvIHRoZSB0b3RhbFxyXG4gICAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICBcclxuICAgIHJldHVybiB0b3RhbEFtb3VudDtcclxuICB9XHJcbiAgXHJcbiAgZnVuY3Rpb24gY2FsY3VsYXRlUmV3YXJkKHJlbWFpbmluZ1N1cHBseTogbnVtYmVyLCB0b3RhbFN1cHBseTogbnVtYmVyLCBiYXNlUmV3YXJkOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgY29uc3QgaGFsdmluZ1RocmVzaG9sZCA9IHRvdGFsU3VwcGx5ICogMC4xOyAvLyAxMCUgb2YgdG90YWwgc3VwcGx5IGFzIHRoZSBoYWx2aW5nIHRocmVzaG9sZFxyXG4gIFxyXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgaGFsdmluZyBzdGVwc1xyXG4gICAgY29uc3QgaGFsdmluZ1N0ZXBzID0gTWF0aC5mbG9vcigodG90YWxTdXBwbHkgLSByZW1haW5pbmdTdXBwbHkpIC8gaGFsdmluZ1RocmVzaG9sZCk7XHJcbiAgXHJcbiAgICAvLyBDYWxjdWxhdGUgdGhlIHJld2FyZCBhZnRlciBhcHBseWluZyBoYWx2aW5nIHN0ZXBzXHJcbiAgICBjb25zdCByZXdhcmQgPSBNYXRoLmZsb29yKGJhc2VSZXdhcmQgLyAoMSArIGhhbHZpbmdTdGVwcykpO1xyXG4gIFxyXG4gICAgLy8gRW5zdXJlIHRoZSByZXdhcmQgZG9lc24ndCBkcm9wIGJlbG93IDFcclxuICAgIHJldHVybiByZXdhcmQgPCAxID8gMSA6IHJld2FyZDtcclxuICB9XHJcbiAgXHJcbiAgZnVuY3Rpb24gcGlja1V0eG9zKHV0eG9zOiBUeElucHV0W10sIHRhcmdldEFtb3VudDogYmlnaW50LCBhc3NldENsYXNzOiBBc3NldENsYXNzKTogeyBzZWxlY3RlZDogVHhJbnB1dFtdOyB0b3RhbEFtb3VudDogYmlnaW50IH0ge1xyXG4gICAgY29uc3Qgc2VsZWN0ZWQ6IFR4SW5wdXRbXSA9IFtdO1xyXG4gICAgbGV0IHRvdGFsQW1vdW50OiBiaWdpbnQgPSAwbjtcclxuICBcclxuICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIGluZGljZXMgd2UndmUgYWxyZWFkeSBwaWNrZWRcclxuICAgIGNvbnN0IHVzZWRJbmRpY2VzID0gbmV3IFNldDxudW1iZXI+KCk7XHJcbiAgXHJcbiAgICB3aGlsZSAodG90YWxBbW91bnQgPCB0YXJnZXRBbW91bnQpIHtcclxuICAgICAgICAvLyBHZW5lcmF0ZSBhIHJhbmRvbSBpbmRleCB3aXRoaW4gdGhlIGJvdW5kcyBvZiB0aGUgVVRYT3MgYXJyYXlcclxuICAgICAgICBjb25zdCByYW5kb21JbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHV0eG9zLmxlbmd0aCk7XHJcbiAgXHJcbiAgICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBzZWxlY3RlZCB0aGlzIGluZGV4LCBza2lwIGl0XHJcbiAgICAgICAgaWYgKHVzZWRJbmRpY2VzLmhhcyhyYW5kb21JbmRleCkpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gIFxyXG4gICAgICAgIC8vIE1hcmsgdGhlIGluZGV4IGFzIHVzZWRcclxuICAgICAgICB1c2VkSW5kaWNlcy5hZGQocmFuZG9tSW5kZXgpO1xyXG4gIFxyXG4gICAgICAgIC8vIEFkZCB0aGUgVVRYTyB0byB0aGUgc2VsZWN0ZWQgbGlzdFxyXG4gICAgICAgIGNvbnN0IHNlbGVjdGVkVXR4byA9IHV0eG9zW3JhbmRvbUluZGV4XTtcclxuICAgICAgICBzZWxlY3RlZC5wdXNoKHNlbGVjdGVkVXR4byk7XHJcbiAgICAgICAgY29uc3QgdG9rZW5zID0gc2VsZWN0ZWRVdHhvLnZhbHVlLmFzc2V0cy5nZXRUb2tlbnMoYXNzZXRDbGFzcy5taW50aW5nUG9saWN5SGFzaCk7XHJcbiAgICAgICAgdG9rZW5zLmZvckVhY2goKFt0b2tlbk5hbWUsIGFtb3VudF0pID0+IHtcclxuICAgICAgICAgIHRvdGFsQW1vdW50ICs9IEJpZ0ludChhbW91bnQudmFsdWUpOyAvLyBBZGQgdGhlIGFtb3VudCB0byB0aGUgdG90YWxcclxuICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG4gIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzZWxlY3RlZCxcclxuICAgICAgICB0b3RhbEFtb3VudCxcclxuICAgIH07XHJcbiAgfVxyXG4gIFxyXG4gIC8vIENhbGN1bGF0ZSB0aGUgcmV3YXJkIGJhc2VkIG9uIHRoZSB0aW1lIGVsYXBzZWQgc2luY2UgY29udHJhY3QgZGVwbG95bWVudFxyXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZVJld2FyZEluVGltZShUaW1lQmVnaW5Db250cmFjdDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIFRpbWVCZWdpbkNvbnRyYWN0ID0gVGltZUJlZ2luQ29udHJhY3QgLyAxMDAwO1xyXG4gICAgY29uc3QgSEFMVklOR19QRVJJT0Q6IG51bWJlciA9IDI1OTIwMDA7IC8vIDEgbW9udGggaW4gc2Vjb25kcyAoNjAgKiA2MCAqIDI0ICogMzApXHJcbiAgICBjb25zdCBNQVhfSEFMVklOR1M6IG51bWJlciA9IDU7IC8vIExpbWl0IGhhbHZpbmdzIHRvIDUgdGltZXNcclxuICAgIGNvbnN0IEJBU0VfUkVXQVJEOiBudW1iZXIgPSAxMDAwOyAvLyBJbml0aWFsIHJld2FyZCBpbiB0b2tlbnNcclxuICBcclxuICAgIC8vIEdldCBjdXJyZW50IHRpbWUgaW4gc2Vjb25kc1xyXG4gICAgY29uc3QgVGltZU5vdzogbnVtYmVyID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7IFxyXG4gIFxyXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBlbGFwc2VkIHRpbWUgaW4gc2Vjb25kc1xyXG4gICAgY29uc3QgdGltZUVsYXBzZWQ6IG51bWJlciA9IFRpbWVOb3cgLSBUaW1lQmVnaW5Db250cmFjdDtcclxuICAgIC8vIERldGVybWluZSBoYWx2aW5nIHN0ZXBzIGJhc2VkIG9uIGVsYXBzZWQgdGltZSwgYnV0IGxpbWl0IHRvIE1BWF9IQUxWSU5HU1xyXG4gICAgbGV0IGhhbHZpbmdTdGVwczogbnVtYmVyID0gTWF0aC5mbG9vcih0aW1lRWxhcHNlZCAvIEhBTFZJTkdfUEVSSU9EKTtcclxuICAgIGhhbHZpbmdTdGVwcyA9IE1hdGgubWluKGhhbHZpbmdTdGVwcywgTUFYX0hBTFZJTkdTKTsgLy8gQ2FwIGhhbHZpbmdzIGF0IE1BWF9IQUxWSU5HU1xyXG4gIFxyXG4gICAgIC8vIEVuc3VyZSB0aGUgbnVtYmVyIG9mIGhhbHZpbmcgc3RlcHMgZG9lc24ndCBleGNlZWQgdGhlIG1heGltdW0gYWxsb3dlZFxyXG4gICAgIGNvbnN0IGVmZmVjdGl2ZUhhbHZpbmdzOiBudW1iZXIgPSBNYXRoLm1pbihoYWx2aW5nU3RlcHMsIE1BWF9IQUxWSU5HUyk7XHJcbiAgICBjb25zb2xlLmxvZyhcIkhhbHZpbmdzXCIgKyBlZmZlY3RpdmVIYWx2aW5ncylcclxuICAgICAvLyBEaXJlY3RseSBjYWxjdWxhdGUgcmV3YXJkIGJhc2VkIG9uIGhhbHZpbmcgc3RlcHMgdXNpbmcgYSBiaXQgc2hpZnRcclxuICAgICBjb25zdCByZXdhcmQ6IG51bWJlciA9IEJBU0VfUkVXQVJEIC8gKDIgKiogZWZmZWN0aXZlSGFsdmluZ3MpO1xyXG4gICBcclxuICAgICAvLyBSZXR1cm4gdGhlIHJld2FyZCwgZW5zdXJpbmcgaXQgZG9lc24ndCBmYWxsIGJlbG93IGEgbWluaW11bSB2YWx1ZVxyXG4gICAgIHJldHVybiByZXdhcmQgPCAxID8gMSA6IHJld2FyZDtcclxuICB9XHJcbiAgXHJcbiAgZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUNvdW50ZG93bihUaW1lQmVnaW5Db250cmFjdDogbnVtYmVyKTogbnVtYmVyIHtcclxuICBcclxuICAgIGNvbnNvbGUubG9nKFwiVGltZUJlZ2luQ29udHJhY3RcIiArIFRpbWVCZWdpbkNvbnRyYWN0KTtcclxuICAgIGNvbnN0IFRpbWVOb3c6IG51bWJlciA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSk7IFxyXG4gICAgY29uc29sZS5sb2coXCJUSU1FIG5vdyBpbiBNU1wiICsgVGltZU5vdylcclxuICAgIGNvbnN0IENZQ0xFX0RVUkFUSU9OID0gNTQwIC8vIDkgbWludXRlcyBcclxuICAgIGNvbnN0IG9mZnNldEluTXMgPSA4OTY4MDtcclxuICAgIGNvbnN0IGVsYXBzZWRUaW1lID0gVGltZU5vdyAtIChvZmZzZXRJbk1zKSAtIFRpbWVCZWdpbkNvbnRyYWN0O1xyXG4gICAgY29uc29sZS5sb2coXCJlbGFwZXNlZFRpbWVcIiArIGVsYXBzZWRUaW1lKVxyXG4gICAgY29uc3QgZWxhcHNlZFRpbWVJblNlY29uZHMgPSBlbGFwc2VkVGltZSAvIDEwMDA7XHJcbiAgICBjb25zdCBwb3NpdGlvbkluQ3ljbGUgPSBlbGFwc2VkVGltZUluU2Vjb25kcyAlIENZQ0xFX0RVUkFUSU9OO1xyXG4gIFxyXG4gICAgY29uc29sZS5sb2cocG9zaXRpb25JbkN5Y2xlKTtcclxuICAgIHJldHVybiBwb3NpdGlvbkluQ3ljbGU7XHJcbiAgfVxyXG4gIFxyXG4gIC8vIEZ1bmN0aW9uIHRvIGZpbHRlciBhbmQgcGljayBhIHJhbmRvbSBUeElucHV0IHdpdGggc3VmZmljaWVudCB2YWx1ZVxyXG4gIGZ1bmN0aW9uIHBpY2tSYW5kb21UeElucHV0V2l0aFN1ZmZpY2llbnRWYWx1ZShcclxuICAgIHR4SW5wdXRzOiBUeElucHV0W10sXHJcbiAgICBkeW5hbWljUmV3YXJkOiBiaWdpbnQsXHJcbiAgICBhc3NldENsYXNzOiBBc3NldENsYXNzXHJcbiAgKTogeyB0eElucHV0OiBUeElucHV0OyB0b2tlbkFtb3VudDogYmlnaW50LCByZW1haW5pbmdVdHhvczogVHhJbnB1dFtdIH0ge1xyXG4gICAgLy8gRmlsdGVyIFR4SW5wdXRzIHRoYXQgaGF2ZSBzdWZmaWNpZW50IHRva2VuIHZhbHVlXHJcbiAgICBjb25zdCBlbGlnaWJsZVR4SW5wdXRzID0gdHhJbnB1dHMuZmlsdGVyKCh0eElucHV0OiBUeElucHV0KSA9PiB7XHJcbiAgICAgIC8vIEV4dHJhY3QgdGhlIHRva2VucyBhbmQgY2hlY2sgdGhlaXIgdmFsdWVcclxuICAgICAgY29uc3QgdG9rZW5zID0gdHhJbnB1dC5vdXRwdXQudmFsdWUuYXNzZXRzLmdldFRva2Vucyhhc3NldENsYXNzLm1pbnRpbmdQb2xpY3lIYXNoKTtcclxuICAgICAgbGV0IHRva2VuQW1vdW50ID0gQmlnSW50KDApO1xyXG4gIFxyXG4gICAgICB0b2tlbnMuZm9yRWFjaCgoW3Rva2VuTmFtZSwgYW1vdW50XSkgPT4ge1xyXG4gICAgICAgIHRva2VuQW1vdW50ICs9IEJpZ0ludChhbW91bnQudmFsdWUpOyAvLyBBZGQgdGhlIGFtb3VudCB0byB0aGUgdG9rZW4gdG90YWxcclxuICAgICAgfSk7XHJcbiAgXHJcbiAgICAgIHJldHVybiB0b2tlbkFtb3VudCA+PSBkeW5hbWljUmV3YXJkOyAvLyBDaGVjayBpZiB0aGUgdG90YWwgdG9rZW4gdmFsdWUgbWVldHMgb3IgZXhjZWVkcyB0aGUgcmV3YXJkXHJcbiAgICB9KTtcclxuICBcclxuICAgIC8vIElmIHRoZXJlIGFyZSBubyBlbGlnaWJsZSBUeElucHV0cywgdGhyb3cgYW4gZXJyb3JcclxuICAgIGlmIChlbGlnaWJsZVR4SW5wdXRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBlbGlnaWJsZSBUeElucHV0IGZvdW5kIHdpdGggc3VmZmljaWVudCB0b2tlbiB2YWx1ZS5cIik7XHJcbiAgICB9XHJcbiAgXHJcbiAgICAvLyBQaWNrIGEgcmFuZG9tIFR4SW5wdXQgZnJvbSB0aGUgZWxpZ2libGUgbGlzdFxyXG4gICAgY29uc3QgcmFuZG9tSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBlbGlnaWJsZVR4SW5wdXRzLmxlbmd0aCk7XHJcbiAgICBjb25zdCBzZWxlY3RlZFR4SW5wdXQgPSBlbGlnaWJsZVR4SW5wdXRzW3JhbmRvbUluZGV4XTtcclxuICBcclxuICAgIC8vIENhbGN1bGF0ZSB0aGUgdG9rZW4gdmFsdWUgb2YgdGhlIHNlbGVjdGVkIFR4SW5wdXRcclxuICAgIGNvbnN0IHRva2VucyA9IHNlbGVjdGVkVHhJbnB1dC5vdXRwdXQudmFsdWUuYXNzZXRzLmdldFRva2Vucyhhc3NldENsYXNzLm1pbnRpbmdQb2xpY3lIYXNoKTtcclxuICAgIGxldCB0b2tlbkFtb3VudCA9IEJpZ0ludCgwKTtcclxuICBcclxuICAgIHRva2Vucy5mb3JFYWNoKChbdG9rZW5OYW1lLCBhbW91bnRdKSA9PiB7XHJcbiAgICAgIHRva2VuQW1vdW50ICs9IEJpZ0ludChhbW91bnQudmFsdWUpOyAvLyBBZGQgdGhlIGFtb3VudCB0byB0aGUgdG9rZW4gdG90YWxcclxuICAgIH0pO1xyXG4gIFxyXG4gICAgY29uc3QgcmVtYWluaW5nVXR4b3MgPSB0eElucHV0cy5maWx0ZXIoKHR4SW5wdXQpID0+IHR4SW5wdXQgIT09IHNlbGVjdGVkVHhJbnB1dCk7XHJcbiAgXHJcbiAgICAvLyBSZXR1cm4gdGhlIHNlbGVjdGVkIFR4SW5wdXQgYW5kIGl0cyB0b2tlbiB2YWx1ZVxyXG4gICAgcmV0dXJuIHsgdHhJbnB1dDogc2VsZWN0ZWRUeElucHV0LCB0b2tlbkFtb3VudCwgcmVtYWluaW5nVXR4b3MgfTtcclxuICB9XHJcbiAgXHJcbiAgZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNsYWltVG9rZW5zKHdhbGxldEFQSTogYW55LCBzZXRJc0xvYWRpbmc6ICh2YWw6IGJvb2xlYW4pID0+IHZvaWQsIHNldFR4OiAodmFsOiB7dHhJZDogc3RyaW5nfSkgPT4gdm9pZCkge1xyXG4gICAgc2V0SXNMb2FkaW5nKHRydWUpO1xyXG5cclxuICAgIGlmICghd2FsbGV0QVBJKSB7XHJcbiAgICAgIHRocm93IGNvbnNvbGUuZXJyb3IoXCJ3YWxsZXRBUEkgaXMgbm90IHNldFwiKTtcclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGNpcDMwV2FsbGV0QVBJID0gbmV3IENpcDMwV2FsbGV0KHdhbGxldEFQSSk7XHJcblxyXG4gICAgICBjb25zdCBiZnJvc3QgPSBuZXcgQmxvY2tmcm9zdFYwKG5ldHdvcmssIEFQSV9LRVkpO1xyXG5cclxuICAgICAgY29uc3Qgd2FsbGV0SGVscGVyID0gbmV3IFdhbGxldEhlbHBlcihjaXAzMFdhbGxldEFQSSk7XHJcbiAgICAgIC8vIFJlYWQgaW4gdGhlIG5ldHdvcmsgcGFyYW1ldGVyIGZpbGVcclxuICAgICAgY29uc3QgbmV0d29ya1BhcmFtc0pzb24gPSBhd2FpdCBnZXROZXR3b3JrUGFyYW1zKG5ldHdvcmspO1xyXG4gICAgICBjb25zdCBuZXR3b3JrUGFyYW1zID0gbmV3IE5ldHdvcmtQYXJhbXMobmV0d29ya1BhcmFtc0pzb24pO1xyXG5cclxuICAgICAgY29uc3QgcG9saWN5SWQgPSBcImUxNmMyZGM4YWU5MzdlOGQzNzkwYzdmZDcxNjhkN2I5OTQ2MjFiYTE0Y2ExMTQxNWYzOWZlZDcyXCI7XHJcbiAgICAgIGNvbnN0IG5hbWUgPSBCdWZmZXIuZnJvbShcIk1JTlwiLCAndXRmOCcpLnRvU3RyaW5nKCdoZXgnKTtcclxuXHJcbiAgICAgIC8vIGNvbnN0IHBvbGljeUlkID0gXCJcIjtcclxuICAgICAgLy8gY29uc3QgbmFtZSA9IEJ1ZmZlci5mcm9tKFwiXCIsICd1dGY4JykudG9TdHJpbmcoJ2hleCcpO1xyXG5cclxuICAgICAgY29uc3QgbXBoID0gTWludGluZ1BvbGljeUhhc2guZnJvbUhleChwb2xpY3lJZCk7XHJcblxyXG4gICAgICBjb25zdCBhc3NldENsYXNzID0gbmV3IEFzc2V0Q2xhc3Moe1xyXG4gICAgICAgIG1waDogbXBoLCAvLyBZb3VyIHBvbGljeSBoYXNoXHJcbiAgICAgICAgdG9rZW5OYW1lOiBuYW1lLy8gQ29udmVydCB0byBoZXggc3RyaW5nXHJcbiAgICAgIH0pOyBcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coYXNzZXRDbGFzcylcclxuXHJcbiAgICAgIGNvbnN0IHRva2VuQW1vdW50ID0gQmlnSW50KDEwMCk7XHJcbiAgICAgIGNvbnN0IHRva2VuVmFsID0gbmV3IFZhbHVlKHRva2VuQW1vdW50KTtcclxuICAgICAgY29uc3QgdXR4b3MgPSBhd2FpdCB3YWxsZXRIZWxwZXIucGlja1V0eG9zKHRva2VuVmFsKTtcclxuXHJcbiAgICAgIC8vIEdldCBjaGFuZ2UgYWRkcmVzc1xyXG4gICAgICBjb25zdCBiZW5lZml0aWFyeSA9IGF3YWl0IHdhbGxldEhlbHBlci5jaGFuZ2VBZGRyZXNzO1xyXG4gICAgICAvLyBMb2FkIGluIHRoZSB2ZXN0aW5nIHZhbGlkYXRvciBzY3JpcHQgKHByb2dyYW0pXHJcbiAgICAgIGNvbnN0IGdhbWVSZXdhcmQgPSBuZXcgR2FtZVJld2FyZCgpO1xyXG5cclxuICAgICAgLy8gQ29tcGlsZSB0aGUgdmVzdGluZyB2YWxpZGF0b3JcclxuICAgICAgY29uc3QgY29tcGlsZWRQcm9ncmFtID0gZ2FtZVJld2FyZC5jb21waWxlKG9wdGltaXplKTtcclxuICAgICAgY29uc29sZS5sb2coXCJXYWxsZXQgYWRkcmVzczogXCIgKyBiZW5lZml0aWFyeSlcclxuICAgICAgY29uc3Qgc2NyaXB0QWRkcmVzcyA9IEFkZHJlc3MuZnJvbUhhc2hlcyhjb21waWxlZFByb2dyYW0udmFsaWRhdG9ySGFzaClcclxuICAgIFxyXG4gICAgICAgIC8vcmVtb3ZlXHJcbiAgICAgIGNvbnNvbGUubG9nKHNjcmlwdEFkZHJlc3MudG9CZWNoMzIoKSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiU2NyaXB0IEFkZHJlc3M6XCIgKyBzY3JpcHRBZGRyZXNzKVxyXG4gICAgICBcclxuICAgICAgY29uc29sZS5kaXIoc2NyaXB0QWRkcmVzcywgeyBkZXB0aDogbnVsbCB9KTtcclxuXHJcblxyXG4gICAgICBjb25zdCB0eElucHV0czogVHhJbnB1dFtdID0gYXdhaXQgYmZyb3N0LmdldFV0eG9zKHNjcmlwdEFkZHJlc3MpO1xyXG4gICAgICB2YXIgZmlsdGVyZWRVdHhvcyA9IHR4SW5wdXRzLmZpbHRlcih4ID0+IHgudmFsdWUuYXNzZXRzLmdldFRva2Vucyhhc3NldENsYXNzLm1pbnRpbmdQb2xpY3lIYXNoKSk7XHJcblxyXG4gICAgICAvLyBjb25zdCBCQVNFX1JFV0FSRDogbnVtYmVyID0gMTAwMDsgIC8vIEJhc2UgcmV3YXJkXHJcbiAgICAgIC8vIGNvbnN0IFRPVEFMX1NVUFBMWSA9IDEwMDAwOyAvLyBUb3RhbCB0b2tlbiBzdXBwbHlcclxuICAgICAgY29uc3QgQ0xBSU1fV0lORE9XID0gNjA7IC8vIDEgbWludXRlIFxyXG5cclxuICAgICAgY29uc29sZS5sb2coXCJmaWx0ZXJlZHVUWE9zXCIgKyBmaWx0ZXJlZFV0eG9zKVxyXG4gICAgICBjb25zdCBUaW1lQmVnaW5Db250cmFjdDogbnVtYmVyID0gTWF0aC5mbG9vcihuZXcgRGF0ZShEYXRlLlVUQygyMDI0LCAxMSwgOCwgMTMsIDQ1LCAwKSkuZ2V0VGltZSgpKTtcclxuICAgICAgLy9jb25zdCByZW1haW5pbmdTdXBwbHkgPSBnZXRUb2tlbkFtb3VudEZyb21VdHhvcyhmaWx0ZXJlZFV0eG9zLCBhc3NldENsYXNzKTtcclxuICAgICAgY29uc3QgZHluYW1pY1Jld2FyZCA9IGNhbGN1bGF0ZVJld2FyZEluVGltZShUaW1lQmVnaW5Db250cmFjdClcclxuICAgICAgY29uc3QgcG9zaXRpb25JbkN5Y2xlID0gY2FsY3VsYXRlQ291bnRkb3duKFRpbWVCZWdpbkNvbnRyYWN0KTtcclxuICAgICAgY29uc29sZS5sb2cocG9zaXRpb25JbkN5Y2xlKTtcclxuICAgICAgd2luZG93Lm9uZXJyb3IgPSAoKSA9PiBwb3NpdGlvbkluQ3ljbGUgPCBDTEFJTV9XSU5ET1c7XHJcbiAgICAgIC8vY29uc3QgZHluYW1pY1Jld2FyZCA9IGNhbGN1bGF0ZVJld2FyZChOdW1iZXIocmVtYWluaW5nU3VwcGx5KSwgVE9UQUxfU1VQUExZLCBCQVNFX1JFV0FSRCk7XHJcbiAgICAgIGNvbnN0IHRlc3RWYWx1ZUJlbmVmaXRpYXJ5PSBuZXcgQXNzZXRzKFtbYXNzZXRDbGFzcywgQmlnSW50KGR5bmFtaWNSZXdhcmQpXV0pO1xyXG5cclxuICAgICAgLy9jb25zdCByZXN1bHQgPSBwaWNrUmFuZG9tVHhJbnB1dFdpdGhTdWZmaWNpZW50VmFsdWUoZmlsdGVyZWRVdHhvcywgQmlnSW50KGR5bmFtaWNSZXdhcmQpLCBhc3NldENsYXNzKTtcclxuICAgICAgLy9jb25zb2xlLmxvZyhcInJhbmRvbVVUWE86XCIgKyByZXN1bHQudHhJbnB1dClcclxuXHJcbiAgICAgIC8vY29uc3QgYW1vdW50VG9TZW5kQmFjayA9IHJlc3VsdC50b2tlbkFtb3VudCAtIEJpZ0ludChkeW5hbWljUmV3YXJkKTtcclxuICAgICAgLy8gY29uc29sZS5sb2coXCJhbW91bnRUb1NlbmRCYWNrXCIgKyBhbW91bnRUb1NlbmRCYWNrKVxyXG4gICAgICAvLyBjb25zb2xlLmxvZyhcIlV0eG9BbW91bnRcIiArIHJlc3VsdC50b2tlbkFtb3VudClcclxuICAgICAgLy8gY29uc29sZS5sb2coXCJUaGUgcmVzdFwiICsgcmVzdWx0LnJlbWFpbmluZ1V0eG9zKVxyXG4gICAgICBcclxuICAgICAgLy9jb25zb2xlLmxvZyhmaWx0ZXJlZFV0eG9zKVxyXG4gICAgICAvLyBjb25zdCByZW1vdGVXYWxsZXQgPSBuZXcgUmVtb3RlV2FsbGV0KGZhbHNlLCBbc2NyaXB0QWRkcmVzc10sIFtdLCB0eElucHV0cyk7XHJcbiAgICAgIC8vIGNvbnN0IHdhbGxldEhlbHBlclNjcmlwdCA9IG5ldyBXYWxsZXRIZWxwZXIocmVtb3RlV2FsbGV0KTtcclxuICAgICAgY29uc3Qgc29ydGVkVXR4b3MgPSBwaWNrVXR4b3MoZmlsdGVyZWRVdHhvcywgQmlnSW50KGR5bmFtaWNSZXdhcmQpLCBhc3NldENsYXNzKTsgXHJcbiAgICAgIFxyXG4gICAgICBzb3J0ZWRVdHhvcy5zZWxlY3RlZC5mb3JFYWNoKGVsZW1lbnQgPT4ge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coZWxlbWVudClcclxuICAgICAgfSk7XHJcbiAgICAgIC8vY29uc3QgdG90YWxBbW91bnRVdHhvID0gZ2V0VG9rZW5BbW91bnRGcm9tVXR4b3Moc29ydGVkVXR4b3Muc2VsZWN0ZWQsIGFzc2V0Q2xhc3MpO1xyXG4gICAgICBjb25zdCBhbW91bnRUb1NlbmRCYWNrID0gc29ydGVkVXR4b3MudG90YWxBbW91bnQgLSBCaWdJbnQoZHluYW1pY1Jld2FyZCk7XHJcblxyXG4gICAgICBjb25zdCBmaXJzdFBhcnRUb1NlbmRCYWNrID0gYW1vdW50VG9TZW5kQmFjayAvIDJuOyAvLyBGaXJzdCBwYXJ0IGlzIGhhbGYgb2YgdGhlIHRvdGFsIGFtb3VudFxyXG4gICAgICBjb25zdCBzZWNvbmRQYXJ0VG9TZW5kQmFjayA9IGFtb3VudFRvU2VuZEJhY2sgLSBmaXJzdFBhcnRUb1NlbmRCYWNrOyAvLyBTZWNvbmQgcGFydCBpcyB0aGUgcmVtYWluZGVyXHJcbiAgICAgIGNvbnNvbGUubG9nKFwiRmlyc3QgXCIgKyBmaXJzdFBhcnRUb1NlbmRCYWNrKVxyXG4gICAgICBjb25zb2xlLmxvZyhcIlNldm9uZCBcIiArIHNlY29uZFBhcnRUb1NlbmRCYWNrKVxyXG4gICAgICBjb25zb2xlLmxvZyhkeW5hbWljUmV3YXJkXHQpXHJcblxyXG4gICAgICBjb25zdCB2YWx1ZUNvbnRyYWN0MT0gbmV3IEFzc2V0cyhbW2Fzc2V0Q2xhc3MsIGZpcnN0UGFydFRvU2VuZEJhY2tdXSk7XHJcbiAgICAgIGNvbnN0IHZhbHVlQ29udHJhY3QyPSBuZXcgQXNzZXRzKFtbYXNzZXRDbGFzcywgc2Vjb25kUGFydFRvU2VuZEJhY2tdXSk7XHJcblxyXG5cclxuICAgICAgY29uc3QgZ2FtZURhdHVtID0gbmV3IGdhbWVSZXdhcmQudHlwZXMuRGF0dW0oXHJcbiAgICAgICAgYmVuZWZpdGlhcnkucHViS2V5SGFzaCxcclxuICAgICAgKVxyXG5cclxuICAgICAgY29uc29sZS5sb2coXCJXZSBoYXZlIGEgZGF0dW0hXCIgKyBnYW1lRGF0dW0pXHJcblxyXG4gICAgICAgLy8gQ3JlYXRlIHRoZSB2ZXN0aW5nIGNsYWltIHJlZGVlbWVyXHJcbiAgICAgICBjb25zdCByZWRlZW1iZXIgPSAobmV3IGdhbWVSZXdhcmQudHlwZXMuUmVkZWVtZXIuQ2xhaW0oYmVuZWZpdGlhcnkucHViS2V5SGFzaCkpXHJcbiAgICAgICAuX3RvVXBsY0RhdGEoKTtcclxuICAgIFxyXG4gICAgICAvL2NvbnNvbGUubG9nKGZpbHRlcmVkVXR4b3MpO1xyXG4gICAgICBjb25zdCB0eCA9IG5ldyBUeCgpO1xyXG5cclxuICAgICAgLy90eC5hZGRJbnB1dHModXR4b3NbMF0pO1xyXG4gICAgICB0eC5hZGRJbnB1dHMoc29ydGVkVXR4b3Muc2VsZWN0ZWQsIHJlZGVlbWJlcik7XHJcbiAgICAgIHR4LmF0dGFjaFNjcmlwdChjb21waWxlZFByb2dyYW0pO1xyXG5cclxuICAgICAgdmFyIHVzZXJDbGFpbU91dHB1dCA9IG5ldyBUeE91dHB1dChcclxuICAgICAgICBiZW5lZml0aWFyeSxcclxuICAgICAgICBuZXcgVmFsdWUodW5kZWZpbmVkLCB0ZXN0VmFsdWVCZW5lZml0aWFyeSkpO1xyXG5cclxuICAgICAgdHguYWRkT3V0cHV0KHVzZXJDbGFpbU91dHB1dCk7XHJcblxyXG4gICAgXHJcbiAgICAvL1NoaWlpdCwgZml4LiBTb21lb25lIGNvdWxkIHJlZGlyZWR0IHRoZSByZXN0IG9mIHRoZSB0b2tlbnNcclxuICAgIC8vIGNvbnN0IGFkZHJlc3NTdHIgPSBcImFkZHJfdGVzdDFxcmFycWhta2xuaHdjdzNxMHptNnNnbTNnM2w3cHVhMHkzNnNxbDlrNXJ1OGRzdWNnbHNrZWQ1ZjV5cmNmOWU5eGd4amdtdDd4azUya25oOGgwZGdheWMwMGFycWxoN2c2MFwiO1xyXG4gICAgLy8gY29uc3QgYWRkcmVzcyA9IEFkZHJlc3MuZnJvbUJlY2gzMihhZGRyZXNzU3RyKTtcclxuICAgIC8vIHR4LmFkZE91dHB1dChuZXcgVHhPdXRwdXQoXHJcbiAgICAvLyAgIGFkZHJlc3MsXHJcbiAgICAvLyAgIG5ldyBWYWx1ZSh1bmRlZmluZWQsIHRlc3RWYWx1ZUNvbnRyYWN0KSAvLyBUaGUgYW1vdW50IGJlaW5nIGNsYWltZWRcclxuICAgIC8vICkpO1xyXG4gICAgXHJcblxyXG4gICAgaWYgKGFtb3VudFRvU2VuZEJhY2sgIT0gQmlnSW50KDApKXtcclxuICAgICAgdmFyIHNjcmlwdFV0eG8xID1uZXcgVHhPdXRwdXQoXHJcbiAgICAgICAgc2NyaXB0QWRkcmVzcyxcclxuICAgICAgICBuZXcgVmFsdWUodW5kZWZpbmVkLCB2YWx1ZUNvbnRyYWN0MSksICAvLyBSZW1haW5pbmcgdHJlYXN1cnkgdG9rZW5zXHJcbiAgICAgICAgRGF0dW0uaW5saW5lKGdhbWVEYXR1bSkgLy8gQ29udHJhY3QgcmVxdWlyZXMgZGF0dW1cclxuICAgICAgICk7XHJcblxyXG4gICAgICAgdHguYWRkT3V0cHV0KHNjcmlwdFV0eG8xKTtcclxuXHJcbiAgICAgIHZhciBzY3JpcHRVdHhvMiA9IG5ldyBUeE91dHB1dChcclxuICAgICAgICBzY3JpcHRBZGRyZXNzLFxyXG4gICAgICAgIG5ldyBWYWx1ZSh1bmRlZmluZWQsIHZhbHVlQ29udHJhY3QyKSwgIC8vIFJlbWFpbmluZyB0cmVhc3VyeSB0b2tlbnNcclxuICAgICAgICBEYXR1bS5pbmxpbmUoZ2FtZURhdHVtKSAvLyBDb250cmFjdCByZXF1aXJlcyBkYXR1bVxyXG4gICAgICAgKTtcclxuICAgIFxyXG4gICAgICAgdHguYWRkT3V0cHV0KHNjcmlwdFV0eG8yKTtcclxuICAgIH0gIFxyXG5cclxuICAgICAgLy92YXIgaW5wdXRGZWVzID0gYXdhaXQgd2FsbGV0SGVscGVyLnBpY2tVdHhvcyhuZXcgVmFsdWUodG9rZW5BbW91bnRGZWVzKSk7XHJcbiAgICAgIFxyXG4gICAgICAvL3R4LmFkZElucHV0cyhpbnB1dEZlZXNbMF0pO1xyXG4gICAgICBjb25zb2xlLmxvZyhcIldlIGF0dGF0Y2hlZCBldmVyeXRoaW5nIVwiKVxyXG5cclxuICAgICAgYXdhaXQgdHguZmluYWxpemUobmV0d29ya1BhcmFtcywgYmVuZWZpdGlhcnksIHV0eG9zWzFdKTtcclxuXHJcbiAgICAgIC8vIFNpZ24gdGhlIHVuc2lnbmVkIHR4IHRvIGdldCB0aGUgd2l0bmVzc1xyXG4gICAgICBjb25zdCBzaWduYXR1cmVzID0gYXdhaXQgY2lwMzBXYWxsZXRBUEkuc2lnblR4KHR4KTtcclxuICAgICAgdHguYWRkU2lnbmF0dXJlcyhzaWduYXR1cmVzKTtcclxuXHJcbiAgICAgIGNvbnN0IHR4SGFzaCA9IGF3YWl0IGNpcDMwV2FsbGV0QVBJLnN1Ym1pdFR4KHR4KTtcclxuXHJcbiAgICAgIHNldFR4KHsgdHhJZDogdHhIYXNoLmhleCB9KTtcclxuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcclxuXHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgIHRocm93IGNvbnNvbGUuZXJyb3IoXCJzdWJtaXQgdHggZmFpbGVkXCIsIGVycik7XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIGV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZW5kKHdhbGxldEFQSTogYW55LCBzZXRJc0xvYWRpbmc6ICh2YWw6IGJvb2xlYW4pID0+IHZvaWQsIHNldFR4OiAodmFsOiB7dHhJZDogc3RyaW5nfSkgPT4gdm9pZCkge1xyXG4gICAgc2V0SXNMb2FkaW5nKHRydWUpO1xyXG5cclxuICAgIGlmICghd2FsbGV0QVBJKSB7XHJcbiAgICAgIHRocm93IGNvbnNvbGUuZXJyb3IoXCJ3YWxsZXRBUEkgaXMgbm90IHNldFwiKTtcclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGNpcDMwV2FsbGV0QVBJID0gbmV3IENpcDMwV2FsbGV0KHdhbGxldEFQSSk7XHJcbiAgICAgIC8vIGNvbnN0IGJsb2NrZnJvc3QgPSBuZXcgQmxvY2tGcm9zdElQRlMoe1xyXG4gICAgICAvLyAgIG5ldHdvcms6IG5ldHdvcmssXHJcbiAgICAgIC8vICAgcHJvamVjdElkOiBcInByZXByb2RKRXhPME1BTVJnZnBYejlJbDRJcUIydTlkZG95bFpCVFwiLFxyXG4gICAgICAvLyB9KTtcclxuICAgICAgY29uc3QgYmZyb3N0ID0gbmV3IEJsb2NrZnJvc3RWMChuZXR3b3JrLCBBUElfS0VZKTtcclxuXHJcbiAgICAgIGNvbnN0IHdhbGxldEhlbHBlciA9IG5ldyBXYWxsZXRIZWxwZXIoY2lwMzBXYWxsZXRBUEkpO1xyXG5cclxuICAgICAgY29uc3QgcG9saWN5SWQgPSBcImUxNmMyZGM4YWU5MzdlOGQzNzkwYzdmZDcxNjhkN2I5OTQ2MjFiYTE0Y2ExMTQxNWYzOWZlZDcyXCI7XHJcbiAgICAgIGNvbnN0IG5hbWUgPSBCdWZmZXIuZnJvbShcIk1JTlwiLCAndXRmOCcpLnRvU3RyaW5nKCdoZXgnKTtcclxuXHJcbiAgICAgIC8vIGNvbnN0IHBvbGljeUlkID0gXCJcIjtcclxuICAgICAgLy8gY29uc3QgbmFtZSA9IEJ1ZmZlci5mcm9tKFwiXCIsICd1dGY4JykudG9TdHJpbmcoJ2hleCcpO1xyXG5cclxuICAgICAgY29uc3QgbXBoID0gTWludGluZ1BvbGljeUhhc2guZnJvbUhleChwb2xpY3lJZCk7XHJcblxyXG4gICAgICBjb25zdCBhc3NldENsYXNzID0gbmV3IEFzc2V0Q2xhc3Moe1xyXG4gICAgICAgIG1waDogbXBoLCAvLyBZb3VyIHBvbGljeSBoYXNoXHJcbiAgICAgICAgdG9rZW5OYW1lOiBuYW1lLy8gQ29udmVydCB0byBoZXggc3RyaW5nXHJcbiAgICAgIH0pOyBcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coYXNzZXRDbGFzcylcclxuXHJcbiAgICAgIGNvbnN0IG1pbkFkYSA6IG51bWJlciA9IDFfMDAwXzAwMDsgLy8gbWluaW11bSBsb3ZlbGFjZSB0byBzZW5kXHJcbiAgICAgIGNvbnN0IG1pbkFkYVZhbCA9IG5ldyBWYWx1ZShCaWdJbnQobWluQWRhKSk7XHJcblxyXG4gICAgICAvLyAgY29uc3QgYmVuZWZpdGlhcnlWYWx1ZSA9IG5ldyBWYWx1ZShCaWdJbnQoMTAwMDApLCBuZXcgQXNzZXRzKFtcclxuICAgICAgLy8gICBbbXBoLCBbW25hbWUsIEJpZ0ludCgxMDAwMCldXV1cclxuICAgICAgLy8gXSkpXHJcblxyXG5cclxuICAgICAgY29uc3QgdGVzdFZhbHVlU2NyaXB0ID0gbmV3IEFzc2V0cyhbW2Fzc2V0Q2xhc3MsIEJpZ0ludCg1MDAwKV1dKTtcclxuXHJcblxyXG4gICAgICAvLyBHZXQgd2FsbGV0IFVUWE9zXHJcbiAgICAgIGNvbnN0IHV0eG9zID0gYXdhaXQgd2FsbGV0SGVscGVyLnBpY2tVdHhvcyhuZXcgVmFsdWUodW5kZWZpbmVkLCB0ZXN0VmFsdWVTY3JpcHQpKTtcclxuICAgICAgY29uc29sZS5sb2codXR4b3MpO1xyXG5cclxuICAgICAgLy8gR2V0IGNoYW5nZSBhZGRyZXNzXHJcbiAgICAgIGNvbnN0IGJlbmVmaXRpYXJ5ID0gYXdhaXQgd2FsbGV0SGVscGVyLmNoYW5nZUFkZHJlc3M7XHJcbiAgICAgIC8vIExvYWQgaW4gdGhlIHZlc3RpbmcgdmFsaWRhdG9yIHNjcmlwdCAocHJvZ3JhbSlcclxuICAgICAgY29uc3QgZ2FtZVJld2FyZCA9IG5ldyBHYW1lUmV3YXJkKCk7XHJcblxyXG4gICAgICAvLyBDb21waWxlIHRoZSB2ZXN0aW5nIHZhbGlkYXRvclxyXG4gICAgICBjb25zdCBjb21waWxlZFByb2dyYW0gPSBnYW1lUmV3YXJkLmNvbXBpbGUob3B0aW1pemUpO1xyXG4gICAgICBjb25zb2xlLmxvZyhcIldhbGxldCBhZGRyZXNzOiBcIiArIGJlbmVmaXRpYXJ5KVxyXG4gICAgICBjb25zdCBzY3JpcHRBZGRyZXNzID0gQWRkcmVzcy5mcm9tSGFzaGVzKGNvbXBpbGVkUHJvZ3JhbS52YWxpZGF0b3JIYXNoKVxyXG4gICAgXHJcbiAgICAgICAgLy9yZW1vdmVcclxuICAgICAgY29uc29sZS5sb2coc2NyaXB0QWRkcmVzcy50b0JlY2gzMigpKTtcclxuICAgICAgY29uc29sZS5sb2coXCJTY3JpcHQgQWRkcmVzczpcIiArIHNjcmlwdEFkZHJlc3MpXHJcbiAgICAgIFxyXG4gICAgICAvLyBDb25zdHJ1Y3QgdGhlIHZlc3RpbmcgZGF0dW1cclxuICAgICAgY29uc3QgZ2FtZURhdHVtID0gbmV3IGdhbWVSZXdhcmQudHlwZXMuRGF0dW0oXHJcbiAgICAgICAgYmVuZWZpdGlhcnkucHViS2V5SGFzaCxcclxuICAgICAgKVxyXG4gICAgXHJcbiAgICAvL2NvbnN0IHJlZGVlbWJlciA9IChuZXcgZ2FtZVJld2FyZC50eXBlcy5SZWRlZW1lci5DbGFpbSgpKS5fdG9VcGxjRGF0YSgpO1xyXG4gICAgXHJcbiAgICAgIGNvbnN0IHR4ID0gbmV3IFR4KCk7XHJcbiAgICAgIHR4LmFkZElucHV0cyh1dHhvc1swXSk7XHJcbiAgICAgIHR4LmFkZE91dHB1dChuZXcgVHhPdXRwdXQoXHJcbiAgICAgICAgc2NyaXB0QWRkcmVzcyxcclxuICAgICAgICBuZXcgVmFsdWUodW5kZWZpbmVkLCB0ZXN0VmFsdWVTY3JpcHQpLFxyXG4gICAgICAgIERhdHVtLmlubGluZShnYW1lRGF0dW0pXHJcbiAgICAgICkpO1xyXG5cclxuICAgICAgLy8gdHguYWRkT3V0cHV0KG5ldyBUeE91dHB1dChcclxuICAgICAgLy8gICBiZW5lZml0aWFyeSxcclxuICAgICAgLy8gICBtaW5BZGFWYWwsXHJcbiAgICAgIC8vICkpO1xyXG4gICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKFwiV2UgYXR0YXRjaGVkIGV2ZXJ5dGhpbmchXCIpXHJcblxyXG4gICAgICAvLyBSZWFkIGluIHRoZSBuZXR3b3JrIHBhcmFtZXRlciBmaWxlXHJcbiAgICAgIGNvbnN0IG5ldHdvcmtQYXJhbXNKc29uID0gYXdhaXQgZ2V0TmV0d29ya1BhcmFtcyhuZXR3b3JrKTtcclxuICAgICAgY29uc3QgbmV0d29ya1BhcmFtcyA9IG5ldyBOZXR3b3JrUGFyYW1zKG5ldHdvcmtQYXJhbXNKc29uKTtcclxuXHJcbiAgICAgIC8vIFNlbmQgYW55IGNoYW5nZSBiYWNrIHRvIHRoZSBidXllclxyXG4gICAgICBhd2FpdCB0eC5maW5hbGl6ZShuZXR3b3JrUGFyYW1zLCBiZW5lZml0aWFyeSwgdXR4b3NbMV0pO1xyXG5cclxuICAgICAgLy8gU2lnbiB0aGUgdW5zaWduZWQgdHggdG8gZ2V0IHRoZSB3aXRuZXNzXHJcbiAgICAgIGNvbnN0IHNpZ25hdHVyZXMgPSBhd2FpdCBjaXAzMFdhbGxldEFQSS5zaWduVHgodHgpO1xyXG4gICAgICB0eC5hZGRTaWduYXR1cmVzKHNpZ25hdHVyZXMpO1xyXG5cclxuICAgICAgY29uc29sZS5sb2coXCJzaWduZWRcIik7XHJcbiAgICAgIC8vIFN1Ym1pdCB0aGUgc2lnbmVkIHR4XHJcbiAgICAgIGNvbnN0IHR4SGFzaCA9IGF3YWl0IGNpcDMwV2FsbGV0QVBJLnN1Ym1pdFR4KHR4KTtcclxuXHJcbiAgICAgIHNldFR4KHsgdHhJZDogdHhIYXNoLmhleCB9KTtcclxuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcclxuXHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgIHRocm93IGNvbnNvbGUuZXJyb3IoXCJzdWJtaXQgdHggZmFpbGVkXCIsIGVycik7XHJcbiAgICB9XHJcbiAgfVxyXG4gICJdLCJuYW1lcyI6WyJOZXR3b3JrUGFyYW1zIiwiVmFsdWUiLCJUeE91dHB1dCIsIlR4IiwiQ2lwMzBXYWxsZXQiLCJEYXR1bSIsIkFzc2V0cyIsIkJsb2NrZnJvc3RWMCIsIldhbGxldEhlbHBlciIsIk1pbnRpbmdQb2xpY3lIYXNoIiwiQXNzZXRDbGFzcyIsIkFkZHJlc3MiLCJuZXR3b3JrIiwiZ2V0TmV0d29ya1BhcmFtcyIsIkdhbWVSZXdhcmQiLCJvcHRpbWl6ZSIsIkFQSV9LRVkiLCJnZXRUb2tlbkFtb3VudEZyb21VdHhvcyIsInV0eG9zIiwiYXNzZXRDbGFzcyIsInRvdGFsQW1vdW50IiwiQmlnSW50IiwiZm9yRWFjaCIsInV0eG8iLCJ0b2tlbnMiLCJ2YWx1ZSIsImFzc2V0cyIsImdldFRva2VucyIsIm1pbnRpbmdQb2xpY3lIYXNoIiwidG9rZW5OYW1lIiwiYW1vdW50IiwiY2FsY3VsYXRlUmV3YXJkIiwicmVtYWluaW5nU3VwcGx5IiwidG90YWxTdXBwbHkiLCJiYXNlUmV3YXJkIiwiaGFsdmluZ1RocmVzaG9sZCIsImhhbHZpbmdTdGVwcyIsIk1hdGgiLCJmbG9vciIsInJld2FyZCIsInBpY2tVdHhvcyIsInRhcmdldEFtb3VudCIsInNlbGVjdGVkIiwidXNlZEluZGljZXMiLCJTZXQiLCJyYW5kb21JbmRleCIsInJhbmRvbSIsImxlbmd0aCIsImhhcyIsImFkZCIsInNlbGVjdGVkVXR4byIsInB1c2giLCJjYWxjdWxhdGVSZXdhcmRJblRpbWUiLCJUaW1lQmVnaW5Db250cmFjdCIsIkhBTFZJTkdfUEVSSU9EIiwiTUFYX0hBTFZJTkdTIiwiQkFTRV9SRVdBUkQiLCJUaW1lTm93IiwiRGF0ZSIsIm5vdyIsInRpbWVFbGFwc2VkIiwibWluIiwiZWZmZWN0aXZlSGFsdmluZ3MiLCJjb25zb2xlIiwibG9nIiwiY2FsY3VsYXRlQ291bnRkb3duIiwiQ1lDTEVfRFVSQVRJT04iLCJvZmZzZXRJbk1zIiwiZWxhcHNlZFRpbWUiLCJlbGFwc2VkVGltZUluU2Vjb25kcyIsInBvc2l0aW9uSW5DeWNsZSIsInBpY2tSYW5kb21UeElucHV0V2l0aFN1ZmZpY2llbnRWYWx1ZSIsInR4SW5wdXRzIiwiZHluYW1pY1Jld2FyZCIsImVsaWdpYmxlVHhJbnB1dHMiLCJmaWx0ZXIiLCJ0eElucHV0Iiwib3V0cHV0IiwidG9rZW5BbW91bnQiLCJFcnJvciIsInNlbGVjdGVkVHhJbnB1dCIsInJlbWFpbmluZ1V0eG9zIiwiY2xhaW1Ub2tlbnMiLCJ3YWxsZXRBUEkiLCJzZXRJc0xvYWRpbmciLCJzZXRUeCIsImVycm9yIiwiY2lwMzBXYWxsZXRBUEkiLCJiZnJvc3QiLCJ3YWxsZXRIZWxwZXIiLCJuZXR3b3JrUGFyYW1zSnNvbiIsIm5ldHdvcmtQYXJhbXMiLCJwb2xpY3lJZCIsIm5hbWUiLCJCdWZmZXIiLCJmcm9tIiwidG9TdHJpbmciLCJtcGgiLCJmcm9tSGV4IiwidG9rZW5WYWwiLCJiZW5lZml0aWFyeSIsImNoYW5nZUFkZHJlc3MiLCJnYW1lUmV3YXJkIiwiY29tcGlsZWRQcm9ncmFtIiwiY29tcGlsZSIsInNjcmlwdEFkZHJlc3MiLCJmcm9tSGFzaGVzIiwidmFsaWRhdG9ySGFzaCIsInRvQmVjaDMyIiwiZGlyIiwiZGVwdGgiLCJnZXRVdHhvcyIsImZpbHRlcmVkVXR4b3MiLCJ4IiwiQ0xBSU1fV0lORE9XIiwiVVRDIiwiZ2V0VGltZSIsIndpbmRvdyIsIm9uZXJyb3IiLCJ0ZXN0VmFsdWVCZW5lZml0aWFyeSIsInNvcnRlZFV0eG9zIiwiZWxlbWVudCIsImFtb3VudFRvU2VuZEJhY2siLCJmaXJzdFBhcnRUb1NlbmRCYWNrIiwic2Vjb25kUGFydFRvU2VuZEJhY2siLCJ2YWx1ZUNvbnRyYWN0MSIsInZhbHVlQ29udHJhY3QyIiwiZ2FtZURhdHVtIiwidHlwZXMiLCJwdWJLZXlIYXNoIiwicmVkZWVtYmVyIiwiUmVkZWVtZXIiLCJDbGFpbSIsIl90b1VwbGNEYXRhIiwidHgiLCJhZGRJbnB1dHMiLCJhdHRhY2hTY3JpcHQiLCJ1c2VyQ2xhaW1PdXRwdXQiLCJ1bmRlZmluZWQiLCJhZGRPdXRwdXQiLCJzY3JpcHRVdHhvMSIsImlubGluZSIsInNjcmlwdFV0eG8yIiwiZmluYWxpemUiLCJzaWduYXR1cmVzIiwic2lnblR4IiwiYWRkU2lnbmF0dXJlcyIsInR4SGFzaCIsInN1Ym1pdFR4IiwidHhJZCIsImhleCIsImVyciIsInNlbmQiLCJtaW5BZGEiLCJtaW5BZGFWYWwiLCJ0ZXN0VmFsdWVTY3JpcHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./public/walletActions.ts\n"));

/***/ })

});