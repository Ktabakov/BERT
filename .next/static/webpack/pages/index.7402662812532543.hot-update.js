"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./public/walletActions.ts":
/*!*********************************!*\
  !*** ./public/walletActions.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateCountdown: function() { return /* binding */ calculateCountdown; },\n/* harmony export */   claimTokens: function() { return /* binding */ claimTokens; },\n/* harmony export */   send: function() { return /* binding */ send; }\n/* harmony export */ });\n/* harmony import */ var _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @hyperionbt/helios */ \"./node_modules/@hyperionbt/helios/helios.js\");\n/* harmony import */ var _common_network__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/network */ \"./common/network.ts\");\n/* harmony import */ var _contracts_vesting_hl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../contracts/vesting.hl */ \"./contracts/vesting.hl\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\n\n // Ensure correct path to your contract\nconst optimize = false;\nfunction getTokenAmountFromUtxos(utxos, assetClass) {\n    let totalAmount = BigInt(0);\n    utxos.forEach((utxo)=>{\n        // Assuming utxo.value is in the right format\n        const tokens = utxo.value.assets.getTokens(assetClass.mintingPolicyHash);\n        tokens.forEach((param)=>{\n            let [tokenName, amount] = param;\n            totalAmount += BigInt(amount.value); // Add the amount to the total\n        });\n    });\n    return totalAmount;\n}\nfunction calculateReward(remainingSupply, totalSupply, baseReward) {\n    const halvingThreshold = totalSupply * 0.1; // 10% of total supply as the halving threshold\n    // Determine the number of halving steps\n    const halvingSteps = Math.floor((totalSupply - remainingSupply) / halvingThreshold);\n    // Calculate the reward after applying halving steps\n    const reward = Math.floor(baseReward / (1 + halvingSteps));\n    // Ensure the reward doesn't drop below 1\n    return reward < 1 ? 1 : reward;\n}\nfunction pickUtxos(utxos, targetAmount, assetClass) {\n    const selected = [];\n    let totalAmount = 0n;\n    // Keep track of the indices we've already picked\n    const usedIndices = new Set();\n    while(totalAmount < targetAmount){\n        // Generate a random index within the bounds of the UTXOs array\n        const randomIndex = Math.floor(Math.random() * utxos.length);\n        // If we've already selected this index, skip it\n        if (usedIndices.has(randomIndex)) {\n            continue;\n        }\n        // Mark the index as used\n        usedIndices.add(randomIndex);\n        // Add the UTXO to the selected list\n        const selectedUtxo = utxos[randomIndex];\n        selected.push(selectedUtxo);\n        const tokens = selectedUtxo.value.assets.getTokens(assetClass.mintingPolicyHash);\n        tokens.forEach((param)=>{\n            let [tokenName, amount] = param;\n            totalAmount += BigInt(amount.value); // Add the amount to the total\n        });\n    }\n    return {\n        selected,\n        totalAmount\n    };\n}\n// Calculate the reward based on the time elapsed since contract deployment\nfunction calculateRewardInTime(TimeBeginContract) {\n    TimeBeginContract = TimeBeginContract / 1000;\n    const HALVING_PERIOD = 2592000; // 1 month in seconds (60 * 60 * 24 * 30)\n    const MAX_HALVINGS = 5; // Limit halvings to 5 times\n    const BASE_REWARD = 1000; // Initial reward in tokens\n    // Get current time in seconds\n    const TimeNow = Math.floor(Date.now() / 1000);\n    // Calculate the elapsed time in seconds\n    const timeElapsed = TimeNow - TimeBeginContract;\n    // Determine halving steps based on elapsed time, but limit to MAX_HALVINGS\n    let halvingSteps = Math.floor(timeElapsed / HALVING_PERIOD);\n    halvingSteps = Math.min(halvingSteps, MAX_HALVINGS); // Cap halvings at MAX_HALVINGS\n    // Ensure the number of halving steps doesn't exceed the maximum allowed\n    const effectiveHalvings = Math.min(halvingSteps, MAX_HALVINGS);\n    console.log(\"Halvings\" + effectiveHalvings);\n    // Directly calculate reward based on halving steps using a bit shift\n    const reward = BASE_REWARD / 2 ** effectiveHalvings;\n    // Return the reward, ensuring it doesn't fall below a minimum value\n    return reward < 1 ? 1 : reward;\n}\nfunction calculateCountdown(TimeBeginContract) {\n    const TimeNow = Math.floor(Date.now());\n    const CYCLE_DURATION = 540 // 9 minutes \n    ;\n    const offsetInMs = 89680;\n    const elapsedTime = TimeNow - offsetInMs - TimeBeginContract;\n    const elapsedTimeInSeconds = elapsedTime / 1000;\n    const positionInCycle = elapsedTimeInSeconds % CYCLE_DURATION;\n    return positionInCycle;\n}\n// Function to filter and pick a random TxInput with sufficient value\nfunction pickRandomTxInputWithSufficientValue(txInputs, dynamicReward, assetClass) {\n    // Filter TxInputs that have sufficient token value\n    const eligibleTxInputs = txInputs.filter((txInput)=>{\n        // Extract the tokens and check their value\n        const tokens = txInput.output.value.assets.getTokens(assetClass.mintingPolicyHash);\n        let tokenAmount = BigInt(0);\n        tokens.forEach((param)=>{\n            let [tokenName, amount] = param;\n            tokenAmount += BigInt(amount.value); // Add the amount to the token total\n        });\n        return tokenAmount >= dynamicReward; // Check if the total token value meets or exceeds the reward\n    });\n    // If there are no eligible TxInputs, throw an error\n    if (eligibleTxInputs.length === 0) {\n        throw new Error(\"No eligible TxInput found with sufficient token value.\");\n    }\n    // Pick a random TxInput from the eligible list\n    const randomIndex = Math.floor(Math.random() * eligibleTxInputs.length);\n    const selectedTxInput = eligibleTxInputs[randomIndex];\n    // Calculate the token value of the selected TxInput\n    const tokens = selectedTxInput.output.value.assets.getTokens(assetClass.mintingPolicyHash);\n    let tokenAmount = BigInt(0);\n    tokens.forEach((param)=>{\n        let [tokenName, amount] = param;\n        tokenAmount += BigInt(amount.value); // Add the amount to the token total\n    });\n    const remainingUtxos = txInputs.filter((txInput)=>txInput !== selectedTxInput);\n    // Return the selected TxInput and its token value\n    return {\n        txInput: selectedTxInput,\n        tokenAmount,\n        remainingUtxos\n    };\n}\nasync function claimTokens(walletAPI, setIsLoading, setTx) {\n    setIsLoading(true);\n    if (!walletAPI) {\n        throw console.error(\"walletAPI is not set\");\n    }\n    try {\n        const cip30WalletAPI = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Cip30Wallet(walletAPI);\n        const walletHelper = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.WalletHelper(cip30WalletAPI);\n        // Read in the network parameter file\n        const networkParamsJson = await (0,_common_network__WEBPACK_IMPORTED_MODULE_0__.getNetworkParams)(_common_network__WEBPACK_IMPORTED_MODULE_0__.network);\n        const networkParams = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.NetworkParams(networkParamsJson);\n        const policyId = \"e16c2dc8ae937e8d3790c7fd7168d7b994621ba14ca11415f39fed72\";\n        const name = Buffer.from(\"MIN\", \"utf8\").toString(\"hex\");\n        // const policyId = \"\";\n        // const name = Buffer.from(\"\", 'utf8').toString('hex');\n        const mph = _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.MintingPolicyHash.fromHex(policyId);\n        const assetClass = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.AssetClass({\n            mph: mph,\n            tokenName: name // Convert to hex string\n        });\n        console.log(assetClass);\n        const tokenAmount = BigInt(100);\n        const tokenVal = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Value(tokenAmount);\n        const utxos = await walletHelper.pickUtxos(tokenVal);\n        // Get change address\n        const benefitiary = await walletHelper.changeAddress;\n        // Load in the vesting validator script (program)\n        const gameReward = new _contracts_vesting_hl__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n        // Compile the vesting validator\n        const compiledProgram = gameReward.compile(optimize);\n        console.log(\"Wallet address: \" + benefitiary);\n        const scriptAddress = _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Address.fromHashes(compiledProgram.validatorHash);\n        console.log(scriptAddress.toBech32());\n        console.log(\"Script Address:\" + scriptAddress);\n        console.dir(scriptAddress, {\n            depth: null\n        });\n        const filteredUtxos = await fetchUtxos(scriptAddress.toBech32());\n        // const BASE_REWARD: number = 1000;  // Base reward\n        // const TOTAL_SUPPLY = 10000; // Total token supply\n        const CLAIM_WINDOW = 60; // 1 minute \n        console.log(\"filteredUtxos\" + filteredUtxos);\n        const TimeBeginContract = Math.floor(new Date(Date.UTC(2024, 11, 8, 13, 45, 0)).getTime());\n        //const remainingSupply = getTokenAmountFromUtxos(filteredUtxos, assetClass);\n        const dynamicReward = calculateRewardInTime(TimeBeginContract);\n        const positionInCycle = calculateCountdown(TimeBeginContract);\n        console.log(positionInCycle);\n        window.onerror = ()=>positionInCycle < CLAIM_WINDOW;\n        //const dynamicReward = calculateReward(Number(remainingSupply), TOTAL_SUPPLY, BASE_REWARD);\n        const testValueBenefitiary = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Assets([\n            [\n                assetClass,\n                BigInt(dynamicReward)\n            ]\n        ]);\n        //const result = pickRandomTxInputWithSufficientValue(filteredUtxos, BigInt(dynamicReward), assetClass);\n        //console.log(\"randomUTXO:\" + result.txInput)\n        //const amountToSendBack = result.tokenAmount - BigInt(dynamicReward);\n        // console.log(\"amountToSendBack\" + amountToSendBack)\n        // console.log(\"UtxoAmount\" + result.tokenAmount)\n        // console.log(\"The rest\" + result.remainingUtxos)\n        //console.log(filteredUtxos)\n        // const remoteWallet = new RemoteWallet(false, [scriptAddress], [], txInputs);\n        // const walletHelperScript = new WalletHelper(remoteWallet);\n        const sortedUtxos = pickUtxos(filteredUtxos, BigInt(dynamicReward), assetClass);\n        sortedUtxos.selected.forEach((element)=>{\n            console.log(element);\n        });\n        //const totalAmountUtxo = getTokenAmountFromUtxos(sortedUtxos.selected, assetClass);\n        const amountToSendBack = BigInt(sortedUtxos.totalAmount) - BigInt(dynamicReward);\n        const firstPartToSendBack = amountToSendBack / 2n; // First part is half of the total amount\n        const secondPartToSendBack = amountToSendBack - firstPartToSendBack; // Second part is the remainder\n        console.log(\"First \" + firstPartToSendBack);\n        console.log(\"Sevond \" + secondPartToSendBack);\n        console.log(dynamicReward);\n        const valueContract1 = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Assets([\n            [\n                assetClass,\n                firstPartToSendBack\n            ]\n        ]);\n        const valueContract2 = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Assets([\n            [\n                assetClass,\n                secondPartToSendBack\n            ]\n        ]);\n        const gameDatum = new gameReward.types.Datum(benefitiary.pubKeyHash);\n        console.log(\"We have a datum!\" + gameDatum);\n        // Create the vesting claim redeemer\n        const redeember = new gameReward.types.Redeemer.Claim(benefitiary.pubKeyHash)._toUplcData();\n        //console.log(filteredUtxos);\n        const tx = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Tx();\n        //tx.addInputs(utxos[0]);\n        tx.addInputs(sortedUtxos.selected, redeember);\n        tx.attachScript(compiledProgram);\n        var userClaimOutput = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.TxOutput(benefitiary, new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Value(undefined, testValueBenefitiary));\n        tx.addOutput(userClaimOutput);\n        //Shiiit, fix. Someone could rediredt the rest of the tokens\n        // const addressStr = \"addr_test1qrarqhmklnhwcw3q0zm6sgm3g3l7pua0y36sql9k5ru8dsucglsked5f5yrcf9e9xgxjgmt7xk52knh8h0dgayc00arqlh7g60\";\n        // const address = Address.fromBech32(addressStr);\n        // tx.addOutput(new TxOutput(\n        //   address,\n        //   new Value(undefined, testValueContract) // The amount being claimed\n        // ));\n        if (amountToSendBack != BigInt(0)) {\n            var scriptUtxo1 = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.TxOutput(scriptAddress, new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Value(undefined, valueContract1), _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Datum.inline(gameDatum) // Contract requires datum\n            );\n            tx.addOutput(scriptUtxo1);\n            var scriptUtxo2 = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.TxOutput(scriptAddress, new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Value(undefined, valueContract2), _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Datum.inline(gameDatum) // Contract requires datum\n            );\n            tx.addOutput(scriptUtxo2);\n        }\n        //var inputFees = await walletHelper.pickUtxos(new Value(tokenAmountFees));\n        //tx.addInputs(inputFees[0]);\n        console.log(\"We attatched everything!\");\n        await tx.finalize(networkParams, benefitiary, utxos[1]);\n        // Sign the unsigned tx to get the witness\n        const signatures = await cip30WalletAPI.signTx(tx);\n        tx.addSignatures(signatures);\n        const txHash = await cip30WalletAPI.submitTx(tx);\n        setTx({\n            txId: txHash.hex\n        });\n        setIsLoading(false);\n    } catch (err) {\n        setIsLoading(false);\n        throw console.error(\"submit tx failed\", err);\n    }\n}\nasync function send(walletAPI, setIsLoading, setTx) {\n    setIsLoading(true);\n    if (!walletAPI) {\n        throw console.error(\"walletAPI is not set\");\n    }\n    try {\n        const cip30WalletAPI = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Cip30Wallet(walletAPI);\n        // const blockfrost = new BlockFrostIPFS({\n        //   network: network,\n        //   projectId: \"preprodJExO0MAMRgfpXz9Il4IqB2u9ddoylZBT\",\n        // });\n        console.log(\"gmmm\");\n        const walletHelper = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.WalletHelper(cip30WalletAPI);\n        const policyId = \"e16c2dc8ae937e8d3790c7fd7168d7b994621ba14ca11415f39fed72\";\n        const name = Buffer.from(\"MIN\", \"utf8\").toString(\"hex\");\n        // const policyId = \"\";\n        // const name = Buffer.from(\"\", 'utf8').toString('hex');\n        const mph = _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.MintingPolicyHash.fromHex(policyId);\n        const assetClass = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.AssetClass({\n            mph: mph,\n            tokenName: name // Convert to hex string\n        });\n        console.log(assetClass);\n        const minAda = 1000000; // minimum lovelace to send\n        const minAdaVal = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Value(BigInt(minAda));\n        //  const benefitiaryValue = new Value(BigInt(10000), new Assets([\n        //   [mph, [[name, BigInt(10000)]]]\n        // ]))\n        const testValueScript = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Assets([\n            [\n                assetClass,\n                BigInt(5000)\n            ]\n        ]);\n        // Get wallet UTXOs\n        const utxos = await walletHelper.pickUtxos(new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Value(undefined, testValueScript));\n        console.log(utxos);\n        // Get change address\n        const benefitiary = await walletHelper.changeAddress;\n        // Load in the vesting validator script (program)\n        const gameReward = new _contracts_vesting_hl__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n        // Compile the vesting validator\n        const compiledProgram = gameReward.compile(optimize);\n        console.log(\"Wallet address: \" + benefitiary);\n        const scriptAddress = _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Address.fromHashes(compiledProgram.validatorHash);\n        //remove\n        console.log(scriptAddress.toBech32());\n        console.log(\"Script Address:\" + scriptAddress);\n        // Construct the vesting datum\n        const gameDatum = new gameReward.types.Datum(benefitiary.pubKeyHash);\n        //const redeember = (new gameReward.types.Redeemer.Claim())._toUplcData();\n        const tx = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Tx();\n        tx.addInputs(utxos[0]);\n        tx.addOutput(new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.TxOutput(scriptAddress, new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Value(undefined, testValueScript), _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Datum.inline(gameDatum)));\n        // tx.addOutput(new TxOutput(\n        //   benefitiary,\n        //   minAdaVal,\n        // ));\n        console.log(\"We attatched everything!\");\n        // Read in the network parameter file\n        const networkParamsJson = await (0,_common_network__WEBPACK_IMPORTED_MODULE_0__.getNetworkParams)(_common_network__WEBPACK_IMPORTED_MODULE_0__.network);\n        const networkParams = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.NetworkParams(networkParamsJson);\n        // Send any change back to the buyer\n        await tx.finalize(networkParams, benefitiary, utxos[1]);\n        // Sign the unsigned tx to get the witness\n        const signatures = await cip30WalletAPI.signTx(tx);\n        tx.addSignatures(signatures);\n        console.log(\"signed\");\n        // Submit the signed tx\n        const txHash = await cip30WalletAPI.submitTx(tx);\n        setTx({\n            txId: txHash.hex\n        });\n        setIsLoading(false);\n    } catch (err) {\n        setIsLoading(false);\n        throw console.error(\"submit tx failed\", err);\n    }\n}\nasync function fetchUtxos(scriptAddress) {\n    const response = await fetch(\"http://localhost:3001/api/getUtxos\", {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n            scriptAddress\n        })\n    });\n    const data = await response.json(); // Raw JSON array from backend\n    // `Convert JSON back to TxInput objects\n    const filteredUtxos = data.map((utxo)=>_hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.TxInput.fromFullCbor(utxo));\n    return filteredUtxos;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFHO1FBQUM7UUFDekJoRSxhQUFhO0lBRWYsRUFBRSxPQUFPaUUsS0FBSztRQUNWakUsYUFBYTtRQUNiLE1BQU1yQixRQUFRdUIsS0FBSyxDQUFDLG9CQUFvQitEO0lBQzVDO0FBQ0Y7QUFFQSxlQUFldEMsV0FBV1AsYUFBcUI7SUFDN0MsTUFBTWtELFdBQVcsTUFBTUMsTUFBTSxzQ0FBc0M7UUFDakVDLFFBQVE7UUFDUkMsU0FBUztZQUFFLGdCQUFnQjtRQUFtQjtRQUM5Q0MsTUFBTUMsS0FBS0MsU0FBUyxDQUFDO1lBQUV4RDtRQUFjO0lBQ3ZDO0lBRUEsTUFBTXlELE9BQU8sTUFBTVAsU0FBU1EsSUFBSSxJQUFJLDhCQUE4QjtJQUVsRSx3Q0FBd0M7SUFDeEMsTUFBTXBELGdCQUFnQm1ELEtBQUtFLEdBQUcsQ0FBQyxDQUFDNUksT0FBY2xCLHVEQUFPQSxDQUFDK0osWUFBWSxDQUFDN0k7SUFFbkUsT0FBT3VGO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcHVibGljL3dhbGxldEFjdGlvbnMudHM/NWIwOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBcclxuICAgIE5ldHdvcmtQYXJhbXMsXHJcbiAgICBWYWx1ZSxcclxuICAgIFR4T3V0cHV0LFxyXG4gICAgVHgsXHJcbiAgICBUeElucHV0LFxyXG4gICAgQ2lwMzBXYWxsZXQsXHJcbiAgICBEYXR1bSxcclxuICAgIEFzc2V0cyxcclxuICAgIEJsb2NrZnJvc3RWMCxcclxuICAgIFVwbGNEYXRhLFxyXG4gICAgV2FsbGV0SGVscGVyLFxyXG4gICAgTWludGluZ1BvbGljeUhhc2gsXHJcbiAgICBBc3NldENsYXNzLFxyXG4gICAgQWRkcmVzcyxcclxuICAgIFR4T3V0cHV0SWRcclxuICB9IGZyb20gXCJAaHlwZXJpb25idC9oZWxpb3NcIjtcclxuICBpbXBvcnQgeyBuZXR3b3JrLCBnZXROZXR3b3JrUGFyYW1zIH0gZnJvbSAnLi4vY29tbW9uL25ldHdvcmsnO1xyXG4gIGltcG9ydCBHYW1lUmV3YXJkIGZyb20gJy4uL2NvbnRyYWN0cy92ZXN0aW5nLmhsJzsgLy8gRW5zdXJlIGNvcnJlY3QgcGF0aCB0byB5b3VyIGNvbnRyYWN0XHJcbmltcG9ydCB7IFR4SW4gfSBmcm9tIFwiQGJsb2NrZnJvc3QvYmxvY2tmcm9zdC1qcy9saWIvdHlwZXMvYXBpL3V0aWxzL3R4c1wiO1xyXG4gIFxyXG4gIGNvbnN0IG9wdGltaXplID0gZmFsc2U7XHJcbiBcclxuZnVuY3Rpb24gZ2V0VG9rZW5BbW91bnRGcm9tVXR4b3ModXR4b3M6IFR4SW5wdXRbXSwgYXNzZXRDbGFzczogQXNzZXRDbGFzcyk6IGJpZ2ludCB7XHJcbiAgICBsZXQgdG90YWxBbW91bnQgPSBCaWdJbnQoMCk7XHJcbiAgXHJcbiAgICB1dHhvcy5mb3JFYWNoKCh1dHhvOiBUeElucHV0KSA9PiB7XHJcbiAgICAgICAgLy8gQXNzdW1pbmcgdXR4by52YWx1ZSBpcyBpbiB0aGUgcmlnaHQgZm9ybWF0XHJcbiAgICAgICAgY29uc3QgdG9rZW5zID0gdXR4by52YWx1ZS5hc3NldHMuZ2V0VG9rZW5zKGFzc2V0Q2xhc3MubWludGluZ1BvbGljeUhhc2gpO1xyXG4gICAgICAgIHRva2Vucy5mb3JFYWNoKChbdG9rZW5OYW1lLCBhbW91bnRdKSA9PiB7XHJcbiAgICAgICAgICB0b3RhbEFtb3VudCArPSBCaWdJbnQoYW1vdW50LnZhbHVlKTsgLy8gQWRkIHRoZSBhbW91bnQgdG8gdGhlIHRvdGFsXHJcbiAgICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gIFxyXG4gICAgcmV0dXJuIHRvdGFsQW1vdW50O1xyXG4gIH1cclxuICBcclxuICBmdW5jdGlvbiBjYWxjdWxhdGVSZXdhcmQocmVtYWluaW5nU3VwcGx5OiBudW1iZXIsIHRvdGFsU3VwcGx5OiBudW1iZXIsIGJhc2VSZXdhcmQ6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICBjb25zdCBoYWx2aW5nVGhyZXNob2xkID0gdG90YWxTdXBwbHkgKiAwLjE7IC8vIDEwJSBvZiB0b3RhbCBzdXBwbHkgYXMgdGhlIGhhbHZpbmcgdGhyZXNob2xkXHJcbiAgXHJcbiAgICAvLyBEZXRlcm1pbmUgdGhlIG51bWJlciBvZiBoYWx2aW5nIHN0ZXBzXHJcbiAgICBjb25zdCBoYWx2aW5nU3RlcHMgPSBNYXRoLmZsb29yKCh0b3RhbFN1cHBseSAtIHJlbWFpbmluZ1N1cHBseSkgLyBoYWx2aW5nVGhyZXNob2xkKTtcclxuICBcclxuICAgIC8vIENhbGN1bGF0ZSB0aGUgcmV3YXJkIGFmdGVyIGFwcGx5aW5nIGhhbHZpbmcgc3RlcHNcclxuICAgIGNvbnN0IHJld2FyZCA9IE1hdGguZmxvb3IoYmFzZVJld2FyZCAvICgxICsgaGFsdmluZ1N0ZXBzKSk7XHJcbiAgXHJcbiAgICAvLyBFbnN1cmUgdGhlIHJld2FyZCBkb2Vzbid0IGRyb3AgYmVsb3cgMVxyXG4gICAgcmV0dXJuIHJld2FyZCA8IDEgPyAxIDogcmV3YXJkO1xyXG4gIH1cclxuICBcclxuICBmdW5jdGlvbiBwaWNrVXR4b3ModXR4b3M6IFR4SW5wdXRbXSwgdGFyZ2V0QW1vdW50OiBiaWdpbnQsIGFzc2V0Q2xhc3M6IEFzc2V0Q2xhc3MpOiB7IHNlbGVjdGVkOiBUeElucHV0W107IHRvdGFsQW1vdW50OiBiaWdpbnQgfSB7XHJcbiAgICBjb25zdCBzZWxlY3RlZDogVHhJbnB1dFtdID0gW107XHJcbiAgICBsZXQgdG90YWxBbW91bnQ6IGJpZ2ludCA9IDBuO1xyXG4gIFxyXG4gICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgaW5kaWNlcyB3ZSd2ZSBhbHJlYWR5IHBpY2tlZFxyXG4gICAgY29uc3QgdXNlZEluZGljZXMgPSBuZXcgU2V0PG51bWJlcj4oKTtcclxuICBcclxuICAgIHdoaWxlICh0b3RhbEFtb3VudCA8IHRhcmdldEFtb3VudCkge1xyXG4gICAgICAgIC8vIEdlbmVyYXRlIGEgcmFuZG9tIGluZGV4IHdpdGhpbiB0aGUgYm91bmRzIG9mIHRoZSBVVFhPcyBhcnJheVxyXG4gICAgICAgIGNvbnN0IHJhbmRvbUluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdXR4b3MubGVuZ3RoKTtcclxuICBcclxuICAgICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IHNlbGVjdGVkIHRoaXMgaW5kZXgsIHNraXAgaXRcclxuICAgICAgICBpZiAodXNlZEluZGljZXMuaGFzKHJhbmRvbUluZGV4KSkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgXHJcbiAgICAgICAgLy8gTWFyayB0aGUgaW5kZXggYXMgdXNlZFxyXG4gICAgICAgIHVzZWRJbmRpY2VzLmFkZChyYW5kb21JbmRleCk7XHJcbiAgXHJcbiAgICAgICAgLy8gQWRkIHRoZSBVVFhPIHRvIHRoZSBzZWxlY3RlZCBsaXN0XHJcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRVdHhvID0gdXR4b3NbcmFuZG9tSW5kZXhdO1xyXG4gICAgICAgIHNlbGVjdGVkLnB1c2goc2VsZWN0ZWRVdHhvKTtcclxuICAgICAgICBjb25zdCB0b2tlbnMgPSBzZWxlY3RlZFV0eG8udmFsdWUuYXNzZXRzLmdldFRva2Vucyhhc3NldENsYXNzLm1pbnRpbmdQb2xpY3lIYXNoKTtcclxuICAgICAgICB0b2tlbnMuZm9yRWFjaCgoW3Rva2VuTmFtZSwgYW1vdW50XSkgPT4ge1xyXG4gICAgICAgICAgdG90YWxBbW91bnQgKz0gQmlnSW50KGFtb3VudC52YWx1ZSk7IC8vIEFkZCB0aGUgYW1vdW50IHRvIHRoZSB0b3RhbFxyXG4gICAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHNlbGVjdGVkLFxyXG4gICAgICAgIHRvdGFsQW1vdW50LFxyXG4gICAgfTtcclxuICB9XHJcbiAgXHJcbiAgLy8gQ2FsY3VsYXRlIHRoZSByZXdhcmQgYmFzZWQgb24gdGhlIHRpbWUgZWxhcHNlZCBzaW5jZSBjb250cmFjdCBkZXBsb3ltZW50XHJcbiAgZnVuY3Rpb24gY2FsY3VsYXRlUmV3YXJkSW5UaW1lKFRpbWVCZWdpbkNvbnRyYWN0OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgVGltZUJlZ2luQ29udHJhY3QgPSBUaW1lQmVnaW5Db250cmFjdCAvIDEwMDA7XHJcbiAgICBjb25zdCBIQUxWSU5HX1BFUklPRDogbnVtYmVyID0gMjU5MjAwMDsgLy8gMSBtb250aCBpbiBzZWNvbmRzICg2MCAqIDYwICogMjQgKiAzMClcclxuICAgIGNvbnN0IE1BWF9IQUxWSU5HUzogbnVtYmVyID0gNTsgLy8gTGltaXQgaGFsdmluZ3MgdG8gNSB0aW1lc1xyXG4gICAgY29uc3QgQkFTRV9SRVdBUkQ6IG51bWJlciA9IDEwMDA7IC8vIEluaXRpYWwgcmV3YXJkIGluIHRva2Vuc1xyXG4gIFxyXG4gICAgLy8gR2V0IGN1cnJlbnQgdGltZSBpbiBzZWNvbmRzXHJcbiAgICBjb25zdCBUaW1lTm93OiBudW1iZXIgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTsgXHJcbiAgXHJcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGVsYXBzZWQgdGltZSBpbiBzZWNvbmRzXHJcbiAgICBjb25zdCB0aW1lRWxhcHNlZDogbnVtYmVyID0gVGltZU5vdyAtIFRpbWVCZWdpbkNvbnRyYWN0O1xyXG4gICAgLy8gRGV0ZXJtaW5lIGhhbHZpbmcgc3RlcHMgYmFzZWQgb24gZWxhcHNlZCB0aW1lLCBidXQgbGltaXQgdG8gTUFYX0hBTFZJTkdTXHJcbiAgICBsZXQgaGFsdmluZ1N0ZXBzOiBudW1iZXIgPSBNYXRoLmZsb29yKHRpbWVFbGFwc2VkIC8gSEFMVklOR19QRVJJT0QpO1xyXG4gICAgaGFsdmluZ1N0ZXBzID0gTWF0aC5taW4oaGFsdmluZ1N0ZXBzLCBNQVhfSEFMVklOR1MpOyAvLyBDYXAgaGFsdmluZ3MgYXQgTUFYX0hBTFZJTkdTXHJcbiAgXHJcbiAgICAgLy8gRW5zdXJlIHRoZSBudW1iZXIgb2YgaGFsdmluZyBzdGVwcyBkb2Vzbid0IGV4Y2VlZCB0aGUgbWF4aW11bSBhbGxvd2VkXHJcbiAgICAgY29uc3QgZWZmZWN0aXZlSGFsdmluZ3M6IG51bWJlciA9IE1hdGgubWluKGhhbHZpbmdTdGVwcywgTUFYX0hBTFZJTkdTKTtcclxuICAgIGNvbnNvbGUubG9nKFwiSGFsdmluZ3NcIiArIGVmZmVjdGl2ZUhhbHZpbmdzKVxyXG4gICAgIC8vIERpcmVjdGx5IGNhbGN1bGF0ZSByZXdhcmQgYmFzZWQgb24gaGFsdmluZyBzdGVwcyB1c2luZyBhIGJpdCBzaGlmdFxyXG4gICAgIGNvbnN0IHJld2FyZDogbnVtYmVyID0gQkFTRV9SRVdBUkQgLyAoMiAqKiBlZmZlY3RpdmVIYWx2aW5ncyk7XHJcbiAgIFxyXG4gICAgIC8vIFJldHVybiB0aGUgcmV3YXJkLCBlbnN1cmluZyBpdCBkb2Vzbid0IGZhbGwgYmVsb3cgYSBtaW5pbXVtIHZhbHVlXHJcbiAgICAgcmV0dXJuIHJld2FyZCA8IDEgPyAxIDogcmV3YXJkO1xyXG4gIH1cclxuICBcclxuICBleHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlQ291bnRkb3duKFRpbWVCZWdpbkNvbnRyYWN0OiBudW1iZXIpOiBudW1iZXIge1xyXG4gIFxyXG4gICAgY29uc3QgVGltZU5vdzogbnVtYmVyID0gTWF0aC5mbG9vcihEYXRlLm5vdygpKTsgXHJcbiAgICBjb25zdCBDWUNMRV9EVVJBVElPTiA9IDU0MCAvLyA5IG1pbnV0ZXMgXHJcbiAgICBjb25zdCBvZmZzZXRJbk1zID0gODk2ODA7XHJcbiAgICBjb25zdCBlbGFwc2VkVGltZSA9IFRpbWVOb3cgLSAob2Zmc2V0SW5NcykgLSBUaW1lQmVnaW5Db250cmFjdDtcclxuICAgIGNvbnN0IGVsYXBzZWRUaW1lSW5TZWNvbmRzID0gZWxhcHNlZFRpbWUgLyAxMDAwO1xyXG4gICAgY29uc3QgcG9zaXRpb25JbkN5Y2xlID0gZWxhcHNlZFRpbWVJblNlY29uZHMgJSBDWUNMRV9EVVJBVElPTjtcclxuICBcclxuICAgIHJldHVybiBwb3NpdGlvbkluQ3ljbGU7XHJcbiAgfVxyXG4gIFxyXG4gIC8vIEZ1bmN0aW9uIHRvIGZpbHRlciBhbmQgcGljayBhIHJhbmRvbSBUeElucHV0IHdpdGggc3VmZmljaWVudCB2YWx1ZVxyXG4gIGZ1bmN0aW9uIHBpY2tSYW5kb21UeElucHV0V2l0aFN1ZmZpY2llbnRWYWx1ZShcclxuICAgIHR4SW5wdXRzOiBUeElucHV0W10sXHJcbiAgICBkeW5hbWljUmV3YXJkOiBiaWdpbnQsXHJcbiAgICBhc3NldENsYXNzOiBBc3NldENsYXNzXHJcbiAgKTogeyB0eElucHV0OiBUeElucHV0OyB0b2tlbkFtb3VudDogYmlnaW50LCByZW1haW5pbmdVdHhvczogVHhJbnB1dFtdIH0ge1xyXG4gICAgLy8gRmlsdGVyIFR4SW5wdXRzIHRoYXQgaGF2ZSBzdWZmaWNpZW50IHRva2VuIHZhbHVlXHJcbiAgICBjb25zdCBlbGlnaWJsZVR4SW5wdXRzID0gdHhJbnB1dHMuZmlsdGVyKCh0eElucHV0OiBUeElucHV0KSA9PiB7XHJcbiAgICAgIC8vIEV4dHJhY3QgdGhlIHRva2VucyBhbmQgY2hlY2sgdGhlaXIgdmFsdWVcclxuICAgICAgY29uc3QgdG9rZW5zID0gdHhJbnB1dC5vdXRwdXQudmFsdWUuYXNzZXRzLmdldFRva2Vucyhhc3NldENsYXNzLm1pbnRpbmdQb2xpY3lIYXNoKTtcclxuICAgICAgbGV0IHRva2VuQW1vdW50ID0gQmlnSW50KDApO1xyXG4gIFxyXG4gICAgICB0b2tlbnMuZm9yRWFjaCgoW3Rva2VuTmFtZSwgYW1vdW50XSkgPT4ge1xyXG4gICAgICAgIHRva2VuQW1vdW50ICs9IEJpZ0ludChhbW91bnQudmFsdWUpOyAvLyBBZGQgdGhlIGFtb3VudCB0byB0aGUgdG9rZW4gdG90YWxcclxuICAgICAgfSk7XHJcbiAgXHJcbiAgICAgIHJldHVybiB0b2tlbkFtb3VudCA+PSBkeW5hbWljUmV3YXJkOyAvLyBDaGVjayBpZiB0aGUgdG90YWwgdG9rZW4gdmFsdWUgbWVldHMgb3IgZXhjZWVkcyB0aGUgcmV3YXJkXHJcbiAgICB9KTtcclxuICBcclxuICAgIC8vIElmIHRoZXJlIGFyZSBubyBlbGlnaWJsZSBUeElucHV0cywgdGhyb3cgYW4gZXJyb3JcclxuICAgIGlmIChlbGlnaWJsZVR4SW5wdXRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBlbGlnaWJsZSBUeElucHV0IGZvdW5kIHdpdGggc3VmZmljaWVudCB0b2tlbiB2YWx1ZS5cIik7XHJcbiAgICB9XHJcbiAgXHJcbiAgICAvLyBQaWNrIGEgcmFuZG9tIFR4SW5wdXQgZnJvbSB0aGUgZWxpZ2libGUgbGlzdFxyXG4gICAgY29uc3QgcmFuZG9tSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBlbGlnaWJsZVR4SW5wdXRzLmxlbmd0aCk7XHJcbiAgICBjb25zdCBzZWxlY3RlZFR4SW5wdXQgPSBlbGlnaWJsZVR4SW5wdXRzW3JhbmRvbUluZGV4XTtcclxuICBcclxuICAgIC8vIENhbGN1bGF0ZSB0aGUgdG9rZW4gdmFsdWUgb2YgdGhlIHNlbGVjdGVkIFR4SW5wdXRcclxuICAgIGNvbnN0IHRva2VucyA9IHNlbGVjdGVkVHhJbnB1dC5vdXRwdXQudmFsdWUuYXNzZXRzLmdldFRva2Vucyhhc3NldENsYXNzLm1pbnRpbmdQb2xpY3lIYXNoKTtcclxuICAgIGxldCB0b2tlbkFtb3VudCA9IEJpZ0ludCgwKTtcclxuICBcclxuICAgIHRva2Vucy5mb3JFYWNoKChbdG9rZW5OYW1lLCBhbW91bnRdKSA9PiB7XHJcbiAgICAgIHRva2VuQW1vdW50ICs9IEJpZ0ludChhbW91bnQudmFsdWUpOyAvLyBBZGQgdGhlIGFtb3VudCB0byB0aGUgdG9rZW4gdG90YWxcclxuICAgIH0pO1xyXG4gIFxyXG4gICAgY29uc3QgcmVtYWluaW5nVXR4b3MgPSB0eElucHV0cy5maWx0ZXIoKHR4SW5wdXQpID0+IHR4SW5wdXQgIT09IHNlbGVjdGVkVHhJbnB1dCk7XHJcbiAgXHJcbiAgICAvLyBSZXR1cm4gdGhlIHNlbGVjdGVkIFR4SW5wdXQgYW5kIGl0cyB0b2tlbiB2YWx1ZVxyXG4gICAgcmV0dXJuIHsgdHhJbnB1dDogc2VsZWN0ZWRUeElucHV0LCB0b2tlbkFtb3VudCwgcmVtYWluaW5nVXR4b3MgfTtcclxuICB9XHJcbiAgXHJcbiAgZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNsYWltVG9rZW5zKHdhbGxldEFQSTogYW55LCBzZXRJc0xvYWRpbmc6ICh2YWw6IGJvb2xlYW4pID0+IHZvaWQsIHNldFR4OiAodmFsOiB7dHhJZDogc3RyaW5nfSkgPT4gdm9pZCkge1xyXG4gICAgc2V0SXNMb2FkaW5nKHRydWUpO1xyXG5cclxuICAgIGlmICghd2FsbGV0QVBJKSB7XHJcbiAgICAgIHRocm93IGNvbnNvbGUuZXJyb3IoXCJ3YWxsZXRBUEkgaXMgbm90IHNldFwiKTtcclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGNpcDMwV2FsbGV0QVBJID0gbmV3IENpcDMwV2FsbGV0KHdhbGxldEFQSSk7XHJcblxyXG4gICAgICBjb25zdCB3YWxsZXRIZWxwZXIgPSBuZXcgV2FsbGV0SGVscGVyKGNpcDMwV2FsbGV0QVBJKTtcclxuICAgICAgLy8gUmVhZCBpbiB0aGUgbmV0d29yayBwYXJhbWV0ZXIgZmlsZVxyXG4gICAgICBjb25zdCBuZXR3b3JrUGFyYW1zSnNvbiA9IGF3YWl0IGdldE5ldHdvcmtQYXJhbXMobmV0d29yayk7XHJcbiAgICAgIGNvbnN0IG5ldHdvcmtQYXJhbXMgPSBuZXcgTmV0d29ya1BhcmFtcyhuZXR3b3JrUGFyYW1zSnNvbik7XHJcblxyXG4gICAgICBjb25zdCBwb2xpY3lJZCA9IFwiZTE2YzJkYzhhZTkzN2U4ZDM3OTBjN2ZkNzE2OGQ3Yjk5NDYyMWJhMTRjYTExNDE1ZjM5ZmVkNzJcIjtcclxuICAgICAgY29uc3QgbmFtZSA9IEJ1ZmZlci5mcm9tKFwiTUlOXCIsICd1dGY4JykudG9TdHJpbmcoJ2hleCcpO1xyXG5cclxuICAgICAgLy8gY29uc3QgcG9saWN5SWQgPSBcIlwiO1xyXG4gICAgICAvLyBjb25zdCBuYW1lID0gQnVmZmVyLmZyb20oXCJcIiwgJ3V0ZjgnKS50b1N0cmluZygnaGV4Jyk7XHJcblxyXG4gICAgICBjb25zdCBtcGggPSBNaW50aW5nUG9saWN5SGFzaC5mcm9tSGV4KHBvbGljeUlkKTtcclxuXHJcbiAgICAgIGNvbnN0IGFzc2V0Q2xhc3MgPSBuZXcgQXNzZXRDbGFzcyh7XHJcbiAgICAgICAgbXBoOiBtcGgsIC8vIFlvdXIgcG9saWN5IGhhc2hcclxuICAgICAgICB0b2tlbk5hbWU6IG5hbWUvLyBDb252ZXJ0IHRvIGhleCBzdHJpbmdcclxuICAgICAgfSk7IFxyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhhc3NldENsYXNzKVxyXG5cclxuICAgICAgY29uc3QgdG9rZW5BbW91bnQgPSBCaWdJbnQoMTAwKTtcclxuICAgICAgY29uc3QgdG9rZW5WYWwgPSBuZXcgVmFsdWUodG9rZW5BbW91bnQpO1xyXG4gICAgICBjb25zdCB1dHhvcyA9IGF3YWl0IHdhbGxldEhlbHBlci5waWNrVXR4b3ModG9rZW5WYWwpO1xyXG5cclxuICAgICAgLy8gR2V0IGNoYW5nZSBhZGRyZXNzXHJcbiAgICAgIGNvbnN0IGJlbmVmaXRpYXJ5ID0gYXdhaXQgd2FsbGV0SGVscGVyLmNoYW5nZUFkZHJlc3M7XHJcbiAgICAgIC8vIExvYWQgaW4gdGhlIHZlc3RpbmcgdmFsaWRhdG9yIHNjcmlwdCAocHJvZ3JhbSlcclxuICAgICAgY29uc3QgZ2FtZVJld2FyZCA9IG5ldyBHYW1lUmV3YXJkKCk7XHJcblxyXG4gICAgICAvLyBDb21waWxlIHRoZSB2ZXN0aW5nIHZhbGlkYXRvclxyXG4gICAgICBjb25zdCBjb21waWxlZFByb2dyYW0gPSBnYW1lUmV3YXJkLmNvbXBpbGUob3B0aW1pemUpO1xyXG4gICAgICBjb25zb2xlLmxvZyhcIldhbGxldCBhZGRyZXNzOiBcIiArIGJlbmVmaXRpYXJ5KVxyXG4gICAgICBjb25zdCBzY3JpcHRBZGRyZXNzID0gQWRkcmVzcy5mcm9tSGFzaGVzKGNvbXBpbGVkUHJvZ3JhbS52YWxpZGF0b3JIYXNoKVxyXG4gICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKHNjcmlwdEFkZHJlc3MudG9CZWNoMzIoKSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiU2NyaXB0IEFkZHJlc3M6XCIgKyBzY3JpcHRBZGRyZXNzKVxyXG4gICAgICBcclxuICAgICAgY29uc29sZS5kaXIoc2NyaXB0QWRkcmVzcywgeyBkZXB0aDogbnVsbCB9KTtcclxuXHJcbiAgICAgIGNvbnN0IGZpbHRlcmVkVXR4b3MgPSBhd2FpdCBmZXRjaFV0eG9zKHNjcmlwdEFkZHJlc3MudG9CZWNoMzIoKSlcclxuICAgXHJcbiAgICAgIC8vIGNvbnN0IEJBU0VfUkVXQVJEOiBudW1iZXIgPSAxMDAwOyAgLy8gQmFzZSByZXdhcmRcclxuICAgICAgLy8gY29uc3QgVE9UQUxfU1VQUExZID0gMTAwMDA7IC8vIFRvdGFsIHRva2VuIHN1cHBseVxyXG4gICAgICBjb25zdCBDTEFJTV9XSU5ET1cgPSA2MDsgLy8gMSBtaW51dGUgXHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhcImZpbHRlcmVkVXR4b3NcIiArIGZpbHRlcmVkVXR4b3MpXHJcbiAgICAgIGNvbnN0IFRpbWVCZWdpbkNvbnRyYWN0OiBudW1iZXIgPSBNYXRoLmZsb29yKG5ldyBEYXRlKERhdGUuVVRDKDIwMjQsIDExLCA4LCAxMywgNDUsIDApKS5nZXRUaW1lKCkpO1xyXG4gICAgICAvL2NvbnN0IHJlbWFpbmluZ1N1cHBseSA9IGdldFRva2VuQW1vdW50RnJvbVV0eG9zKGZpbHRlcmVkVXR4b3MsIGFzc2V0Q2xhc3MpO1xyXG4gICAgICBjb25zdCBkeW5hbWljUmV3YXJkID0gY2FsY3VsYXRlUmV3YXJkSW5UaW1lKFRpbWVCZWdpbkNvbnRyYWN0KVxyXG4gICAgICBjb25zdCBwb3NpdGlvbkluQ3ljbGUgPSBjYWxjdWxhdGVDb3VudGRvd24oVGltZUJlZ2luQ29udHJhY3QpO1xyXG4gICAgICBjb25zb2xlLmxvZyhwb3NpdGlvbkluQ3ljbGUpO1xyXG4gICAgICB3aW5kb3cub25lcnJvciA9ICgpID0+IHBvc2l0aW9uSW5DeWNsZSA8IENMQUlNX1dJTkRPVztcclxuICAgICAgLy9jb25zdCBkeW5hbWljUmV3YXJkID0gY2FsY3VsYXRlUmV3YXJkKE51bWJlcihyZW1haW5pbmdTdXBwbHkpLCBUT1RBTF9TVVBQTFksIEJBU0VfUkVXQVJEKTtcclxuICAgICAgY29uc3QgdGVzdFZhbHVlQmVuZWZpdGlhcnk9IG5ldyBBc3NldHMoW1thc3NldENsYXNzLCBCaWdJbnQoZHluYW1pY1Jld2FyZCldXSk7XHJcblxyXG4gICAgICAvL2NvbnN0IHJlc3VsdCA9IHBpY2tSYW5kb21UeElucHV0V2l0aFN1ZmZpY2llbnRWYWx1ZShmaWx0ZXJlZFV0eG9zLCBCaWdJbnQoZHluYW1pY1Jld2FyZCksIGFzc2V0Q2xhc3MpO1xyXG4gICAgICAvL2NvbnNvbGUubG9nKFwicmFuZG9tVVRYTzpcIiArIHJlc3VsdC50eElucHV0KVxyXG5cclxuICAgICAgLy9jb25zdCBhbW91bnRUb1NlbmRCYWNrID0gcmVzdWx0LnRva2VuQW1vdW50IC0gQmlnSW50KGR5bmFtaWNSZXdhcmQpO1xyXG4gICAgICAvLyBjb25zb2xlLmxvZyhcImFtb3VudFRvU2VuZEJhY2tcIiArIGFtb3VudFRvU2VuZEJhY2spXHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiVXR4b0Ftb3VudFwiICsgcmVzdWx0LnRva2VuQW1vdW50KVxyXG4gICAgICAvLyBjb25zb2xlLmxvZyhcIlRoZSByZXN0XCIgKyByZXN1bHQucmVtYWluaW5nVXR4b3MpXHJcbiAgICAgIFxyXG4gICAgICAvL2NvbnNvbGUubG9nKGZpbHRlcmVkVXR4b3MpXHJcbiAgICAgIC8vIGNvbnN0IHJlbW90ZVdhbGxldCA9IG5ldyBSZW1vdGVXYWxsZXQoZmFsc2UsIFtzY3JpcHRBZGRyZXNzXSwgW10sIHR4SW5wdXRzKTtcclxuICAgICAgLy8gY29uc3Qgd2FsbGV0SGVscGVyU2NyaXB0ID0gbmV3IFdhbGxldEhlbHBlcihyZW1vdGVXYWxsZXQpO1xyXG4gICAgICBjb25zdCBzb3J0ZWRVdHhvcyA9IHBpY2tVdHhvcyhmaWx0ZXJlZFV0eG9zLCBCaWdJbnQoZHluYW1pY1Jld2FyZCksIGFzc2V0Q2xhc3MpOyBcclxuICAgICAgXHJcbiAgICAgIHNvcnRlZFV0eG9zLnNlbGVjdGVkLmZvckVhY2goZWxlbWVudCA9PiB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhlbGVtZW50KVxyXG4gICAgICB9KTtcclxuICAgICAgLy9jb25zdCB0b3RhbEFtb3VudFV0eG8gPSBnZXRUb2tlbkFtb3VudEZyb21VdHhvcyhzb3J0ZWRVdHhvcy5zZWxlY3RlZCwgYXNzZXRDbGFzcyk7XHJcbiAgICAgIGNvbnN0IGFtb3VudFRvU2VuZEJhY2sgPSBCaWdJbnQoc29ydGVkVXR4b3MudG90YWxBbW91bnQpIC0gQmlnSW50KGR5bmFtaWNSZXdhcmQpO1xyXG5cclxuICAgICAgY29uc3QgZmlyc3RQYXJ0VG9TZW5kQmFjayA9IGFtb3VudFRvU2VuZEJhY2sgLyAybjsgLy8gRmlyc3QgcGFydCBpcyBoYWxmIG9mIHRoZSB0b3RhbCBhbW91bnRcclxuICAgICAgY29uc3Qgc2Vjb25kUGFydFRvU2VuZEJhY2sgPSBhbW91bnRUb1NlbmRCYWNrIC0gZmlyc3RQYXJ0VG9TZW5kQmFjazsgLy8gU2Vjb25kIHBhcnQgaXMgdGhlIHJlbWFpbmRlclxyXG4gICAgICBjb25zb2xlLmxvZyhcIkZpcnN0IFwiICsgZmlyc3RQYXJ0VG9TZW5kQmFjaylcclxuICAgICAgY29uc29sZS5sb2coXCJTZXZvbmQgXCIgKyBzZWNvbmRQYXJ0VG9TZW5kQmFjaylcclxuICAgICAgY29uc29sZS5sb2coZHluYW1pY1Jld2FyZFx0KVxyXG5cclxuICAgICAgY29uc3QgdmFsdWVDb250cmFjdDE9IG5ldyBBc3NldHMoW1thc3NldENsYXNzLCBmaXJzdFBhcnRUb1NlbmRCYWNrXV0pO1xyXG4gICAgICBjb25zdCB2YWx1ZUNvbnRyYWN0Mj0gbmV3IEFzc2V0cyhbW2Fzc2V0Q2xhc3MsIHNlY29uZFBhcnRUb1NlbmRCYWNrXV0pO1xyXG5cclxuXHJcbiAgICAgIGNvbnN0IGdhbWVEYXR1bSA9IG5ldyBnYW1lUmV3YXJkLnR5cGVzLkRhdHVtKFxyXG4gICAgICAgIGJlbmVmaXRpYXJ5LnB1YktleUhhc2gsXHJcbiAgICAgIClcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKFwiV2UgaGF2ZSBhIGRhdHVtIVwiICsgZ2FtZURhdHVtKVxyXG5cclxuICAgICAgIC8vIENyZWF0ZSB0aGUgdmVzdGluZyBjbGFpbSByZWRlZW1lclxyXG4gICAgICAgY29uc3QgcmVkZWVtYmVyID0gKG5ldyBnYW1lUmV3YXJkLnR5cGVzLlJlZGVlbWVyLkNsYWltKGJlbmVmaXRpYXJ5LnB1YktleUhhc2gpKVxyXG4gICAgICAgLl90b1VwbGNEYXRhKCk7XHJcbiAgICBcclxuICAgICAgLy9jb25zb2xlLmxvZyhmaWx0ZXJlZFV0eG9zKTtcclxuICAgICAgY29uc3QgdHggPSBuZXcgVHgoKTtcclxuXHJcbiAgICAgIC8vdHguYWRkSW5wdXRzKHV0eG9zWzBdKTtcclxuICAgICAgdHguYWRkSW5wdXRzKHNvcnRlZFV0eG9zLnNlbGVjdGVkLCByZWRlZW1iZXIpO1xyXG4gICAgICB0eC5hdHRhY2hTY3JpcHQoY29tcGlsZWRQcm9ncmFtKTtcclxuXHJcbiAgICAgIHZhciB1c2VyQ2xhaW1PdXRwdXQgPSBuZXcgVHhPdXRwdXQoXHJcbiAgICAgICAgYmVuZWZpdGlhcnksXHJcbiAgICAgICAgbmV3IFZhbHVlKHVuZGVmaW5lZCwgdGVzdFZhbHVlQmVuZWZpdGlhcnkpKTtcclxuXHJcbiAgICAgIHR4LmFkZE91dHB1dCh1c2VyQ2xhaW1PdXRwdXQpO1xyXG5cclxuICAgIFxyXG4gICAgLy9TaGlpaXQsIGZpeC4gU29tZW9uZSBjb3VsZCByZWRpcmVkdCB0aGUgcmVzdCBvZiB0aGUgdG9rZW5zXHJcbiAgICAvLyBjb25zdCBhZGRyZXNzU3RyID0gXCJhZGRyX3Rlc3QxcXJhcnFobWtsbmh3Y3czcTB6bTZzZ20zZzNsN3B1YTB5MzZzcWw5azVydThkc3VjZ2xza2VkNWY1eXJjZjllOXhneGpnbXQ3eGs1MmtuaDhoMGRnYXljMDBhcnFsaDdnNjBcIjtcclxuICAgIC8vIGNvbnN0IGFkZHJlc3MgPSBBZGRyZXNzLmZyb21CZWNoMzIoYWRkcmVzc1N0cik7XHJcbiAgICAvLyB0eC5hZGRPdXRwdXQobmV3IFR4T3V0cHV0KFxyXG4gICAgLy8gICBhZGRyZXNzLFxyXG4gICAgLy8gICBuZXcgVmFsdWUodW5kZWZpbmVkLCB0ZXN0VmFsdWVDb250cmFjdCkgLy8gVGhlIGFtb3VudCBiZWluZyBjbGFpbWVkXHJcbiAgICAvLyApKTtcclxuICAgIFxyXG5cclxuICAgIGlmIChhbW91bnRUb1NlbmRCYWNrICE9IEJpZ0ludCgwKSl7XHJcbiAgICAgIHZhciBzY3JpcHRVdHhvMSA9bmV3IFR4T3V0cHV0KFxyXG4gICAgICAgIHNjcmlwdEFkZHJlc3MsXHJcbiAgICAgICAgbmV3IFZhbHVlKHVuZGVmaW5lZCwgdmFsdWVDb250cmFjdDEpLCAgLy8gUmVtYWluaW5nIHRyZWFzdXJ5IHRva2Vuc1xyXG4gICAgICAgIERhdHVtLmlubGluZShnYW1lRGF0dW0pIC8vIENvbnRyYWN0IHJlcXVpcmVzIGRhdHVtXHJcbiAgICAgICApO1xyXG5cclxuICAgICAgIHR4LmFkZE91dHB1dChzY3JpcHRVdHhvMSk7XHJcblxyXG4gICAgICB2YXIgc2NyaXB0VXR4bzIgPSBuZXcgVHhPdXRwdXQoXHJcbiAgICAgICAgc2NyaXB0QWRkcmVzcyxcclxuICAgICAgICBuZXcgVmFsdWUodW5kZWZpbmVkLCB2YWx1ZUNvbnRyYWN0MiksICAvLyBSZW1haW5pbmcgdHJlYXN1cnkgdG9rZW5zXHJcbiAgICAgICAgRGF0dW0uaW5saW5lKGdhbWVEYXR1bSkgLy8gQ29udHJhY3QgcmVxdWlyZXMgZGF0dW1cclxuICAgICAgICk7XHJcbiAgICBcclxuICAgICAgIHR4LmFkZE91dHB1dChzY3JpcHRVdHhvMik7XHJcbiAgICB9ICBcclxuXHJcbiAgICAgIC8vdmFyIGlucHV0RmVlcyA9IGF3YWl0IHdhbGxldEhlbHBlci5waWNrVXR4b3MobmV3IFZhbHVlKHRva2VuQW1vdW50RmVlcykpO1xyXG4gICAgICBcclxuICAgICAgLy90eC5hZGRJbnB1dHMoaW5wdXRGZWVzWzBdKTtcclxuICAgICAgY29uc29sZS5sb2coXCJXZSBhdHRhdGNoZWQgZXZlcnl0aGluZyFcIilcclxuXHJcbiAgICAgIGF3YWl0IHR4LmZpbmFsaXplKG5ldHdvcmtQYXJhbXMsIGJlbmVmaXRpYXJ5LCB1dHhvc1sxXSk7XHJcblxyXG4gICAgICAvLyBTaWduIHRoZSB1bnNpZ25lZCB0eCB0byBnZXQgdGhlIHdpdG5lc3NcclxuICAgICAgY29uc3Qgc2lnbmF0dXJlcyA9IGF3YWl0IGNpcDMwV2FsbGV0QVBJLnNpZ25UeCh0eCk7XHJcbiAgICAgIHR4LmFkZFNpZ25hdHVyZXMoc2lnbmF0dXJlcyk7XHJcblxyXG4gICAgICBjb25zdCB0eEhhc2ggPSBhd2FpdCBjaXAzMFdhbGxldEFQSS5zdWJtaXRUeCh0eCk7XHJcblxyXG4gICAgICBzZXRUeCh7IHR4SWQ6IHR4SGFzaC5oZXggfSk7XHJcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XHJcblxyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICB0aHJvdyBjb25zb2xlLmVycm9yKFwic3VibWl0IHR4IGZhaWxlZFwiLCBlcnIpO1xyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICBleHBvcnQgYXN5bmMgZnVuY3Rpb24gc2VuZCh3YWxsZXRBUEk6IGFueSwgc2V0SXNMb2FkaW5nOiAodmFsOiBib29sZWFuKSA9PiB2b2lkLCBzZXRUeDogKHZhbDoge3R4SWQ6IHN0cmluZ30pID0+IHZvaWQpIHtcclxuICAgIHNldElzTG9hZGluZyh0cnVlKTtcclxuXHJcbiAgICBpZiAoIXdhbGxldEFQSSkge1xyXG4gICAgICB0aHJvdyBjb25zb2xlLmVycm9yKFwid2FsbGV0QVBJIGlzIG5vdCBzZXRcIik7XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBjaXAzMFdhbGxldEFQSSA9IG5ldyBDaXAzMFdhbGxldCh3YWxsZXRBUEkpO1xyXG4gICAgICAvLyBjb25zdCBibG9ja2Zyb3N0ID0gbmV3IEJsb2NrRnJvc3RJUEZTKHtcclxuICAgICAgLy8gICBuZXR3b3JrOiBuZXR3b3JrLFxyXG4gICAgICAvLyAgIHByb2plY3RJZDogXCJwcmVwcm9kSkV4TzBNQU1SZ2ZwWHo5SWw0SXFCMnU5ZGRveWxaQlRcIixcclxuICAgICAgLy8gfSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiZ21tbVwiKVxyXG5cclxuICAgICAgY29uc3Qgd2FsbGV0SGVscGVyID0gbmV3IFdhbGxldEhlbHBlcihjaXAzMFdhbGxldEFQSSk7XHJcblxyXG4gICAgICBjb25zdCBwb2xpY3lJZCA9IFwiZTE2YzJkYzhhZTkzN2U4ZDM3OTBjN2ZkNzE2OGQ3Yjk5NDYyMWJhMTRjYTExNDE1ZjM5ZmVkNzJcIjtcclxuICAgICAgY29uc3QgbmFtZSA9IEJ1ZmZlci5mcm9tKFwiTUlOXCIsICd1dGY4JykudG9TdHJpbmcoJ2hleCcpO1xyXG5cclxuICAgICAgLy8gY29uc3QgcG9saWN5SWQgPSBcIlwiO1xyXG4gICAgICAvLyBjb25zdCBuYW1lID0gQnVmZmVyLmZyb20oXCJcIiwgJ3V0ZjgnKS50b1N0cmluZygnaGV4Jyk7XHJcblxyXG4gICAgICBjb25zdCBtcGggPSBNaW50aW5nUG9saWN5SGFzaC5mcm9tSGV4KHBvbGljeUlkKTtcclxuXHJcbiAgICAgIGNvbnN0IGFzc2V0Q2xhc3MgPSBuZXcgQXNzZXRDbGFzcyh7XHJcbiAgICAgICAgbXBoOiBtcGgsIC8vIFlvdXIgcG9saWN5IGhhc2hcclxuICAgICAgICB0b2tlbk5hbWU6IG5hbWUvLyBDb252ZXJ0IHRvIGhleCBzdHJpbmdcclxuICAgICAgfSk7IFxyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhhc3NldENsYXNzKVxyXG5cclxuICAgICAgY29uc3QgbWluQWRhIDogbnVtYmVyID0gMV8wMDBfMDAwOyAvLyBtaW5pbXVtIGxvdmVsYWNlIHRvIHNlbmRcclxuICAgICAgY29uc3QgbWluQWRhVmFsID0gbmV3IFZhbHVlKEJpZ0ludChtaW5BZGEpKTtcclxuXHJcbiAgICAgIC8vICBjb25zdCBiZW5lZml0aWFyeVZhbHVlID0gbmV3IFZhbHVlKEJpZ0ludCgxMDAwMCksIG5ldyBBc3NldHMoW1xyXG4gICAgICAvLyAgIFttcGgsIFtbbmFtZSwgQmlnSW50KDEwMDAwKV1dXVxyXG4gICAgICAvLyBdKSlcclxuXHJcblxyXG4gICAgICBjb25zdCB0ZXN0VmFsdWVTY3JpcHQgPSBuZXcgQXNzZXRzKFtbYXNzZXRDbGFzcywgQmlnSW50KDUwMDApXV0pO1xyXG5cclxuXHJcbiAgICAgIC8vIEdldCB3YWxsZXQgVVRYT3NcclxuICAgICAgY29uc3QgdXR4b3MgPSBhd2FpdCB3YWxsZXRIZWxwZXIucGlja1V0eG9zKG5ldyBWYWx1ZSh1bmRlZmluZWQsIHRlc3RWYWx1ZVNjcmlwdCkpO1xyXG4gICAgICBjb25zb2xlLmxvZyh1dHhvcyk7XHJcblxyXG4gICAgICAvLyBHZXQgY2hhbmdlIGFkZHJlc3NcclxuICAgICAgY29uc3QgYmVuZWZpdGlhcnkgPSBhd2FpdCB3YWxsZXRIZWxwZXIuY2hhbmdlQWRkcmVzcztcclxuICAgICAgLy8gTG9hZCBpbiB0aGUgdmVzdGluZyB2YWxpZGF0b3Igc2NyaXB0IChwcm9ncmFtKVxyXG4gICAgICBjb25zdCBnYW1lUmV3YXJkID0gbmV3IEdhbWVSZXdhcmQoKTtcclxuXHJcbiAgICAgIC8vIENvbXBpbGUgdGhlIHZlc3RpbmcgdmFsaWRhdG9yXHJcbiAgICAgIGNvbnN0IGNvbXBpbGVkUHJvZ3JhbSA9IGdhbWVSZXdhcmQuY29tcGlsZShvcHRpbWl6ZSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiV2FsbGV0IGFkZHJlc3M6IFwiICsgYmVuZWZpdGlhcnkpXHJcbiAgICAgIGNvbnN0IHNjcmlwdEFkZHJlc3MgPSBBZGRyZXNzLmZyb21IYXNoZXMoY29tcGlsZWRQcm9ncmFtLnZhbGlkYXRvckhhc2gpXHJcbiAgICBcclxuICAgICAgICAvL3JlbW92ZVxyXG4gICAgICBjb25zb2xlLmxvZyhzY3JpcHRBZGRyZXNzLnRvQmVjaDMyKCkpO1xyXG4gICAgICBjb25zb2xlLmxvZyhcIlNjcmlwdCBBZGRyZXNzOlwiICsgc2NyaXB0QWRkcmVzcylcclxuICAgICAgXHJcbiAgICAgIC8vIENvbnN0cnVjdCB0aGUgdmVzdGluZyBkYXR1bVxyXG4gICAgICBjb25zdCBnYW1lRGF0dW0gPSBuZXcgZ2FtZVJld2FyZC50eXBlcy5EYXR1bShcclxuICAgICAgICBiZW5lZml0aWFyeS5wdWJLZXlIYXNoLFxyXG4gICAgICApXHJcbiAgICBcclxuICAgIC8vY29uc3QgcmVkZWVtYmVyID0gKG5ldyBnYW1lUmV3YXJkLnR5cGVzLlJlZGVlbWVyLkNsYWltKCkpLl90b1VwbGNEYXRhKCk7XHJcbiAgICBcclxuICAgICAgY29uc3QgdHggPSBuZXcgVHgoKTtcclxuICAgICAgdHguYWRkSW5wdXRzKHV0eG9zWzBdKTtcclxuICAgICAgdHguYWRkT3V0cHV0KG5ldyBUeE91dHB1dChcclxuICAgICAgICBzY3JpcHRBZGRyZXNzLFxyXG4gICAgICAgIG5ldyBWYWx1ZSh1bmRlZmluZWQsIHRlc3RWYWx1ZVNjcmlwdCksXHJcbiAgICAgICAgRGF0dW0uaW5saW5lKGdhbWVEYXR1bSlcclxuICAgICAgKSk7XHJcblxyXG4gICAgICAvLyB0eC5hZGRPdXRwdXQobmV3IFR4T3V0cHV0KFxyXG4gICAgICAvLyAgIGJlbmVmaXRpYXJ5LFxyXG4gICAgICAvLyAgIG1pbkFkYVZhbCxcclxuICAgICAgLy8gKSk7XHJcbiAgICBcclxuICAgICAgY29uc29sZS5sb2coXCJXZSBhdHRhdGNoZWQgZXZlcnl0aGluZyFcIilcclxuXHJcbiAgICAgIC8vIFJlYWQgaW4gdGhlIG5ldHdvcmsgcGFyYW1ldGVyIGZpbGVcclxuICAgICAgY29uc3QgbmV0d29ya1BhcmFtc0pzb24gPSBhd2FpdCBnZXROZXR3b3JrUGFyYW1zKG5ldHdvcmspO1xyXG4gICAgICBjb25zdCBuZXR3b3JrUGFyYW1zID0gbmV3IE5ldHdvcmtQYXJhbXMobmV0d29ya1BhcmFtc0pzb24pO1xyXG5cclxuICAgICAgLy8gU2VuZCBhbnkgY2hhbmdlIGJhY2sgdG8gdGhlIGJ1eWVyXHJcbiAgICAgIGF3YWl0IHR4LmZpbmFsaXplKG5ldHdvcmtQYXJhbXMsIGJlbmVmaXRpYXJ5LCB1dHhvc1sxXSk7XHJcblxyXG4gICAgICAvLyBTaWduIHRoZSB1bnNpZ25lZCB0eCB0byBnZXQgdGhlIHdpdG5lc3NcclxuICAgICAgY29uc3Qgc2lnbmF0dXJlcyA9IGF3YWl0IGNpcDMwV2FsbGV0QVBJLnNpZ25UeCh0eCk7XHJcbiAgICAgIHR4LmFkZFNpZ25hdHVyZXMoc2lnbmF0dXJlcyk7XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhcInNpZ25lZFwiKTtcclxuICAgICAgLy8gU3VibWl0IHRoZSBzaWduZWQgdHhcclxuICAgICAgY29uc3QgdHhIYXNoID0gYXdhaXQgY2lwMzBXYWxsZXRBUEkuc3VibWl0VHgodHgpO1xyXG5cclxuICAgICAgc2V0VHgoeyB0eElkOiB0eEhhc2guaGV4IH0pO1xyXG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xyXG5cclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgdGhyb3cgY29uc29sZS5lcnJvcihcInN1Ym1pdCB0eCBmYWlsZWRcIiwgZXJyKTtcclxuICAgIH1cclxuICB9XHJcbiAgICBcclxuICBhc3luYyBmdW5jdGlvbiBmZXRjaFV0eG9zKHNjcmlwdEFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8VHhJbnB1dFtdPiB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFwiaHR0cDovL2xvY2FsaG9zdDozMDAxL2FwaS9nZXRVdHhvc1wiLCB7XHJcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbiAgICAgIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcclxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBzY3JpcHRBZGRyZXNzIH0pLFxyXG4gICAgfSk7XHJcbiAgXHJcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpOyAvLyBSYXcgSlNPTiBhcnJheSBmcm9tIGJhY2tlbmRcclxuICBcclxuICAgIC8vIGBDb252ZXJ0IEpTT04gYmFjayB0byBUeElucHV0IG9iamVjdHNcclxuICAgIGNvbnN0IGZpbHRlcmVkVXR4b3MgPSBkYXRhLm1hcCgodXR4bzogYW55KSA9PiBUeElucHV0LmZyb21GdWxsQ2Jvcih1dHhvKSk7XHJcblxyXG4gICAgcmV0dXJuIGZpbHRlcmVkVXR4b3M7XHJcbiAgfVxyXG4gICJdLCJuYW1lcyI6WyJOZXR3b3JrUGFyYW1zIiwiVmFsdWUiLCJUeE91dHB1dCIsIlR4IiwiVHhJbnB1dCIsIkNpcDMwV2FsbGV0IiwiRGF0dW0iLCJBc3NldHMiLCJXYWxsZXRIZWxwZXIiLCJNaW50aW5nUG9saWN5SGFzaCIsIkFzc2V0Q2xhc3MiLCJBZGRyZXNzIiwibmV0d29yayIsImdldE5ldHdvcmtQYXJhbXMiLCJHYW1lUmV3YXJkIiwib3B0aW1pemUiLCJnZXRUb2tlbkFtb3VudEZyb21VdHhvcyIsInV0eG9zIiwiYXNzZXRDbGFzcyIsInRvdGFsQW1vdW50IiwiQmlnSW50IiwiZm9yRWFjaCIsInV0eG8iLCJ0b2tlbnMiLCJ2YWx1ZSIsImFzc2V0cyIsImdldFRva2VucyIsIm1pbnRpbmdQb2xpY3lIYXNoIiwidG9rZW5OYW1lIiwiYW1vdW50IiwiY2FsY3VsYXRlUmV3YXJkIiwicmVtYWluaW5nU3VwcGx5IiwidG90YWxTdXBwbHkiLCJiYXNlUmV3YXJkIiwiaGFsdmluZ1RocmVzaG9sZCIsImhhbHZpbmdTdGVwcyIsIk1hdGgiLCJmbG9vciIsInJld2FyZCIsInBpY2tVdHhvcyIsInRhcmdldEFtb3VudCIsInNlbGVjdGVkIiwidXNlZEluZGljZXMiLCJTZXQiLCJyYW5kb21JbmRleCIsInJhbmRvbSIsImxlbmd0aCIsImhhcyIsImFkZCIsInNlbGVjdGVkVXR4byIsInB1c2giLCJjYWxjdWxhdGVSZXdhcmRJblRpbWUiLCJUaW1lQmVnaW5Db250cmFjdCIsIkhBTFZJTkdfUEVSSU9EIiwiTUFYX0hBTFZJTkdTIiwiQkFTRV9SRVdBUkQiLCJUaW1lTm93IiwiRGF0ZSIsIm5vdyIsInRpbWVFbGFwc2VkIiwibWluIiwiZWZmZWN0aXZlSGFsdmluZ3MiLCJjb25zb2xlIiwibG9nIiwiY2FsY3VsYXRlQ291bnRkb3duIiwiQ1lDTEVfRFVSQVRJT04iLCJvZmZzZXRJbk1zIiwiZWxhcHNlZFRpbWUiLCJlbGFwc2VkVGltZUluU2Vjb25kcyIsInBvc2l0aW9uSW5DeWNsZSIsInBpY2tSYW5kb21UeElucHV0V2l0aFN1ZmZpY2llbnRWYWx1ZSIsInR4SW5wdXRzIiwiZHluYW1pY1Jld2FyZCIsImVsaWdpYmxlVHhJbnB1dHMiLCJmaWx0ZXIiLCJ0eElucHV0Iiwib3V0cHV0IiwidG9rZW5BbW91bnQiLCJFcnJvciIsInNlbGVjdGVkVHhJbnB1dCIsInJlbWFpbmluZ1V0eG9zIiwiY2xhaW1Ub2tlbnMiLCJ3YWxsZXRBUEkiLCJzZXRJc0xvYWRpbmciLCJzZXRUeCIsImVycm9yIiwiY2lwMzBXYWxsZXRBUEkiLCJ3YWxsZXRIZWxwZXIiLCJuZXR3b3JrUGFyYW1zSnNvbiIsIm5ldHdvcmtQYXJhbXMiLCJwb2xpY3lJZCIsIm5hbWUiLCJCdWZmZXIiLCJmcm9tIiwidG9TdHJpbmciLCJtcGgiLCJmcm9tSGV4IiwidG9rZW5WYWwiLCJiZW5lZml0aWFyeSIsImNoYW5nZUFkZHJlc3MiLCJnYW1lUmV3YXJkIiwiY29tcGlsZWRQcm9ncmFtIiwiY29tcGlsZSIsInNjcmlwdEFkZHJlc3MiLCJmcm9tSGFzaGVzIiwidmFsaWRhdG9ySGFzaCIsInRvQmVjaDMyIiwiZGlyIiwiZGVwdGgiLCJmaWx0ZXJlZFV0eG9zIiwiZmV0Y2hVdHhvcyIsIkNMQUlNX1dJTkRPVyIsIlVUQyIsImdldFRpbWUiLCJ3aW5kb3ciLCJvbmVycm9yIiwidGVzdFZhbHVlQmVuZWZpdGlhcnkiLCJzb3J0ZWRVdHhvcyIsImVsZW1lbnQiLCJhbW91bnRUb1NlbmRCYWNrIiwiZmlyc3RQYXJ0VG9TZW5kQmFjayIsInNlY29uZFBhcnRUb1NlbmRCYWNrIiwidmFsdWVDb250cmFjdDEiLCJ2YWx1ZUNvbnRyYWN0MiIsImdhbWVEYXR1bSIsInR5cGVzIiwicHViS2V5SGFzaCIsInJlZGVlbWJlciIsIlJlZGVlbWVyIiwiQ2xhaW0iLCJfdG9VcGxjRGF0YSIsInR4IiwiYWRkSW5wdXRzIiwiYXR0YWNoU2NyaXB0IiwidXNlckNsYWltT3V0cHV0IiwidW5kZWZpbmVkIiwiYWRkT3V0cHV0Iiwic2NyaXB0VXR4bzEiLCJpbmxpbmUiLCJzY3JpcHRVdHhvMiIsImZpbmFsaXplIiwic2lnbmF0dXJlcyIsInNpZ25UeCIsImFkZFNpZ25hdHVyZXMiLCJ0eEhhc2giLCJzdWJtaXRUeCIsInR4SWQiLCJoZXgiLCJlcnIiLCJzZW5kIiwibWluQWRhIiwibWluQWRhVmFsIiwidGVzdFZhbHVlU2NyaXB0IiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImRhdGEiLCJqc29uIiwibWFwIiwiZnJvbUZ1bGxDYm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./public/walletActions.ts\n"));

/***/ })

});