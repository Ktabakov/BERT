"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/whitepaper",{

/***/ "./public/walletActions.ts":
/*!*********************************!*\
  !*** ./public/walletActions.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateCountdown: function() { return /* binding */ calculateCountdown; },\n/* harmony export */   claimTokens: function() { return /* binding */ claimTokens; },\n/* harmony export */   send: function() { return /* binding */ send; }\n/* harmony export */ });\n/* harmony import */ var _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @hyperionbt/helios */ \"./node_modules/@hyperionbt/helios/helios.js\");\n/* harmony import */ var _common_network__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/network */ \"./common/network.ts\");\n/* harmony import */ var _contracts_vesting_hl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../contracts/vesting.hl */ \"./contracts/vesting.hl\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\n\n // Ensure correct path to your contract\nconst optimize = false;\nfunction getTokenAmountFromUtxos(utxos, assetClass) {\n    let totalAmount = BigInt(0);\n    utxos.forEach((utxo)=>{\n        // Assuming utxo.value is in the right format\n        const tokens = utxo.value.assets.getTokens(assetClass.mintingPolicyHash);\n        tokens.forEach((param)=>{\n            let [tokenName, amount] = param;\n            totalAmount += BigInt(amount.value); // Add the amount to the total\n        });\n    });\n    return totalAmount;\n}\nfunction calculateReward(remainingSupply, totalSupply, baseReward) {\n    const halvingThreshold = totalSupply * 0.1; // 10% of total supply as the halving threshold\n    // Determine the number of halving steps\n    const halvingSteps = Math.floor((totalSupply - remainingSupply) / halvingThreshold);\n    // Calculate the reward after applying halving steps\n    const reward = Math.floor(baseReward / (1 + halvingSteps));\n    // Ensure the reward doesn't drop below 1\n    return reward < 1 ? 1 : reward;\n}\nfunction pickUtxos(utxos, targetAmount, assetClass) {\n    const selected = [];\n    let totalAmount = 0n;\n    // Keep track of the indices we've already picked\n    const usedIndices = new Set();\n    while(totalAmount < targetAmount){\n        // Generate a random index within the bounds of the UTXOs array\n        const randomIndex = Math.floor(Math.random() * utxos.length);\n        // If we've already selected this index, skip it\n        if (usedIndices.has(randomIndex)) {\n            continue;\n        }\n        // Mark the index as used\n        usedIndices.add(randomIndex);\n        // Add the UTXO to the selected list\n        const selectedUtxo = utxos[randomIndex];\n        selected.push(selectedUtxo);\n        const tokens = selectedUtxo.value.assets.getTokens(assetClass.mintingPolicyHash);\n        tokens.forEach((param)=>{\n            let [tokenName, amount] = param;\n            totalAmount += BigInt(amount.value); // Add the amount to the total\n        });\n    }\n    return {\n        selected,\n        totalAmount\n    };\n}\n// Calculate the reward based on the time elapsed since contract deployment\nfunction calculateRewardInTime(TimeBeginContract) {\n    TimeBeginContract = TimeBeginContract / 1000;\n    const HALVING_PERIOD = 2592000; // 1 month in seconds (60 * 60 * 24 * 30)\n    const MAX_HALVINGS = 5; // Limit halvings to 5 times\n    const BASE_REWARD = 1000; // Initial reward in tokens\n    // Get current time in seconds\n    const TimeNow = Math.floor(Date.now() / 1000);\n    // Calculate the elapsed time in seconds\n    const timeElapsed = TimeNow - TimeBeginContract;\n    // Determine halving steps based on elapsed time, but limit to MAX_HALVINGS\n    let halvingSteps = Math.floor(timeElapsed / HALVING_PERIOD);\n    halvingSteps = Math.min(halvingSteps, MAX_HALVINGS); // Cap halvings at MAX_HALVINGS\n    // Ensure the number of halving steps doesn't exceed the maximum allowed\n    const effectiveHalvings = Math.min(halvingSteps, MAX_HALVINGS);\n    console.log(\"Halvings\" + effectiveHalvings);\n    // Directly calculate reward based on halving steps using a bit shift\n    const reward = BASE_REWARD / 2 ** effectiveHalvings;\n    // Return the reward, ensuring it doesn't fall below a minimum value\n    return reward < 1 ? 1 : reward;\n}\nfunction calculateCountdown(TimeBeginContract) {\n    const TimeNow = Math.floor(Date.now());\n    const CYCLE_DURATION = 540 // 9 minutes \n    ;\n    const offsetInMs = 89680;\n    const elapsedTime = TimeNow - offsetInMs - TimeBeginContract;\n    const elapsedTimeInSeconds = elapsedTime / 1000;\n    const positionInCycle = elapsedTimeInSeconds % CYCLE_DURATION;\n    return positionInCycle;\n}\n// Function to filter and pick a random TxInput with sufficient value\nfunction pickRandomTxInputWithSufficientValue(txInputs, dynamicReward, assetClass) {\n    // Filter TxInputs that have sufficient token value\n    const eligibleTxInputs = txInputs.filter((txInput)=>{\n        // Extract the tokens and check their value\n        const tokens = txInput.output.value.assets.getTokens(assetClass.mintingPolicyHash);\n        let tokenAmount = BigInt(0);\n        tokens.forEach((param)=>{\n            let [tokenName, amount] = param;\n            tokenAmount += BigInt(amount.value); // Add the amount to the token total\n        });\n        return tokenAmount >= dynamicReward; // Check if the total token value meets or exceeds the reward\n    });\n    // If there are no eligible TxInputs, throw an error\n    if (eligibleTxInputs.length === 0) {\n        throw new Error(\"No eligible TxInput found with sufficient token value.\");\n    }\n    // Pick a random TxInput from the eligible list\n    const randomIndex = Math.floor(Math.random() * eligibleTxInputs.length);\n    const selectedTxInput = eligibleTxInputs[randomIndex];\n    // Calculate the token value of the selected TxInput\n    const tokens = selectedTxInput.output.value.assets.getTokens(assetClass.mintingPolicyHash);\n    let tokenAmount = BigInt(0);\n    tokens.forEach((param)=>{\n        let [tokenName, amount] = param;\n        tokenAmount += BigInt(amount.value); // Add the amount to the token total\n    });\n    const remainingUtxos = txInputs.filter((txInput)=>txInput !== selectedTxInput);\n    // Return the selected TxInput and its token value\n    return {\n        txInput: selectedTxInput,\n        tokenAmount,\n        remainingUtxos\n    };\n}\nasync function claimTokens(walletAPI, setIsLoading, setTx) {\n    setIsLoading(true);\n    if (!walletAPI) {\n        throw new Error(\"Wallet API is not set.\");\n    }\n    try {\n        const cip30WalletAPI = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Cip30Wallet(walletAPI);\n        const walletHelper = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.WalletHelper(cip30WalletAPI);\n        // Read in the network parameter file\n        const networkParamsJson = await (0,_common_network__WEBPACK_IMPORTED_MODULE_0__.getNetworkParams)(_common_network__WEBPACK_IMPORTED_MODULE_0__.network);\n        const networkParams = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.NetworkParams(networkParamsJson);\n        const policyId = \"e16c2dc8ae937e8d3790c7fd7168d7b994621ba14ca11415f39fed72\";\n        const name = Buffer.from(\"MIN\", \"utf8\").toString(\"hex\");\n        // const policyId = \"\";\n        // const name = Buffer.from(\"\", 'utf8').toString('hex');\n        const mph = _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.MintingPolicyHash.fromHex(policyId);\n        const assetClass = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.AssetClass({\n            mph: mph,\n            tokenName: name // Convert to hex string\n        });\n        console.log(assetClass);\n        const tokenAmount = BigInt(100);\n        const tokenVal = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Value(tokenAmount);\n        const utxos = await walletHelper.pickUtxos(tokenVal);\n        // Get change address\n        const benefitiary = await walletHelper.changeAddress;\n        // Load in the vesting validator script (program)\n        const gameReward = new _contracts_vesting_hl__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n        // Compile the vesting validator\n        const compiledProgram = gameReward.compile(optimize);\n        console.log(\"Wallet address: \" + benefitiary);\n        const scriptAddress = _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Address.fromHashes(compiledProgram.validatorHash);\n        console.log(scriptAddress.toBech32());\n        console.log(\"Script Address:\" + scriptAddress);\n        console.dir(scriptAddress, {\n            depth: null\n        });\n        const filteredUtxos = await fetchUtxos(scriptAddress.toBech32());\n        // const BASE_REWARD: number = 1000;  // Base reward\n        // const TOTAL_SUPPLY = 10000; // Total token supply\n        const CLAIM_WINDOW = 60; // 1 minute \n        console.log(\"filteredUtxos\" + filteredUtxos);\n        const TimeBeginContract = Math.floor(new Date(Date.UTC(2024, 11, 8, 13, 45, 0)).getTime());\n        //const remainingSupply = getTokenAmountFromUtxos(filteredUtxos, assetClass);\n        const dynamicReward = calculateRewardInTime(TimeBeginContract);\n        const positionInCycle = calculateCountdown(TimeBeginContract);\n        console.log(positionInCycle);\n        window.onerror = ()=>positionInCycle < CLAIM_WINDOW;\n        //const dynamicReward = calculateReward(Number(remainingSupply), TOTAL_SUPPLY, BASE_REWARD);\n        const testValueBenefitiary = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Assets([\n            [\n                assetClass,\n                BigInt(dynamicReward)\n            ]\n        ]);\n        //const result = pickRandomTxInputWithSufficientValue(filteredUtxos, BigInt(dynamicReward), assetClass);\n        //console.log(\"randomUTXO:\" + result.txInput)\n        //const amountToSendBack = result.tokenAmount - BigInt(dynamicReward);\n        // console.log(\"amountToSendBack\" + amountToSendBack)\n        // console.log(\"UtxoAmount\" + result.tokenAmount)\n        // console.log(\"The rest\" + result.remainingUtxos)\n        //console.log(filteredUtxos)\n        // const remoteWallet = new RemoteWallet(false, [scriptAddress], [], txInputs);\n        // const walletHelperScript = new WalletHelper(remoteWallet);\n        const sortedUtxos = pickUtxos(filteredUtxos, BigInt(dynamicReward), assetClass);\n        sortedUtxos.selected.forEach((element)=>{\n            console.log(element);\n        });\n        //const totalAmountUtxo = getTokenAmountFromUtxos(sortedUtxos.selected, assetClass);\n        const amountToSendBack = BigInt(sortedUtxos.totalAmount) - BigInt(dynamicReward);\n        const firstPartToSendBack = amountToSendBack / 2n; // First part is half of the total amount\n        const secondPartToSendBack = amountToSendBack - firstPartToSendBack; // Second part is the remainder\n        console.log(\"First \" + firstPartToSendBack);\n        console.log(\"Sevond \" + secondPartToSendBack);\n        console.log(dynamicReward);\n        const valueContract1 = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Assets([\n            [\n                assetClass,\n                firstPartToSendBack\n            ]\n        ]);\n        const valueContract2 = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Assets([\n            [\n                assetClass,\n                secondPartToSendBack\n            ]\n        ]);\n        const gameDatum = new gameReward.types.Datum(benefitiary.pubKeyHash);\n        // Create the vesting claim redeemer\n        const redeember = new gameReward.types.Redeemer.Claim(benefitiary.pubKeyHash)._toUplcData();\n        //console.log(filteredUtxos);\n        const tx = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Tx();\n        //tx.addInputs(utxos[0]);\n        tx.addInputs(sortedUtxos.selected, redeember);\n        tx.attachScript(compiledProgram);\n        var userClaimOutput = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.TxOutput(benefitiary, new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Value(undefined, testValueBenefitiary));\n        tx.addOutput(userClaimOutput);\n        //Shiiit, fix. Someone could rediredt the rest of the tokens\n        // const addressStr = \"addr_test1qrarqhmklnhwcw3q0zm6sgm3g3l7pua0y36sql9k5ru8dsucglsked5f5yrcf9e9xgxjgmt7xk52knh8h0dgayc00arqlh7g60\";\n        // const address = Address.fromBech32(addressStr);\n        // tx.addOutput(new TxOutput(\n        //   address,\n        //   new Value(undefined, testValueContract) // The amount being claimed\n        // ));\n        // Calculate total ADA in the selected script inputs\n        let totalAdaInInputs = BigInt(0);\n        sortedUtxos.selected.forEach((utxo)=>{\n            totalAdaInInputs += BigInt(utxo.output.value.lovelace);\n        });\n        // Distribute ADA equally (or as required) among script outputs\n        const adaPerScriptOutput = totalAdaInInputs / 2n; // Assuming two script outputs\n        if (amountToSendBack != BigInt(0)) {\n            var scriptUtxo1 = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.TxOutput(scriptAddress, new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Value(adaPerScriptOutput, valueContract1), _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Datum.inline(gameDatum) // Contract requires datum\n            );\n            tx.addOutput(scriptUtxo1);\n            var scriptUtxo2 = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.TxOutput(scriptAddress, new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Value(totalAdaInInputs - adaPerScriptOutput, valueContract2), _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Datum.inline(gameDatum) // Contract requires datum\n            );\n            tx.addOutput(scriptUtxo2);\n        }\n        //var inputFees = await walletHelper.pickUtxos(new Value(tokenAmountFees));\n        //tx.addInputs(inputFees[0]);\n        console.log(\"We attatched everything!\");\n        await tx.finalize(networkParams, benefitiary, utxos[1]);\n        // Sign the unsigned tx to get the witness\n        const signatures = await cip30WalletAPI.signTx(tx);\n        tx.addSignatures(signatures);\n        const txHash = await cip30WalletAPI.submitTx(tx);\n        setTx({\n            txId: txHash.hex\n        });\n        setIsLoading(false);\n    } catch (err) {\n        setIsLoading(false);\n        console.error(\"submit tx failed\", err);\n        throw err;\n    }\n}\nasync function send(walletAPI, setIsLoading, setTx) {\n    setIsLoading(true);\n    if (!walletAPI) {\n        throw console.error(\"walletAPI is not set\");\n    }\n    try {\n        const cip30WalletAPI = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Cip30Wallet(walletAPI);\n        // const blockfrost = new BlockFrostIPFS({\n        //   network: network,\n        //   projectId: \"preprodJExO0MAMRgfpXz9Il4IqB2u9ddoylZBT\",\n        // });\n        console.log(\"gmmm\");\n        const walletHelper = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.WalletHelper(cip30WalletAPI);\n        const policyId = \"e16c2dc8ae937e8d3790c7fd7168d7b994621ba14ca11415f39fed72\";\n        const name = Buffer.from(\"MIN\", \"utf8\").toString(\"hex\");\n        // const policyId = \"\";\n        // const name = Buffer.from(\"\", 'utf8').toString('hex');\n        const mph = _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.MintingPolicyHash.fromHex(policyId);\n        const assetClass = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.AssetClass({\n            mph: mph,\n            tokenName: name // Convert to hex string\n        });\n        console.log(assetClass);\n        const minAda = 1000000; // minimum lovelace to send\n        const minAdaVal = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Value(BigInt(minAda));\n        //  const benefitiaryValue = new Value(BigInt(10000), new Assets([\n        //   [mph, [[name, BigInt(10000)]]]\n        // ]))\n        const testValueScript = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Assets([\n            [\n                assetClass,\n                BigInt(10000)\n            ]\n        ]);\n        // Get wallet UTXOs\n        const utxos = await walletHelper.pickUtxos(new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Value(undefined, testValueScript));\n        console.log(utxos);\n        // Get change address\n        const benefitiary = await walletHelper.changeAddress;\n        // Load in the vesting validator script (program)\n        const gameReward = new _contracts_vesting_hl__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n        // Compile the vesting validator\n        const compiledProgram = gameReward.compile(optimize);\n        console.log(\"Wallet address: \" + benefitiary);\n        const scriptAddress = _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Address.fromHashes(compiledProgram.validatorHash);\n        //remove\n        console.log(scriptAddress.toBech32());\n        console.log(\"Script Address:\" + scriptAddress);\n        // Construct the vesting datum\n        const gameDatum = new gameReward.types.Datum(benefitiary.pubKeyHash);\n        //const redeember = (new gameReward.types.Redeemer.Claim())._toUplcData();\n        const tx = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Tx();\n        tx.addInputs(utxos[0]);\n        tx.addOutput(new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.TxOutput(scriptAddress, new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Value(undefined, testValueScript), _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Datum.inline(gameDatum)));\n        // tx.addOutput(new TxOutput(\n        //   benefitiary,\n        //   minAdaVal,\n        // ));\n        console.log(\"We attatched everything!\");\n        // Read in the network parameter file\n        const networkParamsJson = await (0,_common_network__WEBPACK_IMPORTED_MODULE_0__.getNetworkParams)(_common_network__WEBPACK_IMPORTED_MODULE_0__.network);\n        const networkParams = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.NetworkParams(networkParamsJson);\n        // Send any change back to the buyer\n        await tx.finalize(networkParams, benefitiary, utxos[1]);\n        // Sign the unsigned tx to get the witness\n        const signatures = await cip30WalletAPI.signTx(tx);\n        tx.addSignatures(signatures);\n        console.log(\"signed\");\n        // Submit the signed tx\n        const txHash = await cip30WalletAPI.submitTx(tx);\n        setTx({\n            txId: txHash.hex\n        });\n        setIsLoading(false);\n    } catch (err) {\n        setIsLoading(false);\n        throw console.error(\"submit tx failed\", err);\n    }\n}\nasync function fetchUtxos(scriptAddress) {\n    const response = await fetch(\"http://localhost:3001/api/getUtxos\", {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n            scriptAddress\n        })\n    });\n    const data = await response.json(); // Raw JSON array from backend\n    // `Convert JSON back to TxInput objects\n    const filteredUtxos = data.map((utxo)=>_hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.TxInput.fromFullCbor(utxo));\n    return filteredUtxos;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RCwwQ0FBMEM7UUFDMUMsTUFBTThILGFBQWEsTUFBTTFELGVBQWUyRCxNQUFNLENBQUNkO1FBQy9DQSxHQUFHZSxhQUFhLENBQUNGO1FBRWpCakYsUUFBUUMsR0FBRyxDQUFDO1FBQ1osdUJBQXVCO1FBQ3ZCLE1BQU1tRixTQUFTLE1BQU03RCxlQUFlOEQsUUFBUSxDQUFDakI7UUFFN0M5QyxNQUFNO1lBQUVnRSxNQUFNRixPQUFPRyxHQUFHO1FBQUM7UUFDekJsRSxhQUFhO0lBRWYsRUFBRSxPQUFPbUUsS0FBSztRQUNWbkUsYUFBYTtRQUNiLE1BQU1yQixRQUFReUYsS0FBSyxDQUFDLG9CQUFvQkQ7SUFDNUM7QUFDRjtBQUVBLGVBQWV6QyxXQUFXUCxhQUFxQjtJQUM3QyxNQUFNc0QsV0FBVyxNQUFNQyxNQUFNLHNDQUFzQztRQUNqRUMsUUFBUTtRQUNSQyxTQUFTO1lBQUUsZ0JBQWdCO1FBQW1CO1FBQzlDQyxNQUFNQyxLQUFLQyxTQUFTLENBQUM7WUFBRTVEO1FBQWM7SUFDdkM7SUFFQSxNQUFNNkQsT0FBTyxNQUFNUCxTQUFTUSxJQUFJLElBQUksOEJBQThCO0lBRWxFLHdDQUF3QztJQUN4QyxNQUFNeEQsZ0JBQWdCdUQsS0FBS0UsR0FBRyxDQUFDLENBQUMvSSxPQUFjbEIsdURBQU9BLENBQUNrSyxZQUFZLENBQUNoSjtJQUVuRSxPQUFPc0Y7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wdWJsaWMvd2FsbGV0QWN0aW9ucy50cz81YjA4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFxyXG4gICAgTmV0d29ya1BhcmFtcyxcclxuICAgIFZhbHVlLFxyXG4gICAgVHhPdXRwdXQsXHJcbiAgICBUeCxcclxuICAgIFR4SW5wdXQsXHJcbiAgICBDaXAzMFdhbGxldCxcclxuICAgIERhdHVtLFxyXG4gICAgQXNzZXRzLFxyXG4gICAgQmxvY2tmcm9zdFYwLFxyXG4gICAgVXBsY0RhdGEsXHJcbiAgICBXYWxsZXRIZWxwZXIsXHJcbiAgICBNaW50aW5nUG9saWN5SGFzaCxcclxuICAgIEFzc2V0Q2xhc3MsXHJcbiAgICBBZGRyZXNzLFxyXG4gICAgVHhPdXRwdXRJZFxyXG4gIH0gZnJvbSBcIkBoeXBlcmlvbmJ0L2hlbGlvc1wiO1xyXG4gIGltcG9ydCB7IG5ldHdvcmssIGdldE5ldHdvcmtQYXJhbXMgfSBmcm9tICcuLi9jb21tb24vbmV0d29yayc7XHJcbiAgaW1wb3J0IEdhbWVSZXdhcmQgZnJvbSAnLi4vY29udHJhY3RzL3Zlc3RpbmcuaGwnOyAvLyBFbnN1cmUgY29ycmVjdCBwYXRoIHRvIHlvdXIgY29udHJhY3RcclxuaW1wb3J0IHsgVHhJbiB9IGZyb20gXCJAYmxvY2tmcm9zdC9ibG9ja2Zyb3N0LWpzL2xpYi90eXBlcy9hcGkvdXRpbHMvdHhzXCI7XHJcbiAgXHJcbiAgY29uc3Qgb3B0aW1pemUgPSBmYWxzZTtcclxuIFxyXG5mdW5jdGlvbiBnZXRUb2tlbkFtb3VudEZyb21VdHhvcyh1dHhvczogVHhJbnB1dFtdLCBhc3NldENsYXNzOiBBc3NldENsYXNzKTogYmlnaW50IHtcclxuICAgIGxldCB0b3RhbEFtb3VudCA9IEJpZ0ludCgwKTtcclxuICBcclxuICAgIHV0eG9zLmZvckVhY2goKHV0eG86IFR4SW5wdXQpID0+IHtcclxuICAgICAgICAvLyBBc3N1bWluZyB1dHhvLnZhbHVlIGlzIGluIHRoZSByaWdodCBmb3JtYXRcclxuICAgICAgICBjb25zdCB0b2tlbnMgPSB1dHhvLnZhbHVlLmFzc2V0cy5nZXRUb2tlbnMoYXNzZXRDbGFzcy5taW50aW5nUG9saWN5SGFzaCk7XHJcbiAgICAgICAgdG9rZW5zLmZvckVhY2goKFt0b2tlbk5hbWUsIGFtb3VudF0pID0+IHtcclxuICAgICAgICAgIHRvdGFsQW1vdW50ICs9IEJpZ0ludChhbW91bnQudmFsdWUpOyAvLyBBZGQgdGhlIGFtb3VudCB0byB0aGUgdG90YWxcclxuICAgICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgXHJcbiAgICByZXR1cm4gdG90YWxBbW91bnQ7XHJcbiAgfVxyXG4gIFxyXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZVJld2FyZChyZW1haW5pbmdTdXBwbHk6IG51bWJlciwgdG90YWxTdXBwbHk6IG51bWJlciwgYmFzZVJld2FyZDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIGNvbnN0IGhhbHZpbmdUaHJlc2hvbGQgPSB0b3RhbFN1cHBseSAqIDAuMTsgLy8gMTAlIG9mIHRvdGFsIHN1cHBseSBhcyB0aGUgaGFsdmluZyB0aHJlc2hvbGRcclxuICBcclxuICAgIC8vIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGhhbHZpbmcgc3RlcHNcclxuICAgIGNvbnN0IGhhbHZpbmdTdGVwcyA9IE1hdGguZmxvb3IoKHRvdGFsU3VwcGx5IC0gcmVtYWluaW5nU3VwcGx5KSAvIGhhbHZpbmdUaHJlc2hvbGQpO1xyXG4gIFxyXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSByZXdhcmQgYWZ0ZXIgYXBwbHlpbmcgaGFsdmluZyBzdGVwc1xyXG4gICAgY29uc3QgcmV3YXJkID0gTWF0aC5mbG9vcihiYXNlUmV3YXJkIC8gKDEgKyBoYWx2aW5nU3RlcHMpKTtcclxuICBcclxuICAgIC8vIEVuc3VyZSB0aGUgcmV3YXJkIGRvZXNuJ3QgZHJvcCBiZWxvdyAxXHJcbiAgICByZXR1cm4gcmV3YXJkIDwgMSA/IDEgOiByZXdhcmQ7XHJcbiAgfVxyXG4gIFxyXG4gIGZ1bmN0aW9uIHBpY2tVdHhvcyh1dHhvczogVHhJbnB1dFtdLCB0YXJnZXRBbW91bnQ6IGJpZ2ludCwgYXNzZXRDbGFzczogQXNzZXRDbGFzcyk6IHsgc2VsZWN0ZWQ6IFR4SW5wdXRbXTsgdG90YWxBbW91bnQ6IGJpZ2ludCB9IHtcclxuICAgIGNvbnN0IHNlbGVjdGVkOiBUeElucHV0W10gPSBbXTtcclxuICAgIGxldCB0b3RhbEFtb3VudDogYmlnaW50ID0gMG47XHJcbiAgXHJcbiAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBpbmRpY2VzIHdlJ3ZlIGFscmVhZHkgcGlja2VkXHJcbiAgICBjb25zdCB1c2VkSW5kaWNlcyA9IG5ldyBTZXQ8bnVtYmVyPigpO1xyXG4gIFxyXG4gICAgd2hpbGUgKHRvdGFsQW1vdW50IDwgdGFyZ2V0QW1vdW50KSB7XHJcbiAgICAgICAgLy8gR2VuZXJhdGUgYSByYW5kb20gaW5kZXggd2l0aGluIHRoZSBib3VuZHMgb2YgdGhlIFVUWE9zIGFycmF5XHJcbiAgICAgICAgY29uc3QgcmFuZG9tSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB1dHhvcy5sZW5ndGgpO1xyXG4gIFxyXG4gICAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgc2VsZWN0ZWQgdGhpcyBpbmRleCwgc2tpcCBpdFxyXG4gICAgICAgIGlmICh1c2VkSW5kaWNlcy5oYXMocmFuZG9tSW5kZXgpKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICBcclxuICAgICAgICAvLyBNYXJrIHRoZSBpbmRleCBhcyB1c2VkXHJcbiAgICAgICAgdXNlZEluZGljZXMuYWRkKHJhbmRvbUluZGV4KTtcclxuICBcclxuICAgICAgICAvLyBBZGQgdGhlIFVUWE8gdG8gdGhlIHNlbGVjdGVkIGxpc3RcclxuICAgICAgICBjb25zdCBzZWxlY3RlZFV0eG8gPSB1dHhvc1tyYW5kb21JbmRleF07XHJcbiAgICAgICAgc2VsZWN0ZWQucHVzaChzZWxlY3RlZFV0eG8pO1xyXG4gICAgICAgIGNvbnN0IHRva2VucyA9IHNlbGVjdGVkVXR4by52YWx1ZS5hc3NldHMuZ2V0VG9rZW5zKGFzc2V0Q2xhc3MubWludGluZ1BvbGljeUhhc2gpO1xyXG4gICAgICAgIHRva2Vucy5mb3JFYWNoKChbdG9rZW5OYW1lLCBhbW91bnRdKSA9PiB7XHJcbiAgICAgICAgICB0b3RhbEFtb3VudCArPSBCaWdJbnQoYW1vdW50LnZhbHVlKTsgLy8gQWRkIHRoZSBhbW91bnQgdG8gdGhlIHRvdGFsXHJcbiAgICAgICAgICB9KTtcclxuICAgIH1cclxuICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc2VsZWN0ZWQsXHJcbiAgICAgICAgdG90YWxBbW91bnQsXHJcbiAgICB9O1xyXG4gIH1cclxuICBcclxuICAvLyBDYWxjdWxhdGUgdGhlIHJld2FyZCBiYXNlZCBvbiB0aGUgdGltZSBlbGFwc2VkIHNpbmNlIGNvbnRyYWN0IGRlcGxveW1lbnRcclxuICBmdW5jdGlvbiBjYWxjdWxhdGVSZXdhcmRJblRpbWUoVGltZUJlZ2luQ29udHJhY3Q6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICBUaW1lQmVnaW5Db250cmFjdCA9IFRpbWVCZWdpbkNvbnRyYWN0IC8gMTAwMDtcclxuICAgIGNvbnN0IEhBTFZJTkdfUEVSSU9EOiBudW1iZXIgPSAyNTkyMDAwOyAvLyAxIG1vbnRoIGluIHNlY29uZHMgKDYwICogNjAgKiAyNCAqIDMwKVxyXG4gICAgY29uc3QgTUFYX0hBTFZJTkdTOiBudW1iZXIgPSA1OyAvLyBMaW1pdCBoYWx2aW5ncyB0byA1IHRpbWVzXHJcbiAgICBjb25zdCBCQVNFX1JFV0FSRDogbnVtYmVyID0gMTAwMDsgLy8gSW5pdGlhbCByZXdhcmQgaW4gdG9rZW5zXHJcbiAgXHJcbiAgICAvLyBHZXQgY3VycmVudCB0aW1lIGluIHNlY29uZHNcclxuICAgIGNvbnN0IFRpbWVOb3c6IG51bWJlciA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApOyBcclxuICBcclxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZWxhcHNlZCB0aW1lIGluIHNlY29uZHNcclxuICAgIGNvbnN0IHRpbWVFbGFwc2VkOiBudW1iZXIgPSBUaW1lTm93IC0gVGltZUJlZ2luQ29udHJhY3Q7XHJcbiAgICAvLyBEZXRlcm1pbmUgaGFsdmluZyBzdGVwcyBiYXNlZCBvbiBlbGFwc2VkIHRpbWUsIGJ1dCBsaW1pdCB0byBNQVhfSEFMVklOR1NcclxuICAgIGxldCBoYWx2aW5nU3RlcHM6IG51bWJlciA9IE1hdGguZmxvb3IodGltZUVsYXBzZWQgLyBIQUxWSU5HX1BFUklPRCk7XHJcbiAgICBoYWx2aW5nU3RlcHMgPSBNYXRoLm1pbihoYWx2aW5nU3RlcHMsIE1BWF9IQUxWSU5HUyk7IC8vIENhcCBoYWx2aW5ncyBhdCBNQVhfSEFMVklOR1NcclxuICBcclxuICAgICAvLyBFbnN1cmUgdGhlIG51bWJlciBvZiBoYWx2aW5nIHN0ZXBzIGRvZXNuJ3QgZXhjZWVkIHRoZSBtYXhpbXVtIGFsbG93ZWRcclxuICAgICBjb25zdCBlZmZlY3RpdmVIYWx2aW5nczogbnVtYmVyID0gTWF0aC5taW4oaGFsdmluZ1N0ZXBzLCBNQVhfSEFMVklOR1MpO1xyXG4gICAgY29uc29sZS5sb2coXCJIYWx2aW5nc1wiICsgZWZmZWN0aXZlSGFsdmluZ3MpXHJcbiAgICAgLy8gRGlyZWN0bHkgY2FsY3VsYXRlIHJld2FyZCBiYXNlZCBvbiBoYWx2aW5nIHN0ZXBzIHVzaW5nIGEgYml0IHNoaWZ0XHJcbiAgICAgY29uc3QgcmV3YXJkOiBudW1iZXIgPSBCQVNFX1JFV0FSRCAvICgyICoqIGVmZmVjdGl2ZUhhbHZpbmdzKTtcclxuICAgXHJcbiAgICAgLy8gUmV0dXJuIHRoZSByZXdhcmQsIGVuc3VyaW5nIGl0IGRvZXNuJ3QgZmFsbCBiZWxvdyBhIG1pbmltdW0gdmFsdWVcclxuICAgICByZXR1cm4gcmV3YXJkIDwgMSA/IDEgOiByZXdhcmQ7XHJcbiAgfVxyXG4gIFxyXG4gIGV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVDb3VudGRvd24oVGltZUJlZ2luQ29udHJhY3Q6IG51bWJlcik6IG51bWJlciB7XHJcbiAgXHJcbiAgICBjb25zdCBUaW1lTm93OiBudW1iZXIgPSBNYXRoLmZsb29yKERhdGUubm93KCkpOyBcclxuICAgIGNvbnN0IENZQ0xFX0RVUkFUSU9OID0gNTQwIC8vIDkgbWludXRlcyBcclxuICAgIGNvbnN0IG9mZnNldEluTXMgPSA4OTY4MDtcclxuICAgIGNvbnN0IGVsYXBzZWRUaW1lID0gVGltZU5vdyAtIChvZmZzZXRJbk1zKSAtIFRpbWVCZWdpbkNvbnRyYWN0O1xyXG4gICAgY29uc3QgZWxhcHNlZFRpbWVJblNlY29uZHMgPSBlbGFwc2VkVGltZSAvIDEwMDA7XHJcbiAgICBjb25zdCBwb3NpdGlvbkluQ3ljbGUgPSBlbGFwc2VkVGltZUluU2Vjb25kcyAlIENZQ0xFX0RVUkFUSU9OO1xyXG4gIFxyXG4gICAgcmV0dXJuIHBvc2l0aW9uSW5DeWNsZTtcclxuICB9XHJcbiAgXHJcbiAgLy8gRnVuY3Rpb24gdG8gZmlsdGVyIGFuZCBwaWNrIGEgcmFuZG9tIFR4SW5wdXQgd2l0aCBzdWZmaWNpZW50IHZhbHVlXHJcbiAgZnVuY3Rpb24gcGlja1JhbmRvbVR4SW5wdXRXaXRoU3VmZmljaWVudFZhbHVlKFxyXG4gICAgdHhJbnB1dHM6IFR4SW5wdXRbXSxcclxuICAgIGR5bmFtaWNSZXdhcmQ6IGJpZ2ludCxcclxuICAgIGFzc2V0Q2xhc3M6IEFzc2V0Q2xhc3NcclxuICApOiB7IHR4SW5wdXQ6IFR4SW5wdXQ7IHRva2VuQW1vdW50OiBiaWdpbnQsIHJlbWFpbmluZ1V0eG9zOiBUeElucHV0W10gfSB7XHJcbiAgICAvLyBGaWx0ZXIgVHhJbnB1dHMgdGhhdCBoYXZlIHN1ZmZpY2llbnQgdG9rZW4gdmFsdWVcclxuICAgIGNvbnN0IGVsaWdpYmxlVHhJbnB1dHMgPSB0eElucHV0cy5maWx0ZXIoKHR4SW5wdXQ6IFR4SW5wdXQpID0+IHtcclxuICAgICAgLy8gRXh0cmFjdCB0aGUgdG9rZW5zIGFuZCBjaGVjayB0aGVpciB2YWx1ZVxyXG4gICAgICBjb25zdCB0b2tlbnMgPSB0eElucHV0Lm91dHB1dC52YWx1ZS5hc3NldHMuZ2V0VG9rZW5zKGFzc2V0Q2xhc3MubWludGluZ1BvbGljeUhhc2gpO1xyXG4gICAgICBsZXQgdG9rZW5BbW91bnQgPSBCaWdJbnQoMCk7XHJcbiAgXHJcbiAgICAgIHRva2Vucy5mb3JFYWNoKChbdG9rZW5OYW1lLCBhbW91bnRdKSA9PiB7XHJcbiAgICAgICAgdG9rZW5BbW91bnQgKz0gQmlnSW50KGFtb3VudC52YWx1ZSk7IC8vIEFkZCB0aGUgYW1vdW50IHRvIHRoZSB0b2tlbiB0b3RhbFxyXG4gICAgICB9KTtcclxuICBcclxuICAgICAgcmV0dXJuIHRva2VuQW1vdW50ID49IGR5bmFtaWNSZXdhcmQ7IC8vIENoZWNrIGlmIHRoZSB0b3RhbCB0b2tlbiB2YWx1ZSBtZWV0cyBvciBleGNlZWRzIHRoZSByZXdhcmRcclxuICAgIH0pO1xyXG4gIFxyXG4gICAgLy8gSWYgdGhlcmUgYXJlIG5vIGVsaWdpYmxlIFR4SW5wdXRzLCB0aHJvdyBhbiBlcnJvclxyXG4gICAgaWYgKGVsaWdpYmxlVHhJbnB1dHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGVsaWdpYmxlIFR4SW5wdXQgZm91bmQgd2l0aCBzdWZmaWNpZW50IHRva2VuIHZhbHVlLlwiKTtcclxuICAgIH1cclxuICBcclxuICAgIC8vIFBpY2sgYSByYW5kb20gVHhJbnB1dCBmcm9tIHRoZSBlbGlnaWJsZSBsaXN0XHJcbiAgICBjb25zdCByYW5kb21JbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGVsaWdpYmxlVHhJbnB1dHMubGVuZ3RoKTtcclxuICAgIGNvbnN0IHNlbGVjdGVkVHhJbnB1dCA9IGVsaWdpYmxlVHhJbnB1dHNbcmFuZG9tSW5kZXhdO1xyXG4gIFxyXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSB0b2tlbiB2YWx1ZSBvZiB0aGUgc2VsZWN0ZWQgVHhJbnB1dFxyXG4gICAgY29uc3QgdG9rZW5zID0gc2VsZWN0ZWRUeElucHV0Lm91dHB1dC52YWx1ZS5hc3NldHMuZ2V0VG9rZW5zKGFzc2V0Q2xhc3MubWludGluZ1BvbGljeUhhc2gpO1xyXG4gICAgbGV0IHRva2VuQW1vdW50ID0gQmlnSW50KDApO1xyXG4gIFxyXG4gICAgdG9rZW5zLmZvckVhY2goKFt0b2tlbk5hbWUsIGFtb3VudF0pID0+IHtcclxuICAgICAgdG9rZW5BbW91bnQgKz0gQmlnSW50KGFtb3VudC52YWx1ZSk7IC8vIEFkZCB0aGUgYW1vdW50IHRvIHRoZSB0b2tlbiB0b3RhbFxyXG4gICAgfSk7XHJcbiAgXHJcbiAgICBjb25zdCByZW1haW5pbmdVdHhvcyA9IHR4SW5wdXRzLmZpbHRlcigodHhJbnB1dCkgPT4gdHhJbnB1dCAhPT0gc2VsZWN0ZWRUeElucHV0KTtcclxuICBcclxuICAgIC8vIFJldHVybiB0aGUgc2VsZWN0ZWQgVHhJbnB1dCBhbmQgaXRzIHRva2VuIHZhbHVlXHJcbiAgICByZXR1cm4geyB0eElucHV0OiBzZWxlY3RlZFR4SW5wdXQsIHRva2VuQW1vdW50LCByZW1haW5pbmdVdHhvcyB9O1xyXG4gIH1cclxuICBcclxuICBleHBvcnQgYXN5bmMgZnVuY3Rpb24gY2xhaW1Ub2tlbnMod2FsbGV0QVBJOiBhbnksIHNldElzTG9hZGluZzogKHZhbDogYm9vbGVhbikgPT4gdm9pZCwgc2V0VHg6ICh2YWw6IHt0eElkOiBzdHJpbmd9KSA9PiB2b2lkKSB7XHJcbiAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XHJcblxyXG4gICAgaWYgKCF3YWxsZXRBUEkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXYWxsZXQgQVBJIGlzIG5vdCBzZXQuXCIpO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgY2lwMzBXYWxsZXRBUEkgPSBuZXcgQ2lwMzBXYWxsZXQod2FsbGV0QVBJKTtcclxuXHJcbiAgICAgIGNvbnN0IHdhbGxldEhlbHBlciA9IG5ldyBXYWxsZXRIZWxwZXIoY2lwMzBXYWxsZXRBUEkpO1xyXG4gICAgICAvLyBSZWFkIGluIHRoZSBuZXR3b3JrIHBhcmFtZXRlciBmaWxlXHJcbiAgICAgIGNvbnN0IG5ldHdvcmtQYXJhbXNKc29uID0gYXdhaXQgZ2V0TmV0d29ya1BhcmFtcyhuZXR3b3JrKTtcclxuICAgICAgY29uc3QgbmV0d29ya1BhcmFtcyA9IG5ldyBOZXR3b3JrUGFyYW1zKG5ldHdvcmtQYXJhbXNKc29uKTtcclxuXHJcbiAgICAgIGNvbnN0IHBvbGljeUlkID0gXCJlMTZjMmRjOGFlOTM3ZThkMzc5MGM3ZmQ3MTY4ZDdiOTk0NjIxYmExNGNhMTE0MTVmMzlmZWQ3MlwiO1xyXG4gICAgICBjb25zdCBuYW1lID0gQnVmZmVyLmZyb20oXCJNSU5cIiwgJ3V0ZjgnKS50b1N0cmluZygnaGV4Jyk7XHJcblxyXG4gICAgICAvLyBjb25zdCBwb2xpY3lJZCA9IFwiXCI7XHJcbiAgICAgIC8vIGNvbnN0IG5hbWUgPSBCdWZmZXIuZnJvbShcIlwiLCAndXRmOCcpLnRvU3RyaW5nKCdoZXgnKTtcclxuXHJcbiAgICAgIGNvbnN0IG1waCA9IE1pbnRpbmdQb2xpY3lIYXNoLmZyb21IZXgocG9saWN5SWQpO1xyXG5cclxuICAgICAgY29uc3QgYXNzZXRDbGFzcyA9IG5ldyBBc3NldENsYXNzKHtcclxuICAgICAgICBtcGg6IG1waCwgLy8gWW91ciBwb2xpY3kgaGFzaFxyXG4gICAgICAgIHRva2VuTmFtZTogbmFtZS8vIENvbnZlcnQgdG8gaGV4IHN0cmluZ1xyXG4gICAgICB9KTsgXHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKGFzc2V0Q2xhc3MpXHJcblxyXG4gICAgICBjb25zdCB0b2tlbkFtb3VudCA9IEJpZ0ludCgxMDApO1xyXG4gICAgICBjb25zdCB0b2tlblZhbCA9IG5ldyBWYWx1ZSh0b2tlbkFtb3VudCk7XHJcbiAgICAgIGNvbnN0IHV0eG9zID0gYXdhaXQgd2FsbGV0SGVscGVyLnBpY2tVdHhvcyh0b2tlblZhbCk7XHJcblxyXG4gICAgICAvLyBHZXQgY2hhbmdlIGFkZHJlc3NcclxuICAgICAgY29uc3QgYmVuZWZpdGlhcnkgPSBhd2FpdCB3YWxsZXRIZWxwZXIuY2hhbmdlQWRkcmVzcztcclxuICAgICAgLy8gTG9hZCBpbiB0aGUgdmVzdGluZyB2YWxpZGF0b3Igc2NyaXB0IChwcm9ncmFtKVxyXG4gICAgICBjb25zdCBnYW1lUmV3YXJkID0gbmV3IEdhbWVSZXdhcmQoKTtcclxuXHJcbiAgICAgIC8vIENvbXBpbGUgdGhlIHZlc3RpbmcgdmFsaWRhdG9yXHJcbiAgICAgIGNvbnN0IGNvbXBpbGVkUHJvZ3JhbSA9IGdhbWVSZXdhcmQuY29tcGlsZShvcHRpbWl6ZSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiV2FsbGV0IGFkZHJlc3M6IFwiICsgYmVuZWZpdGlhcnkpXHJcbiAgICAgIGNvbnN0IHNjcmlwdEFkZHJlc3MgPSBBZGRyZXNzLmZyb21IYXNoZXMoY29tcGlsZWRQcm9ncmFtLnZhbGlkYXRvckhhc2gpXHJcbiAgICBcclxuICAgICAgY29uc29sZS5sb2coc2NyaXB0QWRkcmVzcy50b0JlY2gzMigpKTtcclxuICAgICAgY29uc29sZS5sb2coXCJTY3JpcHQgQWRkcmVzczpcIiArIHNjcmlwdEFkZHJlc3MpXHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmRpcihzY3JpcHRBZGRyZXNzLCB7IGRlcHRoOiBudWxsIH0pO1xyXG5cclxuICAgICAgY29uc3QgZmlsdGVyZWRVdHhvcyA9IGF3YWl0IGZldGNoVXR4b3Moc2NyaXB0QWRkcmVzcy50b0JlY2gzMigpKVxyXG4gICBcclxuICAgICAgLy8gY29uc3QgQkFTRV9SRVdBUkQ6IG51bWJlciA9IDEwMDA7ICAvLyBCYXNlIHJld2FyZFxyXG4gICAgICAvLyBjb25zdCBUT1RBTF9TVVBQTFkgPSAxMDAwMDsgLy8gVG90YWwgdG9rZW4gc3VwcGx5XHJcbiAgICAgIGNvbnN0IENMQUlNX1dJTkRPVyA9IDYwOyAvLyAxIG1pbnV0ZSBcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKFwiZmlsdGVyZWRVdHhvc1wiICsgZmlsdGVyZWRVdHhvcylcclxuICAgICAgY29uc3QgVGltZUJlZ2luQ29udHJhY3Q6IG51bWJlciA9IE1hdGguZmxvb3IobmV3IERhdGUoRGF0ZS5VVEMoMjAyNCwgMTEsIDgsIDEzLCA0NSwgMCkpLmdldFRpbWUoKSk7XHJcbiAgICAgIC8vY29uc3QgcmVtYWluaW5nU3VwcGx5ID0gZ2V0VG9rZW5BbW91bnRGcm9tVXR4b3MoZmlsdGVyZWRVdHhvcywgYXNzZXRDbGFzcyk7XHJcbiAgICAgIGNvbnN0IGR5bmFtaWNSZXdhcmQgPSBjYWxjdWxhdGVSZXdhcmRJblRpbWUoVGltZUJlZ2luQ29udHJhY3QpXHJcbiAgICAgIGNvbnN0IHBvc2l0aW9uSW5DeWNsZSA9IGNhbGN1bGF0ZUNvdW50ZG93bihUaW1lQmVnaW5Db250cmFjdCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKHBvc2l0aW9uSW5DeWNsZSk7XHJcbiAgICAgIHdpbmRvdy5vbmVycm9yID0gKCkgPT4gcG9zaXRpb25JbkN5Y2xlIDwgQ0xBSU1fV0lORE9XO1xyXG4gICAgICAvL2NvbnN0IGR5bmFtaWNSZXdhcmQgPSBjYWxjdWxhdGVSZXdhcmQoTnVtYmVyKHJlbWFpbmluZ1N1cHBseSksIFRPVEFMX1NVUFBMWSwgQkFTRV9SRVdBUkQpO1xyXG4gICAgICBjb25zdCB0ZXN0VmFsdWVCZW5lZml0aWFyeT0gbmV3IEFzc2V0cyhbW2Fzc2V0Q2xhc3MsIEJpZ0ludChkeW5hbWljUmV3YXJkKV1dKTtcclxuXHJcbiAgICAgIC8vY29uc3QgcmVzdWx0ID0gcGlja1JhbmRvbVR4SW5wdXRXaXRoU3VmZmljaWVudFZhbHVlKGZpbHRlcmVkVXR4b3MsIEJpZ0ludChkeW5hbWljUmV3YXJkKSwgYXNzZXRDbGFzcyk7XHJcbiAgICAgIC8vY29uc29sZS5sb2coXCJyYW5kb21VVFhPOlwiICsgcmVzdWx0LnR4SW5wdXQpXHJcblxyXG4gICAgICAvL2NvbnN0IGFtb3VudFRvU2VuZEJhY2sgPSByZXN1bHQudG9rZW5BbW91bnQgLSBCaWdJbnQoZHluYW1pY1Jld2FyZCk7XHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiYW1vdW50VG9TZW5kQmFja1wiICsgYW1vdW50VG9TZW5kQmFjaylcclxuICAgICAgLy8gY29uc29sZS5sb2coXCJVdHhvQW1vdW50XCIgKyByZXN1bHQudG9rZW5BbW91bnQpXHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiVGhlIHJlc3RcIiArIHJlc3VsdC5yZW1haW5pbmdVdHhvcylcclxuICAgICAgXHJcbiAgICAgIC8vY29uc29sZS5sb2coZmlsdGVyZWRVdHhvcylcclxuICAgICAgLy8gY29uc3QgcmVtb3RlV2FsbGV0ID0gbmV3IFJlbW90ZVdhbGxldChmYWxzZSwgW3NjcmlwdEFkZHJlc3NdLCBbXSwgdHhJbnB1dHMpO1xyXG4gICAgICAvLyBjb25zdCB3YWxsZXRIZWxwZXJTY3JpcHQgPSBuZXcgV2FsbGV0SGVscGVyKHJlbW90ZVdhbGxldCk7XHJcbiAgICAgIGNvbnN0IHNvcnRlZFV0eG9zID0gcGlja1V0eG9zKGZpbHRlcmVkVXR4b3MsIEJpZ0ludChkeW5hbWljUmV3YXJkKSwgYXNzZXRDbGFzcyk7IFxyXG4gICAgICBcclxuICAgICAgc29ydGVkVXR4b3Muc2VsZWN0ZWQuZm9yRWFjaChlbGVtZW50ID0+IHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGVsZW1lbnQpXHJcbiAgICAgIH0pO1xyXG4gICAgICAvL2NvbnN0IHRvdGFsQW1vdW50VXR4byA9IGdldFRva2VuQW1vdW50RnJvbVV0eG9zKHNvcnRlZFV0eG9zLnNlbGVjdGVkLCBhc3NldENsYXNzKTtcclxuICAgICAgY29uc3QgYW1vdW50VG9TZW5kQmFjayA9IEJpZ0ludChzb3J0ZWRVdHhvcy50b3RhbEFtb3VudCkgLSBCaWdJbnQoZHluYW1pY1Jld2FyZCk7XHJcblxyXG4gICAgICBjb25zdCBmaXJzdFBhcnRUb1NlbmRCYWNrID0gYW1vdW50VG9TZW5kQmFjayAvIDJuOyAvLyBGaXJzdCBwYXJ0IGlzIGhhbGYgb2YgdGhlIHRvdGFsIGFtb3VudFxyXG4gICAgICBjb25zdCBzZWNvbmRQYXJ0VG9TZW5kQmFjayA9IGFtb3VudFRvU2VuZEJhY2sgLSBmaXJzdFBhcnRUb1NlbmRCYWNrOyAvLyBTZWNvbmQgcGFydCBpcyB0aGUgcmVtYWluZGVyXHJcbiAgICAgIGNvbnNvbGUubG9nKFwiRmlyc3QgXCIgKyBmaXJzdFBhcnRUb1NlbmRCYWNrKVxyXG4gICAgICBjb25zb2xlLmxvZyhcIlNldm9uZCBcIiArIHNlY29uZFBhcnRUb1NlbmRCYWNrKVxyXG4gICAgICBjb25zb2xlLmxvZyhkeW5hbWljUmV3YXJkXHQpXHJcblxyXG4gICAgICBjb25zdCB2YWx1ZUNvbnRyYWN0MT0gbmV3IEFzc2V0cyhbW2Fzc2V0Q2xhc3MsIGZpcnN0UGFydFRvU2VuZEJhY2tdXSk7XHJcbiAgICAgIGNvbnN0IHZhbHVlQ29udHJhY3QyPSBuZXcgQXNzZXRzKFtbYXNzZXRDbGFzcywgc2Vjb25kUGFydFRvU2VuZEJhY2tdXSk7XHJcblxyXG5cclxuICAgICAgY29uc3QgZ2FtZURhdHVtID0gbmV3IGdhbWVSZXdhcmQudHlwZXMuRGF0dW0oXHJcbiAgICAgICAgYmVuZWZpdGlhcnkucHViS2V5SGFzaCxcclxuICAgICAgKVxyXG5cclxuICAgICAgIC8vIENyZWF0ZSB0aGUgdmVzdGluZyBjbGFpbSByZWRlZW1lclxyXG4gICAgICAgY29uc3QgcmVkZWVtYmVyID0gKG5ldyBnYW1lUmV3YXJkLnR5cGVzLlJlZGVlbWVyLkNsYWltKGJlbmVmaXRpYXJ5LnB1YktleUhhc2gpKVxyXG4gICAgICAgLl90b1VwbGNEYXRhKCk7XHJcbiAgICBcclxuICAgICAgLy9jb25zb2xlLmxvZyhmaWx0ZXJlZFV0eG9zKTtcclxuICAgICAgY29uc3QgdHggPSBuZXcgVHgoKTtcclxuXHJcbiAgICAgIC8vdHguYWRkSW5wdXRzKHV0eG9zWzBdKTtcclxuICAgICAgdHguYWRkSW5wdXRzKHNvcnRlZFV0eG9zLnNlbGVjdGVkLCByZWRlZW1iZXIpO1xyXG4gICAgICB0eC5hdHRhY2hTY3JpcHQoY29tcGlsZWRQcm9ncmFtKTtcclxuXHJcbiAgICAgIHZhciB1c2VyQ2xhaW1PdXRwdXQgPSBuZXcgVHhPdXRwdXQoXHJcbiAgICAgICAgYmVuZWZpdGlhcnksXHJcbiAgICAgICAgbmV3IFZhbHVlKHVuZGVmaW5lZCwgdGVzdFZhbHVlQmVuZWZpdGlhcnkpKTtcclxuXHJcbiAgICAgIHR4LmFkZE91dHB1dCh1c2VyQ2xhaW1PdXRwdXQpO1xyXG5cclxuICAgIFxyXG4gICAgLy9TaGlpaXQsIGZpeC4gU29tZW9uZSBjb3VsZCByZWRpcmVkdCB0aGUgcmVzdCBvZiB0aGUgdG9rZW5zXHJcbiAgICAvLyBjb25zdCBhZGRyZXNzU3RyID0gXCJhZGRyX3Rlc3QxcXJhcnFobWtsbmh3Y3czcTB6bTZzZ20zZzNsN3B1YTB5MzZzcWw5azVydThkc3VjZ2xza2VkNWY1eXJjZjllOXhneGpnbXQ3eGs1MmtuaDhoMGRnYXljMDBhcnFsaDdnNjBcIjtcclxuICAgIC8vIGNvbnN0IGFkZHJlc3MgPSBBZGRyZXNzLmZyb21CZWNoMzIoYWRkcmVzc1N0cik7XHJcbiAgICAvLyB0eC5hZGRPdXRwdXQobmV3IFR4T3V0cHV0KFxyXG4gICAgLy8gICBhZGRyZXNzLFxyXG4gICAgLy8gICBuZXcgVmFsdWUodW5kZWZpbmVkLCB0ZXN0VmFsdWVDb250cmFjdCkgLy8gVGhlIGFtb3VudCBiZWluZyBjbGFpbWVkXHJcbiAgICAvLyApKTtcclxuICAgIFxyXG4gICAgLy8gQ2FsY3VsYXRlIHRvdGFsIEFEQSBpbiB0aGUgc2VsZWN0ZWQgc2NyaXB0IGlucHV0c1xyXG4gICAgbGV0IHRvdGFsQWRhSW5JbnB1dHMgPSBCaWdJbnQoMCk7XHJcbiAgICBzb3J0ZWRVdHhvcy5zZWxlY3RlZC5mb3JFYWNoKHV0eG8gPT4ge1xyXG4gICAgICAgIHRvdGFsQWRhSW5JbnB1dHMgKz0gQmlnSW50KHV0eG8ub3V0cHV0LnZhbHVlLmxvdmVsYWNlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIERpc3RyaWJ1dGUgQURBIGVxdWFsbHkgKG9yIGFzIHJlcXVpcmVkKSBhbW9uZyBzY3JpcHQgb3V0cHV0c1xyXG4gICAgY29uc3QgYWRhUGVyU2NyaXB0T3V0cHV0ID0gdG90YWxBZGFJbklucHV0cyAvIDJuOyAvLyBBc3N1bWluZyB0d28gc2NyaXB0IG91dHB1dHNcclxuXHJcbiAgICBpZiAoYW1vdW50VG9TZW5kQmFjayAhPSBCaWdJbnQoMCkpe1xyXG4gICAgICB2YXIgc2NyaXB0VXR4bzEgPW5ldyBUeE91dHB1dChcclxuICAgICAgICBzY3JpcHRBZGRyZXNzLFxyXG4gICAgICAgIG5ldyBWYWx1ZShhZGFQZXJTY3JpcHRPdXRwdXQsIHZhbHVlQ29udHJhY3QxKSwgIC8vIFJlbWFpbmluZyB0cmVhc3VyeSB0b2tlbnNcclxuICAgICAgICBEYXR1bS5pbmxpbmUoZ2FtZURhdHVtKSAvLyBDb250cmFjdCByZXF1aXJlcyBkYXR1bVxyXG4gICAgICAgKTtcclxuXHJcbiAgICAgICB0eC5hZGRPdXRwdXQoc2NyaXB0VXR4bzEpO1xyXG5cclxuICAgICAgdmFyIHNjcmlwdFV0eG8yID0gbmV3IFR4T3V0cHV0KFxyXG4gICAgICAgIHNjcmlwdEFkZHJlc3MsXHJcbiAgICAgICAgbmV3IFZhbHVlKHRvdGFsQWRhSW5JbnB1dHMgLSBhZGFQZXJTY3JpcHRPdXRwdXQsIHZhbHVlQ29udHJhY3QyKSwgIC8vIFJlbWFpbmluZyB0cmVhc3VyeSB0b2tlbnNcclxuICAgICAgICBEYXR1bS5pbmxpbmUoZ2FtZURhdHVtKSAvLyBDb250cmFjdCByZXF1aXJlcyBkYXR1bVxyXG4gICAgICAgKTtcclxuICAgIFxyXG4gICAgICAgdHguYWRkT3V0cHV0KHNjcmlwdFV0eG8yKTtcclxuICAgIH0gIFxyXG5cclxuICAgICAgLy92YXIgaW5wdXRGZWVzID0gYXdhaXQgd2FsbGV0SGVscGVyLnBpY2tVdHhvcyhuZXcgVmFsdWUodG9rZW5BbW91bnRGZWVzKSk7XHJcbiAgICAgIFxyXG4gICAgICAvL3R4LmFkZElucHV0cyhpbnB1dEZlZXNbMF0pO1xyXG4gICAgICBjb25zb2xlLmxvZyhcIldlIGF0dGF0Y2hlZCBldmVyeXRoaW5nIVwiKVxyXG5cclxuICAgICAgYXdhaXQgdHguZmluYWxpemUobmV0d29ya1BhcmFtcywgYmVuZWZpdGlhcnksIHV0eG9zWzFdKTtcclxuXHJcbiAgICAgIC8vIFNpZ24gdGhlIHVuc2lnbmVkIHR4IHRvIGdldCB0aGUgd2l0bmVzc1xyXG4gICAgICBjb25zdCBzaWduYXR1cmVzID0gYXdhaXQgY2lwMzBXYWxsZXRBUEkuc2lnblR4KHR4KTtcclxuICAgICAgdHguYWRkU2lnbmF0dXJlcyhzaWduYXR1cmVzKTtcclxuXHJcbiAgICAgIGNvbnN0IHR4SGFzaCA9IGF3YWl0IGNpcDMwV2FsbGV0QVBJLnN1Ym1pdFR4KHR4KTtcclxuXHJcbiAgICAgIHNldFR4KHsgdHhJZDogdHhIYXNoLmhleCB9KTtcclxuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcclxuXHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJzdWJtaXQgdHggZmFpbGVkXCIsIGVycik7XHJcbiAgICAgICAgdGhyb3cgZXJyOyBcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlbmQod2FsbGV0QVBJOiBhbnksIHNldElzTG9hZGluZzogKHZhbDogYm9vbGVhbikgPT4gdm9pZCwgc2V0VHg6ICh2YWw6IHt0eElkOiBzdHJpbmd9KSA9PiB2b2lkKSB7XHJcbiAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XHJcblxyXG4gICAgaWYgKCF3YWxsZXRBUEkpIHtcclxuICAgICAgdGhyb3cgY29uc29sZS5lcnJvcihcIndhbGxldEFQSSBpcyBub3Qgc2V0XCIpO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgY2lwMzBXYWxsZXRBUEkgPSBuZXcgQ2lwMzBXYWxsZXQod2FsbGV0QVBJKTtcclxuICAgICAgLy8gY29uc3QgYmxvY2tmcm9zdCA9IG5ldyBCbG9ja0Zyb3N0SVBGUyh7XHJcbiAgICAgIC8vICAgbmV0d29yazogbmV0d29yayxcclxuICAgICAgLy8gICBwcm9qZWN0SWQ6IFwicHJlcHJvZEpFeE8wTUFNUmdmcFh6OUlsNElxQjJ1OWRkb3lsWkJUXCIsXHJcbiAgICAgIC8vIH0pO1xyXG4gICAgICBjb25zb2xlLmxvZyhcImdtbW1cIilcclxuXHJcbiAgICAgIGNvbnN0IHdhbGxldEhlbHBlciA9IG5ldyBXYWxsZXRIZWxwZXIoY2lwMzBXYWxsZXRBUEkpO1xyXG5cclxuICAgICAgY29uc3QgcG9saWN5SWQgPSBcImUxNmMyZGM4YWU5MzdlOGQzNzkwYzdmZDcxNjhkN2I5OTQ2MjFiYTE0Y2ExMTQxNWYzOWZlZDcyXCI7XHJcbiAgICAgIGNvbnN0IG5hbWUgPSBCdWZmZXIuZnJvbShcIk1JTlwiLCAndXRmOCcpLnRvU3RyaW5nKCdoZXgnKTtcclxuXHJcbiAgICAgIC8vIGNvbnN0IHBvbGljeUlkID0gXCJcIjtcclxuICAgICAgLy8gY29uc3QgbmFtZSA9IEJ1ZmZlci5mcm9tKFwiXCIsICd1dGY4JykudG9TdHJpbmcoJ2hleCcpO1xyXG5cclxuICAgICAgY29uc3QgbXBoID0gTWludGluZ1BvbGljeUhhc2guZnJvbUhleChwb2xpY3lJZCk7XHJcblxyXG4gICAgICBjb25zdCBhc3NldENsYXNzID0gbmV3IEFzc2V0Q2xhc3Moe1xyXG4gICAgICAgIG1waDogbXBoLCAvLyBZb3VyIHBvbGljeSBoYXNoXHJcbiAgICAgICAgdG9rZW5OYW1lOiBuYW1lLy8gQ29udmVydCB0byBoZXggc3RyaW5nXHJcbiAgICAgIH0pOyBcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coYXNzZXRDbGFzcylcclxuXHJcbiAgICAgIGNvbnN0IG1pbkFkYSA6IG51bWJlciA9IDFfMDAwXzAwMDsgLy8gbWluaW11bSBsb3ZlbGFjZSB0byBzZW5kXHJcbiAgICAgIGNvbnN0IG1pbkFkYVZhbCA9IG5ldyBWYWx1ZShCaWdJbnQobWluQWRhKSk7XHJcblxyXG4gICAgICAvLyAgY29uc3QgYmVuZWZpdGlhcnlWYWx1ZSA9IG5ldyBWYWx1ZShCaWdJbnQoMTAwMDApLCBuZXcgQXNzZXRzKFtcclxuICAgICAgLy8gICBbbXBoLCBbW25hbWUsIEJpZ0ludCgxMDAwMCldXV1cclxuICAgICAgLy8gXSkpXHJcblxyXG5cclxuICAgICAgY29uc3QgdGVzdFZhbHVlU2NyaXB0ID0gbmV3IEFzc2V0cyhbW2Fzc2V0Q2xhc3MsIEJpZ0ludCgxMDAwMCldXSk7XHJcblxyXG5cclxuICAgICAgLy8gR2V0IHdhbGxldCBVVFhPc1xyXG4gICAgICBjb25zdCB1dHhvcyA9IGF3YWl0IHdhbGxldEhlbHBlci5waWNrVXR4b3MobmV3IFZhbHVlKHVuZGVmaW5lZCwgdGVzdFZhbHVlU2NyaXB0KSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKHV0eG9zKTtcclxuXHJcbiAgICAgIC8vIEdldCBjaGFuZ2UgYWRkcmVzc1xyXG4gICAgICBjb25zdCBiZW5lZml0aWFyeSA9IGF3YWl0IHdhbGxldEhlbHBlci5jaGFuZ2VBZGRyZXNzO1xyXG4gICAgICAvLyBMb2FkIGluIHRoZSB2ZXN0aW5nIHZhbGlkYXRvciBzY3JpcHQgKHByb2dyYW0pXHJcbiAgICAgIGNvbnN0IGdhbWVSZXdhcmQgPSBuZXcgR2FtZVJld2FyZCgpO1xyXG5cclxuICAgICAgLy8gQ29tcGlsZSB0aGUgdmVzdGluZyB2YWxpZGF0b3JcclxuICAgICAgY29uc3QgY29tcGlsZWRQcm9ncmFtID0gZ2FtZVJld2FyZC5jb21waWxlKG9wdGltaXplKTtcclxuICAgICAgY29uc29sZS5sb2coXCJXYWxsZXQgYWRkcmVzczogXCIgKyBiZW5lZml0aWFyeSlcclxuICAgICAgY29uc3Qgc2NyaXB0QWRkcmVzcyA9IEFkZHJlc3MuZnJvbUhhc2hlcyhjb21waWxlZFByb2dyYW0udmFsaWRhdG9ySGFzaClcclxuICAgIFxyXG4gICAgICAgIC8vcmVtb3ZlXHJcbiAgICAgIGNvbnNvbGUubG9nKHNjcmlwdEFkZHJlc3MudG9CZWNoMzIoKSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiU2NyaXB0IEFkZHJlc3M6XCIgKyBzY3JpcHRBZGRyZXNzKVxyXG4gICAgICBcclxuICAgICAgLy8gQ29uc3RydWN0IHRoZSB2ZXN0aW5nIGRhdHVtXHJcbiAgICAgIGNvbnN0IGdhbWVEYXR1bSA9IG5ldyBnYW1lUmV3YXJkLnR5cGVzLkRhdHVtKFxyXG4gICAgICAgIGJlbmVmaXRpYXJ5LnB1YktleUhhc2gsXHJcbiAgICAgIClcclxuICAgIFxyXG4gICAgLy9jb25zdCByZWRlZW1iZXIgPSAobmV3IGdhbWVSZXdhcmQudHlwZXMuUmVkZWVtZXIuQ2xhaW0oKSkuX3RvVXBsY0RhdGEoKTtcclxuICAgIFxyXG4gICAgICBjb25zdCB0eCA9IG5ldyBUeCgpO1xyXG4gICAgICB0eC5hZGRJbnB1dHModXR4b3NbMF0pO1xyXG4gICAgICB0eC5hZGRPdXRwdXQobmV3IFR4T3V0cHV0KFxyXG4gICAgICAgIHNjcmlwdEFkZHJlc3MsXHJcbiAgICAgICAgbmV3IFZhbHVlKHVuZGVmaW5lZCwgdGVzdFZhbHVlU2NyaXB0KSxcclxuICAgICAgICBEYXR1bS5pbmxpbmUoZ2FtZURhdHVtKVxyXG4gICAgICApKTtcclxuXHJcbiAgICAgIC8vIHR4LmFkZE91dHB1dChuZXcgVHhPdXRwdXQoXHJcbiAgICAgIC8vICAgYmVuZWZpdGlhcnksXHJcbiAgICAgIC8vICAgbWluQWRhVmFsLFxyXG4gICAgICAvLyApKTtcclxuICAgIFxyXG4gICAgICBjb25zb2xlLmxvZyhcIldlIGF0dGF0Y2hlZCBldmVyeXRoaW5nIVwiKVxyXG5cclxuICAgICAgLy8gUmVhZCBpbiB0aGUgbmV0d29yayBwYXJhbWV0ZXIgZmlsZVxyXG4gICAgICBjb25zdCBuZXR3b3JrUGFyYW1zSnNvbiA9IGF3YWl0IGdldE5ldHdvcmtQYXJhbXMobmV0d29yayk7XHJcbiAgICAgIGNvbnN0IG5ldHdvcmtQYXJhbXMgPSBuZXcgTmV0d29ya1BhcmFtcyhuZXR3b3JrUGFyYW1zSnNvbik7XHJcblxyXG4gICAgICAvLyBTZW5kIGFueSBjaGFuZ2UgYmFjayB0byB0aGUgYnV5ZXJcclxuICAgICAgYXdhaXQgdHguZmluYWxpemUobmV0d29ya1BhcmFtcywgYmVuZWZpdGlhcnksIHV0eG9zWzFdKTtcclxuXHJcbiAgICAgIC8vIFNpZ24gdGhlIHVuc2lnbmVkIHR4IHRvIGdldCB0aGUgd2l0bmVzc1xyXG4gICAgICBjb25zdCBzaWduYXR1cmVzID0gYXdhaXQgY2lwMzBXYWxsZXRBUEkuc2lnblR4KHR4KTtcclxuICAgICAgdHguYWRkU2lnbmF0dXJlcyhzaWduYXR1cmVzKTtcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKFwic2lnbmVkXCIpO1xyXG4gICAgICAvLyBTdWJtaXQgdGhlIHNpZ25lZCB0eFxyXG4gICAgICBjb25zdCB0eEhhc2ggPSBhd2FpdCBjaXAzMFdhbGxldEFQSS5zdWJtaXRUeCh0eCk7XHJcblxyXG4gICAgICBzZXRUeCh7IHR4SWQ6IHR4SGFzaC5oZXggfSk7XHJcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XHJcblxyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICB0aHJvdyBjb25zb2xlLmVycm9yKFwic3VibWl0IHR4IGZhaWxlZFwiLCBlcnIpO1xyXG4gICAgfVxyXG4gIH1cclxuICAgIFxyXG4gIGFzeW5jIGZ1bmN0aW9uIGZldGNoVXR4b3Moc2NyaXB0QWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxUeElucHV0W10+IHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXCJodHRwOi8vbG9jYWxob3N0OjMwMDEvYXBpL2dldFV0eG9zXCIsIHtcclxuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcclxuICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxyXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHNjcmlwdEFkZHJlc3MgfSksXHJcbiAgICB9KTtcclxuICBcclxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7IC8vIFJhdyBKU09OIGFycmF5IGZyb20gYmFja2VuZFxyXG4gIFxyXG4gICAgLy8gYENvbnZlcnQgSlNPTiBiYWNrIHRvIFR4SW5wdXQgb2JqZWN0c1xyXG4gICAgY29uc3QgZmlsdGVyZWRVdHhvcyA9IGRhdGEubWFwKCh1dHhvOiBhbnkpID0+IFR4SW5wdXQuZnJvbUZ1bGxDYm9yKHV0eG8pKTtcclxuXHJcbiAgICByZXR1cm4gZmlsdGVyZWRVdHhvcztcclxuICB9XHJcbiAgIl0sIm5hbWVzIjpbIk5ldHdvcmtQYXJhbXMiLCJWYWx1ZSIsIlR4T3V0cHV0IiwiVHgiLCJUeElucHV0IiwiQ2lwMzBXYWxsZXQiLCJEYXR1bSIsIkFzc2V0cyIsIldhbGxldEhlbHBlciIsIk1pbnRpbmdQb2xpY3lIYXNoIiwiQXNzZXRDbGFzcyIsIkFkZHJlc3MiLCJuZXR3b3JrIiwiZ2V0TmV0d29ya1BhcmFtcyIsIkdhbWVSZXdhcmQiLCJvcHRpbWl6ZSIsImdldFRva2VuQW1vdW50RnJvbVV0eG9zIiwidXR4b3MiLCJhc3NldENsYXNzIiwidG90YWxBbW91bnQiLCJCaWdJbnQiLCJmb3JFYWNoIiwidXR4byIsInRva2VucyIsInZhbHVlIiwiYXNzZXRzIiwiZ2V0VG9rZW5zIiwibWludGluZ1BvbGljeUhhc2giLCJ0b2tlbk5hbWUiLCJhbW91bnQiLCJjYWxjdWxhdGVSZXdhcmQiLCJyZW1haW5pbmdTdXBwbHkiLCJ0b3RhbFN1cHBseSIsImJhc2VSZXdhcmQiLCJoYWx2aW5nVGhyZXNob2xkIiwiaGFsdmluZ1N0ZXBzIiwiTWF0aCIsImZsb29yIiwicmV3YXJkIiwicGlja1V0eG9zIiwidGFyZ2V0QW1vdW50Iiwic2VsZWN0ZWQiLCJ1c2VkSW5kaWNlcyIsIlNldCIsInJhbmRvbUluZGV4IiwicmFuZG9tIiwibGVuZ3RoIiwiaGFzIiwiYWRkIiwic2VsZWN0ZWRVdHhvIiwicHVzaCIsImNhbGN1bGF0ZVJld2FyZEluVGltZSIsIlRpbWVCZWdpbkNvbnRyYWN0IiwiSEFMVklOR19QRVJJT0QiLCJNQVhfSEFMVklOR1MiLCJCQVNFX1JFV0FSRCIsIlRpbWVOb3ciLCJEYXRlIiwibm93IiwidGltZUVsYXBzZWQiLCJtaW4iLCJlZmZlY3RpdmVIYWx2aW5ncyIsImNvbnNvbGUiLCJsb2ciLCJjYWxjdWxhdGVDb3VudGRvd24iLCJDWUNMRV9EVVJBVElPTiIsIm9mZnNldEluTXMiLCJlbGFwc2VkVGltZSIsImVsYXBzZWRUaW1lSW5TZWNvbmRzIiwicG9zaXRpb25JbkN5Y2xlIiwicGlja1JhbmRvbVR4SW5wdXRXaXRoU3VmZmljaWVudFZhbHVlIiwidHhJbnB1dHMiLCJkeW5hbWljUmV3YXJkIiwiZWxpZ2libGVUeElucHV0cyIsImZpbHRlciIsInR4SW5wdXQiLCJvdXRwdXQiLCJ0b2tlbkFtb3VudCIsIkVycm9yIiwic2VsZWN0ZWRUeElucHV0IiwicmVtYWluaW5nVXR4b3MiLCJjbGFpbVRva2VucyIsIndhbGxldEFQSSIsInNldElzTG9hZGluZyIsInNldFR4IiwiY2lwMzBXYWxsZXRBUEkiLCJ3YWxsZXRIZWxwZXIiLCJuZXR3b3JrUGFyYW1zSnNvbiIsIm5ldHdvcmtQYXJhbXMiLCJwb2xpY3lJZCIsIm5hbWUiLCJCdWZmZXIiLCJmcm9tIiwidG9TdHJpbmciLCJtcGgiLCJmcm9tSGV4IiwidG9rZW5WYWwiLCJiZW5lZml0aWFyeSIsImNoYW5nZUFkZHJlc3MiLCJnYW1lUmV3YXJkIiwiY29tcGlsZWRQcm9ncmFtIiwiY29tcGlsZSIsInNjcmlwdEFkZHJlc3MiLCJmcm9tSGFzaGVzIiwidmFsaWRhdG9ySGFzaCIsInRvQmVjaDMyIiwiZGlyIiwiZGVwdGgiLCJmaWx0ZXJlZFV0eG9zIiwiZmV0Y2hVdHhvcyIsIkNMQUlNX1dJTkRPVyIsIlVUQyIsImdldFRpbWUiLCJ3aW5kb3ciLCJvbmVycm9yIiwidGVzdFZhbHVlQmVuZWZpdGlhcnkiLCJzb3J0ZWRVdHhvcyIsImVsZW1lbnQiLCJhbW91bnRUb1NlbmRCYWNrIiwiZmlyc3RQYXJ0VG9TZW5kQmFjayIsInNlY29uZFBhcnRUb1NlbmRCYWNrIiwidmFsdWVDb250cmFjdDEiLCJ2YWx1ZUNvbnRyYWN0MiIsImdhbWVEYXR1bSIsInR5cGVzIiwicHViS2V5SGFzaCIsInJlZGVlbWJlciIsIlJlZGVlbWVyIiwiQ2xhaW0iLCJfdG9VcGxjRGF0YSIsInR4IiwiYWRkSW5wdXRzIiwiYXR0YWNoU2NyaXB0IiwidXNlckNsYWltT3V0cHV0IiwidW5kZWZpbmVkIiwiYWRkT3V0cHV0IiwidG90YWxBZGFJbklucHV0cyIsImxvdmVsYWNlIiwiYWRhUGVyU2NyaXB0T3V0cHV0Iiwic2NyaXB0VXR4bzEiLCJpbmxpbmUiLCJzY3JpcHRVdHhvMiIsImZpbmFsaXplIiwic2lnbmF0dXJlcyIsInNpZ25UeCIsImFkZFNpZ25hdHVyZXMiLCJ0eEhhc2giLCJzdWJtaXRUeCIsInR4SWQiLCJoZXgiLCJlcnIiLCJlcnJvciIsInNlbmQiLCJtaW5BZGEiLCJtaW5BZGFWYWwiLCJ0ZXN0VmFsdWVTY3JpcHQiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiZGF0YSIsImpzb24iLCJtYXAiLCJmcm9tRnVsbENib3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./public/walletActions.ts\n"));

/***/ })

});