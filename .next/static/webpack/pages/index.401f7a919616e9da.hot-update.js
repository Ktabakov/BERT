"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./public/useFlappyBirdGame.ts":
/*!*************************************!*\
  !*** ./public/useFlappyBirdGame.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFlappyBirdGame: function() { return /* binding */ useFlappyBirdGame; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n// src/hooks/useFlappyBirdGame.ts\n\n// Constants\nconst GRAVITY = 0.7;\nconst FLAP = -11;\nconst PIPE_WIDTH = 90;\nconst PIPE_SPACING = 230;\nconst BIRD_WIDTH = 50;\nconst BIRD_HEIGHT = 50;\nconst COIN_SIZE = 100;\n// How long between pipe spawns (in milliseconds)\nconst PIPE_SPAWN_INTERVAL = 1000;\n// Horizontal speed (pixels per \"60fps\" frame)\nconst HORIZONTAL_SPEED = 4;\n// Rotation speed of coin (complete flip from scale 1 to 0 to 1). 1 = full cycle.\nconst ROTATION_SPEED = 0.01;\n// A small constant representing the \"ideal frame\" for scaling calculations (about 60fps).\nconst IDEAL_FRAME = 16.67; // ms\n/**\r\n * Custom Hook: useFlappyBirdGame\r\n * Handles Flappy Bird game logic, including:\r\n * - Canvas setup\r\n * - Bird movement / flapping\r\n * - Pipe & coin spawning\r\n * - Score tracking\r\n * - Mobile/desktop input handling\r\n */ function useFlappyBirdGame(canvasRef, isPaused, autoStart) {\n    // -----------------------------\n    // 1. TOP-LEVEL HOOKS & REFS\n    // -----------------------------\n    // React State\n    const [highScore, setHighScore] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [currentScore, setCurrentScore] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    // Game Refs\n    const requestIdRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const birdYRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const birdVelocityRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const pipesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const coinsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const gameOverRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const gameStartedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // Coin rotation & pipe spawn timer\n    const coinRotationRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const pipeSpawnTimerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // Timestamp for time-based movement\n    const lastTimeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // Bird animation frames\n    const birdImagesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const pipeTopRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const pipeBottomRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const backgroundRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const coinImageRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // Current Bird Frame\n    const currentBirdFrameRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // For debouncing taps on mobile\n    const lastTapRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const DEBOUNCE_TIME = 300; // ms\n    // -------------------------------------------\n    // 2. IMAGE PRELOAD (only on client)\n    // -------------------------------------------\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (false) {} // Ensure this runs only on client\n        const birdUp = new Image();\n        birdUp.src = \"/assets/redbird-upflap.png\";\n        const birdMid = new Image();\n        birdMid.src = \"/assets/redbird-midflap.png\";\n        const birdDown = new Image();\n        birdDown.src = \"/assets/redbird-downflap.png\";\n        birdImagesRef.current = [\n            birdUp,\n            birdMid,\n            birdDown\n        ];\n        const pipeTop = new Image();\n        pipeTop.src = \"/assets/TopTiny.png\";\n        pipeTopRef.current = pipeTop;\n        const pipeBottom = new Image();\n        pipeBottom.src = \"/assets/BottomTiny.png\";\n        pipeBottomRef.current = pipeBottom;\n        const background = new Image();\n        background.src = \"/assets/background-day.png\";\n        backgroundRef.current = background;\n        const coinImage = new Image();\n        coinImage.src = \"/assets/CoinTiny.png\";\n        coinImageRef.current = coinImage;\n    }, []);\n    // -------------------------------------------\n    // 3. LOAD HIGH SCORE ON HOOK INIT\n    // -------------------------------------------\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (true) {\n            const storedHighScore = localStorage.getItem(\"highScore\");\n            if (storedHighScore) {\n                setHighScore(parseInt(storedHighScore, 10));\n            }\n        }\n    }, []);\n    // -------------------------------------------\n    // 4. MAIN useEffect: SETUP & TEARDOWN\n    // -------------------------------------------\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        // Utility: Ensure an image is fully loaded\n        const loadImage = (img)=>{\n            return new Promise((resolve, reject)=>{\n                if (img.complete) {\n                    resolve();\n                } else {\n                    img.onload = ()=>resolve();\n                    img.onerror = ()=>reject(new Error(\"Failed to load \".concat(img.src)));\n                }\n            });\n        };\n        // Load images, then initialize\n        const loadAssets = async ()=>{\n            try {\n                await Promise.all([\n                    ...birdImagesRef.current.map((img)=>loadImage(img)),\n                    pipeTopRef.current ? loadImage(pipeTopRef.current) : Promise.resolve(),\n                    pipeBottomRef.current ? loadImage(pipeBottomRef.current) : Promise.resolve(),\n                    backgroundRef.current ? loadImage(backgroundRef.current) : Promise.resolve(),\n                    coinImageRef.current ? loadImage(coinImageRef.current) : Promise.resolve()\n                ]);\n                initializeGame();\n            } catch (err) {\n                console.error(\"Error loading assets:\", err);\n            }\n        };\n        loadAssets();\n        // ---------------------------\n        // 4A: INITIALIZE / RESET GAME\n        // ---------------------------\n        function initializeGame() {\n            if (!canvasRef.current || !ctx) return;\n            canvasRef.current.width = 360;\n            canvasRef.current.height = 640;\n            drawStartScreen(ctx, canvasRef.current);\n        }\n        function resetGame() {\n            if (!canvasRef.current) return;\n            const { height } = canvasRef.current;\n            birdYRef.current = height / 3;\n            birdVelocityRef.current = 0;\n            pipesRef.current = [];\n            coinsRef.current = [];\n            setCurrentScore(0);\n            gameOverRef.current = false;\n            gameStartedRef.current = false;\n            coinRotationRef.current = 0;\n            pipeSpawnTimerRef.current = 0;\n            currentBirdFrameRef.current = 0;\n        }\n        // ---------------------------\n        // 4B: INPUT HANDLING WITH POINTER EVENTS\n        // ---------------------------\n        // Use pointer events to unify touch and mouse interactions\n        function handlePointerDown() {\n            flap();\n        }\n        canvas.addEventListener(\"pointerdown\", handlePointerDown);\n        // Desktop keyboard input\n        function handleKeyDown(e) {\n            if (e.key === \" \") {\n                flap();\n            }\n        }\n        window.addEventListener(\"keydown\", handleKeyDown);\n        // Handle resizing\n        function handleResize() {\n            if (!canvasRef.current) return;\n            canvasRef.current.width = 360;\n            canvasRef.current.height = 640;\n            if (!gameStartedRef.current && !gameOverRef.current && ctx) {\n                drawStartScreen(ctx, canvasRef.current);\n            }\n        }\n        window.addEventListener(\"resize\", handleResize);\n        // Start game\n        function startGame() {\n            resetGame();\n            gameStartedRef.current = true;\n            lastTimeRef.current = performance.now(); // reset our time-based reference\n            requestIdRef.current = requestAnimationFrame(animate);\n        }\n        // Flap function\n        function flap() {\n            const now = Date.now();\n            if (now - lastTapRef.current < DEBOUNCE_TIME) {\n                return; // Ignore if within debounce time\n            }\n            lastTapRef.current = now;\n            if (!gameStartedRef.current && !gameOverRef.current) {\n                startGame();\n            } else if (gameOverRef.current) {\n                startGame();\n            } else {\n                birdVelocityRef.current = FLAP;\n                flapAnimation();\n            }\n        }\n        // Quick flap animation\n        function flapAnimation() {\n            currentBirdFrameRef.current = 1;\n            setTimeout(()=>{\n                currentBirdFrameRef.current = 2;\n                setTimeout(()=>{\n                    currentBirdFrameRef.current = 0;\n                }, 170);\n            }, 170);\n        }\n        // ---------------------------------------\n        // 4C: GAME LOOP (ANIMATE)\n        // ---------------------------------------\n        function animate(currentTime) {\n            if (!gameStartedRef.current) {\n                // If game hasn't started, just schedule the next frame\n                requestIdRef.current = requestAnimationFrame(animate);\n                return;\n            }\n            if (isPaused) {\n                // If paused, just schedule the next frame\n                requestIdRef.current = requestAnimationFrame(animate);\n                return;\n            }\n            if (!canvasRef.current) return;\n            const context = canvasRef.current.getContext(\"2d\");\n            if (!context) return;\n            const now = currentTime !== null && currentTime !== void 0 ? currentTime : performance.now();\n            const deltaTime = now - lastTimeRef.current;\n            lastTimeRef.current = now;\n            updateGameState(canvasRef.current, deltaTime);\n            draw(context, canvasRef.current);\n            if (!gameOverRef.current) {\n                requestIdRef.current = requestAnimationFrame(animate);\n            } else {\n                drawGameOverScreen(context, canvasRef.current);\n            }\n        }\n        function updateGameState(canvas, deltaTime) {\n            const scale = deltaTime / IDEAL_FRAME;\n            // Gravity\n            birdVelocityRef.current += GRAVITY * scale;\n            birdYRef.current += birdVelocityRef.current * scale;\n            // Pipe spawn\n            pipeSpawnTimerRef.current += deltaTime;\n            if (pipeSpawnTimerRef.current >= PIPE_SPAWN_INTERVAL) {\n                pipeSpawnTimerRef.current -= PIPE_SPAWN_INTERVAL;\n                createPipe(canvas);\n            }\n            // Move pipes & coins\n            movePipesAndCoins(scale);\n            // Rotate coin\n            coinRotationRef.current += ROTATION_SPEED * scale;\n            if (coinRotationRef.current >= 1) {\n                coinRotationRef.current = 0;\n            }\n            // Collisions\n            if (checkCollisions(canvas)) {\n                gameOverRef.current = true;\n                return;\n            }\n            // Coin collection\n            checkCoinCollection();\n            // Score\n            updateScore();\n        }\n        // ---------------------------------------\n        // 4D: DRAW FUNCTIONS\n        // ---------------------------------------\n        function draw(ctx, canvas) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawBackground(ctx, canvas);\n            drawBird(ctx);\n            drawPipes(ctx);\n            drawCoins(ctx);\n        }\n        function drawStartScreen(ctx, canvas) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawBackground(ctx, canvas);\n            ctx.font = \"bold 30px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.fillStyle = \"#ffffff\";\n            ctx.shadowColor = \"black\";\n            ctx.textBaseline = \"middle\";\n            ctx.fillText(\"Tap or Press Space to Start\", canvas.width / 2, canvas.height / 2);\n        }\n        function drawGameOverScreen(ctx, canvas) {\n            ctx.fillStyle = \"#ffcc00\";\n            ctx.font = \"bold 50px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"middle\";\n            ctx.shadowColor = \"black\";\n            ctx.shadowBlur = 10;\n            ctx.fillText(\"Game Over!\", canvas.width / 2, canvas.height / 2 - 40);\n            ctx.fillStyle = \"#ffffff\";\n            ctx.font = \"bold 30px Arial\";\n            ctx.fillText(\"Tap or Press Space to Restart\", canvas.width / 2, canvas.height / 2 + 20);\n        }\n        function drawBackground(ctx, canvas) {\n            if (backgroundRef.current && backgroundRef.current.complete) {\n                ctx.drawImage(backgroundRef.current, 0, 0, canvas.width, canvas.height);\n            }\n        }\n        function drawBird(ctx) {\n            const currentImage = birdImagesRef.current[currentBirdFrameRef.current];\n            if (currentImage && currentImage.complete) {\n                ctx.drawImage(currentImage, 100, birdYRef.current, BIRD_WIDTH, BIRD_HEIGHT);\n            }\n        }\n        function drawPipes(ctx) {\n            pipesRef.current.forEach((pipe)=>{\n                if (pipeTopRef.current && pipeTopRef.current.complete) {\n                    ctx.drawImage(pipeTopRef.current, pipe.x, 0, PIPE_WIDTH, pipe.topHeight);\n                }\n                if (pipeBottomRef.current && pipeBottomRef.current.complete) {\n                    ctx.drawImage(pipeBottomRef.current, pipe.x, pipe.bottomY, PIPE_WIDTH, pipe.bottomHeight);\n                }\n            });\n        }\n        function drawCoins(ctx) {\n            if (!coinImageRef.current || !coinImageRef.current.complete) return;\n            const scaleX = Math.abs(Math.cos(coinRotationRef.current * Math.PI * 2));\n            const halfSize = COIN_SIZE / 2;\n            coinsRef.current.forEach((coin)=>{\n                if (!coin.collected) {\n                    if (!coinImageRef.current) return;\n                    ctx.save();\n                    ctx.translate(coin.x + halfSize, coin.y + halfSize);\n                    ctx.scale(scaleX, 1);\n                    ctx.drawImage(coinImageRef.current, -halfSize, -halfSize, COIN_SIZE, COIN_SIZE);\n                    ctx.restore();\n                }\n            });\n        }\n        // ---------------------------------------\n        // 4F: GAME LOGIC FUNCTIONS\n        // ---------------------------------------\n        function createPipe(canvas) {\n            const pipeHeight = Math.random() * (canvas.height - PIPE_SPACING - 100) + 50;\n            const bottomY = pipeHeight + PIPE_SPACING;\n            pipesRef.current.push({\n                x: canvas.width,\n                topHeight: pipeHeight,\n                bottomY,\n                bottomHeight: canvas.height - bottomY,\n                scored: false\n            });\n            // 50% chance for coin\n            if (Math.random() > 0.5) {\n                coinsRef.current.push({\n                    x: canvas.width + PIPE_WIDTH / 2 - COIN_SIZE / 2,\n                    y: pipeHeight + PIPE_SPACING / 2 - COIN_SIZE / 2,\n                    width: COIN_SIZE,\n                    height: COIN_SIZE,\n                    collected: false\n                });\n            }\n        }\n        function movePipesAndCoins(scale) {\n            // Move pipes to the left\n            pipesRef.current.forEach((pipe)=>{\n                pipe.x -= HORIZONTAL_SPEED * scale;\n            });\n            pipesRef.current = pipesRef.current.filter((p)=>p.x + PIPE_WIDTH > 0);\n            // Move coins\n            coinsRef.current.forEach((coin)=>{\n                coin.x -= HORIZONTAL_SPEED * scale;\n            });\n            coinsRef.current = coinsRef.current.filter((c)=>c.x + c.width > 0 && !c.collected);\n        }\n        function checkCollisions(canvas) {\n            // Bird vs boundaries\n            if (birdYRef.current < 0 || birdYRef.current + BIRD_HEIGHT > canvas.height) {\n                return true;\n            }\n            const birdLeft = 100;\n            const birdRight = birdLeft + BIRD_WIDTH;\n            const birdTop = birdYRef.current;\n            const birdBottom = birdYRef.current + BIRD_HEIGHT;\n            // Bird vs pipes\n            for (const pipe of pipesRef.current){\n                const withinPipeX = birdRight > pipe.x && birdLeft < pipe.x + PIPE_WIDTH;\n                const withinPipeY = birdTop < pipe.topHeight || birdBottom > pipe.bottomY;\n                if (withinPipeX && withinPipeY) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function checkCoinCollection() {\n            const birdLeft = 100;\n            const birdRight = birdLeft + BIRD_WIDTH;\n            const birdTop = birdYRef.current;\n            const birdBottom = birdYRef.current + BIRD_HEIGHT;\n            coinsRef.current.forEach((coin)=>{\n                if (!coin.collected) {\n                    const coinLeft = coin.x;\n                    const coinRight = coin.x + coin.width;\n                    const coinTop = coin.y;\n                    const coinBottom = coin.y + coin.height;\n                    if (birdRight > coinLeft && birdLeft < coinRight && birdBottom > coinTop && birdTop < coinBottom) {\n                        // Collect coin\n                        coin.collected = true;\n                        setCurrentScore((prevScore)=>{\n                            const newScore = prevScore + 5;\n                            setHighScore((prevHighScore)=>Math.max(prevHighScore, newScore));\n                            return newScore;\n                        });\n                    }\n                }\n            });\n        }\n        function updateScore() {\n            pipesRef.current.forEach((pipe)=>{\n                // Score +1 for passing each pipe, only once\n                if (!pipe.scored && pipe.x + PIPE_WIDTH < 100) {\n                    pipe.scored = true;\n                    setCurrentScore((prevScore)=>{\n                        const newScore = prevScore + 1;\n                        setHighScore((prevHighScore)=>{\n                            const updatedHighScore = Math.max(prevHighScore, newScore);\n                            if (true) {\n                                localStorage.setItem(\"highScore\", updatedHighScore.toString());\n                            }\n                            return updatedHighScore;\n                        });\n                        return newScore;\n                    });\n                }\n            });\n        }\n        // ---------------------------------------\n        // 4G: CLEANUP FUNCTION\n        // ---------------------------------------\n        return ()=>{\n            window.removeEventListener(\"keydown\", handleKeyDown);\n            window.removeEventListener(\"resize\", handleResize);\n            canvas.removeEventListener(\"pointerdown\", handlePointerDown);\n            if (requestIdRef.current) {\n                cancelAnimationFrame(requestIdRef.current);\n            }\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        canvasRef,\n        isPaused,\n        autoStart\n    ]);\n    // ---------------------------------------\n    // 5. FLAP ANIMATION FUNCTION\n    // ---------------------------------------\n    const flapAnimation = ()=>{\n        currentBirdFrameRef.current = 1;\n        setTimeout(()=>{\n            currentBirdFrameRef.current = 2;\n            setTimeout(()=>{\n                currentBirdFrameRef.current = 0;\n            }, 170);\n        }, 170);\n    };\n    // ---------------------------------------\n    // 6. FLAP FUNCTION\n    // ---------------------------------------\n    const flap = ()=>{\n        const now = Date.now();\n        if (now - lastTapRef.current < DEBOUNCE_TIME) {\n            return; // Ignore if within debounce time\n        }\n        lastTapRef.current = now;\n        if (!gameStartedRef.current && !gameOverRef.current) {\n            startGame();\n        } else if (gameOverRef.current) {\n            startGame();\n        } else {\n            birdVelocityRef.current = FLAP;\n            flapAnimation();\n        }\n    };\n    // ---------------------------------------\n    // 7. START GAME FUNCTION\n    // ---------------------------------------\n    const startGame = ()=>{\n        resetGame();\n        gameStartedRef.current = true;\n        lastTimeRef.current = performance.now(); // reset our time-based reference\n        requestIdRef.current = requestAnimationFrame(animate);\n    };\n    function resetGame() {\n        if (!canvasRef.current) return;\n        const { width, height } = canvasRef.current;\n        birdYRef.current = height / 3;\n        birdVelocityRef.current = 0;\n        pipesRef.current = [];\n        coinsRef.current = [];\n        setCurrentScore(0);\n        gameOverRef.current = false;\n        gameStartedRef.current = false;\n        coinRotationRef.current = 0;\n        pipeSpawnTimerRef.current = 0;\n        currentBirdFrameRef.current = 0;\n    }\n    // ---------------------------------------\n    // 8. GAME LOOP FUNCTION\n    // ---------------------------------------\n    const animate = (currentTime)=>{\n        if (!gameStartedRef.current) {\n            // If game hasn't started, just schedule the next frame\n            requestIdRef.current = requestAnimationFrame(animate);\n            return;\n        }\n        if (isPaused) {\n            // If paused, just schedule the next frame\n            requestIdRef.current = requestAnimationFrame(animate);\n            return;\n        }\n        if (!canvasRef.current) return;\n        const context = canvasRef.current.getContext(\"2d\");\n        if (!context) return;\n        const now = currentTime !== null && currentTime !== void 0 ? currentTime : performance.now();\n        const deltaTime = now - lastTimeRef.current;\n        lastTimeRef.current = now;\n        updateGameState(canvasRef.current, deltaTime);\n        draw(context, canvasRef.current);\n        if (!gameOverRef.current) {\n            requestIdRef.current = requestAnimationFrame(animate);\n        } else {\n            drawGameOverScreen(context, canvasRef.current);\n        }\n    };\n    // ---------------------------------------\n    // 9. GAME LOOP AND DRAW FUNCTIONS\n    // ---------------------------------------\n    const updateGameState = (canvas, deltaTime)=>{\n        const scale = deltaTime / IDEAL_FRAME;\n        // Gravity\n        birdVelocityRef.current += GRAVITY * scale;\n        birdYRef.current += birdVelocityRef.current * scale;\n        // Pipe spawn\n        pipeSpawnTimerRef.current += deltaTime;\n        if (pipeSpawnTimerRef.current >= PIPE_SPAWN_INTERVAL) {\n            pipeSpawnTimerRef.current -= PIPE_SPAWN_INTERVAL;\n            createPipe(canvas);\n        }\n        // Move pipes & coins\n        movePipesAndCoins(scale);\n        // Rotate coin\n        coinRotationRef.current += ROTATION_SPEED * scale;\n        if (coinRotationRef.current >= 1) {\n            coinRotationRef.current = 0;\n        }\n        // Collisions\n        if (checkCollisions(canvas)) {\n            gameOverRef.current = true;\n            return;\n        }\n        // Coin collection\n        checkCoinCollection();\n        // Score\n        updateScore();\n    };\n    const draw = (ctx, canvas)=>{\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        drawBackground(ctx, canvas);\n        drawBird(ctx);\n        drawPipes(ctx);\n        drawCoins(ctx);\n    };\n    const drawStartScreen = (ctx, canvas)=>{\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        drawBackground(ctx, canvas);\n        ctx.font = \"bold 30px Arial\";\n        ctx.textAlign = \"center\";\n        ctx.fillStyle = \"#ffffff\";\n        ctx.shadowColor = \"black\";\n        ctx.textBaseline = \"middle\";\n        ctx.fillText(\"Tap or Press Space to Start\", canvas.width / 2, canvas.height / 2);\n    };\n    const drawGameOverScreen = (ctx, canvas)=>{\n        ctx.fillStyle = \"#ffcc00\";\n        ctx.font = \"bold 50px Arial\";\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        ctx.shadowColor = \"black\";\n        ctx.shadowBlur = 10;\n        ctx.fillText(\"Game Over!\", canvas.width / 2, canvas.height / 2 - 40);\n        ctx.fillStyle = \"#ffffff\";\n        ctx.font = \"bold 30px Arial\";\n        ctx.fillText(\"Tap or Press Space to Restart\", canvas.width / 2, canvas.height / 2 + 20);\n    };\n    const drawBackground = (ctx, canvas)=>{\n        if (backgroundRef.current && backgroundRef.current.complete) {\n            ctx.drawImage(backgroundRef.current, 0, 0, canvas.width, canvas.height);\n        }\n    };\n    const drawBird = (ctx)=>{\n        const currentImage = birdImagesRef.current[currentBirdFrameRef.current];\n        if (currentImage && currentImage.complete) {\n            ctx.drawImage(currentImage, 100, birdYRef.current, BIRD_WIDTH, BIRD_HEIGHT);\n        }\n    };\n    const drawPipes = (ctx)=>{\n        pipesRef.current.forEach((pipe)=>{\n            if (pipeTopRef.current && pipeTopRef.current.complete) {\n                ctx.drawImage(pipeTopRef.current, pipe.x, 0, PIPE_WIDTH, pipe.topHeight);\n            }\n            if (pipeBottomRef.current && pipeBottomRef.current.complete) {\n                ctx.drawImage(pipeBottomRef.current, pipe.x, pipe.bottomY, PIPE_WIDTH, pipe.bottomHeight);\n            }\n        });\n    };\n    const drawCoins = (ctx)=>{\n        if (!coinImageRef.current || !coinImageRef.current.complete) return;\n        const scaleX = Math.abs(Math.cos(coinRotationRef.current * Math.PI * 2));\n        const halfSize = COIN_SIZE / 2;\n        coinsRef.current.forEach((coin)=>{\n            if (!coin.collected) {\n                if (!coinImageRef.current) return;\n                ctx.save();\n                ctx.translate(coin.x + halfSize, coin.y + halfSize);\n                ctx.scale(scaleX, 1);\n                ctx.drawImage(coinImageRef.current, -halfSize, -halfSize, COIN_SIZE, COIN_SIZE);\n                ctx.restore();\n            }\n        });\n    };\n    // ---------------------------------------\n    // 10. GAME LOGIC FUNCTIONS\n    // ---------------------------------------\n    const createPipe = (canvas)=>{\n        const pipeHeight = Math.random() * (canvas.height - PIPE_SPACING - 100) + 50;\n        const bottomY = pipeHeight + PIPE_SPACING;\n        pipesRef.current.push({\n            x: canvas.width,\n            topHeight: pipeHeight,\n            bottomY,\n            bottomHeight: canvas.height - bottomY,\n            scored: false\n        });\n        // 50% chance for coin\n        if (Math.random() > 0.5) {\n            coinsRef.current.push({\n                x: canvas.width + PIPE_WIDTH / 2 - COIN_SIZE / 2,\n                y: pipeHeight + PIPE_SPACING / 2 - COIN_SIZE / 2,\n                width: COIN_SIZE,\n                height: COIN_SIZE,\n                collected: false\n            });\n        }\n    };\n    const movePipesAndCoins = (scale)=>{\n        // Move pipes to the left\n        pipesRef.current.forEach((pipe)=>{\n            pipe.x -= HORIZONTAL_SPEED * scale;\n        });\n        pipesRef.current = pipesRef.current.filter((p)=>p.x + PIPE_WIDTH > 0);\n        // Move coins\n        coinsRef.current.forEach((coin)=>{\n            coin.x -= HORIZONTAL_SPEED * scale;\n        });\n        coinsRef.current = coinsRef.current.filter((c)=>c.x + c.width > 0 && !c.collected);\n    };\n    const checkCollisions = (canvas)=>{\n        // Bird vs boundaries\n        if (birdYRef.current < 0 || birdYRef.current + BIRD_HEIGHT > canvas.height) {\n            return true;\n        }\n        const birdLeft = 100;\n        const birdRight = birdLeft + BIRD_WIDTH;\n        const birdTop = birdYRef.current;\n        const birdBottom = birdYRef.current + BIRD_HEIGHT;\n        // Bird vs pipes\n        for (const pipe of pipesRef.current){\n            const withinPipeX = birdRight > pipe.x && birdLeft < pipe.x + PIPE_WIDTH;\n            const withinPipeY = birdTop < pipe.topHeight || birdBottom > pipe.bottomY;\n            if (withinPipeX && withinPipeY) {\n                return true;\n            }\n        }\n        return false;\n    };\n    const checkCoinCollection = ()=>{\n        const birdLeft = 100;\n        const birdRight = birdLeft + BIRD_WIDTH;\n        const birdTop = birdYRef.current;\n        const birdBottom = birdYRef.current + BIRD_HEIGHT;\n        coinsRef.current.forEach((coin)=>{\n            if (!coin.collected) {\n                const coinLeft = coin.x;\n                const coinRight = coin.x + coin.width;\n                const coinTop = coin.y;\n                const coinBottom = coin.y + coin.height;\n                if (birdRight > coinLeft && birdLeft < coinRight && birdBottom > coinTop && birdTop < coinBottom) {\n                    // Collect coin\n                    coin.collected = true;\n                    setCurrentScore((prevScore)=>{\n                        const newScore = prevScore + 5;\n                        setHighScore((prevHighScore)=>Math.max(prevHighScore, newScore));\n                        return newScore;\n                    });\n                }\n            }\n        });\n    };\n    const updateScore = ()=>{\n        pipesRef.current.forEach((pipe)=>{\n            // Score +1 for passing each pipe, only once\n            if (!pipe.scored && pipe.x + PIPE_WIDTH < 100) {\n                pipe.scored = true;\n                setCurrentScore((prevScore)=>{\n                    const newScore = prevScore + 1;\n                    setHighScore((prevHighScore)=>{\n                        const updatedHighScore = Math.max(prevHighScore, newScore);\n                        if (true) {\n                            localStorage.setItem(\"highScore\", updatedHighScore.toString());\n                        }\n                        return updatedHighScore;\n                    });\n                    return newScore;\n                });\n            }\n        });\n    };\n    // ---------------------------------------\n    // 11. CLEANUP FUNCTION\n    // ---------------------------------------\n    // Already handled in useEffect return function\n    // ---------------------------------------\n    // 12. RETURN GAME STATS AND INPUT Handler\n    // ---------------------------------------\n    return {\n        highScore,\n        currentScore,\n        handleUserInput: flap\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q1hKLGFBQWFLLFdBQ2JOLFVBQVVPLFlBQ1Y7b0JBQ0EsZUFBZTtvQkFDZnRCLEtBQUtDLFNBQVMsR0FBRztvQkFDakIvRyxnQkFBZ0IsQ0FBQ3FJO3dCQUNmLE1BQU1DLFdBQVdELFlBQVk7d0JBQzdCdkksYUFBYSxDQUFDeUksZ0JBQWtCOUIsS0FBSytCLEdBQUcsQ0FBQ0QsZUFBZUQ7d0JBQ3hELE9BQU9BO29CQUNUO2dCQUNGO1lBQ0Y7UUFDRjtJQUNGO0lBRUEsTUFBTW5ELGNBQWM7UUFDbEIvRSxTQUFTb0IsT0FBTyxDQUFDMEUsT0FBTyxDQUFDLENBQUNDO1lBQ3hCLDRDQUE0QztZQUM1QyxJQUFJLENBQUNBLEtBQUtvQixNQUFNLElBQUlwQixLQUFLQyxDQUFDLEdBQUdwSCxhQUFhLEtBQUs7Z0JBQzdDbUgsS0FBS29CLE1BQU0sR0FBRztnQkFDZHZILGdCQUFnQixDQUFDcUk7b0JBQ2YsTUFBTUMsV0FBV0QsWUFBWTtvQkFDN0J2SSxhQUFhLENBQUN5STt3QkFDWixNQUFNRSxtQkFBbUJoQyxLQUFLK0IsR0FBRyxDQUFDRCxlQUFlRDt3QkFDakQsSUFBSSxJQUE2QixFQUFFOzRCQUNqQ3hHLGFBQWE0RyxPQUFPLENBQUMsYUFBYUQsaUJBQWlCRSxRQUFRO3dCQUM3RDt3QkFDQSxPQUFPRjtvQkFDVDtvQkFDQSxPQUFPSDtnQkFDVDtZQUNGO1FBQ0Y7SUFDRjtJQUVBLDBDQUEwQztJQUMxQyx1QkFBdUI7SUFDdkIsMENBQTBDO0lBQzFDLCtDQUErQztJQUUvQywwQ0FBMEM7SUFDMUMsMENBQTBDO0lBQzFDLDBDQUEwQztJQUMxQyxPQUFPO1FBQ0x6STtRQUNBRTtRQUNBK0ksaUJBQWlCckY7SUFDbkI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wdWJsaWMvdXNlRmxhcHB5QmlyZEdhbWUudHM/NWM3OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaG9va3MvdXNlRmxhcHB5QmlyZEdhbWUudHNcclxuXHJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xyXG5cclxuLy8gVHlwZXMgZm9yIGdhbWUgb2JqZWN0c1xyXG5pbnRlcmZhY2UgUGlwZSB7XHJcbiAgeDogbnVtYmVyO1xyXG4gIHRvcEhlaWdodDogbnVtYmVyO1xyXG4gIGJvdHRvbVk6IG51bWJlcjtcclxuICBib3R0b21IZWlnaHQ6IG51bWJlcjtcclxuICBzY29yZWQ6IGJvb2xlYW47XHJcbn1cclxuXHJcbmludGVyZmFjZSBDb2luIHtcclxuICB4OiBudW1iZXI7XHJcbiAgeTogbnVtYmVyO1xyXG4gIHdpZHRoOiBudW1iZXI7XHJcbiAgaGVpZ2h0OiBudW1iZXI7XHJcbiAgY29sbGVjdGVkOiBib29sZWFuO1xyXG59XHJcblxyXG4vLyBDb25zdGFudHNcclxuY29uc3QgR1JBVklUWSA9IDAuNztcclxuY29uc3QgRkxBUCA9IC0xMTtcclxuY29uc3QgUElQRV9XSURUSCA9IDkwO1xyXG5jb25zdCBQSVBFX1NQQUNJTkcgPSAyMzA7XHJcbmNvbnN0IEJJUkRfV0lEVEggPSA1MDtcclxuY29uc3QgQklSRF9IRUlHSFQgPSA1MDtcclxuY29uc3QgQ09JTl9TSVpFID0gMTAwO1xyXG5cclxuLy8gSG93IGxvbmcgYmV0d2VlbiBwaXBlIHNwYXducyAoaW4gbWlsbGlzZWNvbmRzKVxyXG5jb25zdCBQSVBFX1NQQVdOX0lOVEVSVkFMID0gMTAwMDtcclxuXHJcbi8vIEhvcml6b250YWwgc3BlZWQgKHBpeGVscyBwZXIgXCI2MGZwc1wiIGZyYW1lKVxyXG5jb25zdCBIT1JJWk9OVEFMX1NQRUVEID0gNDtcclxuXHJcbi8vIFJvdGF0aW9uIHNwZWVkIG9mIGNvaW4gKGNvbXBsZXRlIGZsaXAgZnJvbSBzY2FsZSAxIHRvIDAgdG8gMSkuIDEgPSBmdWxsIGN5Y2xlLlxyXG5jb25zdCBST1RBVElPTl9TUEVFRCA9IDAuMDE7XHJcblxyXG4vLyBBIHNtYWxsIGNvbnN0YW50IHJlcHJlc2VudGluZyB0aGUgXCJpZGVhbCBmcmFtZVwiIGZvciBzY2FsaW5nIGNhbGN1bGF0aW9ucyAoYWJvdXQgNjBmcHMpLlxyXG5jb25zdCBJREVBTF9GUkFNRSA9IDE2LjY3OyAvLyBtc1xyXG5cclxuLyoqXHJcbiAqIEN1c3RvbSBIb29rOiB1c2VGbGFwcHlCaXJkR2FtZVxyXG4gKiBIYW5kbGVzIEZsYXBweSBCaXJkIGdhbWUgbG9naWMsIGluY2x1ZGluZzpcclxuICogLSBDYW52YXMgc2V0dXBcclxuICogLSBCaXJkIG1vdmVtZW50IC8gZmxhcHBpbmdcclxuICogLSBQaXBlICYgY29pbiBzcGF3bmluZ1xyXG4gKiAtIFNjb3JlIHRyYWNraW5nXHJcbiAqIC0gTW9iaWxlL2Rlc2t0b3AgaW5wdXQgaGFuZGxpbmdcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VGbGFwcHlCaXJkR2FtZShcclxuICBjYW52YXNSZWY6IFJlYWN0LlJlZk9iamVjdDxIVE1MQ2FudmFzRWxlbWVudD4sXHJcbiAgaXNQYXVzZWQ6IGJvb2xlYW4sXHJcbiAgYXV0b1N0YXJ0OiBib29sZWFuXHJcbikge1xyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gMS4gVE9QLUxFVkVMIEhPT0tTICYgUkVGU1xyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIFJlYWN0IFN0YXRlXHJcbiAgY29uc3QgW2hpZ2hTY29yZSwgc2V0SGlnaFNjb3JlXSA9IHVzZVN0YXRlKDApO1xyXG4gIGNvbnN0IFtjdXJyZW50U2NvcmUsIHNldEN1cnJlbnRTY29yZV0gPSB1c2VTdGF0ZSgwKTtcclxuXHJcbiAgLy8gR2FtZSBSZWZzXHJcbiAgY29uc3QgcmVxdWVzdElkUmVmID0gdXNlUmVmPG51bWJlciB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IGJpcmRZUmVmID0gdXNlUmVmPG51bWJlcj4oMCk7XHJcbiAgY29uc3QgYmlyZFZlbG9jaXR5UmVmID0gdXNlUmVmPG51bWJlcj4oMCk7XHJcbiAgY29uc3QgcGlwZXNSZWYgPSB1c2VSZWY8UGlwZVtdPihbXSk7XHJcbiAgY29uc3QgY29pbnNSZWYgPSB1c2VSZWY8Q29pbltdPihbXSk7XHJcbiAgY29uc3QgZ2FtZU92ZXJSZWYgPSB1c2VSZWY8Ym9vbGVhbj4oZmFsc2UpO1xyXG4gIGNvbnN0IGdhbWVTdGFydGVkUmVmID0gdXNlUmVmPGJvb2xlYW4+KGZhbHNlKTtcclxuXHJcbiAgLy8gQ29pbiByb3RhdGlvbiAmIHBpcGUgc3Bhd24gdGltZXJcclxuICBjb25zdCBjb2luUm90YXRpb25SZWYgPSB1c2VSZWY8bnVtYmVyPigwKTtcclxuICBjb25zdCBwaXBlU3Bhd25UaW1lclJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xyXG5cclxuICAvLyBUaW1lc3RhbXAgZm9yIHRpbWUtYmFzZWQgbW92ZW1lbnRcclxuICBjb25zdCBsYXN0VGltZVJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xyXG5cclxuICAvLyBCaXJkIGFuaW1hdGlvbiBmcmFtZXNcclxuICBjb25zdCBiaXJkSW1hZ2VzUmVmID0gdXNlUmVmPEhUTUxJbWFnZUVsZW1lbnRbXT4oW10pO1xyXG4gIGNvbnN0IHBpcGVUb3BSZWYgPSB1c2VSZWY8SFRNTEltYWdlRWxlbWVudCB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IHBpcGVCb3R0b21SZWYgPSB1c2VSZWY8SFRNTEltYWdlRWxlbWVudCB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IGJhY2tncm91bmRSZWYgPSB1c2VSZWY8SFRNTEltYWdlRWxlbWVudCB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IGNvaW5JbWFnZVJlZiA9IHVzZVJlZjxIVE1MSW1hZ2VFbGVtZW50IHwgbnVsbD4obnVsbCk7XHJcblxyXG4gIC8vIEN1cnJlbnQgQmlyZCBGcmFtZVxyXG4gIGNvbnN0IGN1cnJlbnRCaXJkRnJhbWVSZWYgPSB1c2VSZWY8bnVtYmVyPigwKTtcclxuXHJcbiAgLy8gRm9yIGRlYm91bmNpbmcgdGFwcyBvbiBtb2JpbGVcclxuICBjb25zdCBsYXN0VGFwUmVmID0gdXNlUmVmPG51bWJlcj4oMCk7XHJcbiAgY29uc3QgREVCT1VOQ0VfVElNRSA9IDMwMDsgLy8gbXNcclxuXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIDIuIElNQUdFIFBSRUxPQUQgKG9ubHkgb24gY2xpZW50KVxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybjsgLy8gRW5zdXJlIHRoaXMgcnVucyBvbmx5IG9uIGNsaWVudFxyXG5cclxuICAgIGNvbnN0IGJpcmRVcCA9IG5ldyBJbWFnZSgpO1xyXG4gICAgYmlyZFVwLnNyYyA9IFwiL2Fzc2V0cy9yZWRiaXJkLXVwZmxhcC5wbmdcIjtcclxuXHJcbiAgICBjb25zdCBiaXJkTWlkID0gbmV3IEltYWdlKCk7XHJcbiAgICBiaXJkTWlkLnNyYyA9IFwiL2Fzc2V0cy9yZWRiaXJkLW1pZGZsYXAucG5nXCI7XHJcblxyXG4gICAgY29uc3QgYmlyZERvd24gPSBuZXcgSW1hZ2UoKTtcclxuICAgIGJpcmREb3duLnNyYyA9IFwiL2Fzc2V0cy9yZWRiaXJkLWRvd25mbGFwLnBuZ1wiO1xyXG5cclxuICAgIGJpcmRJbWFnZXNSZWYuY3VycmVudCA9IFtiaXJkVXAsIGJpcmRNaWQsIGJpcmREb3duXTtcclxuXHJcbiAgICBjb25zdCBwaXBlVG9wID0gbmV3IEltYWdlKCk7XHJcbiAgICBwaXBlVG9wLnNyYyA9IFwiL2Fzc2V0cy9Ub3BUaW55LnBuZ1wiO1xyXG4gICAgcGlwZVRvcFJlZi5jdXJyZW50ID0gcGlwZVRvcDtcclxuXHJcbiAgICBjb25zdCBwaXBlQm90dG9tID0gbmV3IEltYWdlKCk7XHJcbiAgICBwaXBlQm90dG9tLnNyYyA9IFwiL2Fzc2V0cy9Cb3R0b21UaW55LnBuZ1wiO1xyXG4gICAgcGlwZUJvdHRvbVJlZi5jdXJyZW50ID0gcGlwZUJvdHRvbTtcclxuXHJcbiAgICBjb25zdCBiYWNrZ3JvdW5kID0gbmV3IEltYWdlKCk7XHJcbiAgICBiYWNrZ3JvdW5kLnNyYyA9IFwiL2Fzc2V0cy9iYWNrZ3JvdW5kLWRheS5wbmdcIjtcclxuICAgIGJhY2tncm91bmRSZWYuY3VycmVudCA9IGJhY2tncm91bmQ7XHJcblxyXG4gICAgY29uc3QgY29pbkltYWdlID0gbmV3IEltYWdlKCk7XHJcbiAgICBjb2luSW1hZ2Uuc3JjID0gXCIvYXNzZXRzL0NvaW5UaW55LnBuZ1wiO1xyXG4gICAgY29pbkltYWdlUmVmLmN1cnJlbnQgPSBjb2luSW1hZ2U7XHJcbiAgfSwgW10pO1xyXG5cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gMy4gTE9BRCBISUdIIFNDT1JFIE9OIEhPT0sgSU5JVFxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgY29uc3Qgc3RvcmVkSGlnaFNjb3JlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJoaWdoU2NvcmVcIik7XHJcbiAgICAgIGlmIChzdG9yZWRIaWdoU2NvcmUpIHtcclxuICAgICAgICBzZXRIaWdoU2NvcmUocGFyc2VJbnQoc3RvcmVkSGlnaFNjb3JlLCAxMCkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSwgW10pO1xyXG5cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gNC4gTUFJTiB1c2VFZmZlY3Q6IFNFVFVQICYgVEVBUkRPV05cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xyXG4gICAgaWYgKCFjYW52YXMpIHJldHVybjtcclxuXHJcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgaWYgKCFjdHgpIHJldHVybjtcclxuXHJcbiAgICAvLyBVdGlsaXR5OiBFbnN1cmUgYW4gaW1hZ2UgaXMgZnVsbHkgbG9hZGVkXHJcbiAgICBjb25zdCBsb2FkSW1hZ2UgPSAoaW1nOiBIVE1MSW1hZ2VFbGVtZW50KTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgaWYgKGltZy5jb21wbGV0ZSkge1xyXG4gICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpbWcub25sb2FkID0gKCkgPT4gcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgaW1nLm9uZXJyb3IgPSAoKSA9PiByZWplY3QobmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCAke2ltZy5zcmN9YCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIExvYWQgaW1hZ2VzLCB0aGVuIGluaXRpYWxpemVcclxuICAgIGNvbnN0IGxvYWRBc3NldHMgPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgLi4uYmlyZEltYWdlc1JlZi5jdXJyZW50Lm1hcCgoaW1nKSA9PiBsb2FkSW1hZ2UoaW1nKSksXHJcbiAgICAgICAgICBwaXBlVG9wUmVmLmN1cnJlbnQgPyBsb2FkSW1hZ2UocGlwZVRvcFJlZi5jdXJyZW50KSA6IFByb21pc2UucmVzb2x2ZSgpLFxyXG4gICAgICAgICAgcGlwZUJvdHRvbVJlZi5jdXJyZW50ID8gbG9hZEltYWdlKHBpcGVCb3R0b21SZWYuY3VycmVudCkgOiBQcm9taXNlLnJlc29sdmUoKSxcclxuICAgICAgICAgIGJhY2tncm91bmRSZWYuY3VycmVudCA/IGxvYWRJbWFnZShiYWNrZ3JvdW5kUmVmLmN1cnJlbnQpIDogUHJvbWlzZS5yZXNvbHZlKCksXHJcbiAgICAgICAgICBjb2luSW1hZ2VSZWYuY3VycmVudCA/IGxvYWRJbWFnZShjb2luSW1hZ2VSZWYuY3VycmVudCkgOiBQcm9taXNlLnJlc29sdmUoKSxcclxuICAgICAgICBdKTtcclxuICAgICAgICBpbml0aWFsaXplR2FtZSgpO1xyXG4gICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgbG9hZGluZyBhc3NldHM6XCIsIGVycik7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICBsb2FkQXNzZXRzKCk7XHJcblxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyA0QTogSU5JVElBTElaRSAvIFJFU0VUIEdBTUVcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgZnVuY3Rpb24gaW5pdGlhbGl6ZUdhbWUoKSB7XHJcbiAgICAgIGlmICghY2FudmFzUmVmLmN1cnJlbnQgfHwgIWN0eCkgcmV0dXJuO1xyXG4gICAgICBjYW52YXNSZWYuY3VycmVudC53aWR0aCA9IDM2MDtcclxuICAgICAgY2FudmFzUmVmLmN1cnJlbnQuaGVpZ2h0ID0gNjQwO1xyXG4gICAgICBkcmF3U3RhcnRTY3JlZW4oY3R4LCBjYW52YXNSZWYuY3VycmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVzZXRHYW1lKCkge1xyXG4gICAgICBpZiAoIWNhbnZhc1JlZi5jdXJyZW50KSByZXR1cm47XHJcbiAgICAgIGNvbnN0IHsgaGVpZ2h0IH0gPSBjYW52YXNSZWYuY3VycmVudDtcclxuICAgICAgYmlyZFlSZWYuY3VycmVudCA9IGhlaWdodCAvIDM7XHJcbiAgICAgIGJpcmRWZWxvY2l0eVJlZi5jdXJyZW50ID0gMDtcclxuICAgICAgcGlwZXNSZWYuY3VycmVudCA9IFtdO1xyXG4gICAgICBjb2luc1JlZi5jdXJyZW50ID0gW107XHJcbiAgICAgIHNldEN1cnJlbnRTY29yZSgwKTtcclxuICAgICAgZ2FtZU92ZXJSZWYuY3VycmVudCA9IGZhbHNlO1xyXG4gICAgICBnYW1lU3RhcnRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICAgIGNvaW5Sb3RhdGlvblJlZi5jdXJyZW50ID0gMDtcclxuICAgICAgcGlwZVNwYXduVGltZXJSZWYuY3VycmVudCA9IDA7XHJcbiAgICAgIGN1cnJlbnRCaXJkRnJhbWVSZWYuY3VycmVudCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyA0QjogSU5QVVQgSEFORExJTkcgV0lUSCBQT0lOVEVSIEVWRU5UU1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBVc2UgcG9pbnRlciBldmVudHMgdG8gdW5pZnkgdG91Y2ggYW5kIG1vdXNlIGludGVyYWN0aW9uc1xyXG4gICAgZnVuY3Rpb24gaGFuZGxlUG9pbnRlckRvd24oKSB7XHJcbiAgICAgIGZsYXAoKTtcclxuICAgIH1cclxuXHJcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIGhhbmRsZVBvaW50ZXJEb3duKTtcclxuXHJcbiAgICAvLyBEZXNrdG9wIGtleWJvYXJkIGlucHV0XHJcbiAgICBmdW5jdGlvbiBoYW5kbGVLZXlEb3duKGU6IEtleWJvYXJkRXZlbnQpIHtcclxuICAgICAgaWYgKGUua2V5ID09PSBcIiBcIikge1xyXG4gICAgICAgIGZsYXAoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGhhbmRsZUtleURvd24pO1xyXG5cclxuICAgIC8vIEhhbmRsZSByZXNpemluZ1xyXG4gICAgZnVuY3Rpb24gaGFuZGxlUmVzaXplKCkge1xyXG4gICAgICBpZiAoIWNhbnZhc1JlZi5jdXJyZW50KSByZXR1cm47XHJcbiAgICAgIGNhbnZhc1JlZi5jdXJyZW50LndpZHRoID0gMzYwO1xyXG4gICAgICBjYW52YXNSZWYuY3VycmVudC5oZWlnaHQgPSA2NDA7XHJcbiAgICAgIGlmICghZ2FtZVN0YXJ0ZWRSZWYuY3VycmVudCAmJiAhZ2FtZU92ZXJSZWYuY3VycmVudCAmJiBjdHgpIHtcclxuICAgICAgICBkcmF3U3RhcnRTY3JlZW4oY3R4LCBjYW52YXNSZWYuY3VycmVudCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGhhbmRsZVJlc2l6ZSk7XHJcblxyXG4gICAgLy8gU3RhcnQgZ2FtZVxyXG4gICAgZnVuY3Rpb24gc3RhcnRHYW1lKCkge1xyXG4gICAgICByZXNldEdhbWUoKTtcclxuICAgICAgZ2FtZVN0YXJ0ZWRSZWYuY3VycmVudCA9IHRydWU7XHJcbiAgICAgIGxhc3RUaW1lUmVmLmN1cnJlbnQgPSBwZXJmb3JtYW5jZS5ub3coKTsgLy8gcmVzZXQgb3VyIHRpbWUtYmFzZWQgcmVmZXJlbmNlXHJcbiAgICAgIHJlcXVlc3RJZFJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEZsYXAgZnVuY3Rpb25cclxuICAgIGZ1bmN0aW9uIGZsYXAoKSB7XHJcbiAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICAgIGlmIChub3cgLSBsYXN0VGFwUmVmLmN1cnJlbnQgPCBERUJPVU5DRV9USU1FKSB7XHJcbiAgICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgaWYgd2l0aGluIGRlYm91bmNlIHRpbWVcclxuICAgICAgfVxyXG4gICAgICBsYXN0VGFwUmVmLmN1cnJlbnQgPSBub3c7XHJcblxyXG4gICAgICBpZiAoIWdhbWVTdGFydGVkUmVmLmN1cnJlbnQgJiYgIWdhbWVPdmVyUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBzdGFydEdhbWUoKTtcclxuICAgICAgfSBlbHNlIGlmIChnYW1lT3ZlclJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgc3RhcnRHYW1lKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYmlyZFZlbG9jaXR5UmVmLmN1cnJlbnQgPSBGTEFQO1xyXG4gICAgICAgIGZsYXBBbmltYXRpb24oKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFF1aWNrIGZsYXAgYW5pbWF0aW9uXHJcbiAgICBmdW5jdGlvbiBmbGFwQW5pbWF0aW9uKCkge1xyXG4gICAgICBjdXJyZW50QmlyZEZyYW1lUmVmLmN1cnJlbnQgPSAxO1xyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBjdXJyZW50QmlyZEZyYW1lUmVmLmN1cnJlbnQgPSAyO1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgY3VycmVudEJpcmRGcmFtZVJlZi5jdXJyZW50ID0gMDtcclxuICAgICAgICB9LCAxNzApO1xyXG4gICAgICB9LCAxNzApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gNEM6IEdBTUUgTE9PUCAoQU5JTUFURSlcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgZnVuY3Rpb24gYW5pbWF0ZShjdXJyZW50VGltZT86IG51bWJlcikge1xyXG4gICAgICBpZiAoIWdhbWVTdGFydGVkUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAvLyBJZiBnYW1lIGhhc24ndCBzdGFydGVkLCBqdXN0IHNjaGVkdWxlIHRoZSBuZXh0IGZyYW1lXHJcbiAgICAgICAgcmVxdWVzdElkUmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpc1BhdXNlZCkge1xyXG4gICAgICAgIC8vIElmIHBhdXNlZCwganVzdCBzY2hlZHVsZSB0aGUgbmV4dCBmcmFtZVxyXG4gICAgICAgIHJlcXVlc3RJZFJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIWNhbnZhc1JlZi5jdXJyZW50KSByZXR1cm47XHJcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXNSZWYuY3VycmVudC5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICAgIGlmICghY29udGV4dCkgcmV0dXJuO1xyXG5cclxuICAgICAgY29uc3Qgbm93ID0gY3VycmVudFRpbWUgPz8gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgIGNvbnN0IGRlbHRhVGltZSA9IG5vdyAtIGxhc3RUaW1lUmVmLmN1cnJlbnQ7XHJcbiAgICAgIGxhc3RUaW1lUmVmLmN1cnJlbnQgPSBub3c7XHJcblxyXG4gICAgICB1cGRhdGVHYW1lU3RhdGUoY2FudmFzUmVmLmN1cnJlbnQsIGRlbHRhVGltZSk7XHJcbiAgICAgIGRyYXcoY29udGV4dCwgY2FudmFzUmVmLmN1cnJlbnQpO1xyXG5cclxuICAgICAgaWYgKCFnYW1lT3ZlclJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgcmVxdWVzdElkUmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZHJhd0dhbWVPdmVyU2NyZWVuKGNvbnRleHQsIGNhbnZhc1JlZi5jdXJyZW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZUdhbWVTdGF0ZShjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCBkZWx0YVRpbWU6IG51bWJlcikge1xyXG4gICAgICBjb25zdCBzY2FsZSA9IGRlbHRhVGltZSAvIElERUFMX0ZSQU1FO1xyXG5cclxuICAgICAgLy8gR3Jhdml0eVxyXG4gICAgICBiaXJkVmVsb2NpdHlSZWYuY3VycmVudCArPSBHUkFWSVRZICogc2NhbGU7XHJcbiAgICAgIGJpcmRZUmVmLmN1cnJlbnQgKz0gYmlyZFZlbG9jaXR5UmVmLmN1cnJlbnQgKiBzY2FsZTtcclxuXHJcbiAgICAgIC8vIFBpcGUgc3Bhd25cclxuICAgICAgcGlwZVNwYXduVGltZXJSZWYuY3VycmVudCArPSBkZWx0YVRpbWU7XHJcbiAgICAgIGlmIChwaXBlU3Bhd25UaW1lclJlZi5jdXJyZW50ID49IFBJUEVfU1BBV05fSU5URVJWQUwpIHtcclxuICAgICAgICBwaXBlU3Bhd25UaW1lclJlZi5jdXJyZW50IC09IFBJUEVfU1BBV05fSU5URVJWQUw7XHJcbiAgICAgICAgY3JlYXRlUGlwZShjYW52YXMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBNb3ZlIHBpcGVzICYgY29pbnNcclxuICAgICAgbW92ZVBpcGVzQW5kQ29pbnMoc2NhbGUpO1xyXG5cclxuICAgICAgLy8gUm90YXRlIGNvaW5cclxuICAgICAgY29pblJvdGF0aW9uUmVmLmN1cnJlbnQgKz0gUk9UQVRJT05fU1BFRUQgKiBzY2FsZTtcclxuICAgICAgaWYgKGNvaW5Sb3RhdGlvblJlZi5jdXJyZW50ID49IDEpIHtcclxuICAgICAgICBjb2luUm90YXRpb25SZWYuY3VycmVudCA9IDA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENvbGxpc2lvbnNcclxuICAgICAgaWYgKGNoZWNrQ29sbGlzaW9ucyhjYW52YXMpKSB7XHJcbiAgICAgICAgZ2FtZU92ZXJSZWYuY3VycmVudCA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDb2luIGNvbGxlY3Rpb25cclxuICAgICAgY2hlY2tDb2luQ29sbGVjdGlvbigpO1xyXG5cclxuICAgICAgLy8gU2NvcmVcclxuICAgICAgdXBkYXRlU2NvcmUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIDREOiBEUkFXIEZVTkNUSU9OU1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBmdW5jdGlvbiBkcmF3KGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICAgICAgZHJhd0JhY2tncm91bmQoY3R4LCBjYW52YXMpO1xyXG4gICAgICBkcmF3QmlyZChjdHgpO1xyXG4gICAgICBkcmF3UGlwZXMoY3R4KTtcclxuICAgICAgZHJhd0NvaW5zKGN0eCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd1N0YXJ0U2NyZWVuKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICAgICAgZHJhd0JhY2tncm91bmQoY3R4LCBjYW52YXMpO1xyXG4gIFxyXG4gICAgICBjdHguZm9udCA9IFwiYm9sZCAzMHB4IEFyaWFsXCI7XHJcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xyXG4gICAgICBjdHguZmlsbFN0eWxlID0gXCIjZmZmZmZmXCI7XHJcbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFwiYmxhY2tcIjtcclxuICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XHJcbiAgXHJcbiAgICAgIGN0eC5maWxsVGV4dChcIlRhcCBvciBQcmVzcyBTcGFjZSB0byBTdGFydFwiLCBjYW52YXMud2lkdGggLyAyLCBjYW52YXMuaGVpZ2h0IC8gMik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd0dhbWVPdmVyU2NyZWVuKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNmZmNjMDBcIjtcclxuICAgICAgY3R4LmZvbnQgPSBcImJvbGQgNTBweCBBcmlhbFwiO1xyXG4gICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcclxuICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XHJcbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFwiYmxhY2tcIjtcclxuICAgICAgY3R4LnNoYWRvd0JsdXIgPSAxMDtcclxuXHJcbiAgICAgIGN0eC5maWxsVGV4dChcIkdhbWUgT3ZlciFcIiwgY2FudmFzLndpZHRoIC8gMiwgY2FudmFzLmhlaWdodCAvIDIgLSA0MCk7XHJcblxyXG4gICAgICBjdHguZmlsbFN0eWxlID0gXCIjZmZmZmZmXCI7XHJcbiAgICAgIGN0eC5mb250ID0gXCJib2xkIDMwcHggQXJpYWxcIjtcclxuICAgICAgY3R4LmZpbGxUZXh0KFxyXG4gICAgICAgIFwiVGFwIG9yIFByZXNzIFNwYWNlIHRvIFJlc3RhcnRcIixcclxuICAgICAgICBjYW52YXMud2lkdGggLyAyLFxyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgLyAyICsgMjBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3QmFja2dyb3VuZChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkge1xyXG4gICAgICBpZiAoYmFja2dyb3VuZFJlZi5jdXJyZW50ICYmIGJhY2tncm91bmRSZWYuY3VycmVudC5jb21wbGV0ZSkge1xyXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoYmFja2dyb3VuZFJlZi5jdXJyZW50LCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd0JpcmQoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcclxuICAgICAgY29uc3QgY3VycmVudEltYWdlID0gYmlyZEltYWdlc1JlZi5jdXJyZW50W2N1cnJlbnRCaXJkRnJhbWVSZWYuY3VycmVudF07XHJcbiAgICAgIGlmIChjdXJyZW50SW1hZ2UgJiYgY3VycmVudEltYWdlLmNvbXBsZXRlKSB7XHJcbiAgICAgICAgY3R4LmRyYXdJbWFnZShjdXJyZW50SW1hZ2UsIDEwMCwgYmlyZFlSZWYuY3VycmVudCwgQklSRF9XSURUSCwgQklSRF9IRUlHSFQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd1BpcGVzKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XHJcbiAgICAgIHBpcGVzUmVmLmN1cnJlbnQuZm9yRWFjaCgocGlwZSkgPT4ge1xyXG4gICAgICAgIGlmIChwaXBlVG9wUmVmLmN1cnJlbnQgJiYgcGlwZVRvcFJlZi5jdXJyZW50LmNvbXBsZXRlKSB7XHJcbiAgICAgICAgICBjdHguZHJhd0ltYWdlKHBpcGVUb3BSZWYuY3VycmVudCwgcGlwZS54LCAwLCBQSVBFX1dJRFRILCBwaXBlLnRvcEhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwaXBlQm90dG9tUmVmLmN1cnJlbnQgJiYgcGlwZUJvdHRvbVJlZi5jdXJyZW50LmNvbXBsZXRlKSB7XHJcbiAgICAgICAgICBjdHguZHJhd0ltYWdlKHBpcGVCb3R0b21SZWYuY3VycmVudCwgcGlwZS54LCBwaXBlLmJvdHRvbVksIFBJUEVfV0lEVEgsIHBpcGUuYm90dG9tSGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdDb2lucyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xyXG4gICAgICBpZiAoIWNvaW5JbWFnZVJlZi5jdXJyZW50IHx8ICFjb2luSW1hZ2VSZWYuY3VycmVudC5jb21wbGV0ZSkgcmV0dXJuO1xyXG4gICAgICBjb25zdCBzY2FsZVggPSBNYXRoLmFicyhNYXRoLmNvcyhjb2luUm90YXRpb25SZWYuY3VycmVudCAqIE1hdGguUEkgKiAyKSk7XHJcbiAgICAgIGNvbnN0IGhhbGZTaXplID0gQ09JTl9TSVpFIC8gMjtcclxuICAgICAgY29pbnNSZWYuY3VycmVudC5mb3JFYWNoKChjb2luKSA9PiB7XHJcbiAgICAgICAgaWYgKCFjb2luLmNvbGxlY3RlZCkge1xyXG4gICAgICAgICAgaWYgKCFjb2luSW1hZ2VSZWYuY3VycmVudClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgIGN0eC50cmFuc2xhdGUoY29pbi54ICsgaGFsZlNpemUsIGNvaW4ueSArIGhhbGZTaXplKTtcclxuICAgICAgICAgIGN0eC5zY2FsZShzY2FsZVgsIDEpO1xyXG4gICAgICAgICAgY3R4LmRyYXdJbWFnZShjb2luSW1hZ2VSZWYuY3VycmVudCwgLWhhbGZTaXplLCAtaGFsZlNpemUsIENPSU5fU0laRSwgQ09JTl9TSVpFKTtcclxuICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIDRGOiBHQU1FIExPR0lDIEZVTkNUSU9OU1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVQaXBlKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcclxuICAgICAgY29uc3QgcGlwZUhlaWdodCA9IE1hdGgucmFuZG9tKCkgKiAoY2FudmFzLmhlaWdodCAtIFBJUEVfU1BBQ0lORyAtIDEwMCkgKyA1MDtcclxuICAgICAgY29uc3QgYm90dG9tWSA9IHBpcGVIZWlnaHQgKyBQSVBFX1NQQUNJTkc7XHJcbiAgICAgIHBpcGVzUmVmLmN1cnJlbnQucHVzaCh7XHJcbiAgICAgICAgeDogY2FudmFzLndpZHRoLFxyXG4gICAgICAgIHRvcEhlaWdodDogcGlwZUhlaWdodCxcclxuICAgICAgICBib3R0b21ZLFxyXG4gICAgICAgIGJvdHRvbUhlaWdodDogY2FudmFzLmhlaWdodCAtIGJvdHRvbVksXHJcbiAgICAgICAgc2NvcmVkOiBmYWxzZSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyA1MCUgY2hhbmNlIGZvciBjb2luXHJcbiAgICAgIGlmIChNYXRoLnJhbmRvbSgpID4gMC41KSB7XHJcbiAgICAgICAgY29pbnNSZWYuY3VycmVudC5wdXNoKHtcclxuICAgICAgICAgIHg6IGNhbnZhcy53aWR0aCArIFBJUEVfV0lEVEggLyAyIC0gQ09JTl9TSVpFIC8gMixcclxuICAgICAgICAgIHk6IHBpcGVIZWlnaHQgKyBQSVBFX1NQQUNJTkcgLyAyIC0gQ09JTl9TSVpFIC8gMixcclxuICAgICAgICAgIHdpZHRoOiBDT0lOX1NJWkUsXHJcbiAgICAgICAgICBoZWlnaHQ6IENPSU5fU0laRSxcclxuICAgICAgICAgIGNvbGxlY3RlZDogZmFsc2UsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtb3ZlUGlwZXNBbmRDb2lucyhzY2FsZTogbnVtYmVyKSB7XHJcbiAgICAgIC8vIE1vdmUgcGlwZXMgdG8gdGhlIGxlZnRcclxuICAgICAgcGlwZXNSZWYuY3VycmVudC5mb3JFYWNoKChwaXBlKSA9PiB7XHJcbiAgICAgICAgcGlwZS54IC09IEhPUklaT05UQUxfU1BFRUQgKiBzY2FsZTtcclxuICAgICAgfSk7XHJcbiAgICAgIHBpcGVzUmVmLmN1cnJlbnQgPSBwaXBlc1JlZi5jdXJyZW50LmZpbHRlcigocCkgPT4gcC54ICsgUElQRV9XSURUSCA+IDApO1xyXG5cclxuICAgICAgLy8gTW92ZSBjb2luc1xyXG4gICAgICBjb2luc1JlZi5jdXJyZW50LmZvckVhY2goKGNvaW4pID0+IHtcclxuICAgICAgICBjb2luLnggLT0gSE9SSVpPTlRBTF9TUEVFRCAqIHNjYWxlO1xyXG4gICAgICB9KTtcclxuICAgICAgY29pbnNSZWYuY3VycmVudCA9IGNvaW5zUmVmLmN1cnJlbnQuZmlsdGVyKFxyXG4gICAgICAgIChjKSA9PiBjLnggKyBjLndpZHRoID4gMCAmJiAhYy5jb2xsZWN0ZWRcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjaGVja0NvbGxpc2lvbnMoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCk6IGJvb2xlYW4ge1xyXG4gICAgICAvLyBCaXJkIHZzIGJvdW5kYXJpZXNcclxuICAgICAgaWYgKGJpcmRZUmVmLmN1cnJlbnQgPCAwIHx8IGJpcmRZUmVmLmN1cnJlbnQgKyBCSVJEX0hFSUdIVCA+IGNhbnZhcy5oZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgYmlyZExlZnQgPSAxMDA7XHJcbiAgICAgIGNvbnN0IGJpcmRSaWdodCA9IGJpcmRMZWZ0ICsgQklSRF9XSURUSDtcclxuICAgICAgY29uc3QgYmlyZFRvcCA9IGJpcmRZUmVmLmN1cnJlbnQ7XHJcbiAgICAgIGNvbnN0IGJpcmRCb3R0b20gPSBiaXJkWVJlZi5jdXJyZW50ICsgQklSRF9IRUlHSFQ7XHJcblxyXG4gICAgICAvLyBCaXJkIHZzIHBpcGVzXHJcbiAgICAgIGZvciAoY29uc3QgcGlwZSBvZiBwaXBlc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY29uc3Qgd2l0aGluUGlwZVggPSBiaXJkUmlnaHQgPiBwaXBlLnggJiYgYmlyZExlZnQgPCBwaXBlLnggKyBQSVBFX1dJRFRIO1xyXG4gICAgICAgIGNvbnN0IHdpdGhpblBpcGVZID0gYmlyZFRvcCA8IHBpcGUudG9wSGVpZ2h0IHx8IGJpcmRCb3R0b20gPiBwaXBlLmJvdHRvbVk7XHJcbiAgICAgICAgaWYgKHdpdGhpblBpcGVYICYmIHdpdGhpblBpcGVZKSB7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNoZWNrQ29pbkNvbGxlY3Rpb24oKSB7XHJcbiAgICAgIGNvbnN0IGJpcmRMZWZ0ID0gMTAwO1xyXG4gICAgICBjb25zdCBiaXJkUmlnaHQgPSBiaXJkTGVmdCArIEJJUkRfV0lEVEg7XHJcbiAgICAgIGNvbnN0IGJpcmRUb3AgPSBiaXJkWVJlZi5jdXJyZW50O1xyXG4gICAgICBjb25zdCBiaXJkQm90dG9tID0gYmlyZFlSZWYuY3VycmVudCArIEJJUkRfSEVJR0hUO1xyXG5cclxuICAgICAgY29pbnNSZWYuY3VycmVudC5mb3JFYWNoKChjb2luKSA9PiB7XHJcbiAgICAgICAgaWYgKCFjb2luLmNvbGxlY3RlZCkge1xyXG4gICAgICAgICAgY29uc3QgY29pbkxlZnQgPSBjb2luLng7XHJcbiAgICAgICAgICBjb25zdCBjb2luUmlnaHQgPSBjb2luLnggKyBjb2luLndpZHRoO1xyXG4gICAgICAgICAgY29uc3QgY29pblRvcCA9IGNvaW4ueTtcclxuICAgICAgICAgIGNvbnN0IGNvaW5Cb3R0b20gPSBjb2luLnkgKyBjb2luLmhlaWdodDtcclxuXHJcbiAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIGJpcmRSaWdodCA+IGNvaW5MZWZ0ICYmXHJcbiAgICAgICAgICAgIGJpcmRMZWZ0IDwgY29pblJpZ2h0ICYmXHJcbiAgICAgICAgICAgIGJpcmRCb3R0b20gPiBjb2luVG9wICYmXHJcbiAgICAgICAgICAgIGJpcmRUb3AgPCBjb2luQm90dG9tXHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgLy8gQ29sbGVjdCBjb2luXHJcbiAgICAgICAgICAgIGNvaW4uY29sbGVjdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgc2V0Q3VycmVudFNjb3JlKChwcmV2U2NvcmUpID0+IHtcclxuICAgICAgICAgICAgICBjb25zdCBuZXdTY29yZSA9IHByZXZTY29yZSArIDU7XHJcbiAgICAgICAgICAgICAgc2V0SGlnaFNjb3JlKChwcmV2SGlnaFNjb3JlKSA9PiBNYXRoLm1heChwcmV2SGlnaFNjb3JlLCBuZXdTY29yZSkpO1xyXG4gICAgICAgICAgICAgIHJldHVybiBuZXdTY29yZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVTY29yZSgpIHtcclxuICAgICAgcGlwZXNSZWYuY3VycmVudC5mb3JFYWNoKChwaXBlKSA9PiB7XHJcbiAgICAgICAgLy8gU2NvcmUgKzEgZm9yIHBhc3NpbmcgZWFjaCBwaXBlLCBvbmx5IG9uY2VcclxuICAgICAgICBpZiAoIXBpcGUuc2NvcmVkICYmIHBpcGUueCArIFBJUEVfV0lEVEggPCAxMDApIHtcclxuICAgICAgICAgIHBpcGUuc2NvcmVkID0gdHJ1ZTtcclxuICAgICAgICAgIHNldEN1cnJlbnRTY29yZSgocHJldlNjb3JlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1Njb3JlID0gcHJldlNjb3JlICsgMTtcclxuICAgICAgICAgICAgc2V0SGlnaFNjb3JlKChwcmV2SGlnaFNjb3JlKSA9PiB7XHJcbiAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZEhpZ2hTY29yZSA9IE1hdGgubWF4KHByZXZIaWdoU2NvcmUsIG5ld1Njb3JlKTtcclxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJoaWdoU2NvcmVcIiwgdXBkYXRlZEhpZ2hTY29yZS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZWRIaWdoU2NvcmU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3U2NvcmU7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gNEc6IENMRUFOVVAgRlVOQ1RJT05cclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGhhbmRsZUtleURvd24pO1xyXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBoYW5kbGVSZXNpemUpO1xyXG4gICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIGhhbmRsZVBvaW50ZXJEb3duKTtcclxuICAgICAgaWYgKHJlcXVlc3RJZFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmVxdWVzdElkUmVmLmN1cnJlbnQpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xyXG4gIH0sIFtjYW52YXNSZWYsIGlzUGF1c2VkLCBhdXRvU3RhcnRdKTtcclxuXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gNS4gRkxBUCBBTklNQVRJT04gRlVOQ1RJT05cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICBjb25zdCBmbGFwQW5pbWF0aW9uID0gKCkgPT4ge1xyXG4gICAgY3VycmVudEJpcmRGcmFtZVJlZi5jdXJyZW50ID0gMTtcclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICBjdXJyZW50QmlyZEZyYW1lUmVmLmN1cnJlbnQgPSAyO1xyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBjdXJyZW50QmlyZEZyYW1lUmVmLmN1cnJlbnQgPSAwO1xyXG4gICAgICB9LCAxNzApO1xyXG4gICAgfSwgMTcwKTtcclxuICB9O1xyXG5cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvLyA2LiBGTEFQIEZVTkNUSU9OXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgY29uc3QgZmxhcCA9ICgpID0+IHtcclxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICBpZiAobm93IC0gbGFzdFRhcFJlZi5jdXJyZW50IDwgREVCT1VOQ0VfVElNRSkge1xyXG4gICAgICByZXR1cm47IC8vIElnbm9yZSBpZiB3aXRoaW4gZGVib3VuY2UgdGltZVxyXG4gICAgfVxyXG4gICAgbGFzdFRhcFJlZi5jdXJyZW50ID0gbm93O1xyXG5cclxuICAgIGlmICghZ2FtZVN0YXJ0ZWRSZWYuY3VycmVudCAmJiAhZ2FtZU92ZXJSZWYuY3VycmVudCkge1xyXG4gICAgICBzdGFydEdhbWUoKTtcclxuICAgIH0gZWxzZSBpZiAoZ2FtZU92ZXJSZWYuY3VycmVudCkge1xyXG4gICAgICBzdGFydEdhbWUoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGJpcmRWZWxvY2l0eVJlZi5jdXJyZW50ID0gRkxBUDtcclxuICAgICAgZmxhcEFuaW1hdGlvbigpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIDcuIFNUQVJUIEdBTUUgRlVOQ1RJT05cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICBjb25zdCBzdGFydEdhbWUgPSAoKSA9PiB7XHJcbiAgICByZXNldEdhbWUoKTtcclxuICAgIGdhbWVTdGFydGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xyXG4gICAgbGFzdFRpbWVSZWYuY3VycmVudCA9IHBlcmZvcm1hbmNlLm5vdygpOyAvLyByZXNldCBvdXIgdGltZS1iYXNlZCByZWZlcmVuY2VcclxuICAgIHJlcXVlc3RJZFJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIHJlc2V0R2FtZSgpIHtcclxuICAgIGlmICghY2FudmFzUmVmLmN1cnJlbnQpIHJldHVybjtcclxuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gY2FudmFzUmVmLmN1cnJlbnQ7XHJcbiAgICBiaXJkWVJlZi5jdXJyZW50ID0gaGVpZ2h0IC8gMztcclxuICAgIGJpcmRWZWxvY2l0eVJlZi5jdXJyZW50ID0gMDtcclxuICAgIHBpcGVzUmVmLmN1cnJlbnQgPSBbXTtcclxuICAgIGNvaW5zUmVmLmN1cnJlbnQgPSBbXTtcclxuICAgIHNldEN1cnJlbnRTY29yZSgwKTtcclxuICAgIGdhbWVPdmVyUmVmLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgIGdhbWVTdGFydGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgIGNvaW5Sb3RhdGlvblJlZi5jdXJyZW50ID0gMDtcclxuICAgIHBpcGVTcGF3blRpbWVyUmVmLmN1cnJlbnQgPSAwO1xyXG4gICAgY3VycmVudEJpcmRGcmFtZVJlZi5jdXJyZW50ID0gMDtcclxuICB9XHJcblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIDguIEdBTUUgTE9PUCBGVU5DVElPTlxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIGNvbnN0IGFuaW1hdGUgPSAoY3VycmVudFRpbWU/OiBudW1iZXIpID0+IHtcclxuICAgIGlmICghZ2FtZVN0YXJ0ZWRSZWYuY3VycmVudCkge1xyXG4gICAgICAvLyBJZiBnYW1lIGhhc24ndCBzdGFydGVkLCBqdXN0IHNjaGVkdWxlIHRoZSBuZXh0IGZyYW1lXHJcbiAgICAgIHJlcXVlc3RJZFJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoaXNQYXVzZWQpIHtcclxuICAgICAgLy8gSWYgcGF1c2VkLCBqdXN0IHNjaGVkdWxlIHRoZSBuZXh0IGZyYW1lXHJcbiAgICAgIHJlcXVlc3RJZFJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoIWNhbnZhc1JlZi5jdXJyZW50KSByZXR1cm47XHJcbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzUmVmLmN1cnJlbnQuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgaWYgKCFjb250ZXh0KSByZXR1cm47XHJcblxyXG4gICAgY29uc3Qgbm93ID0gY3VycmVudFRpbWUgPz8gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICBjb25zdCBkZWx0YVRpbWUgPSBub3cgLSBsYXN0VGltZVJlZi5jdXJyZW50O1xyXG4gICAgbGFzdFRpbWVSZWYuY3VycmVudCA9IG5vdztcclxuXHJcbiAgICB1cGRhdGVHYW1lU3RhdGUoY2FudmFzUmVmLmN1cnJlbnQsIGRlbHRhVGltZSk7XHJcbiAgICBkcmF3KGNvbnRleHQsIGNhbnZhc1JlZi5jdXJyZW50KTtcclxuXHJcbiAgICBpZiAoIWdhbWVPdmVyUmVmLmN1cnJlbnQpIHtcclxuICAgICAgcmVxdWVzdElkUmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkcmF3R2FtZU92ZXJTY3JlZW4oY29udGV4dCwgY2FudmFzUmVmLmN1cnJlbnQpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIDkuIEdBTUUgTE9PUCBBTkQgRFJBVyBGVU5DVElPTlNcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICBjb25zdCB1cGRhdGVHYW1lU3RhdGUgPSAoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgZGVsdGFUaW1lOiBudW1iZXIpID0+IHtcclxuICAgIGNvbnN0IHNjYWxlID0gZGVsdGFUaW1lIC8gSURFQUxfRlJBTUU7XHJcblxyXG4gICAgLy8gR3Jhdml0eVxyXG4gICAgYmlyZFZlbG9jaXR5UmVmLmN1cnJlbnQgKz0gR1JBVklUWSAqIHNjYWxlO1xyXG4gICAgYmlyZFlSZWYuY3VycmVudCArPSBiaXJkVmVsb2NpdHlSZWYuY3VycmVudCAqIHNjYWxlO1xyXG5cclxuICAgIC8vIFBpcGUgc3Bhd25cclxuICAgIHBpcGVTcGF3blRpbWVyUmVmLmN1cnJlbnQgKz0gZGVsdGFUaW1lO1xyXG4gICAgaWYgKHBpcGVTcGF3blRpbWVyUmVmLmN1cnJlbnQgPj0gUElQRV9TUEFXTl9JTlRFUlZBTCkge1xyXG4gICAgICBwaXBlU3Bhd25UaW1lclJlZi5jdXJyZW50IC09IFBJUEVfU1BBV05fSU5URVJWQUw7XHJcbiAgICAgIGNyZWF0ZVBpcGUoY2FudmFzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBNb3ZlIHBpcGVzICYgY29pbnNcclxuICAgIG1vdmVQaXBlc0FuZENvaW5zKHNjYWxlKTtcclxuXHJcbiAgICAvLyBSb3RhdGUgY29pblxyXG4gICAgY29pblJvdGF0aW9uUmVmLmN1cnJlbnQgKz0gUk9UQVRJT05fU1BFRUQgKiBzY2FsZTtcclxuICAgIGlmIChjb2luUm90YXRpb25SZWYuY3VycmVudCA+PSAxKSB7XHJcbiAgICAgIGNvaW5Sb3RhdGlvblJlZi5jdXJyZW50ID0gMDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDb2xsaXNpb25zXHJcbiAgICBpZiAoY2hlY2tDb2xsaXNpb25zKGNhbnZhcykpIHtcclxuICAgICAgZ2FtZU92ZXJSZWYuY3VycmVudCA9IHRydWU7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDb2luIGNvbGxlY3Rpb25cclxuICAgIGNoZWNrQ29pbkNvbGxlY3Rpb24oKTtcclxuXHJcbiAgICAvLyBTY29yZVxyXG4gICAgdXBkYXRlU2NvcmUoKTtcclxuICB9O1xyXG5cclxuICBjb25zdCBkcmF3ID0gKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSA9PiB7XHJcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcbiAgICBkcmF3QmFja2dyb3VuZChjdHgsIGNhbnZhcyk7XHJcbiAgICBkcmF3QmlyZChjdHgpO1xyXG4gICAgZHJhd1BpcGVzKGN0eCk7XHJcbiAgICBkcmF3Q29pbnMoY3R4KTtcclxuICB9O1xyXG5cclxuICBjb25zdCBkcmF3U3RhcnRTY3JlZW4gPSAoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpID0+IHtcclxuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICAgIGRyYXdCYWNrZ3JvdW5kKGN0eCwgY2FudmFzKTtcclxuXHJcbiAgICBjdHguZm9udCA9IFwiYm9sZCAzMHB4IEFyaWFsXCI7XHJcbiAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcclxuICAgIGN0eC5maWxsU3R5bGUgPSBcIiNmZmZmZmZcIjtcclxuICAgIGN0eC5zaGFkb3dDb2xvciA9IFwiYmxhY2tcIjtcclxuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xyXG5cclxuICAgIGN0eC5maWxsVGV4dChcIlRhcCBvciBQcmVzcyBTcGFjZSB0byBTdGFydFwiLCBjYW52YXMud2lkdGggLyAyLCBjYW52YXMuaGVpZ2h0IC8gMik7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgZHJhd0dhbWVPdmVyU2NyZWVuID0gKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSA9PiB7XHJcbiAgICBjdHguZmlsbFN0eWxlID0gXCIjZmZjYzAwXCI7XHJcbiAgICBjdHguZm9udCA9IFwiYm9sZCA1MHB4IEFyaWFsXCI7XHJcbiAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcclxuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xyXG4gICAgY3R4LnNoYWRvd0NvbG9yID0gXCJibGFja1wiO1xyXG4gICAgY3R4LnNoYWRvd0JsdXIgPSAxMDtcclxuXHJcbiAgICBjdHguZmlsbFRleHQoXCJHYW1lIE92ZXIhXCIsIGNhbnZhcy53aWR0aCAvIDIsIGNhbnZhcy5oZWlnaHQgLyAyIC0gNDApO1xyXG5cclxuICAgIGN0eC5maWxsU3R5bGUgPSBcIiNmZmZmZmZcIjtcclxuICAgIGN0eC5mb250ID0gXCJib2xkIDMwcHggQXJpYWxcIjtcclxuICAgIGN0eC5maWxsVGV4dChcclxuICAgICAgXCJUYXAgb3IgUHJlc3MgU3BhY2UgdG8gUmVzdGFydFwiLFxyXG4gICAgICBjYW52YXMud2lkdGggLyAyLFxyXG4gICAgICBjYW52YXMuaGVpZ2h0IC8gMiArIDIwXHJcbiAgICApO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGRyYXdCYWNrZ3JvdW5kID0gKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSA9PiB7XHJcbiAgICBpZiAoYmFja2dyb3VuZFJlZi5jdXJyZW50ICYmIGJhY2tncm91bmRSZWYuY3VycmVudC5jb21wbGV0ZSkge1xyXG4gICAgICBjdHguZHJhd0ltYWdlKGJhY2tncm91bmRSZWYuY3VycmVudCwgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCBkcmF3QmlyZCA9IChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkgPT4ge1xyXG4gICAgY29uc3QgY3VycmVudEltYWdlID0gYmlyZEltYWdlc1JlZi5jdXJyZW50W2N1cnJlbnRCaXJkRnJhbWVSZWYuY3VycmVudF07XHJcbiAgICBpZiAoY3VycmVudEltYWdlICYmIGN1cnJlbnRJbWFnZS5jb21wbGV0ZSkge1xyXG4gICAgICBjdHguZHJhd0ltYWdlKGN1cnJlbnRJbWFnZSwgMTAwLCBiaXJkWVJlZi5jdXJyZW50LCBCSVJEX1dJRFRILCBCSVJEX0hFSUdIVCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgZHJhd1BpcGVzID0gKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSA9PiB7XHJcbiAgICBwaXBlc1JlZi5jdXJyZW50LmZvckVhY2goKHBpcGUpID0+IHtcclxuICAgICAgaWYgKHBpcGVUb3BSZWYuY3VycmVudCAmJiBwaXBlVG9wUmVmLmN1cnJlbnQuY29tcGxldGUpIHtcclxuICAgICAgICBjdHguZHJhd0ltYWdlKHBpcGVUb3BSZWYuY3VycmVudCwgcGlwZS54LCAwLCBQSVBFX1dJRFRILCBwaXBlLnRvcEhlaWdodCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHBpcGVCb3R0b21SZWYuY3VycmVudCAmJiBwaXBlQm90dG9tUmVmLmN1cnJlbnQuY29tcGxldGUpIHtcclxuICAgICAgICBjdHguZHJhd0ltYWdlKHBpcGVCb3R0b21SZWYuY3VycmVudCwgcGlwZS54LCBwaXBlLmJvdHRvbVksIFBJUEVfV0lEVEgsIHBpcGUuYm90dG9tSGVpZ2h0KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgZHJhd0NvaW5zID0gKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSA9PiB7XHJcbiAgICBpZiAoIWNvaW5JbWFnZVJlZi5jdXJyZW50IHx8ICFjb2luSW1hZ2VSZWYuY3VycmVudC5jb21wbGV0ZSkgcmV0dXJuO1xyXG4gICAgY29uc3Qgc2NhbGVYID0gTWF0aC5hYnMoTWF0aC5jb3MoY29pblJvdGF0aW9uUmVmLmN1cnJlbnQgKiBNYXRoLlBJICogMikpO1xyXG4gICAgY29uc3QgaGFsZlNpemUgPSBDT0lOX1NJWkUgLyAyO1xyXG4gICAgY29pbnNSZWYuY3VycmVudC5mb3JFYWNoKChjb2luKSA9PiB7XHJcbiAgICAgIGlmICghY29pbi5jb2xsZWN0ZWQpIHtcclxuICAgICAgICBpZighY29pbkltYWdlUmVmLmN1cnJlbnQpXHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICBjdHgudHJhbnNsYXRlKGNvaW4ueCArIGhhbGZTaXplLCBjb2luLnkgKyBoYWxmU2l6ZSk7XHJcbiAgICAgICAgY3R4LnNjYWxlKHNjYWxlWCwgMSk7XHJcbiAgICAgICAgY3R4LmRyYXdJbWFnZShjb2luSW1hZ2VSZWYuY3VycmVudCwgLWhhbGZTaXplLCAtaGFsZlNpemUsIENPSU5fU0laRSwgQ09JTl9TSVpFKTtcclxuICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvLyAxMC4gR0FNRSBMT0dJQyBGVU5DVElPTlNcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICBjb25zdCBjcmVhdGVQaXBlID0gKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpID0+IHtcclxuICAgIGNvbnN0IHBpcGVIZWlnaHQgPSBNYXRoLnJhbmRvbSgpICogKGNhbnZhcy5oZWlnaHQgLSBQSVBFX1NQQUNJTkcgLSAxMDApICsgNTA7XHJcbiAgICBjb25zdCBib3R0b21ZID0gcGlwZUhlaWdodCArIFBJUEVfU1BBQ0lORztcclxuICAgIHBpcGVzUmVmLmN1cnJlbnQucHVzaCh7XHJcbiAgICAgIHg6IGNhbnZhcy53aWR0aCxcclxuICAgICAgdG9wSGVpZ2h0OiBwaXBlSGVpZ2h0LFxyXG4gICAgICBib3R0b21ZLFxyXG4gICAgICBib3R0b21IZWlnaHQ6IGNhbnZhcy5oZWlnaHQgLSBib3R0b21ZLFxyXG4gICAgICBzY29yZWQ6IGZhbHNlLFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gNTAlIGNoYW5jZSBmb3IgY29pblxyXG4gICAgaWYgKE1hdGgucmFuZG9tKCkgPiAwLjUpIHtcclxuICAgICAgY29pbnNSZWYuY3VycmVudC5wdXNoKHtcclxuICAgICAgICB4OiBjYW52YXMud2lkdGggKyBQSVBFX1dJRFRIIC8gMiAtIENPSU5fU0laRSAvIDIsXHJcbiAgICAgICAgeTogcGlwZUhlaWdodCArIFBJUEVfU1BBQ0lORyAvIDIgLSBDT0lOX1NJWkUgLyAyLFxyXG4gICAgICAgIHdpZHRoOiBDT0lOX1NJWkUsXHJcbiAgICAgICAgaGVpZ2h0OiBDT0lOX1NJWkUsXHJcbiAgICAgICAgY29sbGVjdGVkOiBmYWxzZSxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgbW92ZVBpcGVzQW5kQ29pbnMgPSAoc2NhbGU6IG51bWJlcikgPT4ge1xyXG4gICAgLy8gTW92ZSBwaXBlcyB0byB0aGUgbGVmdFxyXG4gICAgcGlwZXNSZWYuY3VycmVudC5mb3JFYWNoKChwaXBlKSA9PiB7XHJcbiAgICAgIHBpcGUueCAtPSBIT1JJWk9OVEFMX1NQRUVEICogc2NhbGU7XHJcbiAgICB9KTtcclxuICAgIHBpcGVzUmVmLmN1cnJlbnQgPSBwaXBlc1JlZi5jdXJyZW50LmZpbHRlcigocCkgPT4gcC54ICsgUElQRV9XSURUSCA+IDApO1xyXG5cclxuICAgIC8vIE1vdmUgY29pbnNcclxuICAgIGNvaW5zUmVmLmN1cnJlbnQuZm9yRWFjaCgoY29pbikgPT4ge1xyXG4gICAgICBjb2luLnggLT0gSE9SSVpPTlRBTF9TUEVFRCAqIHNjYWxlO1xyXG4gICAgfSk7XHJcbiAgICBjb2luc1JlZi5jdXJyZW50ID0gY29pbnNSZWYuY3VycmVudC5maWx0ZXIoXHJcbiAgICAgIChjKSA9PiBjLnggKyBjLndpZHRoID4gMCAmJiAhYy5jb2xsZWN0ZWRcclxuICAgICk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgY2hlY2tDb2xsaXNpb25zID0gKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpOiBib29sZWFuID0+IHtcclxuICAgIC8vIEJpcmQgdnMgYm91bmRhcmllc1xyXG4gICAgaWYgKGJpcmRZUmVmLmN1cnJlbnQgPCAwIHx8IGJpcmRZUmVmLmN1cnJlbnQgKyBCSVJEX0hFSUdIVCA+IGNhbnZhcy5oZWlnaHQpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYmlyZExlZnQgPSAxMDA7XHJcbiAgICBjb25zdCBiaXJkUmlnaHQgPSBiaXJkTGVmdCArIEJJUkRfV0lEVEg7XHJcbiAgICBjb25zdCBiaXJkVG9wID0gYmlyZFlSZWYuY3VycmVudDtcclxuICAgIGNvbnN0IGJpcmRCb3R0b20gPSBiaXJkWVJlZi5jdXJyZW50ICsgQklSRF9IRUlHSFQ7XHJcblxyXG4gICAgLy8gQmlyZCB2cyBwaXBlc1xyXG4gICAgZm9yIChjb25zdCBwaXBlIG9mIHBpcGVzUmVmLmN1cnJlbnQpIHtcclxuICAgICAgY29uc3Qgd2l0aGluUGlwZVggPSBiaXJkUmlnaHQgPiBwaXBlLnggJiYgYmlyZExlZnQgPCBwaXBlLnggKyBQSVBFX1dJRFRIO1xyXG4gICAgICBjb25zdCB3aXRoaW5QaXBlWSA9IGJpcmRUb3AgPCBwaXBlLnRvcEhlaWdodCB8fCBiaXJkQm90dG9tID4gcGlwZS5ib3R0b21ZO1xyXG4gICAgICBpZiAod2l0aGluUGlwZVggJiYgd2l0aGluUGlwZVkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGNoZWNrQ29pbkNvbGxlY3Rpb24gPSAoKSA9PiB7XHJcbiAgICBjb25zdCBiaXJkTGVmdCA9IDEwMDtcclxuICAgIGNvbnN0IGJpcmRSaWdodCA9IGJpcmRMZWZ0ICsgQklSRF9XSURUSDtcclxuICAgIGNvbnN0IGJpcmRUb3AgPSBiaXJkWVJlZi5jdXJyZW50O1xyXG4gICAgY29uc3QgYmlyZEJvdHRvbSA9IGJpcmRZUmVmLmN1cnJlbnQgKyBCSVJEX0hFSUdIVDtcclxuXHJcbiAgICBjb2luc1JlZi5jdXJyZW50LmZvckVhY2goKGNvaW4pID0+IHtcclxuICAgICAgaWYgKCFjb2luLmNvbGxlY3RlZCkge1xyXG4gICAgICAgIGNvbnN0IGNvaW5MZWZ0ID0gY29pbi54O1xyXG4gICAgICAgIGNvbnN0IGNvaW5SaWdodCA9IGNvaW4ueCArIGNvaW4ud2lkdGg7XHJcbiAgICAgICAgY29uc3QgY29pblRvcCA9IGNvaW4ueTtcclxuICAgICAgICBjb25zdCBjb2luQm90dG9tID0gY29pbi55ICsgY29pbi5oZWlnaHQ7XHJcblxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIGJpcmRSaWdodCA+IGNvaW5MZWZ0ICYmXHJcbiAgICAgICAgICBiaXJkTGVmdCA8IGNvaW5SaWdodCAmJlxyXG4gICAgICAgICAgYmlyZEJvdHRvbSA+IGNvaW5Ub3AgJiZcclxuICAgICAgICAgIGJpcmRUb3AgPCBjb2luQm90dG9tXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAvLyBDb2xsZWN0IGNvaW5cclxuICAgICAgICAgIGNvaW4uY29sbGVjdGVkID0gdHJ1ZTtcclxuICAgICAgICAgIHNldEN1cnJlbnRTY29yZSgocHJldlNjb3JlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1Njb3JlID0gcHJldlNjb3JlICsgNTtcclxuICAgICAgICAgICAgc2V0SGlnaFNjb3JlKChwcmV2SGlnaFNjb3JlKSA9PiBNYXRoLm1heChwcmV2SGlnaFNjb3JlLCBuZXdTY29yZSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3U2NvcmU7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IHVwZGF0ZVNjb3JlID0gKCkgPT4ge1xyXG4gICAgcGlwZXNSZWYuY3VycmVudC5mb3JFYWNoKChwaXBlKSA9PiB7XHJcbiAgICAgIC8vIFNjb3JlICsxIGZvciBwYXNzaW5nIGVhY2ggcGlwZSwgb25seSBvbmNlXHJcbiAgICAgIGlmICghcGlwZS5zY29yZWQgJiYgcGlwZS54ICsgUElQRV9XSURUSCA8IDEwMCkge1xyXG4gICAgICAgIHBpcGUuc2NvcmVkID0gdHJ1ZTtcclxuICAgICAgICBzZXRDdXJyZW50U2NvcmUoKHByZXZTY29yZSkgPT4ge1xyXG4gICAgICAgICAgY29uc3QgbmV3U2NvcmUgPSBwcmV2U2NvcmUgKyAxO1xyXG4gICAgICAgICAgc2V0SGlnaFNjb3JlKChwcmV2SGlnaFNjb3JlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRIaWdoU2NvcmUgPSBNYXRoLm1heChwcmV2SGlnaFNjb3JlLCBuZXdTY29yZSk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJoaWdoU2NvcmVcIiwgdXBkYXRlZEhpZ2hTY29yZS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlZEhpZ2hTY29yZTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgcmV0dXJuIG5ld1Njb3JlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvLyAxMS4gQ0xFQU5VUCBGVU5DVElPTlxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIEFscmVhZHkgaGFuZGxlZCBpbiB1c2VFZmZlY3QgcmV0dXJuIGZ1bmN0aW9uXHJcblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIDEyLiBSRVRVUk4gR0FNRSBTVEFUUyBBTkQgSU5QVVQgSGFuZGxlclxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIHJldHVybiB7XHJcbiAgICBoaWdoU2NvcmUsXHJcbiAgICBjdXJyZW50U2NvcmUsXHJcbiAgICBoYW5kbGVVc2VySW5wdXQ6IGZsYXAsIC8vIEV4cG9zZWQgdG8gdGhlIGNvbXBvbmVudFxyXG4gIH07XHJcbn1cclxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwiR1JBVklUWSIsIkZMQVAiLCJQSVBFX1dJRFRIIiwiUElQRV9TUEFDSU5HIiwiQklSRF9XSURUSCIsIkJJUkRfSEVJR0hUIiwiQ09JTl9TSVpFIiwiUElQRV9TUEFXTl9JTlRFUlZBTCIsIkhPUklaT05UQUxfU1BFRUQiLCJST1RBVElPTl9TUEVFRCIsIklERUFMX0ZSQU1FIiwidXNlRmxhcHB5QmlyZEdhbWUiLCJjYW52YXNSZWYiLCJpc1BhdXNlZCIsImF1dG9TdGFydCIsImhpZ2hTY29yZSIsInNldEhpZ2hTY29yZSIsImN1cnJlbnRTY29yZSIsInNldEN1cnJlbnRTY29yZSIsInJlcXVlc3RJZFJlZiIsImJpcmRZUmVmIiwiYmlyZFZlbG9jaXR5UmVmIiwicGlwZXNSZWYiLCJjb2luc1JlZiIsImdhbWVPdmVyUmVmIiwiZ2FtZVN0YXJ0ZWRSZWYiLCJjb2luUm90YXRpb25SZWYiLCJwaXBlU3Bhd25UaW1lclJlZiIsImxhc3RUaW1lUmVmIiwiYmlyZEltYWdlc1JlZiIsInBpcGVUb3BSZWYiLCJwaXBlQm90dG9tUmVmIiwiYmFja2dyb3VuZFJlZiIsImNvaW5JbWFnZVJlZiIsImN1cnJlbnRCaXJkRnJhbWVSZWYiLCJsYXN0VGFwUmVmIiwiREVCT1VOQ0VfVElNRSIsImJpcmRVcCIsIkltYWdlIiwic3JjIiwiYmlyZE1pZCIsImJpcmREb3duIiwiY3VycmVudCIsInBpcGVUb3AiLCJwaXBlQm90dG9tIiwiYmFja2dyb3VuZCIsImNvaW5JbWFnZSIsInN0b3JlZEhpZ2hTY29yZSIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJwYXJzZUludCIsImNhbnZhcyIsImN0eCIsImdldENvbnRleHQiLCJsb2FkSW1hZ2UiLCJpbWciLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImNvbXBsZXRlIiwib25sb2FkIiwib25lcnJvciIsIkVycm9yIiwibG9hZEFzc2V0cyIsImFsbCIsIm1hcCIsImluaXRpYWxpemVHYW1lIiwiZXJyIiwiY29uc29sZSIsImVycm9yIiwid2lkdGgiLCJoZWlnaHQiLCJkcmF3U3RhcnRTY3JlZW4iLCJyZXNldEdhbWUiLCJoYW5kbGVQb2ludGVyRG93biIsImZsYXAiLCJhZGRFdmVudExpc3RlbmVyIiwiaGFuZGxlS2V5RG93biIsImUiLCJrZXkiLCJ3aW5kb3ciLCJoYW5kbGVSZXNpemUiLCJzdGFydEdhbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImFuaW1hdGUiLCJEYXRlIiwiZmxhcEFuaW1hdGlvbiIsInNldFRpbWVvdXQiLCJjdXJyZW50VGltZSIsImNvbnRleHQiLCJkZWx0YVRpbWUiLCJ1cGRhdGVHYW1lU3RhdGUiLCJkcmF3IiwiZHJhd0dhbWVPdmVyU2NyZWVuIiwic2NhbGUiLCJjcmVhdGVQaXBlIiwibW92ZVBpcGVzQW5kQ29pbnMiLCJjaGVja0NvbGxpc2lvbnMiLCJjaGVja0NvaW5Db2xsZWN0aW9uIiwidXBkYXRlU2NvcmUiLCJjbGVhclJlY3QiLCJkcmF3QmFja2dyb3VuZCIsImRyYXdCaXJkIiwiZHJhd1BpcGVzIiwiZHJhd0NvaW5zIiwiZm9udCIsInRleHRBbGlnbiIsImZpbGxTdHlsZSIsInNoYWRvd0NvbG9yIiwidGV4dEJhc2VsaW5lIiwiZmlsbFRleHQiLCJzaGFkb3dCbHVyIiwiZHJhd0ltYWdlIiwiY3VycmVudEltYWdlIiwiZm9yRWFjaCIsInBpcGUiLCJ4IiwidG9wSGVpZ2h0IiwiYm90dG9tWSIsImJvdHRvbUhlaWdodCIsInNjYWxlWCIsIk1hdGgiLCJhYnMiLCJjb3MiLCJQSSIsImhhbGZTaXplIiwiY29pbiIsImNvbGxlY3RlZCIsInNhdmUiLCJ0cmFuc2xhdGUiLCJ5IiwicmVzdG9yZSIsInBpcGVIZWlnaHQiLCJyYW5kb20iLCJwdXNoIiwic2NvcmVkIiwiZmlsdGVyIiwicCIsImMiLCJiaXJkTGVmdCIsImJpcmRSaWdodCIsImJpcmRUb3AiLCJiaXJkQm90dG9tIiwid2l0aGluUGlwZVgiLCJ3aXRoaW5QaXBlWSIsImNvaW5MZWZ0IiwiY29pblJpZ2h0IiwiY29pblRvcCIsImNvaW5Cb3R0b20iLCJwcmV2U2NvcmUiLCJuZXdTY29yZSIsInByZXZIaWdoU2NvcmUiLCJtYXgiLCJ1cGRhdGVkSGlnaFNjb3JlIiwic2V0SXRlbSIsInRvU3RyaW5nIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiaGFuZGxlVXNlcklucHV0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./public/useFlappyBirdGame.ts\n"));

/***/ })

});