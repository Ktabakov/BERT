"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./public/useFlappyBirdGame.ts":
/*!*************************************!*\
  !*** ./public/useFlappyBirdGame.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFlappyBirdGame: function() { return /* binding */ useFlappyBirdGame; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n// Constants\nconst GRAVITY = 0.25;\nconst FLAP = -7.5;\nconst PIPE_WIDTH = 90;\nconst PIPE_SPACING = 250;\nconst BIRD_WIDTH = 50;\nconst BIRD_HEIGHT = 50;\nconst COIN_SIZE = 100;\nconst ROTATION_SPEED = 0.005;\n// How often to spawn pipes in terms of frames\n// ~100 frames at ~60fps is ~1.66 seconds. Adjust as needed\nconst PIPE_SPAWN_FRAMES = 100;\nfunction useFlappyBirdGame(canvasRef, isPaused, autoStart) {\n    const requestIdRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // State refs\n    const [highScore, setHighScore] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [currentScore, setCurrentScore] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const birdYRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const birdVelocityRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const pipesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const coinsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const gameOverRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const gameStartedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const coinRotationStepRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const framesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0); // Count frames\n    // Assets\n    let birdImages = [];\n    let pipeTop;\n    let pipeBottom;\n    let background;\n    let coinImage;\n    if (true) {\n        const birdUp = new Image();\n        birdUp.src = \"/assets/redbird-upflap.png\";\n        const birdMid = new Image();\n        birdMid.src = \"/assets/redbird-midflap.png\";\n        const birdDown = new Image();\n        birdDown.src = \"/assets/redbird-downflap.png\";\n        birdImages = [\n            birdUp,\n            birdMid,\n            birdDown\n        ];\n        pipeTop = new Image();\n        pipeTop.src = \"/assets/TopTiny.png\";\n        pipeBottom = new Image();\n        pipeBottom.src = \"/assets/BottomTiny.png\";\n        background = new Image();\n        background.src = \"/assets/background-day.png\";\n        coinImage = new Image();\n        coinImage.src = \"/assets/CoinTiny.png\";\n    }\n    // Reference to track current bird frame\n    const currentBirdFrameRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // Reference for continuous animation (optional)\n    const animationFrameRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // Load high score from localStorage after mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (true) {\n            const storedHighScore = localStorage.getItem(\"highScore\");\n            if (storedHighScore) {\n                setHighScore(parseInt(storedHighScore, 10));\n            }\n        }\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        // Helper function to load images\n        const loadImage = (img)=>{\n            return new Promise((resolve, reject)=>{\n                if (img.complete) {\n                    resolve();\n                } else {\n                    img.onload = ()=>resolve();\n                    img.onerror = ()=>reject(new Error(\"Failed to load image: \".concat(img.src)));\n                }\n            });\n        };\n        // Load all assets before initializing the game\n        const loadAssets = async ()=>{\n            try {\n                await Promise.all([\n                    ...birdImages.map((img)=>loadImage(img)),\n                    loadImage(pipeTop),\n                    loadImage(pipeBottom),\n                    loadImage(background),\n                    loadImage(coinImage)\n                ]);\n                console.log(\"All assets loaded successfully!\");\n                initializeGame();\n            } catch (error) {\n                console.error(\"Error loading assets:\", error);\n            }\n        };\n        loadAssets();\n        function resetGame() {\n            const c = canvasRef.current;\n            if (!c) return;\n            const { width, height } = c;\n            birdYRef.current = height / 3;\n            birdVelocityRef.current = 0;\n            pipesRef.current = [];\n            coinsRef.current = [];\n            setCurrentScore(0);\n            gameOverRef.current = false;\n            gameStartedRef.current = false;\n            coinRotationStepRef.current = 0;\n            framesRef.current = 0;\n            currentBirdFrameRef.current = 0; // Reset bird frame\n        }\n        function handleKeyDown(e) {\n            if (e.key === \" \") {\n                if (!gameStartedRef.current && !gameOverRef.current) {\n                    startGame();\n                } else if (gameOverRef.current) {\n                    startGame();\n                } else {\n                    birdVelocityRef.current = FLAP;\n                    flap(); // Trigger flap animation\n                }\n            }\n        }\n        window.addEventListener(\"keydown\", handleKeyDown);\n        function handleResize() {\n            const c = canvasRef.current;\n            if (!c) return;\n            c.width = 360;\n            c.height = 640;\n            if (!gameStartedRef.current && !gameOverRef.current && ctx) {\n                drawStartScreen(ctx, c);\n            }\n        }\n        window.addEventListener(\"resize\", handleResize);\n        // Initialize the game\n        const initializeGame = ()=>{\n            if (!canvas) return;\n            canvas.width = 360;\n            canvas.height = 640;\n            drawStartScreen(ctx, canvas);\n        };\n        initializeGame();\n        function startGame() {\n            resetGame();\n            gameStartedRef.current = true;\n            animate(); // Start the loop\n        }\n        // Flap animation sequence\n        const flap = ()=>{\n            currentBirdFrameRef.current = 1;\n            setTimeout(()=>{\n                currentBirdFrameRef.current = 2;\n                setTimeout(()=>{\n                    currentBirdFrameRef.current = 0;\n                }, 170);\n            }, 170);\n        };\n        function animate() {\n            if (isPaused || !gameStartedRef.current) {\n                // If paused or not started, just request next frame without updating state\n                requestIdRef.current = requestAnimationFrame(animate);\n                return;\n            }\n            const c = canvasRef.current;\n            if (!c) return;\n            const context = c.getContext(\"2d\");\n            if (!context) return;\n            updateGameState(c);\n            draw(context, c);\n            // Optional: Continuous wing flapping\n            /*\r\n      animationFrameRef.current++;\r\n      if (animationFrameRef.current % 10 === 0) { // Adjust the modulo value for speed\r\n        currentBirdFrameRef.current = (currentBirdFrameRef.current + 1) % birdImages.length;\r\n      }\r\n      */ if (!gameOverRef.current) {\n                requestIdRef.current = requestAnimationFrame(animate);\n            } else {\n                drawGameOverScreen(context, c);\n            }\n        }\n        function updateGameState(canvas) {\n            framesRef.current++;\n            // Gravity\n            birdVelocityRef.current += GRAVITY;\n            birdYRef.current += birdVelocityRef.current;\n            // Spawn pipes every PIPE_SPAWN_FRAMES frames\n            if (framesRef.current % PIPE_SPAWN_FRAMES === 0) {\n                createPipe(canvas);\n            }\n            movePipesAndCoins();\n            checkCoinCollection();\n            // Check collisions after movement\n            if (checkCollisions(canvas)) {\n                gameOverRef.current = true;\n                return;\n            }\n            updateScore();\n            // Rotate coin a bit each frame\n            coinRotationStepRef.current += ROTATION_SPEED;\n            if (coinRotationStepRef.current >= 1) coinRotationStepRef.current = 0;\n        }\n        function draw(ctx, canvas) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawBackground(ctx, canvas);\n            drawBird(ctx);\n            drawPipes(ctx);\n            drawCoins(ctx);\n        }\n        function drawStartScreen(ctx, canvas) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawBackground(ctx, canvas);\n            ctx.font = \"bold 30px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.fillStyle = \"#ffffff\";\n            ctx.shadowColor = \"black\";\n            ctx.textBaseline = \"middle\";\n            ctx.fillText(\"Press Space to Start\", canvas.width / 2, canvas.height / 2);\n        }\n        function drawGameOverScreen(ctx, canvas) {\n            ctx.fillStyle = \"#ffcc00\";\n            ctx.font = \"bold 50px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"middle\";\n            ctx.shadowColor = \"black\";\n            ctx.shadowBlur = 10;\n            ctx.fillText(\"Game Over!\", canvas.width / 2, canvas.height / 2 - 40);\n            ctx.fillStyle = \"#ffffff\";\n            ctx.font = \"bold 30px Arial\";\n            ctx.fillText(\"Press Space to Restart\", canvas.width / 2, canvas.height / 2 + 20);\n            ctx.fillStyle = \"#ffff00\";\n            ctx.font = \"30px Arial\";\n        }\n        function drawBackground(ctx, canvas) {\n            ctx.drawImage(background, 0, 0, canvas.width, canvas.height);\n        }\n        function drawBird(ctx) {\n            const currentImage = birdImages[currentBirdFrameRef.current];\n            if (currentImage.complete) {\n                ctx.drawImage(currentImage, 100, birdYRef.current, BIRD_WIDTH, BIRD_HEIGHT);\n            } else {\n                console.warn(\"Bird image at index \".concat(currentBirdFrameRef.current, \" not loaded yet.\"));\n            }\n        }\n        function drawPipes(ctx) {\n            for (const pipe of pipesRef.current){\n                ctx.drawImage(pipeTop, pipe.x, 0, PIPE_WIDTH, pipe.topHeight);\n                ctx.drawImage(pipeBottom, pipe.x, pipe.bottomY, PIPE_WIDTH, pipe.bottomHeight);\n            }\n        }\n        function drawCoins(ctx) {\n            const scaleX = Math.abs(Math.cos(coinRotationStepRef.current * Math.PI * 2));\n            const halfSize = COIN_SIZE / 2;\n            for (const coin of coinsRef.current){\n                if (!coin.collected) {\n                    ctx.save();\n                    ctx.translate(coin.x + halfSize, coin.y + halfSize);\n                    ctx.scale(scaleX, 1);\n                    ctx.drawImage(coinImage, -halfSize, -halfSize, COIN_SIZE, COIN_SIZE);\n                    ctx.restore();\n                }\n            }\n        }\n        function createPipe(canvas) {\n            const pipeHeight = Math.random() * (canvas.height - PIPE_SPACING - 100) + 50;\n            const bottomY = pipeHeight + PIPE_SPACING;\n            pipesRef.current.push({\n                x: canvas.width,\n                topHeight: pipeHeight,\n                bottomY,\n                bottomHeight: canvas.height - bottomY,\n                scored: false\n            });\n            // 50% chance to spawn a coin\n            if (Math.random() > 0.5) {\n                coinsRef.current.push({\n                    x: canvas.width + PIPE_WIDTH / 2 - COIN_SIZE / 2,\n                    y: pipeHeight + PIPE_SPACING / 2 - COIN_SIZE / 2,\n                    width: COIN_SIZE,\n                    height: COIN_SIZE,\n                    collected: false\n                });\n            }\n        }\n        function movePipesAndCoins() {\n            for (const pipe of pipesRef.current){\n                pipe.x -= 2;\n            }\n            pipesRef.current = pipesRef.current.filter((pipe)=>pipe.x + PIPE_WIDTH > 0);\n            for (const coin of coinsRef.current){\n                coin.x -= 2;\n            }\n            coinsRef.current = coinsRef.current.filter((coin)=>coin.x + coin.width > 0 && !coin.collected);\n        }\n        function checkCollisions(canvas) {\n            if (birdYRef.current < 0 || birdYRef.current + BIRD_HEIGHT > canvas.height) {\n                return true;\n            }\n            const birdLeft = 100;\n            const birdRight = birdLeft + BIRD_WIDTH;\n            const birdTop = birdYRef.current;\n            const birdBottom = birdYRef.current + BIRD_HEIGHT;\n            for (const pipe of pipesRef.current){\n                const withinPipeX = birdRight > pipe.x && birdLeft < pipe.x + PIPE_WIDTH;\n                const withinPipeY = birdTop < pipe.topHeight || birdBottom > pipe.bottomY;\n                if (withinPipeX && withinPipeY) return true;\n            }\n            return false;\n        }\n        function checkCoinCollection() {\n            const birdLeft = 100;\n            const birdRight = birdLeft + BIRD_WIDTH;\n            const birdTop = birdYRef.current;\n            const birdBottom = birdYRef.current + BIRD_HEIGHT;\n            for (const coin of coinsRef.current){\n                if (!coin.collected) {\n                    const coinLeft = coin.x;\n                    const coinRight = coin.x + coin.width;\n                    const coinTop = coin.y;\n                    const coinBottom = coin.y + coin.height;\n                    if (birdRight > coinLeft && birdLeft < coinRight && birdBottom > coinTop && birdTop < coinBottom) {\n                        coin.collected = true;\n                        setCurrentScore((prevScore)=>{\n                            const newScore = prevScore + 5;\n                            setHighScore((prevHighScore)=>Math.max(prevHighScore, newScore));\n                            return newScore;\n                        });\n                    }\n                }\n            }\n        }\n        function updateScore() {\n            for (const pipe of pipesRef.current){\n                if (!pipe.scored && pipe.x + PIPE_WIDTH < 100) {\n                    setCurrentScore((prevScore)=>{\n                        const newScore = prevScore + 1;\n                        setHighScore((prevHighScore)=>{\n                            const updatedHighScore = Math.max(prevHighScore, newScore);\n                            if (true) {\n                                localStorage.setItem(\"highScore\", updatedHighScore.toString());\n                            }\n                            return updatedHighScore;\n                        });\n                        return newScore;\n                    });\n                    pipe.scored = true;\n                }\n            }\n        }\n        return ()=>{\n            window.removeEventListener(\"keydown\", handleKeyDown);\n            window.removeEventListener(\"resize\", handleResize);\n            if (requestIdRef.current) {\n                cancelAnimationFrame(requestIdRef.current);\n            }\n        };\n    }, [\n        canvasRef,\n        isPaused,\n        autoStart\n    ]);\n    return {\n        highScore,\n        currentScore\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LFFBQVFsRixTQUFTdUIsT0FBTyxDQUFFO2dCQUNuQyxJQUFJLENBQUMyRCxLQUFLcUIsTUFBTSxJQUFJckIsS0FBS0MsQ0FBQyxHQUFHckcsYUFBYSxLQUFLO29CQUM3Q2UsZ0JBQWdCLENBQUNzSDt3QkFDZixNQUFNQyxXQUFXRCxZQUFZO3dCQUM3QnhILGFBQWEsQ0FBQzBIOzRCQUNaLE1BQU1FLG1CQUFtQi9CLEtBQUs4QixHQUFHLENBQUNELGVBQWVEOzRCQUVqRCxJQUFJLElBQTZCLEVBQUU7Z0NBQ2pDakcsYUFBYXFHLE9BQU8sQ0FBQyxhQUFhRCxpQkFBaUJFLFFBQVE7NEJBQzdEOzRCQUNBLE9BQU9GO3dCQUNUO3dCQUNBLE9BQU9IO29CQUNUO29CQUNBbEMsS0FBS3FCLE1BQU0sR0FBRztnQkFDaEI7WUFDRjtRQUNGO1FBRUEsT0FBTztZQUNMcEQsT0FBT3VFLG1CQUFtQixDQUFDLFdBQVc1RTtZQUN0Q0ssT0FBT3VFLG1CQUFtQixDQUFDLFVBQVVyRTtZQUNyQyxJQUFJNUQsYUFBYThCLE9BQU8sRUFBRTtnQkFDeEJvRyxxQkFBcUJsSSxhQUFhOEIsT0FBTztZQUMzQztRQUNGO0lBQ0YsR0FBRztRQUFDakM7UUFBV0M7UUFBVUM7S0FBVTtJQUVuQyxPQUFPO1FBQUVFO1FBQVdFO0lBQWE7QUFDbkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcHVibGljL3VzZUZsYXBweUJpcmRHYW1lLnRzPzVjNzgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XHJcblxyXG4vLyBUeXBlcyBmb3IgZ2FtZSBvYmplY3RzXHJcbmludGVyZmFjZSBQaXBlIHtcclxuICB4OiBudW1iZXI7XHJcbiAgdG9wSGVpZ2h0OiBudW1iZXI7XHJcbiAgYm90dG9tWTogbnVtYmVyO1xyXG4gIGJvdHRvbUhlaWdodDogbnVtYmVyO1xyXG4gIHNjb3JlZDogYm9vbGVhbjtcclxufVxyXG5cclxuaW50ZXJmYWNlIENvaW4ge1xyXG4gIHg6IG51bWJlcjtcclxuICB5OiBudW1iZXI7XHJcbiAgd2lkdGg6IG51bWJlcjtcclxuICBoZWlnaHQ6IG51bWJlcjtcclxuICBjb2xsZWN0ZWQ6IGJvb2xlYW47XHJcbn1cclxuXHJcbi8vIENvbnN0YW50c1xyXG5jb25zdCBHUkFWSVRZID0gMC4yNTtcclxuY29uc3QgRkxBUCA9IC03LjU7XHJcbmNvbnN0IFBJUEVfV0lEVEggPSA5MDtcclxuY29uc3QgUElQRV9TUEFDSU5HID0gMjUwO1xyXG5jb25zdCBCSVJEX1dJRFRIID0gNTA7XHJcbmNvbnN0IEJJUkRfSEVJR0hUID0gNTA7XHJcbmNvbnN0IENPSU5fU0laRSA9IDEwMDtcclxuY29uc3QgUk9UQVRJT05fU1BFRUQgPSAwLjAwNTtcclxuXHJcbi8vIEhvdyBvZnRlbiB0byBzcGF3biBwaXBlcyBpbiB0ZXJtcyBvZiBmcmFtZXNcclxuLy8gfjEwMCBmcmFtZXMgYXQgfjYwZnBzIGlzIH4xLjY2IHNlY29uZHMuIEFkanVzdCBhcyBuZWVkZWRcclxuY29uc3QgUElQRV9TUEFXTl9GUkFNRVMgPSAxMDA7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlRmxhcHB5QmlyZEdhbWUoXHJcbiAgY2FudmFzUmVmOiBSZWFjdC5SZWZPYmplY3Q8SFRNTENhbnZhc0VsZW1lbnQ+LFxyXG4gIGlzUGF1c2VkOiBib29sZWFuLFxyXG4gIGF1dG9TdGFydDogYm9vbGVhblxyXG4pIHtcclxuICBjb25zdCByZXF1ZXN0SWRSZWYgPSB1c2VSZWY8bnVtYmVyIHwgbnVsbD4obnVsbCk7XHJcblxyXG4gIC8vIFN0YXRlIHJlZnNcclxuICBjb25zdCBbaGlnaFNjb3JlLCBzZXRIaWdoU2NvcmVdID0gdXNlU3RhdGUoMCk7XHJcbiAgY29uc3QgW2N1cnJlbnRTY29yZSwgc2V0Q3VycmVudFNjb3JlXSA9IHVzZVN0YXRlKDApO1xyXG5cclxuICBjb25zdCBiaXJkWVJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xyXG4gIGNvbnN0IGJpcmRWZWxvY2l0eVJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xyXG4gIGNvbnN0IHBpcGVzUmVmID0gdXNlUmVmPFBpcGVbXT4oW10pO1xyXG4gIGNvbnN0IGNvaW5zUmVmID0gdXNlUmVmPENvaW5bXT4oW10pO1xyXG4gIGNvbnN0IGdhbWVPdmVyUmVmID0gdXNlUmVmPGJvb2xlYW4+KGZhbHNlKTtcclxuICBjb25zdCBnYW1lU3RhcnRlZFJlZiA9IHVzZVJlZjxib29sZWFuPihmYWxzZSk7XHJcblxyXG4gIGNvbnN0IGNvaW5Sb3RhdGlvblN0ZXBSZWYgPSB1c2VSZWY8bnVtYmVyPigwKTtcclxuICBjb25zdCBmcmFtZXNSZWYgPSB1c2VSZWY8bnVtYmVyPigwKTsgLy8gQ291bnQgZnJhbWVzXHJcblxyXG4gIC8vIEFzc2V0c1xyXG4gIGxldCBiaXJkSW1hZ2VzOiBIVE1MSW1hZ2VFbGVtZW50W10gPSBbXTtcclxuICBsZXQgcGlwZVRvcDogSFRNTEltYWdlRWxlbWVudDtcclxuICBsZXQgcGlwZUJvdHRvbTogSFRNTEltYWdlRWxlbWVudDtcclxuICBsZXQgYmFja2dyb3VuZDogSFRNTEltYWdlRWxlbWVudDtcclxuICBsZXQgY29pbkltYWdlOiBIVE1MSW1hZ2VFbGVtZW50O1xyXG5cclxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgY29uc3QgYmlyZFVwID0gbmV3IEltYWdlKCk7XHJcbiAgICBiaXJkVXAuc3JjID0gXCIvYXNzZXRzL3JlZGJpcmQtdXBmbGFwLnBuZ1wiO1xyXG5cclxuICAgIGNvbnN0IGJpcmRNaWQgPSBuZXcgSW1hZ2UoKTtcclxuICAgIGJpcmRNaWQuc3JjID0gXCIvYXNzZXRzL3JlZGJpcmQtbWlkZmxhcC5wbmdcIjtcclxuXHJcbiAgICBjb25zdCBiaXJkRG93biA9IG5ldyBJbWFnZSgpO1xyXG4gICAgYmlyZERvd24uc3JjID0gXCIvYXNzZXRzL3JlZGJpcmQtZG93bmZsYXAucG5nXCI7XHJcblxyXG4gICAgYmlyZEltYWdlcyA9IFtiaXJkVXAsIGJpcmRNaWQsIGJpcmREb3duXTtcclxuXHJcbiAgICBwaXBlVG9wID0gbmV3IEltYWdlKCk7XHJcbiAgICBwaXBlVG9wLnNyYyA9IFwiL2Fzc2V0cy9Ub3BUaW55LnBuZ1wiO1xyXG5cclxuICAgIHBpcGVCb3R0b20gPSBuZXcgSW1hZ2UoKTtcclxuICAgIHBpcGVCb3R0b20uc3JjID0gXCIvYXNzZXRzL0JvdHRvbVRpbnkucG5nXCI7XHJcblxyXG4gICAgYmFja2dyb3VuZCA9IG5ldyBJbWFnZSgpO1xyXG4gICAgYmFja2dyb3VuZC5zcmMgPSBcIi9hc3NldHMvYmFja2dyb3VuZC1kYXkucG5nXCI7XHJcblxyXG4gICAgY29pbkltYWdlID0gbmV3IEltYWdlKCk7XHJcbiAgICBjb2luSW1hZ2Uuc3JjID0gXCIvYXNzZXRzL0NvaW5UaW55LnBuZ1wiO1xyXG4gIH1cclxuXHJcbiAgLy8gUmVmZXJlbmNlIHRvIHRyYWNrIGN1cnJlbnQgYmlyZCBmcmFtZVxyXG4gIGNvbnN0IGN1cnJlbnRCaXJkRnJhbWVSZWYgPSB1c2VSZWY8bnVtYmVyPigwKTtcclxuXHJcbiAgLy8gUmVmZXJlbmNlIGZvciBjb250aW51b3VzIGFuaW1hdGlvbiAob3B0aW9uYWwpXHJcbiAgY29uc3QgYW5pbWF0aW9uRnJhbWVSZWYgPSB1c2VSZWY8bnVtYmVyPigwKTtcclxuXHJcbiAgLy8gTG9hZCBoaWdoIHNjb3JlIGZyb20gbG9jYWxTdG9yYWdlIGFmdGVyIG1vdW50XHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgIGNvbnN0IHN0b3JlZEhpZ2hTY29yZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwiaGlnaFNjb3JlXCIpO1xyXG4gICAgICBpZiAoc3RvcmVkSGlnaFNjb3JlKSB7XHJcbiAgICAgICAgc2V0SGlnaFNjb3JlKHBhcnNlSW50KHN0b3JlZEhpZ2hTY29yZSwgMTApKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sIFtdKTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xyXG4gICAgaWYgKCFjYW52YXMpIHJldHVybjtcclxuXHJcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgaWYgKCFjdHgpIHJldHVybjtcclxuXHJcbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gbG9hZCBpbWFnZXNcclxuICAgIGNvbnN0IGxvYWRJbWFnZSA9IChpbWc6IEhUTUxJbWFnZUVsZW1lbnQpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICBpZiAoaW1nLmNvbXBsZXRlKSB7XHJcbiAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKCk7XHJcbiAgICAgICAgICBpbWcub25lcnJvciA9ICgpID0+IHJlamVjdChuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIGltYWdlOiAke2ltZy5zcmN9YCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIExvYWQgYWxsIGFzc2V0cyBiZWZvcmUgaW5pdGlhbGl6aW5nIHRoZSBnYW1lXHJcbiAgICBjb25zdCBsb2FkQXNzZXRzID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgICAgICAgIC4uLmJpcmRJbWFnZXMubWFwKChpbWcpID0+IGxvYWRJbWFnZShpbWcpKSxcclxuICAgICAgICAgIGxvYWRJbWFnZShwaXBlVG9wKSxcclxuICAgICAgICAgIGxvYWRJbWFnZShwaXBlQm90dG9tKSxcclxuICAgICAgICAgIGxvYWRJbWFnZShiYWNrZ3JvdW5kKSxcclxuICAgICAgICAgIGxvYWRJbWFnZShjb2luSW1hZ2UpLFxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQWxsIGFzc2V0cyBsb2FkZWQgc3VjY2Vzc2Z1bGx5IVwiKTtcclxuICAgICAgICBpbml0aWFsaXplR2FtZSgpO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsb2FkaW5nIGFzc2V0czpcIiwgZXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGxvYWRBc3NldHMoKTtcclxuXHJcbiAgICBmdW5jdGlvbiByZXNldEdhbWUoKSB7XHJcbiAgICAgIGNvbnN0IGMgPSBjYW52YXNSZWYuY3VycmVudDtcclxuICAgICAgaWYgKCFjKSByZXR1cm47XHJcbiAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gYztcclxuXHJcbiAgICAgIGJpcmRZUmVmLmN1cnJlbnQgPSBoZWlnaHQgLyAzO1xyXG4gICAgICBiaXJkVmVsb2NpdHlSZWYuY3VycmVudCA9IDA7XHJcbiAgICAgIHBpcGVzUmVmLmN1cnJlbnQgPSBbXTtcclxuICAgICAgY29pbnNSZWYuY3VycmVudCA9IFtdO1xyXG4gICAgICBzZXRDdXJyZW50U2NvcmUoMCk7XHJcbiAgICAgIGdhbWVPdmVyUmVmLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgICAgZ2FtZVN0YXJ0ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xyXG4gICAgICBjb2luUm90YXRpb25TdGVwUmVmLmN1cnJlbnQgPSAwO1xyXG4gICAgICBmcmFtZXNSZWYuY3VycmVudCA9IDA7XHJcbiAgICAgIGN1cnJlbnRCaXJkRnJhbWVSZWYuY3VycmVudCA9IDA7IC8vIFJlc2V0IGJpcmQgZnJhbWVcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVLZXlEb3duKGU6IEtleWJvYXJkRXZlbnQpIHtcclxuICAgICAgaWYgKGUua2V5ID09PSBcIiBcIikge1xyXG4gICAgICAgIGlmICghZ2FtZVN0YXJ0ZWRSZWYuY3VycmVudCAmJiAhZ2FtZU92ZXJSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgc3RhcnRHYW1lKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChnYW1lT3ZlclJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICBzdGFydEdhbWUoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYmlyZFZlbG9jaXR5UmVmLmN1cnJlbnQgPSBGTEFQO1xyXG4gICAgICAgICAgZmxhcCgpOyAvLyBUcmlnZ2VyIGZsYXAgYW5pbWF0aW9uXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGhhbmRsZUtleURvd24pO1xyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZVJlc2l6ZSgpIHtcclxuICAgICAgY29uc3QgYyA9IGNhbnZhc1JlZi5jdXJyZW50O1xyXG4gICAgICBpZiAoIWMpIHJldHVybjtcclxuICAgICAgYy53aWR0aCA9IDM2MDtcclxuICAgICAgYy5oZWlnaHQgPSA2NDA7XHJcblxyXG4gICAgICBpZiAoIWdhbWVTdGFydGVkUmVmLmN1cnJlbnQgJiYgIWdhbWVPdmVyUmVmLmN1cnJlbnQgJiYgY3R4KSB7XHJcbiAgICAgICAgZHJhd1N0YXJ0U2NyZWVuKGN0eCwgYyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGhhbmRsZVJlc2l6ZSk7XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgZ2FtZVxyXG4gICAgY29uc3QgaW5pdGlhbGl6ZUdhbWUgPSAoKSA9PiB7XHJcbiAgICAgIGlmICghY2FudmFzKSByZXR1cm47XHJcbiAgICAgIGNhbnZhcy53aWR0aCA9IDM2MDtcclxuICAgICAgY2FudmFzLmhlaWdodCA9IDY0MDtcclxuICAgICAgZHJhd1N0YXJ0U2NyZWVuKGN0eCwgY2FudmFzKTtcclxuICAgIH07XHJcblxyXG4gICAgaW5pdGlhbGl6ZUdhbWUoKTtcclxuXHJcbiAgICBmdW5jdGlvbiBzdGFydEdhbWUoKSB7XHJcbiAgICAgIHJlc2V0R2FtZSgpO1xyXG4gICAgICBnYW1lU3RhcnRlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcclxuICAgICAgYW5pbWF0ZSgpOyAvLyBTdGFydCB0aGUgbG9vcFxyXG4gICAgfVxyXG5cclxuICAgIC8vIEZsYXAgYW5pbWF0aW9uIHNlcXVlbmNlXHJcbiAgICBjb25zdCBmbGFwID0gKCkgPT4ge1xyXG4gICAgICBjdXJyZW50QmlyZEZyYW1lUmVmLmN1cnJlbnQgPSAxOyBcclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgY3VycmVudEJpcmRGcmFtZVJlZi5jdXJyZW50ID0gMjsgXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICBjdXJyZW50QmlyZEZyYW1lUmVmLmN1cnJlbnQgPSAwOyBcclxuICAgICAgICB9LCAxNzApOyBcclxuICAgICAgfSwgMTcwKTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gYW5pbWF0ZSgpIHtcclxuICAgICAgaWYgKGlzUGF1c2VkIHx8ICFnYW1lU3RhcnRlZFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgLy8gSWYgcGF1c2VkIG9yIG5vdCBzdGFydGVkLCBqdXN0IHJlcXVlc3QgbmV4dCBmcmFtZSB3aXRob3V0IHVwZGF0aW5nIHN0YXRlXHJcbiAgICAgICAgcmVxdWVzdElkUmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBjID0gY2FudmFzUmVmLmN1cnJlbnQ7XHJcbiAgICAgIGlmICghYykgcmV0dXJuO1xyXG4gICAgICBjb25zdCBjb250ZXh0ID0gYy5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICAgIGlmICghY29udGV4dCkgcmV0dXJuO1xyXG5cclxuICAgICAgdXBkYXRlR2FtZVN0YXRlKGMpO1xyXG4gICAgICBkcmF3KGNvbnRleHQsIGMpO1xyXG5cclxuICAgICAgLy8gT3B0aW9uYWw6IENvbnRpbnVvdXMgd2luZyBmbGFwcGluZ1xyXG4gICAgICAvKlxyXG4gICAgICBhbmltYXRpb25GcmFtZVJlZi5jdXJyZW50Kys7XHJcbiAgICAgIGlmIChhbmltYXRpb25GcmFtZVJlZi5jdXJyZW50ICUgMTAgPT09IDApIHsgLy8gQWRqdXN0IHRoZSBtb2R1bG8gdmFsdWUgZm9yIHNwZWVkXHJcbiAgICAgICAgY3VycmVudEJpcmRGcmFtZVJlZi5jdXJyZW50ID0gKGN1cnJlbnRCaXJkRnJhbWVSZWYuY3VycmVudCArIDEpICUgYmlyZEltYWdlcy5sZW5ndGg7XHJcbiAgICAgIH1cclxuICAgICAgKi9cclxuXHJcbiAgICAgIGlmICghZ2FtZU92ZXJSZWYuY3VycmVudCkge1xyXG4gICAgICAgIHJlcXVlc3RJZFJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRyYXdHYW1lT3ZlclNjcmVlbihjb250ZXh0LCBjKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZUdhbWVTdGF0ZShjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgIGZyYW1lc1JlZi5jdXJyZW50Kys7XHJcblxyXG4gICAgICAvLyBHcmF2aXR5XHJcbiAgICAgIGJpcmRWZWxvY2l0eVJlZi5jdXJyZW50ICs9IEdSQVZJVFk7XHJcbiAgICAgIGJpcmRZUmVmLmN1cnJlbnQgKz0gYmlyZFZlbG9jaXR5UmVmLmN1cnJlbnQ7XHJcblxyXG4gICAgICAvLyBTcGF3biBwaXBlcyBldmVyeSBQSVBFX1NQQVdOX0ZSQU1FUyBmcmFtZXNcclxuICAgICAgaWYgKGZyYW1lc1JlZi5jdXJyZW50ICUgUElQRV9TUEFXTl9GUkFNRVMgPT09IDApIHtcclxuICAgICAgICBjcmVhdGVQaXBlKGNhbnZhcyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG1vdmVQaXBlc0FuZENvaW5zKCk7XHJcbiAgICAgIGNoZWNrQ29pbkNvbGxlY3Rpb24oKTtcclxuXHJcbiAgICAgIC8vIENoZWNrIGNvbGxpc2lvbnMgYWZ0ZXIgbW92ZW1lbnRcclxuICAgICAgaWYgKGNoZWNrQ29sbGlzaW9ucyhjYW52YXMpKSB7XHJcbiAgICAgICAgZ2FtZU92ZXJSZWYuY3VycmVudCA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB1cGRhdGVTY29yZSgpO1xyXG5cclxuICAgICAgLy8gUm90YXRlIGNvaW4gYSBiaXQgZWFjaCBmcmFtZVxyXG4gICAgICBjb2luUm90YXRpb25TdGVwUmVmLmN1cnJlbnQgKz0gUk9UQVRJT05fU1BFRUQ7XHJcbiAgICAgIGlmIChjb2luUm90YXRpb25TdGVwUmVmLmN1cnJlbnQgPj0gMSkgY29pblJvdGF0aW9uU3RlcFJlZi5jdXJyZW50ID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3KGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICAgICAgZHJhd0JhY2tncm91bmQoY3R4LCBjYW52YXMpO1xyXG4gICAgICBkcmF3QmlyZChjdHgpO1xyXG4gICAgICBkcmF3UGlwZXMoY3R4KTtcclxuICAgICAgZHJhd0NvaW5zKGN0eCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd1N0YXJ0U2NyZWVuKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICAgICAgZHJhd0JhY2tncm91bmQoY3R4LCBjYW52YXMpO1xyXG4gICAgICBjdHguZm9udCA9IFwiYm9sZCAzMHB4IEFyaWFsXCI7XHJcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xyXG4gICAgICBjdHguZmlsbFN0eWxlID0gXCIjZmZmZmZmXCI7XHJcbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFwiYmxhY2tcIjtcclxuICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XHJcbiAgICAgIGN0eC5maWxsVGV4dChcIlByZXNzIFNwYWNlIHRvIFN0YXJ0XCIsIGNhbnZhcy53aWR0aCAvIDIsIGNhbnZhcy5oZWlnaHQgLyAyKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3R2FtZU92ZXJTY3JlZW4oY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiI2ZmY2MwMFwiO1xyXG4gICAgICBjdHguZm9udCA9IFwiYm9sZCA1MHB4IEFyaWFsXCI7XHJcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xyXG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcclxuICAgICAgY3R4LnNoYWRvd0NvbG9yID0gXCJibGFja1wiO1xyXG4gICAgICBjdHguc2hhZG93Qmx1ciA9IDEwO1xyXG5cclxuICAgICAgY3R4LmZpbGxUZXh0KFwiR2FtZSBPdmVyIVwiLCBjYW52YXMud2lkdGggLyAyLCBjYW52YXMuaGVpZ2h0IC8gMiAtIDQwKTtcclxuXHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNmZmZmZmZcIjtcclxuICAgICAgY3R4LmZvbnQgPSBcImJvbGQgMzBweCBBcmlhbFwiO1xyXG4gICAgICBjdHguZmlsbFRleHQoXCJQcmVzcyBTcGFjZSB0byBSZXN0YXJ0XCIsIGNhbnZhcy53aWR0aCAvIDIsIGNhbnZhcy5oZWlnaHQgLyAyICsgMjApO1xyXG5cclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiI2ZmZmYwMFwiO1xyXG4gICAgICBjdHguZm9udCA9IFwiMzBweCBBcmlhbFwiO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdCYWNrZ3JvdW5kKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgIGN0eC5kcmF3SW1hZ2UoYmFja2dyb3VuZCwgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3QmlyZChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xyXG4gICAgICBjb25zdCBjdXJyZW50SW1hZ2UgPSBiaXJkSW1hZ2VzW2N1cnJlbnRCaXJkRnJhbWVSZWYuY3VycmVudF07XHJcbiAgICAgIGlmIChjdXJyZW50SW1hZ2UuY29tcGxldGUpIHtcclxuICAgICAgICBjdHguZHJhd0ltYWdlKGN1cnJlbnRJbWFnZSwgMTAwLCBiaXJkWVJlZi5jdXJyZW50LCBCSVJEX1dJRFRILCBCSVJEX0hFSUdIVCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGBCaXJkIGltYWdlIGF0IGluZGV4ICR7Y3VycmVudEJpcmRGcmFtZVJlZi5jdXJyZW50fSBub3QgbG9hZGVkIHlldC5gKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdQaXBlcyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xyXG4gICAgICBmb3IgKGNvbnN0IHBpcGUgb2YgcGlwZXNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UocGlwZVRvcCwgcGlwZS54LCAwLCBQSVBFX1dJRFRILCBwaXBlLnRvcEhlaWdodCk7XHJcbiAgICAgICAgY3R4LmRyYXdJbWFnZShwaXBlQm90dG9tLCBwaXBlLngsIHBpcGUuYm90dG9tWSwgUElQRV9XSURUSCwgcGlwZS5ib3R0b21IZWlnaHQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd0NvaW5zKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XHJcbiAgICAgIGNvbnN0IHNjYWxlWCA9IE1hdGguYWJzKE1hdGguY29zKGNvaW5Sb3RhdGlvblN0ZXBSZWYuY3VycmVudCAqIE1hdGguUEkgKiAyKSk7XHJcbiAgICAgIGNvbnN0IGhhbGZTaXplID0gQ09JTl9TSVpFIC8gMjtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgY29pbiBvZiBjb2luc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgaWYgKCFjb2luLmNvbGxlY3RlZCkge1xyXG4gICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgIGN0eC50cmFuc2xhdGUoY29pbi54ICsgaGFsZlNpemUsIGNvaW4ueSArIGhhbGZTaXplKTtcclxuICAgICAgICAgIGN0eC5zY2FsZShzY2FsZVgsIDEpO1xyXG4gICAgICAgICAgY3R4LmRyYXdJbWFnZShjb2luSW1hZ2UsIC1oYWxmU2l6ZSwgLWhhbGZTaXplLCBDT0lOX1NJWkUsIENPSU5fU0laRSk7XHJcbiAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBpcGUoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkge1xyXG4gICAgICBjb25zdCBwaXBlSGVpZ2h0ID1cclxuICAgICAgICBNYXRoLnJhbmRvbSgpICogKGNhbnZhcy5oZWlnaHQgLSBQSVBFX1NQQUNJTkcgLSAxMDApICsgNTA7XHJcbiAgICAgIGNvbnN0IGJvdHRvbVkgPSBwaXBlSGVpZ2h0ICsgUElQRV9TUEFDSU5HO1xyXG4gICAgICBwaXBlc1JlZi5jdXJyZW50LnB1c2goe1xyXG4gICAgICAgIHg6IGNhbnZhcy53aWR0aCxcclxuICAgICAgICB0b3BIZWlnaHQ6IHBpcGVIZWlnaHQsXHJcbiAgICAgICAgYm90dG9tWSxcclxuICAgICAgICBib3R0b21IZWlnaHQ6IGNhbnZhcy5oZWlnaHQgLSBib3R0b21ZLFxyXG4gICAgICAgIHNjb3JlZDogZmFsc2UsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gNTAlIGNoYW5jZSB0byBzcGF3biBhIGNvaW5cclxuICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPiAwLjUpIHtcclxuICAgICAgICBjb2luc1JlZi5jdXJyZW50LnB1c2goe1xyXG4gICAgICAgICAgeDogY2FudmFzLndpZHRoICsgUElQRV9XSURUSCAvIDIgLSBDT0lOX1NJWkUgLyAyLFxyXG4gICAgICAgICAgeTogcGlwZUhlaWdodCArIFBJUEVfU1BBQ0lORyAvIDIgLSBDT0lOX1NJWkUgLyAyLFxyXG4gICAgICAgICAgd2lkdGg6IENPSU5fU0laRSxcclxuICAgICAgICAgIGhlaWdodDogQ09JTl9TSVpFLFxyXG4gICAgICAgICAgY29sbGVjdGVkOiBmYWxzZSxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1vdmVQaXBlc0FuZENvaW5zKCkge1xyXG4gICAgICBmb3IgKGNvbnN0IHBpcGUgb2YgcGlwZXNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIHBpcGUueCAtPSAyO1xyXG4gICAgICB9XHJcbiAgICAgIHBpcGVzUmVmLmN1cnJlbnQgPSBwaXBlc1JlZi5jdXJyZW50LmZpbHRlcihcclxuICAgICAgICAocGlwZSkgPT4gcGlwZS54ICsgUElQRV9XSURUSCA+IDBcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgY29pbiBvZiBjb2luc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY29pbi54IC09IDI7XHJcbiAgICAgIH1cclxuICAgICAgY29pbnNSZWYuY3VycmVudCA9IGNvaW5zUmVmLmN1cnJlbnQuZmlsdGVyKFxyXG4gICAgICAgIChjb2luKSA9PiBjb2luLnggKyBjb2luLndpZHRoID4gMCAmJiAhY29pbi5jb2xsZWN0ZWRcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjaGVja0NvbGxpc2lvbnMoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCk6IGJvb2xlYW4ge1xyXG4gICAgICBpZiAoYmlyZFlSZWYuY3VycmVudCA8IDAgfHwgYmlyZFlSZWYuY3VycmVudCArIEJJUkRfSEVJR0hUID4gY2FudmFzLmhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBiaXJkTGVmdCA9IDEwMDtcclxuICAgICAgY29uc3QgYmlyZFJpZ2h0ID0gYmlyZExlZnQgKyBCSVJEX1dJRFRIO1xyXG4gICAgICBjb25zdCBiaXJkVG9wID0gYmlyZFlSZWYuY3VycmVudDtcclxuICAgICAgY29uc3QgYmlyZEJvdHRvbSA9IGJpcmRZUmVmLmN1cnJlbnQgKyBCSVJEX0hFSUdIVDtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgcGlwZSBvZiBwaXBlc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY29uc3Qgd2l0aGluUGlwZVggPVxyXG4gICAgICAgICAgYmlyZFJpZ2h0ID4gcGlwZS54ICYmIGJpcmRMZWZ0IDwgcGlwZS54ICsgUElQRV9XSURUSDtcclxuICAgICAgICBjb25zdCB3aXRoaW5QaXBlWSA9XHJcbiAgICAgICAgICBiaXJkVG9wIDwgcGlwZS50b3BIZWlnaHQgfHwgYmlyZEJvdHRvbSA+IHBpcGUuYm90dG9tWTtcclxuICAgICAgICBpZiAod2l0aGluUGlwZVggJiYgd2l0aGluUGlwZVkpIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2hlY2tDb2luQ29sbGVjdGlvbigpIHtcclxuICAgICAgY29uc3QgYmlyZExlZnQgPSAxMDA7XHJcbiAgICAgIGNvbnN0IGJpcmRSaWdodCA9IGJpcmRMZWZ0ICsgQklSRF9XSURUSDtcclxuICAgICAgY29uc3QgYmlyZFRvcCA9IGJpcmRZUmVmLmN1cnJlbnQ7XHJcbiAgICAgIGNvbnN0IGJpcmRCb3R0b20gPSBiaXJkWVJlZi5jdXJyZW50ICsgQklSRF9IRUlHSFQ7XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGNvaW4gb2YgY29pbnNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGlmICghY29pbi5jb2xsZWN0ZWQpIHtcclxuICAgICAgICAgIGNvbnN0IGNvaW5MZWZ0ID0gY29pbi54O1xyXG4gICAgICAgICAgY29uc3QgY29pblJpZ2h0ID0gY29pbi54ICsgY29pbi53aWR0aDtcclxuICAgICAgICAgIGNvbnN0IGNvaW5Ub3AgPSBjb2luLnk7XHJcbiAgICAgICAgICBjb25zdCBjb2luQm90dG9tID0gY29pbi55ICsgY29pbi5oZWlnaHQ7XHJcblxyXG4gICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICBiaXJkUmlnaHQgPiBjb2luTGVmdCAmJlxyXG4gICAgICAgICAgICBiaXJkTGVmdCA8IGNvaW5SaWdodCAmJlxyXG4gICAgICAgICAgICBiaXJkQm90dG9tID4gY29pblRvcCAmJlxyXG4gICAgICAgICAgICBiaXJkVG9wIDwgY29pbkJvdHRvbVxyXG4gICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIGNvaW4uY29sbGVjdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgc2V0Q3VycmVudFNjb3JlKChwcmV2U2NvcmUpID0+IHtcclxuICAgICAgICAgICAgICBjb25zdCBuZXdTY29yZSA9IHByZXZTY29yZSArIDU7XHJcbiAgICAgICAgICAgICAgc2V0SGlnaFNjb3JlKChwcmV2SGlnaFNjb3JlKSA9PlxyXG4gICAgICAgICAgICAgICAgTWF0aC5tYXgocHJldkhpZ2hTY29yZSwgbmV3U2NvcmUpXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICByZXR1cm4gbmV3U2NvcmU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZVNjb3JlKCkge1xyXG4gICAgICBmb3IgKGNvbnN0IHBpcGUgb2YgcGlwZXNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGlmICghcGlwZS5zY29yZWQgJiYgcGlwZS54ICsgUElQRV9XSURUSCA8IDEwMCkge1xyXG4gICAgICAgICAgc2V0Q3VycmVudFNjb3JlKChwcmV2U2NvcmUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbmV3U2NvcmUgPSBwcmV2U2NvcmUgKyAxO1xyXG4gICAgICAgICAgICBzZXRIaWdoU2NvcmUoKHByZXZIaWdoU2NvcmUpID0+IHtcclxuICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkSGlnaFNjb3JlID0gTWF0aC5tYXgocHJldkhpZ2hTY29yZSwgbmV3U2NvcmUpO1xyXG5cclxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJoaWdoU2NvcmVcIiwgdXBkYXRlZEhpZ2hTY29yZS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZWRIaWdoU2NvcmU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3U2NvcmU7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHBpcGUuc2NvcmVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgaGFuZGxlS2V5RG93bik7XHJcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGhhbmRsZVJlc2l6ZSk7XHJcbiAgICAgIGlmIChyZXF1ZXN0SWRSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJlcXVlc3RJZFJlZi5jdXJyZW50KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9LCBbY2FudmFzUmVmLCBpc1BhdXNlZCwgYXV0b1N0YXJ0XSk7XHJcblxyXG4gIHJldHVybiB7IGhpZ2hTY29yZSwgY3VycmVudFNjb3JlIH07XHJcbn1cclxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwiR1JBVklUWSIsIkZMQVAiLCJQSVBFX1dJRFRIIiwiUElQRV9TUEFDSU5HIiwiQklSRF9XSURUSCIsIkJJUkRfSEVJR0hUIiwiQ09JTl9TSVpFIiwiUk9UQVRJT05fU1BFRUQiLCJQSVBFX1NQQVdOX0ZSQU1FUyIsInVzZUZsYXBweUJpcmRHYW1lIiwiY2FudmFzUmVmIiwiaXNQYXVzZWQiLCJhdXRvU3RhcnQiLCJyZXF1ZXN0SWRSZWYiLCJoaWdoU2NvcmUiLCJzZXRIaWdoU2NvcmUiLCJjdXJyZW50U2NvcmUiLCJzZXRDdXJyZW50U2NvcmUiLCJiaXJkWVJlZiIsImJpcmRWZWxvY2l0eVJlZiIsInBpcGVzUmVmIiwiY29pbnNSZWYiLCJnYW1lT3ZlclJlZiIsImdhbWVTdGFydGVkUmVmIiwiY29pblJvdGF0aW9uU3RlcFJlZiIsImZyYW1lc1JlZiIsImJpcmRJbWFnZXMiLCJwaXBlVG9wIiwicGlwZUJvdHRvbSIsImJhY2tncm91bmQiLCJjb2luSW1hZ2UiLCJiaXJkVXAiLCJJbWFnZSIsInNyYyIsImJpcmRNaWQiLCJiaXJkRG93biIsImN1cnJlbnRCaXJkRnJhbWVSZWYiLCJhbmltYXRpb25GcmFtZVJlZiIsInN0b3JlZEhpZ2hTY29yZSIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJwYXJzZUludCIsImNhbnZhcyIsImN1cnJlbnQiLCJjdHgiLCJnZXRDb250ZXh0IiwibG9hZEltYWdlIiwiaW1nIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJjb21wbGV0ZSIsIm9ubG9hZCIsIm9uZXJyb3IiLCJFcnJvciIsImxvYWRBc3NldHMiLCJhbGwiLCJtYXAiLCJjb25zb2xlIiwibG9nIiwiaW5pdGlhbGl6ZUdhbWUiLCJlcnJvciIsInJlc2V0R2FtZSIsImMiLCJ3aWR0aCIsImhlaWdodCIsImhhbmRsZUtleURvd24iLCJlIiwia2V5Iiwic3RhcnRHYW1lIiwiZmxhcCIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJoYW5kbGVSZXNpemUiLCJkcmF3U3RhcnRTY3JlZW4iLCJhbmltYXRlIiwic2V0VGltZW91dCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNvbnRleHQiLCJ1cGRhdGVHYW1lU3RhdGUiLCJkcmF3IiwiZHJhd0dhbWVPdmVyU2NyZWVuIiwiY3JlYXRlUGlwZSIsIm1vdmVQaXBlc0FuZENvaW5zIiwiY2hlY2tDb2luQ29sbGVjdGlvbiIsImNoZWNrQ29sbGlzaW9ucyIsInVwZGF0ZVNjb3JlIiwiY2xlYXJSZWN0IiwiZHJhd0JhY2tncm91bmQiLCJkcmF3QmlyZCIsImRyYXdQaXBlcyIsImRyYXdDb2lucyIsImZvbnQiLCJ0ZXh0QWxpZ24iLCJmaWxsU3R5bGUiLCJzaGFkb3dDb2xvciIsInRleHRCYXNlbGluZSIsImZpbGxUZXh0Iiwic2hhZG93Qmx1ciIsImRyYXdJbWFnZSIsImN1cnJlbnRJbWFnZSIsIndhcm4iLCJwaXBlIiwieCIsInRvcEhlaWdodCIsImJvdHRvbVkiLCJib3R0b21IZWlnaHQiLCJzY2FsZVgiLCJNYXRoIiwiYWJzIiwiY29zIiwiUEkiLCJoYWxmU2l6ZSIsImNvaW4iLCJjb2xsZWN0ZWQiLCJzYXZlIiwidHJhbnNsYXRlIiwieSIsInNjYWxlIiwicmVzdG9yZSIsInBpcGVIZWlnaHQiLCJyYW5kb20iLCJwdXNoIiwic2NvcmVkIiwiZmlsdGVyIiwiYmlyZExlZnQiLCJiaXJkUmlnaHQiLCJiaXJkVG9wIiwiYmlyZEJvdHRvbSIsIndpdGhpblBpcGVYIiwid2l0aGluUGlwZVkiLCJjb2luTGVmdCIsImNvaW5SaWdodCIsImNvaW5Ub3AiLCJjb2luQm90dG9tIiwicHJldlNjb3JlIiwibmV3U2NvcmUiLCJwcmV2SGlnaFNjb3JlIiwibWF4IiwidXBkYXRlZEhpZ2hTY29yZSIsInNldEl0ZW0iLCJ0b1N0cmluZyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjYW5jZWxBbmltYXRpb25GcmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./public/useFlappyBirdGame.ts\n"));

/***/ })

});