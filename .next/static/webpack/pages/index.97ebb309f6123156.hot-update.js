"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./public/useFlappyBirdGame.ts":
/*!*************************************!*\
  !*** ./public/useFlappyBirdGame.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFlappyBirdGame: function() { return /* binding */ useFlappyBirdGame; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n// Constants\nconst GRAVITY = 0.25;\nconst FLAP = -7.5;\nconst PIPE_WIDTH = 90;\nconst PIPE_SPACING = 250;\nconst BIRD_WIDTH = 50;\nconst BIRD_HEIGHT = 50;\nconst COIN_SIZE = 100;\nconst ROTATION_SPEED = 0.005;\n// How often to spawn pipes in terms of frames\n// ~100 frames at ~60fps is ~1.66 seconds. Adjust as needed\nconst PIPE_SPAWN_FRAMES = 100;\nfunction useFlappyBirdGame(canvasRef, isPaused, autoStart) {\n    const requestIdRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // State refs\n    const [highScore, setHighScore] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [currentScore, setCurrentScore] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const currentBirdFrameRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const birdYRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const birdVelocityRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const pipesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const coinsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const gameOverRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const gameStartedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const coinRotationStepRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const framesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0); // Count frames\n    // Assets\n    let birdImages = [];\n    let pipeTop;\n    let pipeBottom;\n    let background;\n    let coinImage;\n    if (true) {\n        const birdUp = new Image();\n        birdUp.src = \"/assets/redbird-upflap.png\";\n        const birdMid = new Image();\n        birdMid.src = \"/assets/redbird-midflap.png\";\n        const birdDown = new Image();\n        birdDown.src = \"/assets/redbird-downflap.png\";\n        birdImages = [\n            birdUp,\n            birdMid,\n            birdDown\n        ];\n        pipeTop = new Image();\n        pipeTop.src = \"/assets/TopTiny.png\";\n        pipeBottom = new Image();\n        pipeBottom.src = \"/assets/BottomTiny.png\";\n        background = new Image();\n        background.src = \"/assets/background-day.png\";\n        coinImage = new Image();\n        coinImage.src = \"/assets/CoinTiny.png\";\n    }\n    // Load high score from localStorage after mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (true) {\n            const storedHighScore = localStorage.getItem(\"highScore\");\n            if (storedHighScore) {\n                setHighScore(parseInt(storedHighScore, 10));\n            }\n        }\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        function resetGame() {\n            const c = canvasRef.current;\n            if (!c) return;\n            const { width, height } = c;\n            birdYRef.current = height / 3;\n            birdVelocityRef.current = 0;\n            pipesRef.current = [];\n            coinsRef.current = [];\n            setCurrentScore(0);\n            gameOverRef.current = false;\n            gameStartedRef.current = false;\n            coinRotationStepRef.current = 0;\n            framesRef.current = 0;\n        }\n        function handleKeyDown(e) {\n            if (e.key === \" \") {\n                if (!gameStartedRef.current && !gameOverRef.current) {\n                    startGame();\n                } else if (gameOverRef.current) {\n                    startGame();\n                } else {\n                    birdVelocityRef.current = FLAP;\n                    flap();\n                }\n            }\n        }\n        background.onload = ()=>{\n            console.log(\"Background image loaded!\");\n            const canvas = canvasRef.current;\n            if (canvas) {\n                const ctx = canvas.getContext(\"2d\");\n                if (ctx) initializeGame();\n            }\n        };\n        window.addEventListener(\"keydown\", handleKeyDown);\n        function handleResize() {\n            const c = canvasRef.current;\n            if (!c) return;\n            c.width = 360;\n            c.height = 640;\n            if (!gameStartedRef.current && !gameOverRef.current && ctx) {\n                drawStartScreen(ctx, c);\n            }\n        }\n        window.addEventListener(\"resize\", handleResize);\n        // Initialize the game\n        const initializeGame = ()=>{\n            canvas.width = 360;\n            canvas.height = 640;\n            drawStartScreen(ctx, canvas);\n        };\n        initializeGame();\n        function startGame() {\n            resetGame();\n            gameStartedRef.current = true;\n            animate(); // Start the loop\n        }\n        function animate() {\n            if (isPaused || !gameStartedRef.current) {\n                // If paused or not started, just request next frame without updating state\n                requestIdRef.current = requestAnimationFrame(animate);\n                return;\n            }\n            const c = canvasRef.current;\n            if (!c) return;\n            const context = c.getContext(\"2d\");\n            if (!context) return;\n            updateGameState(c);\n            draw(context, c);\n            if (!gameOverRef.current) {\n                requestIdRef.current = requestAnimationFrame(animate);\n            } else {\n                drawGameOverScreen(context, c);\n            }\n        }\n        function updateGameState(canvas) {\n            framesRef.current++;\n            // Gravity\n            birdVelocityRef.current += GRAVITY;\n            birdYRef.current += birdVelocityRef.current;\n            // Spawn pipes every PIPE_SPAWN_FRAMES frames\n            if (framesRef.current % PIPE_SPAWN_FRAMES === 0) {\n                createPipe(canvas);\n            }\n            movePipesAndCoins();\n            checkCoinCollection();\n            // Check collisions after movement\n            if (checkCollisions(canvas)) {\n                gameOverRef.current = true;\n                return;\n            }\n            updateScore();\n            // Rotate coin a bit each frame\n            coinRotationStepRef.current += ROTATION_SPEED;\n            if (coinRotationStepRef.current >= 1) coinRotationStepRef.current = 0;\n        }\n        function draw(ctx, canvas) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawBackground(ctx, canvas);\n            drawBird(ctx);\n            drawPipes(ctx);\n            drawCoins(ctx);\n        }\n        function drawStartScreen(ctx, canvas) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawBackground(ctx, canvas);\n            ctx.font = \"bold 30px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.fillStyle = \"#ffffff\";\n            ctx.shadowColor = \"black\";\n            ctx.textBaseline = \"middle\";\n            ctx.fillText(\"Press Space to Start\", canvas.width / 2, canvas.height / 2);\n        }\n        function drawGameOverScreen(ctx, canvas) {\n            ctx.fillStyle = \"#ffcc00\";\n            ctx.font = \"bold 50px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"middle\";\n            ctx.shadowColor = \"black\";\n            ctx.shadowBlur = 10;\n            ctx.fillText(\"Game Over!\", canvas.width / 2, canvas.height / 2 - 40);\n            ctx.fillStyle = \"#ffffff\";\n            ctx.font = \"bold 30px Arial\";\n            ctx.fillText(\"Press Space to Restart\", canvas.width / 2, canvas.height / 2 + 20);\n            ctx.fillStyle = \"#ffff00\";\n            ctx.font = \"30px Arial\";\n        }\n        function drawBackground(ctx, canvas) {\n            ctx.drawImage(background, 0, 0, canvas.width, canvas.height);\n        }\n        function drawBird(ctx) {\n            const currentImage = birdImages[currentBirdFrameRef.current];\n            if (currentImage.complete) {\n                ctx.drawImage(currentImage, 100, birdYRef.current, BIRD_WIDTH, BIRD_HEIGHT);\n            } else {\n                // Optionally, handle the case where the image hasn't loaded yet\n                console.warn(\"Bird image at index \".concat(currentBirdFrameRef.current, \" not loaded yet.\"));\n            }\n        }\n        function drawPipes(ctx) {\n            for (const pipe of pipesRef.current){\n                ctx.drawImage(pipeTop, pipe.x, 0, PIPE_WIDTH, pipe.topHeight);\n                ctx.drawImage(pipeBottom, pipe.x, pipe.bottomY, PIPE_WIDTH, pipe.bottomHeight);\n            }\n        }\n        function drawCoins(ctx) {\n            const scaleX = Math.abs(Math.cos(coinRotationStepRef.current * Math.PI * 2));\n            const halfSize = COIN_SIZE / 2;\n            for (const coin of coinsRef.current){\n                if (!coin.collected) {\n                    ctx.save();\n                    ctx.translate(coin.x + halfSize, coin.y + halfSize);\n                    ctx.scale(scaleX, 1);\n                    ctx.drawImage(coinImage, -halfSize, -halfSize, COIN_SIZE, COIN_SIZE);\n                    ctx.restore();\n                }\n            }\n        }\n        function createPipe(canvas) {\n            const pipeHeight = Math.random() * (canvas.height - PIPE_SPACING - 100) + 50;\n            const bottomY = pipeHeight + PIPE_SPACING;\n            pipesRef.current.push({\n                x: canvas.width,\n                topHeight: pipeHeight,\n                bottomY,\n                bottomHeight: canvas.height - bottomY,\n                scored: false\n            });\n            // 50% chance to spawn a coin\n            if (Math.random() > 0.5) {\n                coinsRef.current.push({\n                    x: canvas.width + PIPE_WIDTH / 2 - COIN_SIZE / 2,\n                    y: pipeHeight + PIPE_SPACING / 2 - COIN_SIZE / 2,\n                    width: COIN_SIZE,\n                    height: COIN_SIZE,\n                    collected: false\n                });\n            }\n        }\n        function movePipesAndCoins() {\n            for (const pipe of pipesRef.current){\n                pipe.x -= 2;\n            }\n            pipesRef.current = pipesRef.current.filter((pipe)=>pipe.x + PIPE_WIDTH > 0);\n            for (const coin of coinsRef.current){\n                coin.x -= 2;\n            }\n            coinsRef.current = coinsRef.current.filter((coin)=>coin.x + coin.width > 0 && !coin.collected);\n        }\n        const flap = ()=>{\n            currentBirdFrameRef.current = 1;\n            setTimeout(()=>{\n                currentBirdFrameRef.current = 2;\n                setTimeout(()=>{\n                    currentBirdFrameRef.current = 0;\n                }, 100);\n            }, 100);\n        };\n        function checkCollisions(canvas) {\n            if (birdYRef.current < 0 || birdYRef.current + BIRD_HEIGHT > canvas.height) {\n                return true;\n            }\n            const birdLeft = 100;\n            const birdRight = birdLeft + BIRD_WIDTH;\n            const birdTop = birdYRef.current;\n            const birdBottom = birdYRef.current + BIRD_HEIGHT;\n            for (const pipe of pipesRef.current){\n                const withinPipeX = birdRight > pipe.x && birdLeft < pipe.x + PIPE_WIDTH;\n                const withinPipeY = birdTop < pipe.topHeight || birdBottom > pipe.bottomY;\n                if (withinPipeX && withinPipeY) return true;\n            }\n            return false;\n        }\n        function checkCoinCollection() {\n            const birdLeft = 100;\n            const birdRight = birdLeft + BIRD_WIDTH;\n            const birdTop = birdYRef.current;\n            const birdBottom = birdYRef.current + BIRD_HEIGHT;\n            for (const coin of coinsRef.current){\n                if (!coin.collected) {\n                    const coinLeft = coin.x;\n                    const coinRight = coin.x + coin.width;\n                    const coinTop = coin.y;\n                    const coinBottom = coin.y + coin.height;\n                    if (birdRight > coinLeft && birdLeft < coinRight && birdBottom > coinTop && birdTop < coinBottom) {\n                        coin.collected = true;\n                        setCurrentScore((prevScore)=>{\n                            const newScore = prevScore + 5;\n                            setHighScore((prevHighScore)=>Math.max(prevHighScore, newScore));\n                            return newScore;\n                        });\n                    }\n                }\n            }\n        }\n        function updateScore() {\n            for (const pipe of pipesRef.current){\n                if (!pipe.scored && pipe.x + PIPE_WIDTH < 100) {\n                    setCurrentScore((prevScore)=>{\n                        const newScore = prevScore + 1;\n                        setHighScore((prevHighScore)=>{\n                            const updatedHighScore = Math.max(prevHighScore, newScore);\n                            if (true) {\n                                localStorage.setItem(\"highScore\", updatedHighScore.toString());\n                            }\n                            return updatedHighScore;\n                        });\n                        return newScore;\n                    });\n                    pipe.scored = true;\n                }\n            }\n        }\n        return ()=>{\n            window.removeEventListener(\"keydown\", handleKeyDown);\n            window.removeEventListener(\"resize\", handleResize);\n            if (requestIdRef.current) {\n                cancelAnimationFrame(requestIdRef.current);\n            }\n        };\n    }, [\n        canvasRef,\n        isPaused,\n        autoStart\n    ]);\n    return {\n        highScore,\n        currentScore\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0lBRW5DLE9BQU87UUFBRUU7UUFBV0U7SUFBYTtBQUNuQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wdWJsaWMvdXNlRmxhcHB5QmlyZEdhbWUudHM/NWM3OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcclxuXHJcbi8vIFR5cGVzIGZvciBnYW1lIG9iamVjdHNcclxuaW50ZXJmYWNlIFBpcGUge1xyXG4gIHg6IG51bWJlcjtcclxuICB0b3BIZWlnaHQ6IG51bWJlcjtcclxuICBib3R0b21ZOiBudW1iZXI7XHJcbiAgYm90dG9tSGVpZ2h0OiBudW1iZXI7XHJcbiAgc2NvcmVkOiBib29sZWFuO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgQ29pbiB7XHJcbiAgeDogbnVtYmVyO1xyXG4gIHk6IG51bWJlcjtcclxuICB3aWR0aDogbnVtYmVyO1xyXG4gIGhlaWdodDogbnVtYmVyO1xyXG4gIGNvbGxlY3RlZDogYm9vbGVhbjtcclxufVxyXG5cclxuLy8gQ29uc3RhbnRzXHJcbmNvbnN0IEdSQVZJVFkgPSAwLjI1O1xyXG5jb25zdCBGTEFQID0gLTcuNTtcclxuY29uc3QgUElQRV9XSURUSCA9IDkwO1xyXG5jb25zdCBQSVBFX1NQQUNJTkcgPSAyNTA7XHJcbmNvbnN0IEJJUkRfV0lEVEggPSA1MDtcclxuY29uc3QgQklSRF9IRUlHSFQgPSA1MDtcclxuY29uc3QgQ09JTl9TSVpFID0gMTAwO1xyXG5jb25zdCBST1RBVElPTl9TUEVFRCA9IDAuMDA1O1xyXG5cclxuLy8gSG93IG9mdGVuIHRvIHNwYXduIHBpcGVzIGluIHRlcm1zIG9mIGZyYW1lc1xyXG4vLyB+MTAwIGZyYW1lcyBhdCB+NjBmcHMgaXMgfjEuNjYgc2Vjb25kcy4gQWRqdXN0IGFzIG5lZWRlZFxyXG5jb25zdCBQSVBFX1NQQVdOX0ZSQU1FUyA9IDEwMDtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VGbGFwcHlCaXJkR2FtZShjYW52YXNSZWY6IFJlYWN0LlJlZk9iamVjdDxIVE1MQ2FudmFzRWxlbWVudD4sIGlzUGF1c2VkOiBib29sZWFuLCBhdXRvU3RhcnQ6IGJvb2xlYW4pIHtcclxuICAgIGNvbnN0IHJlcXVlc3RJZFJlZiA9IHVzZVJlZjxudW1iZXIgfCBudWxsPihudWxsKTtcclxuICBcclxuICAvLyBTdGF0ZSByZWZzXHJcbiAgY29uc3QgW2hpZ2hTY29yZSwgc2V0SGlnaFNjb3JlXSA9IHVzZVN0YXRlKDApO1xyXG4gIGNvbnN0IFtjdXJyZW50U2NvcmUsIHNldEN1cnJlbnRTY29yZV0gPSB1c2VTdGF0ZSgwKTtcclxuXHJcbiAgY29uc3QgY3VycmVudEJpcmRGcmFtZVJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xyXG4gIGNvbnN0IGJpcmRZUmVmID0gdXNlUmVmPG51bWJlcj4oMCk7XHJcbiAgY29uc3QgYmlyZFZlbG9jaXR5UmVmID0gdXNlUmVmPG51bWJlcj4oMCk7XHJcbiAgY29uc3QgcGlwZXNSZWYgPSB1c2VSZWY8UGlwZVtdPihbXSk7XHJcbiAgY29uc3QgY29pbnNSZWYgPSB1c2VSZWY8Q29pbltdPihbXSk7XHJcbiAgY29uc3QgZ2FtZU92ZXJSZWYgPSB1c2VSZWY8Ym9vbGVhbj4oZmFsc2UpO1xyXG4gIGNvbnN0IGdhbWVTdGFydGVkUmVmID0gdXNlUmVmPGJvb2xlYW4+KGZhbHNlKTtcclxuXHJcbiAgY29uc3QgY29pblJvdGF0aW9uU3RlcFJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xyXG4gIGNvbnN0IGZyYW1lc1JlZiA9IHVzZVJlZjxudW1iZXI+KDApOyAvLyBDb3VudCBmcmFtZXNcclxuXHJcbi8vIEFzc2V0c1xyXG5sZXQgYmlyZEltYWdlczogSFRNTEltYWdlRWxlbWVudFtdID0gW107XHJcbmxldCBwaXBlVG9wOiBIVE1MSW1hZ2VFbGVtZW50O1xyXG5sZXQgcGlwZUJvdHRvbTogSFRNTEltYWdlRWxlbWVudDtcclxubGV0IGJhY2tncm91bmQ6IEhUTUxJbWFnZUVsZW1lbnQ7XHJcbmxldCBjb2luSW1hZ2U6IEhUTUxJbWFnZUVsZW1lbnQ7XHJcblxyXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gIGNvbnN0IGJpcmRVcCA9IG5ldyBJbWFnZSgpO1xyXG4gIGJpcmRVcC5zcmMgPSBcIi9hc3NldHMvcmVkYmlyZC11cGZsYXAucG5nXCI7XHJcblxyXG4gIGNvbnN0IGJpcmRNaWQgPSBuZXcgSW1hZ2UoKTtcclxuICBiaXJkTWlkLnNyYyA9IFwiL2Fzc2V0cy9yZWRiaXJkLW1pZGZsYXAucG5nXCI7XHJcblxyXG4gIGNvbnN0IGJpcmREb3duID0gbmV3IEltYWdlKCk7XHJcbiAgYmlyZERvd24uc3JjID0gXCIvYXNzZXRzL3JlZGJpcmQtZG93bmZsYXAucG5nXCI7XHJcblxyXG4gIGJpcmRJbWFnZXMgPSBbYmlyZFVwLCBiaXJkTWlkLCBiaXJkRG93bl07XHJcblxyXG4gIHBpcGVUb3AgPSBuZXcgSW1hZ2UoKTtcclxuICBwaXBlVG9wLnNyYyA9IFwiL2Fzc2V0cy9Ub3BUaW55LnBuZ1wiO1xyXG5cclxuICBwaXBlQm90dG9tID0gbmV3IEltYWdlKCk7XHJcbiAgcGlwZUJvdHRvbS5zcmMgPSBcIi9hc3NldHMvQm90dG9tVGlueS5wbmdcIjtcclxuXHJcbiAgYmFja2dyb3VuZCA9IG5ldyBJbWFnZSgpO1xyXG4gIGJhY2tncm91bmQuc3JjID0gXCIvYXNzZXRzL2JhY2tncm91bmQtZGF5LnBuZ1wiO1xyXG5cclxuICBjb2luSW1hZ2UgPSBuZXcgSW1hZ2UoKTtcclxuICBjb2luSW1hZ2Uuc3JjID0gXCIvYXNzZXRzL0NvaW5UaW55LnBuZ1wiO1xyXG59XHJcbiAgXHJcbiAgLy8gTG9hZCBoaWdoIHNjb3JlIGZyb20gbG9jYWxTdG9yYWdlIGFmdGVyIG1vdW50XHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgIGNvbnN0IHN0b3JlZEhpZ2hTY29yZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwiaGlnaFNjb3JlXCIpO1xyXG4gICAgICBpZiAoc3RvcmVkSGlnaFNjb3JlKSB7XHJcbiAgICAgICAgc2V0SGlnaFNjb3JlKHBhcnNlSW50KHN0b3JlZEhpZ2hTY29yZSwgMTApKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sIFtdKTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xyXG4gICAgaWYgKCFjYW52YXMpIHJldHVybjtcclxuXHJcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgaWYgKCFjdHgpIHJldHVybjtcclxuXHJcbiAgICBmdW5jdGlvbiByZXNldEdhbWUoKSB7XHJcbiAgICAgIGNvbnN0IGMgPSBjYW52YXNSZWYuY3VycmVudDtcclxuICAgICAgaWYgKCFjKSByZXR1cm47XHJcbiAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gYztcclxuXHJcbiAgICAgIGJpcmRZUmVmLmN1cnJlbnQgPSBoZWlnaHQgLyAzO1xyXG4gICAgICBiaXJkVmVsb2NpdHlSZWYuY3VycmVudCA9IDA7XHJcbiAgICAgIHBpcGVzUmVmLmN1cnJlbnQgPSBbXTtcclxuICAgICAgY29pbnNSZWYuY3VycmVudCA9IFtdO1xyXG4gICAgICBzZXRDdXJyZW50U2NvcmUoMCk7XHJcbiAgICAgIGdhbWVPdmVyUmVmLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgICAgZ2FtZVN0YXJ0ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xyXG4gICAgICBjb2luUm90YXRpb25TdGVwUmVmLmN1cnJlbnQgPSAwO1xyXG4gICAgICBmcmFtZXNSZWYuY3VycmVudCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlS2V5RG93bihlOiBLZXlib2FyZEV2ZW50KSB7XHJcbiAgICAgIGlmIChlLmtleSA9PT0gXCIgXCIpIHtcclxuICAgICAgICBpZiAoIWdhbWVTdGFydGVkUmVmLmN1cnJlbnQgJiYgIWdhbWVPdmVyUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgIHN0YXJ0R2FtZSgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZ2FtZU92ZXJSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgc3RhcnRHYW1lKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGJpcmRWZWxvY2l0eVJlZi5jdXJyZW50ID0gRkxBUDtcclxuICAgICAgICAgIGZsYXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBiYWNrZ3JvdW5kLm9ubG9hZCA9ICgpID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIkJhY2tncm91bmQgaW1hZ2UgbG9hZGVkIVwiKTtcclxuICAgICAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcclxuICAgICAgICBpZiAoY2FudmFzKSB7XHJcbiAgICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgICAgICAgaWYgKGN0eCkgaW5pdGlhbGl6ZUdhbWUoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGhhbmRsZUtleURvd24pO1xyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZVJlc2l6ZSgpIHtcclxuICAgICAgY29uc3QgYyA9IGNhbnZhc1JlZi5jdXJyZW50O1xyXG4gICAgICBpZiAoIWMpIHJldHVybjtcclxuICAgICAgYy53aWR0aCA9IDM2MDtcclxuICAgICAgYy5oZWlnaHQgPSA2NDA7XHJcblxyXG4gICAgICBpZiAoIWdhbWVTdGFydGVkUmVmLmN1cnJlbnQgJiYgIWdhbWVPdmVyUmVmLmN1cnJlbnQgJiYgY3R4KSB7XHJcbiAgICAgICAgZHJhd1N0YXJ0U2NyZWVuKGN0eCwgYyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGhhbmRsZVJlc2l6ZSk7XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgZ2FtZVxyXG4gICAgY29uc3QgaW5pdGlhbGl6ZUdhbWUgPSAoKSA9PiB7XHJcbiAgICAgICAgY2FudmFzLndpZHRoID0gMzYwO1xyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSA2NDA7XHJcbiAgICAgICAgZHJhd1N0YXJ0U2NyZWVuKGN0eCwgY2FudmFzKTtcclxuICAgIH07XHJcblxyXG4gICAgaW5pdGlhbGl6ZUdhbWUoKTtcclxuXHJcbiAgICBmdW5jdGlvbiBzdGFydEdhbWUoKSB7XHJcbiAgICAgIHJlc2V0R2FtZSgpO1xyXG4gICAgICBnYW1lU3RhcnRlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcclxuICAgICAgYW5pbWF0ZSgpOyAvLyBTdGFydCB0aGUgbG9vcFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFuaW1hdGUoKSB7XHJcbiAgICAgIGlmIChpc1BhdXNlZCB8fCAhZ2FtZVN0YXJ0ZWRSZWYuY3VycmVudCkge1xyXG4gICAgICAgIC8vIElmIHBhdXNlZCBvciBub3Qgc3RhcnRlZCwganVzdCByZXF1ZXN0IG5leHQgZnJhbWUgd2l0aG91dCB1cGRhdGluZyBzdGF0ZVxyXG4gICAgICAgIHJlcXVlc3RJZFJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgYyA9IGNhbnZhc1JlZi5jdXJyZW50O1xyXG4gICAgICBpZiAoIWMpIHJldHVybjtcclxuICAgICAgY29uc3QgY29udGV4dCA9IGMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgICBpZiAoIWNvbnRleHQpIHJldHVybjtcclxuXHJcbiAgICAgIHVwZGF0ZUdhbWVTdGF0ZShjKTtcclxuICAgICAgZHJhdyhjb250ZXh0LCBjKTtcclxuXHJcbiAgICAgIGlmICghZ2FtZU92ZXJSZWYuY3VycmVudCkge1xyXG4gICAgICAgIHJlcXVlc3RJZFJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRyYXdHYW1lT3ZlclNjcmVlbihjb250ZXh0LCBjKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZUdhbWVTdGF0ZShjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgIGZyYW1lc1JlZi5jdXJyZW50Kys7XHJcblxyXG4gICAgICAvLyBHcmF2aXR5XHJcbiAgICAgIGJpcmRWZWxvY2l0eVJlZi5jdXJyZW50ICs9IEdSQVZJVFk7XHJcbiAgICAgIGJpcmRZUmVmLmN1cnJlbnQgKz0gYmlyZFZlbG9jaXR5UmVmLmN1cnJlbnQ7XHJcblxyXG4gICAgICAvLyBTcGF3biBwaXBlcyBldmVyeSBQSVBFX1NQQVdOX0ZSQU1FUyBmcmFtZXNcclxuICAgICAgaWYgKGZyYW1lc1JlZi5jdXJyZW50ICUgUElQRV9TUEFXTl9GUkFNRVMgPT09IDApIHtcclxuICAgICAgICBjcmVhdGVQaXBlKGNhbnZhcyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG1vdmVQaXBlc0FuZENvaW5zKCk7XHJcbiAgICAgIGNoZWNrQ29pbkNvbGxlY3Rpb24oKTtcclxuXHJcbiAgICAgIC8vIENoZWNrIGNvbGxpc2lvbnMgYWZ0ZXIgbW92ZW1lbnRcclxuICAgICAgaWYgKGNoZWNrQ29sbGlzaW9ucyhjYW52YXMpKSB7XHJcbiAgICAgICAgZ2FtZU92ZXJSZWYuY3VycmVudCA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB1cGRhdGVTY29yZSgpO1xyXG5cclxuICAgICAgLy8gUm90YXRlIGNvaW4gYSBiaXQgZWFjaCBmcmFtZVxyXG4gICAgICBjb2luUm90YXRpb25TdGVwUmVmLmN1cnJlbnQgKz0gUk9UQVRJT05fU1BFRUQ7XHJcbiAgICAgIGlmIChjb2luUm90YXRpb25TdGVwUmVmLmN1cnJlbnQgPj0gMSkgY29pblJvdGF0aW9uU3RlcFJlZi5jdXJyZW50ID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3KGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICAgICAgZHJhd0JhY2tncm91bmQoY3R4LCBjYW52YXMpO1xyXG4gICAgICBkcmF3QmlyZChjdHgpO1xyXG4gICAgICBkcmF3UGlwZXMoY3R4KTtcclxuICAgICAgZHJhd0NvaW5zKGN0eCk7XHJcbiAgICB9XHJcblxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBkcmF3U3RhcnRTY3JlZW4oY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcclxuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICBkcmF3QmFja2dyb3VuZChjdHgsIGNhbnZhcyk7XHJcbiAgICAgIGN0eC5mb250ID0gXCJib2xkIDMwcHggQXJpYWxcIjtcclxuICAgICAgY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAnI2ZmZmZmZic7XHJcbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9ICdibGFjayc7XHJcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcclxuICAgICAgY3R4LmZpbGxUZXh0KFwiUHJlc3MgU3BhY2UgdG8gU3RhcnRcIiwgY2FudmFzLndpZHRoIC8gMiwgY2FudmFzLmhlaWdodCAvIDIpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdHYW1lT3ZlclNjcmVlbihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkge1xyXG4gICAgICBjdHguZmlsbFN0eWxlID0gJyNmZmNjMDAnO1xyXG4gICAgICBjdHguZm9udCA9ICdib2xkIDUwcHggQXJpYWwnO1xyXG4gICAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XHJcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcclxuICAgICAgY3R4LnNoYWRvd0NvbG9yID0gJ2JsYWNrJztcclxuICAgICAgY3R4LnNoYWRvd0JsdXIgPSAxMDtcclxuXHJcbiAgICAgIGN0eC5maWxsVGV4dCgnR2FtZSBPdmVyIScsIGNhbnZhcy53aWR0aCAvIDIsIGNhbnZhcy5oZWlnaHQgLyAyIC0gNDApO1xyXG5cclxuICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjZmZmZmZmJztcclxuICAgICAgY3R4LmZvbnQgPSAnYm9sZCAzMHB4IEFyaWFsJztcclxuICAgICAgY3R4LmZpbGxUZXh0KCdQcmVzcyBTcGFjZSB0byBSZXN0YXJ0JywgY2FudmFzLndpZHRoIC8gMiwgY2FudmFzLmhlaWdodCAvIDIgKyAyMCk7XHJcblxyXG4gICAgICBjdHguZmlsbFN0eWxlID0gJyNmZmZmMDAnO1xyXG4gICAgICBjdHguZm9udCA9ICczMHB4IEFyaWFsJztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3QmFja2dyb3VuZChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkge1xyXG4gICAgICBjdHguZHJhd0ltYWdlKGJhY2tncm91bmQsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd0JpcmQoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcclxuICAgICAgY29uc3QgY3VycmVudEltYWdlID0gYmlyZEltYWdlc1tjdXJyZW50QmlyZEZyYW1lUmVmLmN1cnJlbnRdO1xyXG4gICAgICBpZiAoY3VycmVudEltYWdlLmNvbXBsZXRlKSB7XHJcbiAgICAgICAgY3R4LmRyYXdJbWFnZShjdXJyZW50SW1hZ2UsIDEwMCwgYmlyZFlSZWYuY3VycmVudCwgQklSRF9XSURUSCwgQklSRF9IRUlHSFQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIE9wdGlvbmFsbHksIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0aGUgaW1hZ2UgaGFzbid0IGxvYWRlZCB5ZXRcclxuICAgICAgICBjb25zb2xlLndhcm4oYEJpcmQgaW1hZ2UgYXQgaW5kZXggJHtjdXJyZW50QmlyZEZyYW1lUmVmLmN1cnJlbnR9IG5vdCBsb2FkZWQgeWV0LmApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd1BpcGVzKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XHJcbiAgICAgIGZvciAoY29uc3QgcGlwZSBvZiBwaXBlc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY3R4LmRyYXdJbWFnZShwaXBlVG9wLCBwaXBlLngsIDAsIFBJUEVfV0lEVEgsIHBpcGUudG9wSGVpZ2h0KTtcclxuICAgICAgICBjdHguZHJhd0ltYWdlKHBpcGVCb3R0b20sIHBpcGUueCwgcGlwZS5ib3R0b21ZLCBQSVBFX1dJRFRILCBwaXBlLmJvdHRvbUhlaWdodCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3Q29pbnMoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcclxuICAgICAgY29uc3Qgc2NhbGVYID0gTWF0aC5hYnMoTWF0aC5jb3MoY29pblJvdGF0aW9uU3RlcFJlZi5jdXJyZW50ICogTWF0aC5QSSAqIDIpKTtcclxuICAgICAgY29uc3QgaGFsZlNpemUgPSBDT0lOX1NJWkUgLyAyO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBjb2luIG9mIGNvaW5zUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBpZiAoIWNvaW4uY29sbGVjdGVkKSB7XHJcbiAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgY3R4LnRyYW5zbGF0ZShjb2luLnggKyBoYWxmU2l6ZSwgY29pbi55ICsgaGFsZlNpemUpO1xyXG4gICAgICAgICAgY3R4LnNjYWxlKHNjYWxlWCwgMSk7XHJcbiAgICAgICAgICBjdHguZHJhd0ltYWdlKGNvaW5JbWFnZSwgLWhhbGZTaXplLCAtaGFsZlNpemUsIENPSU5fU0laRSwgQ09JTl9TSVpFKTtcclxuICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlUGlwZShjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgIGNvbnN0IHBpcGVIZWlnaHQgPSBNYXRoLnJhbmRvbSgpICogKGNhbnZhcy5oZWlnaHQgLSBQSVBFX1NQQUNJTkcgLSAxMDApICsgNTA7XHJcbiAgICAgIGNvbnN0IGJvdHRvbVkgPSBwaXBlSGVpZ2h0ICsgUElQRV9TUEFDSU5HO1xyXG4gICAgICBwaXBlc1JlZi5jdXJyZW50LnB1c2goe1xyXG4gICAgICAgIHg6IGNhbnZhcy53aWR0aCxcclxuICAgICAgICB0b3BIZWlnaHQ6IHBpcGVIZWlnaHQsXHJcbiAgICAgICAgYm90dG9tWSxcclxuICAgICAgICBib3R0b21IZWlnaHQ6IGNhbnZhcy5oZWlnaHQgLSBib3R0b21ZLFxyXG4gICAgICAgIHNjb3JlZDogZmFsc2VcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyA1MCUgY2hhbmNlIHRvIHNwYXduIGEgY29pblxyXG4gICAgICBpZiAoTWF0aC5yYW5kb20oKSA+IDAuNSkge1xyXG4gICAgICAgIGNvaW5zUmVmLmN1cnJlbnQucHVzaCh7XHJcbiAgICAgICAgICB4OiBjYW52YXMud2lkdGggKyBQSVBFX1dJRFRIIC8gMiAtIENPSU5fU0laRSAvIDIsXHJcbiAgICAgICAgICB5OiBwaXBlSGVpZ2h0ICsgUElQRV9TUEFDSU5HIC8gMiAtIENPSU5fU0laRSAvIDIsXHJcbiAgICAgICAgICB3aWR0aDogQ09JTl9TSVpFLFxyXG4gICAgICAgICAgaGVpZ2h0OiBDT0lOX1NJWkUsXHJcbiAgICAgICAgICBjb2xsZWN0ZWQ6IGZhbHNlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtb3ZlUGlwZXNBbmRDb2lucygpIHtcclxuICAgICAgZm9yIChjb25zdCBwaXBlIG9mIHBpcGVzUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBwaXBlLnggLT0gMjtcclxuICAgICAgfVxyXG4gICAgICBwaXBlc1JlZi5jdXJyZW50ID0gcGlwZXNSZWYuY3VycmVudC5maWx0ZXIocGlwZSA9PiBwaXBlLnggKyBQSVBFX1dJRFRIID4gMCk7XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGNvaW4gb2YgY29pbnNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGNvaW4ueCAtPSAyO1xyXG4gICAgICB9XHJcbiAgICAgIGNvaW5zUmVmLmN1cnJlbnQgPSBjb2luc1JlZi5jdXJyZW50LmZpbHRlcihjb2luID0+IGNvaW4ueCArIGNvaW4ud2lkdGggPiAwICYmICFjb2luLmNvbGxlY3RlZCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZmxhcCA9ICgpID0+IHtcclxuICAgICAgY3VycmVudEJpcmRGcmFtZVJlZi5jdXJyZW50ID0gMTsgXHJcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIGN1cnJlbnRCaXJkRnJhbWVSZWYuY3VycmVudCA9IDI7XHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICBjdXJyZW50QmlyZEZyYW1lUmVmLmN1cnJlbnQgPSAwOyBcclxuICAgICAgICB9LCAxMDApOyBcclxuICAgICAgfSwgMTAwKTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gY2hlY2tDb2xsaXNpb25zKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpOiBib29sZWFuIHtcclxuICAgICAgaWYgKGJpcmRZUmVmLmN1cnJlbnQgPCAwIHx8IGJpcmRZUmVmLmN1cnJlbnQgKyBCSVJEX0hFSUdIVCA+IGNhbnZhcy5oZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgYmlyZExlZnQgPSAxMDA7XHJcbiAgICAgIGNvbnN0IGJpcmRSaWdodCA9IGJpcmRMZWZ0ICsgQklSRF9XSURUSDtcclxuICAgICAgY29uc3QgYmlyZFRvcCA9IGJpcmRZUmVmLmN1cnJlbnQ7XHJcbiAgICAgIGNvbnN0IGJpcmRCb3R0b20gPSBiaXJkWVJlZi5jdXJyZW50ICsgQklSRF9IRUlHSFQ7XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IHBpcGUgb2YgcGlwZXNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGNvbnN0IHdpdGhpblBpcGVYID0gYmlyZFJpZ2h0ID4gcGlwZS54ICYmIGJpcmRMZWZ0IDwgcGlwZS54ICsgUElQRV9XSURUSDtcclxuICAgICAgICBjb25zdCB3aXRoaW5QaXBlWSA9IGJpcmRUb3AgPCBwaXBlLnRvcEhlaWdodCB8fCBiaXJkQm90dG9tID4gcGlwZS5ib3R0b21ZO1xyXG4gICAgICAgIGlmICh3aXRoaW5QaXBlWCAmJiB3aXRoaW5QaXBlWSkgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjaGVja0NvaW5Db2xsZWN0aW9uKCkge1xyXG4gICAgICBjb25zdCBiaXJkTGVmdCA9IDEwMDtcclxuICAgICAgY29uc3QgYmlyZFJpZ2h0ID0gYmlyZExlZnQgKyBCSVJEX1dJRFRIO1xyXG4gICAgICBjb25zdCBiaXJkVG9wID0gYmlyZFlSZWYuY3VycmVudDtcclxuICAgICAgY29uc3QgYmlyZEJvdHRvbSA9IGJpcmRZUmVmLmN1cnJlbnQgKyBCSVJEX0hFSUdIVDtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgY29pbiBvZiBjb2luc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgaWYgKCFjb2luLmNvbGxlY3RlZCkge1xyXG4gICAgICAgICAgY29uc3QgY29pbkxlZnQgPSBjb2luLng7XHJcbiAgICAgICAgICBjb25zdCBjb2luUmlnaHQgPSBjb2luLnggKyBjb2luLndpZHRoO1xyXG4gICAgICAgICAgY29uc3QgY29pblRvcCA9IGNvaW4ueTtcclxuICAgICAgICAgIGNvbnN0IGNvaW5Cb3R0b20gPSBjb2luLnkgKyBjb2luLmhlaWdodDtcclxuXHJcbiAgICAgICAgICBpZiAoYmlyZFJpZ2h0ID4gY29pbkxlZnQgJiYgYmlyZExlZnQgPCBjb2luUmlnaHQgJiYgYmlyZEJvdHRvbSA+IGNvaW5Ub3AgJiYgYmlyZFRvcCA8IGNvaW5Cb3R0b20pIHtcclxuICAgICAgICAgICAgY29pbi5jb2xsZWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBzZXRDdXJyZW50U2NvcmUoKHByZXZTY29yZSkgPT4ge1xyXG4gICAgICAgICAgICAgIGNvbnN0IG5ld1Njb3JlID0gcHJldlNjb3JlICsgNTsgICAgICBcclxuICAgICAgICAgICAgICBzZXRIaWdoU2NvcmUoKHByZXZIaWdoU2NvcmUpID0+IE1hdGgubWF4KHByZXZIaWdoU2NvcmUsIG5ld1Njb3JlKSk7ICAgICAgIFxyXG4gICAgICAgICAgICAgIHJldHVybiBuZXdTY29yZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdXBkYXRlU2NvcmUoKSB7XHJcbiAgICAgIGZvciAoY29uc3QgcGlwZSBvZiBwaXBlc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgaWYgKCFwaXBlLnNjb3JlZCAmJiBwaXBlLnggKyBQSVBFX1dJRFRIIDwgMTAwKSB7XHJcbiAgICAgICAgICAgIHNldEN1cnJlbnRTY29yZSgocHJldlNjb3JlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdTY29yZSA9IHByZXZTY29yZSArIDE7XHJcbiAgICAgICAgICAgICAgICBzZXRIaWdoU2NvcmUoKHByZXZIaWdoU2NvcmUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZEhpZ2hTY29yZSA9IE1hdGgubWF4KHByZXZIaWdoU2NvcmUsIG5ld1Njb3JlKTtcclxuICAgICAgXHJcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJoaWdoU2NvcmVcIiwgdXBkYXRlZEhpZ2hTY29yZS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlZEhpZ2hTY29yZTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld1Njb3JlO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgcGlwZS5zY29yZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBoYW5kbGVLZXlEb3duKTtcclxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgaGFuZGxlUmVzaXplKTtcclxuICAgICAgaWYgKHJlcXVlc3RJZFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmVxdWVzdElkUmVmLmN1cnJlbnQpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH0sIFtjYW52YXNSZWYsIGlzUGF1c2VkLCBhdXRvU3RhcnRdKTtcclxuXHJcbiAgcmV0dXJuIHsgaGlnaFNjb3JlLCBjdXJyZW50U2NvcmUgfTtcclxufVxyXG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJHUkFWSVRZIiwiRkxBUCIsIlBJUEVfV0lEVEgiLCJQSVBFX1NQQUNJTkciLCJCSVJEX1dJRFRIIiwiQklSRF9IRUlHSFQiLCJDT0lOX1NJWkUiLCJST1RBVElPTl9TUEVFRCIsIlBJUEVfU1BBV05fRlJBTUVTIiwidXNlRmxhcHB5QmlyZEdhbWUiLCJjYW52YXNSZWYiLCJpc1BhdXNlZCIsImF1dG9TdGFydCIsInJlcXVlc3RJZFJlZiIsImhpZ2hTY29yZSIsInNldEhpZ2hTY29yZSIsImN1cnJlbnRTY29yZSIsInNldEN1cnJlbnRTY29yZSIsImN1cnJlbnRCaXJkRnJhbWVSZWYiLCJiaXJkWVJlZiIsImJpcmRWZWxvY2l0eVJlZiIsInBpcGVzUmVmIiwiY29pbnNSZWYiLCJnYW1lT3ZlclJlZiIsImdhbWVTdGFydGVkUmVmIiwiY29pblJvdGF0aW9uU3RlcFJlZiIsImZyYW1lc1JlZiIsImJpcmRJbWFnZXMiLCJwaXBlVG9wIiwicGlwZUJvdHRvbSIsImJhY2tncm91bmQiLCJjb2luSW1hZ2UiLCJiaXJkVXAiLCJJbWFnZSIsInNyYyIsImJpcmRNaWQiLCJiaXJkRG93biIsInN0b3JlZEhpZ2hTY29yZSIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJwYXJzZUludCIsImNhbnZhcyIsImN1cnJlbnQiLCJjdHgiLCJnZXRDb250ZXh0IiwicmVzZXRHYW1lIiwiYyIsIndpZHRoIiwiaGVpZ2h0IiwiaGFuZGxlS2V5RG93biIsImUiLCJrZXkiLCJzdGFydEdhbWUiLCJmbGFwIiwib25sb2FkIiwiY29uc29sZSIsImxvZyIsImluaXRpYWxpemVHYW1lIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsImhhbmRsZVJlc2l6ZSIsImRyYXdTdGFydFNjcmVlbiIsImFuaW1hdGUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjb250ZXh0IiwidXBkYXRlR2FtZVN0YXRlIiwiZHJhdyIsImRyYXdHYW1lT3ZlclNjcmVlbiIsImNyZWF0ZVBpcGUiLCJtb3ZlUGlwZXNBbmRDb2lucyIsImNoZWNrQ29pbkNvbGxlY3Rpb24iLCJjaGVja0NvbGxpc2lvbnMiLCJ1cGRhdGVTY29yZSIsImNsZWFyUmVjdCIsImRyYXdCYWNrZ3JvdW5kIiwiZHJhd0JpcmQiLCJkcmF3UGlwZXMiLCJkcmF3Q29pbnMiLCJmb250IiwidGV4dEFsaWduIiwiZmlsbFN0eWxlIiwic2hhZG93Q29sb3IiLCJ0ZXh0QmFzZWxpbmUiLCJmaWxsVGV4dCIsInNoYWRvd0JsdXIiLCJkcmF3SW1hZ2UiLCJjdXJyZW50SW1hZ2UiLCJjb21wbGV0ZSIsIndhcm4iLCJwaXBlIiwieCIsInRvcEhlaWdodCIsImJvdHRvbVkiLCJib3R0b21IZWlnaHQiLCJzY2FsZVgiLCJNYXRoIiwiYWJzIiwiY29zIiwiUEkiLCJoYWxmU2l6ZSIsImNvaW4iLCJjb2xsZWN0ZWQiLCJzYXZlIiwidHJhbnNsYXRlIiwieSIsInNjYWxlIiwicmVzdG9yZSIsInBpcGVIZWlnaHQiLCJyYW5kb20iLCJwdXNoIiwic2NvcmVkIiwiZmlsdGVyIiwic2V0VGltZW91dCIsImJpcmRMZWZ0IiwiYmlyZFJpZ2h0IiwiYmlyZFRvcCIsImJpcmRCb3R0b20iLCJ3aXRoaW5QaXBlWCIsIndpdGhpblBpcGVZIiwiY29pbkxlZnQiLCJjb2luUmlnaHQiLCJjb2luVG9wIiwiY29pbkJvdHRvbSIsInByZXZTY29yZSIsIm5ld1Njb3JlIiwicHJldkhpZ2hTY29yZSIsIm1heCIsInVwZGF0ZWRIaWdoU2NvcmUiLCJzZXRJdGVtIiwidG9TdHJpbmciLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./public/useFlappyBirdGame.ts\n"));

/***/ })

});