"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./public/useFlappyBirdGame.ts":
/*!*************************************!*\
  !*** ./public/useFlappyBirdGame.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFlappyBirdGame: function() { return /* binding */ useFlappyBirdGame; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n// Constants\nconst GRAVITY = 0.25;\nconst FLAP = -7.5;\nconst PIPE_WIDTH = 90;\nconst PIPE_SPACING = 250;\nconst BIRD_WIDTH = 50;\nconst BIRD_HEIGHT = 50;\n// For performance, let's reduce coin size or rotation\nconst COIN_SIZE = 80;\nconst ROTATION_SPEED = 0.002; // Reduced from 0.005\n// Increase spawn frames => fewer pipes\nconst PIPE_SPAWN_FRAMES = 120;\n// Limit FPS to 30\nconst TARGET_FPS = 30;\nconst FRAME_DURATION = 1000 / TARGET_FPS;\nfunction useFlappyBirdGame(canvasRef, isPaused, autoStart) {\n    const requestIdRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // State\n    const [highScore, setHighScore] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [currentScore, setCurrentScore] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    // Refs for game logic\n    const birdYRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const birdVelocityRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const pipesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const coinsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const gameOverRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const gameStartedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const coinRotationStepRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const framesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const currentBirdFrameRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // For frame-limiting:\n    const lastTimeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // Assets\n    let birdImages = [];\n    let pipeTop;\n    let pipeBottom;\n    let background;\n    let coinImage;\n    if (true) {\n        const birdUp = new Image();\n        birdUp.src = \"/assets/redbird-upflap.png\";\n        const birdMid = new Image();\n        birdMid.src = \"/assets/redbird-midflap.png\";\n        const birdDown = new Image();\n        birdDown.src = \"/assets/redbird-downflap.png\";\n        birdImages = [\n            birdUp,\n            birdMid,\n            birdDown\n        ];\n        pipeTop = new Image();\n        pipeTop.src = \"/assets/TopTiny.png\";\n        pipeBottom = new Image();\n        pipeBottom.src = \"/assets/BottomTiny.png\";\n        background = new Image();\n        background.src = \"/assets/background-day.png\";\n        coinImage = new Image();\n        coinImage.src = \"/assets/CoinTiny.png\";\n    }\n    // Load high score from localStorage\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (true) {\n            const storedHighScore = localStorage.getItem(\"highScore\");\n            if (storedHighScore) {\n                setHighScore(parseInt(storedHighScore, 10));\n            }\n        }\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        // Helper to load images fully\n        const loadImage = (img)=>{\n            return new Promise((resolve, reject)=>{\n                if (img.complete) {\n                    resolve();\n                } else {\n                    img.onload = ()=>resolve();\n                    img.onerror = ()=>reject(new Error(\"Failed to load image: \".concat(img.src)));\n                }\n            });\n        };\n        // Preload assets\n        const loadAssets = async ()=>{\n            try {\n                await Promise.all([\n                    ...birdImages.map((img)=>loadImage(img)),\n                    loadImage(pipeTop),\n                    loadImage(pipeBottom),\n                    loadImage(background),\n                    loadImage(coinImage)\n                ]);\n                console.log(\"All assets loaded!\");\n                initializeGame();\n            } catch (error) {\n                console.error(\"Error loading assets:\", error);\n            }\n        };\n        loadAssets();\n        // Set up the canvas once assets are loaded\n        function initializeGame() {\n            if (!canvasRef.current) return;\n            // We'll rely on the parent to set a smaller dimension (e.g. 270Ã—480).\n            // Draw the start screen:\n            drawStartScreen(ctx, canvasRef.current);\n        }\n        function resetGame() {\n            if (!canvasRef.current) return;\n            const { height } = canvasRef.current;\n            birdYRef.current = height / 3;\n            birdVelocityRef.current = 0;\n            pipesRef.current = [];\n            coinsRef.current = [];\n            setCurrentScore(0);\n            gameOverRef.current = false;\n            gameStartedRef.current = false;\n            coinRotationStepRef.current = 0;\n            framesRef.current = 0;\n            currentBirdFrameRef.current = 0;\n        }\n        function handleKeyDown(e) {\n            if (e.key === \" \") {\n                if (!gameStartedRef.current && !gameOverRef.current) {\n                    startGame();\n                } else if (gameOverRef.current) {\n                    startGame();\n                } else {\n                    birdVelocityRef.current = FLAP;\n                    flap();\n                }\n            }\n        }\n        window.addEventListener(\"keydown\", handleKeyDown);\n        // Optional: If you want to dynamically reset or resize the canvas\n        // do it here, but we've set a smaller dimension in the parent.\n        // Draw start screen\n        function startGame() {\n            resetGame();\n            gameStartedRef.current = true;\n            lastTimeRef.current = 0; // Reset for frame-limiting\n            animate(0);\n        }\n        function handleUserInput() {\n            if (!gameStartedRef.current && !gameOverRef.current) {\n                startGame();\n            } else if (gameOverRef.current) {\n                startGame();\n            } else {\n                birdVelocityRef.current = FLAP;\n                flap();\n            }\n        }\n        const flap = ()=>{\n            // Quick 3-frame flap\n            currentBirdFrameRef.current = 1;\n            setTimeout(()=>{\n                currentBirdFrameRef.current = 2;\n                setTimeout(()=>{\n                    currentBirdFrameRef.current = 0;\n                }, 170);\n            }, 170);\n        };\n        // The main loop with FPS limit\n        function animate(timestamp) {\n            if (isPaused || !gameStartedRef.current) {\n                requestIdRef.current = requestAnimationFrame(animate);\n                return;\n            }\n            if (!canvasRef.current) return;\n            const context = canvasRef.current.getContext(\"2d\");\n            if (!context) return;\n            // Frame-limiting logic\n            const delta = timestamp - lastTimeRef.current;\n            if (delta < FRAME_DURATION) {\n                requestIdRef.current = requestAnimationFrame(animate);\n                return;\n            }\n            lastTimeRef.current = timestamp;\n            updateGameState(canvasRef.current);\n            draw(context, canvasRef.current);\n            if (!gameOverRef.current) {\n                requestIdRef.current = requestAnimationFrame(animate);\n            } else {\n                drawGameOverScreen(context, canvasRef.current);\n            }\n        }\n        function updateGameState(canvas) {\n            framesRef.current++;\n            // Gravity\n            birdVelocityRef.current += GRAVITY;\n            birdYRef.current += birdVelocityRef.current;\n            // Spawn pipes less frequently\n            if (framesRef.current % PIPE_SPAWN_FRAMES === 0) {\n                createPipe(canvas);\n            }\n            movePipesAndCoins();\n            checkCoinCollection();\n            // Collisions\n            if (checkCollisions(canvas)) {\n                gameOverRef.current = true;\n                return;\n            }\n            updateScore();\n            // Coin rotation\n            coinRotationStepRef.current += ROTATION_SPEED;\n            if (coinRotationStepRef.current >= 1) {\n                coinRotationStepRef.current = 0;\n            }\n        }\n        function draw(ctx, canvas) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawBackground(ctx, canvas);\n            drawBird(ctx);\n            drawPipes(ctx);\n            drawCoins(ctx);\n        }\n        function drawStartScreen(ctx, canvas) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawBackground(ctx, canvas);\n            ctx.font = \"bold 22px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.fillStyle = \"#ffffff\";\n            ctx.shadowColor = \"black\";\n            ctx.shadowBlur = 2;\n            ctx.textBaseline = \"middle\";\n            ctx.fillText(\"Press Space or Tap to Start\", canvas.width / 2, canvas.height / 2);\n        }\n        function drawGameOverScreen(ctx, canvas) {\n            ctx.fillStyle = \"#ffcc00\";\n            ctx.font = \"bold 36px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"middle\";\n            ctx.shadowColor = \"black\";\n            ctx.shadowBlur = 6;\n            ctx.fillText(\"Game Over!\", canvas.width / 2, canvas.height / 2 - 30);\n            ctx.fillStyle = \"#ffffff\";\n            ctx.font = \"bold 20px Arial\";\n            ctx.fillText(\"Press Space or Tap to Restart\", canvas.width / 2, canvas.height / 2 + 10);\n        }\n        function drawBackground(ctx, canvas) {\n            ctx.drawImage(background, 0, 0, canvas.width, canvas.height);\n        }\n        function drawBird(ctx) {\n            const currentImage = birdImages[currentBirdFrameRef.current];\n            if (currentImage.complete) {\n                ctx.drawImage(currentImage, 100, birdYRef.current, BIRD_WIDTH, BIRD_HEIGHT);\n            }\n        }\n        function drawPipes(ctx) {\n            for (const pipe of pipesRef.current){\n                ctx.drawImage(pipeTop, pipe.x, 0, PIPE_WIDTH, pipe.topHeight);\n                ctx.drawImage(pipeBottom, pipe.x, pipe.bottomY, PIPE_WIDTH, pipe.bottomHeight);\n            }\n        }\n        function drawCoins(ctx) {\n            const scaleX = Math.abs(Math.cos(coinRotationStepRef.current * Math.PI * 2));\n            const halfSize = COIN_SIZE / 2;\n            for (const coin of coinsRef.current){\n                if (!coin.collected) {\n                    ctx.save();\n                    ctx.translate(coin.x + halfSize, coin.y + halfSize);\n                    // The smaller rotation speed might make it appear mostly stable.\n                    ctx.scale(scaleX, 1);\n                    ctx.drawImage(coinImage, -halfSize, -halfSize, COIN_SIZE, COIN_SIZE);\n                    ctx.restore();\n                }\n            }\n        }\n        function createPipe(canvas) {\n            const pipeHeight = Math.random() * (canvas.height - PIPE_SPACING - 100) + 50;\n            const bottomY = pipeHeight + PIPE_SPACING;\n            pipesRef.current.push({\n                x: canvas.width,\n                topHeight: pipeHeight,\n                bottomY,\n                bottomHeight: canvas.height - bottomY,\n                scored: false\n            });\n            // Spawn coin only 25% chance\n            if (Math.random() > 0.75) {\n                coinsRef.current.push({\n                    x: canvas.width + PIPE_WIDTH / 2 - COIN_SIZE / 2,\n                    y: pipeHeight + PIPE_SPACING / 2 - COIN_SIZE / 2,\n                    width: COIN_SIZE,\n                    height: COIN_SIZE,\n                    collected: false\n                });\n            }\n        }\n        function movePipesAndCoins() {\n            for (const pipe of pipesRef.current){\n                // Move slower if you want to reduce CPU load (1 px per frame)\n                pipe.x -= 2;\n            }\n            pipesRef.current = pipesRef.current.filter((pipe)=>pipe.x + PIPE_WIDTH > 0);\n            for (const coin of coinsRef.current){\n                coin.x -= 2;\n            }\n            coinsRef.current = coinsRef.current.filter((coin)=>coin.x + coin.width > 0 && !coin.collected);\n        }\n        function checkCollisions(canvas) {\n            // Bird out of bounds\n            if (birdYRef.current < 0 || birdYRef.current + BIRD_HEIGHT > canvas.height) {\n                return true;\n            }\n            const birdLeft = 100;\n            const birdRight = birdLeft + BIRD_WIDTH;\n            const birdTop = birdYRef.current;\n            const birdBottom = birdYRef.current + BIRD_HEIGHT;\n            // Pipe collision\n            for (const pipe of pipesRef.current){\n                const withinPipeX = birdRight > pipe.x && birdLeft < pipe.x + PIPE_WIDTH;\n                const withinPipeY = birdTop < pipe.topHeight || birdBottom > pipe.bottomY;\n                if (withinPipeX && withinPipeY) return true;\n            }\n            return false;\n        }\n        function checkCoinCollection() {\n            const birdLeft = 100;\n            const birdRight = birdLeft + BIRD_WIDTH;\n            const birdTop = birdYRef.current;\n            const birdBottom = birdYRef.current + BIRD_HEIGHT;\n            for (const coin of coinsRef.current){\n                if (!coin.collected) {\n                    const coinLeft = coin.x;\n                    const coinRight = coin.x + coin.width;\n                    const coinTop = coin.y;\n                    const coinBottom = coin.y + coin.height;\n                    if (birdRight > coinLeft && birdLeft < coinRight && birdBottom > coinTop && birdTop < coinBottom) {\n                        coin.collected = true;\n                        setCurrentScore((prevScore)=>{\n                            const newScore = prevScore + 5;\n                            setHighScore((prevHighScore)=>Math.max(prevHighScore, newScore));\n                            return newScore;\n                        });\n                    }\n                }\n            }\n        }\n        function updateScore() {\n            for (const pipe of pipesRef.current){\n                // Score +1 for passing each pipe once\n                if (!pipe.scored && pipe.x + PIPE_WIDTH < 100) {\n                    setCurrentScore((prevScore)=>{\n                        const newScore = prevScore + 1;\n                        setHighScore((prevHighScore)=>{\n                            const updatedHighScore = Math.max(prevHighScore, newScore);\n                            if (true) {\n                                localStorage.setItem(\"highScore\", updatedHighScore.toString());\n                            }\n                            return updatedHighScore;\n                        });\n                        return newScore;\n                    });\n                    pipe.scored = true;\n                }\n            }\n        }\n        // Cleanup\n        return ()=>{\n            window.removeEventListener(\"keydown\", handleKeyDown);\n            if (requestIdRef.current) {\n                cancelAnimationFrame(requestIdRef.current);\n            }\n        };\n    }, [\n        canvasRef,\n        isPaused,\n        autoStart\n    ]);\n    // Expose handleUserInput\n    const handleUserInput = ()=>{\n        // We'll dispatch a \"keydown\" event with keyCode for space as a quick hack\n        const spaceEvent = new KeyboardEvent(\"keydown\", {\n            key: \" \"\n        });\n        window.dispatchEvent(spaceEvent);\n    };\n    return {\n        highScore,\n        currentScore,\n        handleUserInput\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QmlyZEdhbWUudHM/NWM3OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcclxuXHJcbi8vIFR5cGVzXHJcbmludGVyZmFjZSBQaXBlIHtcclxuICB4OiBudW1iZXI7XHJcbiAgdG9wSGVpZ2h0OiBudW1iZXI7XHJcbiAgYm90dG9tWTogbnVtYmVyO1xyXG4gIGJvdHRvbUhlaWdodDogbnVtYmVyO1xyXG4gIHNjb3JlZDogYm9vbGVhbjtcclxufVxyXG5pbnRlcmZhY2UgQ29pbiB7XHJcbiAgeDogbnVtYmVyO1xyXG4gIHk6IG51bWJlcjtcclxuICB3aWR0aDogbnVtYmVyO1xyXG4gIGhlaWdodDogbnVtYmVyO1xyXG4gIGNvbGxlY3RlZDogYm9vbGVhbjtcclxufVxyXG5cclxuLy8gQ29uc3RhbnRzXHJcbmNvbnN0IEdSQVZJVFkgPSAwLjI1O1xyXG5jb25zdCBGTEFQID0gLTcuNTtcclxuY29uc3QgUElQRV9XSURUSCA9IDkwO1xyXG5jb25zdCBQSVBFX1NQQUNJTkcgPSAyNTA7XHJcbmNvbnN0IEJJUkRfV0lEVEggPSA1MDtcclxuY29uc3QgQklSRF9IRUlHSFQgPSA1MDtcclxuXHJcbi8vIEZvciBwZXJmb3JtYW5jZSwgbGV0J3MgcmVkdWNlIGNvaW4gc2l6ZSBvciByb3RhdGlvblxyXG5jb25zdCBDT0lOX1NJWkUgPSA4MDtcclxuY29uc3QgUk9UQVRJT05fU1BFRUQgPSAwLjAwMjsgLy8gUmVkdWNlZCBmcm9tIDAuMDA1XHJcblxyXG4vLyBJbmNyZWFzZSBzcGF3biBmcmFtZXMgPT4gZmV3ZXIgcGlwZXNcclxuY29uc3QgUElQRV9TUEFXTl9GUkFNRVMgPSAxMjA7XHJcblxyXG4vLyBMaW1pdCBGUFMgdG8gMzBcclxuY29uc3QgVEFSR0VUX0ZQUyA9IDMwO1xyXG5jb25zdCBGUkFNRV9EVVJBVElPTiA9IDEwMDAgLyBUQVJHRVRfRlBTO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUZsYXBweUJpcmRHYW1lKFxyXG4gIGNhbnZhc1JlZjogUmVhY3QuUmVmT2JqZWN0PEhUTUxDYW52YXNFbGVtZW50PixcclxuICBpc1BhdXNlZDogYm9vbGVhbixcclxuICBhdXRvU3RhcnQ6IGJvb2xlYW5cclxuKSB7XHJcbiAgY29uc3QgcmVxdWVzdElkUmVmID0gdXNlUmVmPG51bWJlciB8IG51bGw+KG51bGwpO1xyXG5cclxuICAvLyBTdGF0ZVxyXG4gIGNvbnN0IFtoaWdoU2NvcmUsIHNldEhpZ2hTY29yZV0gPSB1c2VTdGF0ZSgwKTtcclxuICBjb25zdCBbY3VycmVudFNjb3JlLCBzZXRDdXJyZW50U2NvcmVdID0gdXNlU3RhdGUoMCk7XHJcblxyXG4gIC8vIFJlZnMgZm9yIGdhbWUgbG9naWNcclxuICBjb25zdCBiaXJkWVJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xyXG4gIGNvbnN0IGJpcmRWZWxvY2l0eVJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xyXG4gIGNvbnN0IHBpcGVzUmVmID0gdXNlUmVmPFBpcGVbXT4oW10pO1xyXG4gIGNvbnN0IGNvaW5zUmVmID0gdXNlUmVmPENvaW5bXT4oW10pO1xyXG4gIGNvbnN0IGdhbWVPdmVyUmVmID0gdXNlUmVmPGJvb2xlYW4+KGZhbHNlKTtcclxuICBjb25zdCBnYW1lU3RhcnRlZFJlZiA9IHVzZVJlZjxib29sZWFuPihmYWxzZSk7XHJcblxyXG4gIGNvbnN0IGNvaW5Sb3RhdGlvblN0ZXBSZWYgPSB1c2VSZWY8bnVtYmVyPigwKTtcclxuICBjb25zdCBmcmFtZXNSZWYgPSB1c2VSZWY8bnVtYmVyPigwKTtcclxuXHJcbiAgY29uc3QgY3VycmVudEJpcmRGcmFtZVJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xyXG5cclxuICAvLyBGb3IgZnJhbWUtbGltaXRpbmc6XHJcbiAgY29uc3QgbGFzdFRpbWVSZWYgPSB1c2VSZWY8bnVtYmVyPigwKTtcclxuXHJcbiAgLy8gQXNzZXRzXHJcbiAgbGV0IGJpcmRJbWFnZXM6IEhUTUxJbWFnZUVsZW1lbnRbXSA9IFtdO1xyXG4gIGxldCBwaXBlVG9wOiBIVE1MSW1hZ2VFbGVtZW50O1xyXG4gIGxldCBwaXBlQm90dG9tOiBIVE1MSW1hZ2VFbGVtZW50O1xyXG4gIGxldCBiYWNrZ3JvdW5kOiBIVE1MSW1hZ2VFbGVtZW50O1xyXG4gIGxldCBjb2luSW1hZ2U6IEhUTUxJbWFnZUVsZW1lbnQ7XHJcblxyXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICBjb25zdCBiaXJkVXAgPSBuZXcgSW1hZ2UoKTtcclxuICAgIGJpcmRVcC5zcmMgPSBcIi9hc3NldHMvcmVkYmlyZC11cGZsYXAucG5nXCI7XHJcblxyXG4gICAgY29uc3QgYmlyZE1pZCA9IG5ldyBJbWFnZSgpO1xyXG4gICAgYmlyZE1pZC5zcmMgPSBcIi9hc3NldHMvcmVkYmlyZC1taWRmbGFwLnBuZ1wiO1xyXG5cclxuICAgIGNvbnN0IGJpcmREb3duID0gbmV3IEltYWdlKCk7XHJcbiAgICBiaXJkRG93bi5zcmMgPSBcIi9hc3NldHMvcmVkYmlyZC1kb3duZmxhcC5wbmdcIjtcclxuXHJcbiAgICBiaXJkSW1hZ2VzID0gW2JpcmRVcCwgYmlyZE1pZCwgYmlyZERvd25dO1xyXG5cclxuICAgIHBpcGVUb3AgPSBuZXcgSW1hZ2UoKTtcclxuICAgIHBpcGVUb3Auc3JjID0gXCIvYXNzZXRzL1RvcFRpbnkucG5nXCI7XHJcblxyXG4gICAgcGlwZUJvdHRvbSA9IG5ldyBJbWFnZSgpO1xyXG4gICAgcGlwZUJvdHRvbS5zcmMgPSBcIi9hc3NldHMvQm90dG9tVGlueS5wbmdcIjtcclxuXHJcbiAgICBiYWNrZ3JvdW5kID0gbmV3IEltYWdlKCk7XHJcbiAgICBiYWNrZ3JvdW5kLnNyYyA9IFwiL2Fzc2V0cy9iYWNrZ3JvdW5kLWRheS5wbmdcIjtcclxuXHJcbiAgICBjb2luSW1hZ2UgPSBuZXcgSW1hZ2UoKTtcclxuICAgIGNvaW5JbWFnZS5zcmMgPSBcIi9hc3NldHMvQ29pblRpbnkucG5nXCI7XHJcbiAgfVxyXG5cclxuICAvLyBMb2FkIGhpZ2ggc2NvcmUgZnJvbSBsb2NhbFN0b3JhZ2VcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgY29uc3Qgc3RvcmVkSGlnaFNjb3JlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJoaWdoU2NvcmVcIik7XHJcbiAgICAgIGlmIChzdG9yZWRIaWdoU2NvcmUpIHtcclxuICAgICAgICBzZXRIaWdoU2NvcmUocGFyc2VJbnQoc3RvcmVkSGlnaFNjb3JlLCAxMCkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSwgW10pO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XHJcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuO1xyXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuICAgIGlmICghY3R4KSByZXR1cm47XHJcblxyXG4gICAgLy8gSGVscGVyIHRvIGxvYWQgaW1hZ2VzIGZ1bGx5XHJcbiAgICBjb25zdCBsb2FkSW1hZ2UgPSAoaW1nOiBIVE1MSW1hZ2VFbGVtZW50KSA9PiB7XHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgaWYgKGltZy5jb21wbGV0ZSkge1xyXG4gICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpbWcub25sb2FkID0gKCkgPT4gcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgaW1nLm9uZXJyb3IgPSAoKSA9PlxyXG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBpbWFnZTogJHtpbWcuc3JjfWApKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBQcmVsb2FkIGFzc2V0c1xyXG4gICAgY29uc3QgbG9hZEFzc2V0cyA9IGFzeW5jICgpID0+IHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgICAuLi5iaXJkSW1hZ2VzLm1hcCgoaW1nKSA9PiBsb2FkSW1hZ2UoaW1nKSksXHJcbiAgICAgICAgICBsb2FkSW1hZ2UocGlwZVRvcCksXHJcbiAgICAgICAgICBsb2FkSW1hZ2UocGlwZUJvdHRvbSksXHJcbiAgICAgICAgICBsb2FkSW1hZ2UoYmFja2dyb3VuZCksXHJcbiAgICAgICAgICBsb2FkSW1hZ2UoY29pbkltYWdlKSxcclxuICAgICAgICBdKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIkFsbCBhc3NldHMgbG9hZGVkIVwiKTtcclxuICAgICAgICBpbml0aWFsaXplR2FtZSgpO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsb2FkaW5nIGFzc2V0czpcIiwgZXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGxvYWRBc3NldHMoKTtcclxuXHJcbiAgICAvLyBTZXQgdXAgdGhlIGNhbnZhcyBvbmNlIGFzc2V0cyBhcmUgbG9hZGVkXHJcbiAgICBmdW5jdGlvbiBpbml0aWFsaXplR2FtZSgpIHtcclxuICAgICAgaWYgKCFjYW52YXNSZWYuY3VycmVudCkgcmV0dXJuO1xyXG4gICAgICAvLyBXZSdsbCByZWx5IG9uIHRoZSBwYXJlbnQgdG8gc2V0IGEgc21hbGxlciBkaW1lbnNpb24gKGUuZy4gMjcww5c0ODApLlxyXG4gICAgICAvLyBEcmF3IHRoZSBzdGFydCBzY3JlZW46XHJcbiAgICAgIGRyYXdTdGFydFNjcmVlbihjdHgsIGNhbnZhc1JlZi5jdXJyZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZXNldEdhbWUoKSB7XHJcbiAgICAgIGlmICghY2FudmFzUmVmLmN1cnJlbnQpIHJldHVybjtcclxuICAgICAgY29uc3QgeyBoZWlnaHQgfSA9IGNhbnZhc1JlZi5jdXJyZW50O1xyXG5cclxuICAgICAgYmlyZFlSZWYuY3VycmVudCA9IGhlaWdodCAvIDM7XHJcbiAgICAgIGJpcmRWZWxvY2l0eVJlZi5jdXJyZW50ID0gMDtcclxuICAgICAgcGlwZXNSZWYuY3VycmVudCA9IFtdO1xyXG4gICAgICBjb2luc1JlZi5jdXJyZW50ID0gW107XHJcbiAgICAgIHNldEN1cnJlbnRTY29yZSgwKTtcclxuICAgICAgZ2FtZU92ZXJSZWYuY3VycmVudCA9IGZhbHNlO1xyXG4gICAgICBnYW1lU3RhcnRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICAgIGNvaW5Sb3RhdGlvblN0ZXBSZWYuY3VycmVudCA9IDA7XHJcbiAgICAgIGZyYW1lc1JlZi5jdXJyZW50ID0gMDtcclxuICAgICAgY3VycmVudEJpcmRGcmFtZVJlZi5jdXJyZW50ID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVLZXlEb3duKGU6IEtleWJvYXJkRXZlbnQpIHtcclxuICAgICAgaWYgKGUua2V5ID09PSBcIiBcIikge1xyXG4gICAgICAgIGlmICghZ2FtZVN0YXJ0ZWRSZWYuY3VycmVudCAmJiAhZ2FtZU92ZXJSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgc3RhcnRHYW1lKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChnYW1lT3ZlclJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICBzdGFydEdhbWUoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYmlyZFZlbG9jaXR5UmVmLmN1cnJlbnQgPSBGTEFQO1xyXG4gICAgICAgICAgZmxhcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBoYW5kbGVLZXlEb3duKTtcclxuXHJcbiAgICAvLyBPcHRpb25hbDogSWYgeW91IHdhbnQgdG8gZHluYW1pY2FsbHkgcmVzZXQgb3IgcmVzaXplIHRoZSBjYW52YXNcclxuICAgIC8vIGRvIGl0IGhlcmUsIGJ1dCB3ZSd2ZSBzZXQgYSBzbWFsbGVyIGRpbWVuc2lvbiBpbiB0aGUgcGFyZW50LlxyXG5cclxuICAgIC8vIERyYXcgc3RhcnQgc2NyZWVuXHJcbiAgICBmdW5jdGlvbiBzdGFydEdhbWUoKSB7XHJcbiAgICAgIHJlc2V0R2FtZSgpO1xyXG4gICAgICBnYW1lU3RhcnRlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcclxuICAgICAgbGFzdFRpbWVSZWYuY3VycmVudCA9IDA7IC8vIFJlc2V0IGZvciBmcmFtZS1saW1pdGluZ1xyXG4gICAgICBhbmltYXRlKDApO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZVVzZXJJbnB1dCgpIHtcclxuICAgICAgaWYgKCFnYW1lU3RhcnRlZFJlZi5jdXJyZW50ICYmICFnYW1lT3ZlclJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgc3RhcnRHYW1lKCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoZ2FtZU92ZXJSZWYuY3VycmVudCkge1xyXG4gICAgICAgIHN0YXJ0R2FtZSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGJpcmRWZWxvY2l0eVJlZi5jdXJyZW50ID0gRkxBUDtcclxuICAgICAgICBmbGFwKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBmbGFwID0gKCkgPT4ge1xyXG4gICAgICAvLyBRdWljayAzLWZyYW1lIGZsYXBcclxuICAgICAgY3VycmVudEJpcmRGcmFtZVJlZi5jdXJyZW50ID0gMTtcclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgY3VycmVudEJpcmRGcmFtZVJlZi5jdXJyZW50ID0gMjtcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgIGN1cnJlbnRCaXJkRnJhbWVSZWYuY3VycmVudCA9IDA7XHJcbiAgICAgICAgfSwgMTcwKTtcclxuICAgICAgfSwgMTcwKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gVGhlIG1haW4gbG9vcCB3aXRoIEZQUyBsaW1pdFxyXG4gICAgZnVuY3Rpb24gYW5pbWF0ZSh0aW1lc3RhbXA6IG51bWJlcikge1xyXG4gICAgICBpZiAoaXNQYXVzZWQgfHwgIWdhbWVTdGFydGVkUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICByZXF1ZXN0SWRSZWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFjYW52YXNSZWYuY3VycmVudCkgcmV0dXJuO1xyXG5cclxuICAgICAgY29uc3QgY29udGV4dCA9IGNhbnZhc1JlZi5jdXJyZW50LmdldENvbnRleHQoXCIyZFwiKTtcclxuICAgICAgaWYgKCFjb250ZXh0KSByZXR1cm47XHJcblxyXG4gICAgICAvLyBGcmFtZS1saW1pdGluZyBsb2dpY1xyXG4gICAgICBjb25zdCBkZWx0YSA9IHRpbWVzdGFtcCAtIGxhc3RUaW1lUmVmLmN1cnJlbnQ7XHJcbiAgICAgIGlmIChkZWx0YSA8IEZSQU1FX0RVUkFUSU9OKSB7XHJcbiAgICAgICAgcmVxdWVzdElkUmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGxhc3RUaW1lUmVmLmN1cnJlbnQgPSB0aW1lc3RhbXA7XHJcblxyXG4gICAgICB1cGRhdGVHYW1lU3RhdGUoY2FudmFzUmVmLmN1cnJlbnQpO1xyXG4gICAgICBkcmF3KGNvbnRleHQsIGNhbnZhc1JlZi5jdXJyZW50KTtcclxuXHJcbiAgICAgIGlmICghZ2FtZU92ZXJSZWYuY3VycmVudCkge1xyXG4gICAgICAgIHJlcXVlc3RJZFJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRyYXdHYW1lT3ZlclNjcmVlbihjb250ZXh0LCBjYW52YXNSZWYuY3VycmVudCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVHYW1lU3RhdGUoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkge1xyXG4gICAgICBmcmFtZXNSZWYuY3VycmVudCsrO1xyXG5cclxuICAgICAgLy8gR3Jhdml0eVxyXG4gICAgICBiaXJkVmVsb2NpdHlSZWYuY3VycmVudCArPSBHUkFWSVRZO1xyXG4gICAgICBiaXJkWVJlZi5jdXJyZW50ICs9IGJpcmRWZWxvY2l0eVJlZi5jdXJyZW50O1xyXG5cclxuICAgICAgLy8gU3Bhd24gcGlwZXMgbGVzcyBmcmVxdWVudGx5XHJcbiAgICAgIGlmIChmcmFtZXNSZWYuY3VycmVudCAlIFBJUEVfU1BBV05fRlJBTUVTID09PSAwKSB7XHJcbiAgICAgICAgY3JlYXRlUGlwZShjYW52YXMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBtb3ZlUGlwZXNBbmRDb2lucygpO1xyXG4gICAgICBjaGVja0NvaW5Db2xsZWN0aW9uKCk7XHJcblxyXG4gICAgICAvLyBDb2xsaXNpb25zXHJcbiAgICAgIGlmIChjaGVja0NvbGxpc2lvbnMoY2FudmFzKSkge1xyXG4gICAgICAgIGdhbWVPdmVyUmVmLmN1cnJlbnQgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdXBkYXRlU2NvcmUoKTtcclxuXHJcbiAgICAgIC8vIENvaW4gcm90YXRpb25cclxuICAgICAgY29pblJvdGF0aW9uU3RlcFJlZi5jdXJyZW50ICs9IFJPVEFUSU9OX1NQRUVEO1xyXG4gICAgICBpZiAoY29pblJvdGF0aW9uU3RlcFJlZi5jdXJyZW50ID49IDEpIHtcclxuICAgICAgICBjb2luUm90YXRpb25TdGVwUmVmLmN1cnJlbnQgPSAwO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhdyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkge1xyXG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcbiAgICAgIGRyYXdCYWNrZ3JvdW5kKGN0eCwgY2FudmFzKTtcclxuICAgICAgZHJhd0JpcmQoY3R4KTtcclxuICAgICAgZHJhd1BpcGVzKGN0eCk7XHJcbiAgICAgIGRyYXdDb2lucyhjdHgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdTdGFydFNjcmVlbihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkge1xyXG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcbiAgICAgIGRyYXdCYWNrZ3JvdW5kKGN0eCwgY2FudmFzKTtcclxuICAgICAgY3R4LmZvbnQgPSBcImJvbGQgMjJweCBBcmlhbFwiO1xyXG4gICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiI2ZmZmZmZlwiO1xyXG4gICAgICBjdHguc2hhZG93Q29sb3IgPSBcImJsYWNrXCI7XHJcbiAgICAgIGN0eC5zaGFkb3dCbHVyID0gMjtcclxuICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XHJcblxyXG4gICAgICBjdHguZmlsbFRleHQoXHJcbiAgICAgICAgXCJQcmVzcyBTcGFjZSBvciBUYXAgdG8gU3RhcnRcIixcclxuICAgICAgICBjYW52YXMud2lkdGggLyAyLFxyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgLyAyXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd0dhbWVPdmVyU2NyZWVuKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNmZmNjMDBcIjtcclxuICAgICAgY3R4LmZvbnQgPSBcImJvbGQgMzZweCBBcmlhbFwiO1xyXG4gICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcclxuICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XHJcbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFwiYmxhY2tcIjtcclxuICAgICAgY3R4LnNoYWRvd0JsdXIgPSA2O1xyXG5cclxuICAgICAgY3R4LmZpbGxUZXh0KFwiR2FtZSBPdmVyIVwiLCBjYW52YXMud2lkdGggLyAyLCBjYW52YXMuaGVpZ2h0IC8gMiAtIDMwKTtcclxuXHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNmZmZmZmZcIjtcclxuICAgICAgY3R4LmZvbnQgPSBcImJvbGQgMjBweCBBcmlhbFwiO1xyXG4gICAgICBjdHguZmlsbFRleHQoXHJcbiAgICAgICAgXCJQcmVzcyBTcGFjZSBvciBUYXAgdG8gUmVzdGFydFwiLFxyXG4gICAgICAgIGNhbnZhcy53aWR0aCAvIDIsXHJcbiAgICAgICAgY2FudmFzLmhlaWdodCAvIDIgKyAxMFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdCYWNrZ3JvdW5kKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgIGN0eC5kcmF3SW1hZ2UoYmFja2dyb3VuZCwgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3QmlyZChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xyXG4gICAgICBjb25zdCBjdXJyZW50SW1hZ2UgPSBiaXJkSW1hZ2VzW2N1cnJlbnRCaXJkRnJhbWVSZWYuY3VycmVudF07XHJcbiAgICAgIGlmIChjdXJyZW50SW1hZ2UuY29tcGxldGUpIHtcclxuICAgICAgICBjdHguZHJhd0ltYWdlKGN1cnJlbnRJbWFnZSwgMTAwLCBiaXJkWVJlZi5jdXJyZW50LCBCSVJEX1dJRFRILCBCSVJEX0hFSUdIVCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3UGlwZXMoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcclxuICAgICAgZm9yIChjb25zdCBwaXBlIG9mIHBpcGVzUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBjdHguZHJhd0ltYWdlKHBpcGVUb3AsIHBpcGUueCwgMCwgUElQRV9XSURUSCwgcGlwZS50b3BIZWlnaHQpO1xyXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoXHJcbiAgICAgICAgICBwaXBlQm90dG9tLFxyXG4gICAgICAgICAgcGlwZS54LFxyXG4gICAgICAgICAgcGlwZS5ib3R0b21ZLFxyXG4gICAgICAgICAgUElQRV9XSURUSCxcclxuICAgICAgICAgIHBpcGUuYm90dG9tSGVpZ2h0XHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdDb2lucyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xyXG4gICAgICBjb25zdCBzY2FsZVggPSBNYXRoLmFicyhNYXRoLmNvcyhjb2luUm90YXRpb25TdGVwUmVmLmN1cnJlbnQgKiBNYXRoLlBJICogMikpO1xyXG4gICAgICBjb25zdCBoYWxmU2l6ZSA9IENPSU5fU0laRSAvIDI7XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGNvaW4gb2YgY29pbnNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGlmICghY29pbi5jb2xsZWN0ZWQpIHtcclxuICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICBjdHgudHJhbnNsYXRlKGNvaW4ueCArIGhhbGZTaXplLCBjb2luLnkgKyBoYWxmU2l6ZSk7XHJcbiAgICAgICAgICAvLyBUaGUgc21hbGxlciByb3RhdGlvbiBzcGVlZCBtaWdodCBtYWtlIGl0IGFwcGVhciBtb3N0bHkgc3RhYmxlLlxyXG4gICAgICAgICAgY3R4LnNjYWxlKHNjYWxlWCwgMSk7XHJcbiAgICAgICAgICBjdHguZHJhd0ltYWdlKGNvaW5JbWFnZSwgLWhhbGZTaXplLCAtaGFsZlNpemUsIENPSU5fU0laRSwgQ09JTl9TSVpFKTtcclxuICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlUGlwZShjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgIGNvbnN0IHBpcGVIZWlnaHQgPVxyXG4gICAgICAgIE1hdGgucmFuZG9tKCkgKiAoY2FudmFzLmhlaWdodCAtIFBJUEVfU1BBQ0lORyAtIDEwMCkgKyA1MDtcclxuICAgICAgY29uc3QgYm90dG9tWSA9IHBpcGVIZWlnaHQgKyBQSVBFX1NQQUNJTkc7XHJcbiAgICAgIHBpcGVzUmVmLmN1cnJlbnQucHVzaCh7XHJcbiAgICAgICAgeDogY2FudmFzLndpZHRoLFxyXG4gICAgICAgIHRvcEhlaWdodDogcGlwZUhlaWdodCxcclxuICAgICAgICBib3R0b21ZLFxyXG4gICAgICAgIGJvdHRvbUhlaWdodDogY2FudmFzLmhlaWdodCAtIGJvdHRvbVksXHJcbiAgICAgICAgc2NvcmVkOiBmYWxzZSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBTcGF3biBjb2luIG9ubHkgMjUlIGNoYW5jZVxyXG4gICAgICBpZiAoTWF0aC5yYW5kb20oKSA+IDAuNzUpIHtcclxuICAgICAgICBjb2luc1JlZi5jdXJyZW50LnB1c2goe1xyXG4gICAgICAgICAgeDogY2FudmFzLndpZHRoICsgUElQRV9XSURUSCAvIDIgLSBDT0lOX1NJWkUgLyAyLFxyXG4gICAgICAgICAgeTogcGlwZUhlaWdodCArIFBJUEVfU1BBQ0lORyAvIDIgLSBDT0lOX1NJWkUgLyAyLFxyXG4gICAgICAgICAgd2lkdGg6IENPSU5fU0laRSxcclxuICAgICAgICAgIGhlaWdodDogQ09JTl9TSVpFLFxyXG4gICAgICAgICAgY29sbGVjdGVkOiBmYWxzZSxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1vdmVQaXBlc0FuZENvaW5zKCkge1xyXG4gICAgICBmb3IgKGNvbnN0IHBpcGUgb2YgcGlwZXNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIC8vIE1vdmUgc2xvd2VyIGlmIHlvdSB3YW50IHRvIHJlZHVjZSBDUFUgbG9hZCAoMSBweCBwZXIgZnJhbWUpXHJcbiAgICAgICAgcGlwZS54IC09IDI7XHJcbiAgICAgIH1cclxuICAgICAgcGlwZXNSZWYuY3VycmVudCA9IHBpcGVzUmVmLmN1cnJlbnQuZmlsdGVyKChwaXBlKSA9PiBwaXBlLnggKyBQSVBFX1dJRFRIID4gMCk7XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGNvaW4gb2YgY29pbnNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGNvaW4ueCAtPSAyO1xyXG4gICAgICB9XHJcbiAgICAgIGNvaW5zUmVmLmN1cnJlbnQgPSBjb2luc1JlZi5jdXJyZW50LmZpbHRlcihcclxuICAgICAgICAoY29pbikgPT4gY29pbi54ICsgY29pbi53aWR0aCA+IDAgJiYgIWNvaW4uY29sbGVjdGVkXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2hlY2tDb2xsaXNpb25zKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpOiBib29sZWFuIHtcclxuICAgICAgLy8gQmlyZCBvdXQgb2YgYm91bmRzXHJcbiAgICAgIGlmIChiaXJkWVJlZi5jdXJyZW50IDwgMCB8fCBiaXJkWVJlZi5jdXJyZW50ICsgQklSRF9IRUlHSFQgPiBjYW52YXMuaGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGJpcmRMZWZ0ID0gMTAwO1xyXG4gICAgICBjb25zdCBiaXJkUmlnaHQgPSBiaXJkTGVmdCArIEJJUkRfV0lEVEg7XHJcbiAgICAgIGNvbnN0IGJpcmRUb3AgPSBiaXJkWVJlZi5jdXJyZW50O1xyXG4gICAgICBjb25zdCBiaXJkQm90dG9tID0gYmlyZFlSZWYuY3VycmVudCArIEJJUkRfSEVJR0hUO1xyXG5cclxuICAgICAgLy8gUGlwZSBjb2xsaXNpb25cclxuICAgICAgZm9yIChjb25zdCBwaXBlIG9mIHBpcGVzUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBjb25zdCB3aXRoaW5QaXBlWCA9IGJpcmRSaWdodCA+IHBpcGUueCAmJiBiaXJkTGVmdCA8IHBpcGUueCArIFBJUEVfV0lEVEg7XHJcbiAgICAgICAgY29uc3Qgd2l0aGluUGlwZVkgPVxyXG4gICAgICAgICAgYmlyZFRvcCA8IHBpcGUudG9wSGVpZ2h0IHx8IGJpcmRCb3R0b20gPiBwaXBlLmJvdHRvbVk7XHJcbiAgICAgICAgaWYgKHdpdGhpblBpcGVYICYmIHdpdGhpblBpcGVZKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2hlY2tDb2luQ29sbGVjdGlvbigpIHtcclxuICAgICAgY29uc3QgYmlyZExlZnQgPSAxMDA7XHJcbiAgICAgIGNvbnN0IGJpcmRSaWdodCA9IGJpcmRMZWZ0ICsgQklSRF9XSURUSDtcclxuICAgICAgY29uc3QgYmlyZFRvcCA9IGJpcmRZUmVmLmN1cnJlbnQ7XHJcbiAgICAgIGNvbnN0IGJpcmRCb3R0b20gPSBiaXJkWVJlZi5jdXJyZW50ICsgQklSRF9IRUlHSFQ7XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGNvaW4gb2YgY29pbnNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGlmICghY29pbi5jb2xsZWN0ZWQpIHtcclxuICAgICAgICAgIGNvbnN0IGNvaW5MZWZ0ID0gY29pbi54O1xyXG4gICAgICAgICAgY29uc3QgY29pblJpZ2h0ID0gY29pbi54ICsgY29pbi53aWR0aDtcclxuICAgICAgICAgIGNvbnN0IGNvaW5Ub3AgPSBjb2luLnk7XHJcbiAgICAgICAgICBjb25zdCBjb2luQm90dG9tID0gY29pbi55ICsgY29pbi5oZWlnaHQ7XHJcblxyXG4gICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICBiaXJkUmlnaHQgPiBjb2luTGVmdCAmJlxyXG4gICAgICAgICAgICBiaXJkTGVmdCA8IGNvaW5SaWdodCAmJlxyXG4gICAgICAgICAgICBiaXJkQm90dG9tID4gY29pblRvcCAmJlxyXG4gICAgICAgICAgICBiaXJkVG9wIDwgY29pbkJvdHRvbVxyXG4gICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIGNvaW4uY29sbGVjdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgc2V0Q3VycmVudFNjb3JlKChwcmV2U2NvcmUpID0+IHtcclxuICAgICAgICAgICAgICBjb25zdCBuZXdTY29yZSA9IHByZXZTY29yZSArIDU7XHJcbiAgICAgICAgICAgICAgc2V0SGlnaFNjb3JlKChwcmV2SGlnaFNjb3JlKSA9PiBNYXRoLm1heChwcmV2SGlnaFNjb3JlLCBuZXdTY29yZSkpO1xyXG4gICAgICAgICAgICAgIHJldHVybiBuZXdTY29yZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdXBkYXRlU2NvcmUoKSB7XHJcbiAgICAgIGZvciAoY29uc3QgcGlwZSBvZiBwaXBlc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgLy8gU2NvcmUgKzEgZm9yIHBhc3NpbmcgZWFjaCBwaXBlIG9uY2VcclxuICAgICAgICBpZiAoIXBpcGUuc2NvcmVkICYmIHBpcGUueCArIFBJUEVfV0lEVEggPCAxMDApIHtcclxuICAgICAgICAgIHNldEN1cnJlbnRTY29yZSgocHJldlNjb3JlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1Njb3JlID0gcHJldlNjb3JlICsgMTtcclxuICAgICAgICAgICAgc2V0SGlnaFNjb3JlKChwcmV2SGlnaFNjb3JlKSA9PiB7XHJcbiAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZEhpZ2hTY29yZSA9IE1hdGgubWF4KHByZXZIaWdoU2NvcmUsIG5ld1Njb3JlKTtcclxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJoaWdoU2NvcmVcIiwgdXBkYXRlZEhpZ2hTY29yZS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZWRIaWdoU2NvcmU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3U2NvcmU7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHBpcGUuc2NvcmVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBDbGVhbnVwXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgaGFuZGxlS2V5RG93bik7XHJcbiAgICAgIGlmIChyZXF1ZXN0SWRSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJlcXVlc3RJZFJlZi5jdXJyZW50KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9LCBbY2FudmFzUmVmLCBpc1BhdXNlZCwgYXV0b1N0YXJ0XSk7XHJcblxyXG4gIC8vIEV4cG9zZSBoYW5kbGVVc2VySW5wdXRcclxuICBjb25zdCBoYW5kbGVVc2VySW5wdXQgPSAoKSA9PiB7XHJcbiAgICAvLyBXZSdsbCBkaXNwYXRjaCBhIFwia2V5ZG93blwiIGV2ZW50IHdpdGgga2V5Q29kZSBmb3Igc3BhY2UgYXMgYSBxdWljayBoYWNrXHJcbiAgICBjb25zdCBzcGFjZUV2ZW50ID0gbmV3IEtleWJvYXJkRXZlbnQoXCJrZXlkb3duXCIsIHsga2V5OiBcIiBcIiB9KTtcclxuICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KHNwYWNlRXZlbnQpO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBoaWdoU2NvcmUsXHJcbiAgICBjdXJyZW50U2NvcmUsXHJcbiAgICBoYW5kbGVVc2VySW5wdXQsXHJcbiAgfTtcclxufVxyXG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJHUkFWSVRZIiwiRkxBUCIsIlBJUEVfV0lEVEgiLCJQSVBFX1NQQUNJTkciLCJCSVJEX1dJRFRIIiwiQklSRF9IRUlHSFQiLCJDT0lOX1NJWkUiLCJST1RBVElPTl9TUEVFRCIsIlBJUEVfU1BBV05fRlJBTUVTIiwiVEFSR0VUX0ZQUyIsIkZSQU1FX0RVUkFUSU9OIiwidXNlRmxhcHB5QmlyZEdhbWUiLCJjYW52YXNSZWYiLCJpc1BhdXNlZCIsImF1dG9TdGFydCIsInJlcXVlc3RJZFJlZiIsImhpZ2hTY29yZSIsInNldEhpZ2hTY29yZSIsImN1cnJlbnRTY29yZSIsInNldEN1cnJlbnRTY29yZSIsImJpcmRZUmVmIiwiYmlyZFZlbG9jaXR5UmVmIiwicGlwZXNSZWYiLCJjb2luc1JlZiIsImdhbWVPdmVyUmVmIiwiZ2FtZVN0YXJ0ZWRSZWYiLCJjb2luUm90YXRpb25TdGVwUmVmIiwiZnJhbWVzUmVmIiwiY3VycmVudEJpcmRGcmFtZVJlZiIsImxhc3RUaW1lUmVmIiwiYmlyZEltYWdlcyIsInBpcGVUb3AiLCJwaXBlQm90dG9tIiwiYmFja2dyb3VuZCIsImNvaW5JbWFnZSIsImJpcmRVcCIsIkltYWdlIiwic3JjIiwiYmlyZE1pZCIsImJpcmREb3duIiwic3RvcmVkSGlnaFNjb3JlIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInBhcnNlSW50IiwiY2FudmFzIiwiY3VycmVudCIsImN0eCIsImdldENvbnRleHQiLCJsb2FkSW1hZ2UiLCJpbWciLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImNvbXBsZXRlIiwib25sb2FkIiwib25lcnJvciIsIkVycm9yIiwibG9hZEFzc2V0cyIsImFsbCIsIm1hcCIsImNvbnNvbGUiLCJsb2ciLCJpbml0aWFsaXplR2FtZSIsImVycm9yIiwiZHJhd1N0YXJ0U2NyZWVuIiwicmVzZXRHYW1lIiwiaGVpZ2h0IiwiaGFuZGxlS2V5RG93biIsImUiLCJrZXkiLCJzdGFydEdhbWUiLCJmbGFwIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsImFuaW1hdGUiLCJoYW5kbGVVc2VySW5wdXQiLCJzZXRUaW1lb3V0IiwidGltZXN0YW1wIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY29udGV4dCIsImRlbHRhIiwidXBkYXRlR2FtZVN0YXRlIiwiZHJhdyIsImRyYXdHYW1lT3ZlclNjcmVlbiIsImNyZWF0ZVBpcGUiLCJtb3ZlUGlwZXNBbmRDb2lucyIsImNoZWNrQ29pbkNvbGxlY3Rpb24iLCJjaGVja0NvbGxpc2lvbnMiLCJ1cGRhdGVTY29yZSIsImNsZWFyUmVjdCIsIndpZHRoIiwiZHJhd0JhY2tncm91bmQiLCJkcmF3QmlyZCIsImRyYXdQaXBlcyIsImRyYXdDb2lucyIsImZvbnQiLCJ0ZXh0QWxpZ24iLCJmaWxsU3R5bGUiLCJzaGFkb3dDb2xvciIsInNoYWRvd0JsdXIiLCJ0ZXh0QmFzZWxpbmUiLCJmaWxsVGV4dCIsImRyYXdJbWFnZSIsImN1cnJlbnRJbWFnZSIsInBpcGUiLCJ4IiwidG9wSGVpZ2h0IiwiYm90dG9tWSIsImJvdHRvbUhlaWdodCIsInNjYWxlWCIsIk1hdGgiLCJhYnMiLCJjb3MiLCJQSSIsImhhbGZTaXplIiwiY29pbiIsImNvbGxlY3RlZCIsInNhdmUiLCJ0cmFuc2xhdGUiLCJ5Iiwic2NhbGUiLCJyZXN0b3JlIiwicGlwZUhlaWdodCIsInJhbmRvbSIsInB1c2giLCJzY29yZWQiLCJmaWx0ZXIiLCJiaXJkTGVmdCIsImJpcmRSaWdodCIsImJpcmRUb3AiLCJiaXJkQm90dG9tIiwid2l0aGluUGlwZVgiLCJ3aXRoaW5QaXBlWSIsImNvaW5MZWZ0IiwiY29pblJpZ2h0IiwiY29pblRvcCIsImNvaW5Cb3R0b20iLCJwcmV2U2NvcmUiLCJuZXdTY29yZSIsInByZXZIaWdoU2NvcmUiLCJtYXgiLCJ1cGRhdGVkSGlnaFNjb3JlIiwic2V0SXRlbSIsInRvU3RyaW5nIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwic3BhY2VFdmVudCIsIktleWJvYXJkRXZlbnQiLCJkaXNwYXRjaEV2ZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./public/useFlappyBirdGame.ts\n"));

/***/ })

});