"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./public/useFlappyBirdGame.ts":
/*!*************************************!*\
  !*** ./public/useFlappyBirdGame.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFlappyBirdGame: function() { return /* binding */ useFlappyBirdGame; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n// Constants\nconst GRAVITY = 0.7;\nconst FLAP = -11;\nconst PIPE_WIDTH = 90;\nconst PIPE_SPACING = 230;\nconst BIRD_WIDTH = 50;\nconst BIRD_HEIGHT = 50;\nconst COIN_SIZE = 100;\nconst PIPE_SPAWN_INTERVAL = 1000; // 1 second\nconst HORIZONTAL_SPEED = 4;\nconst ROTATION_SPEED = 0.01;\nconst IDEAL_FRAME = 16.67; // ~60fps\nfunction useFlappyBirdGame(canvasRef, isPaused, autoStart) {\n    const requestIdRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // State\n    const [highScore, setHighScore] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [currentScore, setCurrentScore] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    // Game refs\n    const birdYRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const birdVelocityRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const pipesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const coinsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const gameOverRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const gameStartedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // Coin rotation\n    const coinRotationRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // Pipe spawn timer\n    const pipeSpawnTimerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // Timestamp for time-based movement\n    const lastTimeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // Bird animation frames\n    let birdImages = [];\n    let pipeTop;\n    let pipeBottom;\n    let background;\n    let coinImage;\n    // Preload images (client-side)\n    if (true) {\n        const birdUp = new Image();\n        birdUp.src = \"/assets/redbird-upflap.png\";\n        const birdMid = new Image();\n        birdMid.src = \"/assets/redbird-midflap.png\";\n        const birdDown = new Image();\n        birdDown.src = \"/assets/redbird-downflap.png\";\n        birdImages = [\n            birdUp,\n            birdMid,\n            birdDown\n        ];\n        pipeTop = new Image();\n        pipeTop.src = \"/assets/TopTiny.png\";\n        pipeBottom = new Image();\n        pipeBottom.src = \"/assets/BottomTiny.png\";\n        background = new Image();\n        background.src = \"/assets/background-day.png\";\n        coinImage = new Image();\n        coinImage.src = \"/assets/CoinTiny.png\";\n    }\n    const currentBirdFrameRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // Load high score on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (true) {\n            const storedHighScore = localStorage.getItem(\"highScore\");\n            if (storedHighScore) {\n                setHighScore(parseInt(storedHighScore, 10));\n            }\n        }\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        // Ensure images are fully loaded\n        const loadImage = (img)=>{\n            return new Promise((resolve, reject)=>{\n                if (img.complete) {\n                    resolve();\n                } else {\n                    img.onload = ()=>resolve();\n                    img.onerror = ()=>reject(new Error(\"Failed to load \".concat(img.src)));\n                }\n            });\n        };\n        // Load all images, then initialize\n        const loadAssets = async ()=>{\n            try {\n                await Promise.all([\n                    ...birdImages.map((img)=>loadImage(img)),\n                    loadImage(pipeTop),\n                    loadImage(pipeBottom),\n                    loadImage(background),\n                    loadImage(coinImage)\n                ]);\n                initializeGame();\n            } catch (err) {\n                console.error(\"Error loading assets:\", err);\n            }\n        };\n        loadAssets();\n        // Setup / reset game state\n        function initializeGame() {\n            if (!canvasRef.current || !ctx) return;\n            canvasRef.current.width = 360;\n            canvasRef.current.height = 640;\n            drawStartScreen(ctx, canvasRef.current);\n        }\n        function resetGame() {\n            if (!canvasRef.current) return;\n            const { height } = canvasRef.current;\n            birdYRef.current = height / 3;\n            birdVelocityRef.current = 0;\n            pipesRef.current = [];\n            coinsRef.current = [];\n            setCurrentScore(0);\n            gameOverRef.current = false;\n            gameStartedRef.current = false;\n            coinRotationRef.current = 0;\n            pipeSpawnTimerRef.current = 0;\n            currentBirdFrameRef.current = 0;\n        }\n        // Desktop keyboard input\n        function handleKeyDown(e) {\n            if (e.key === \" \") {\n                flapOrStart();\n            }\n        }\n        window.addEventListener(\"keydown\", handleKeyDown);\n        // Listen for canvas resizing\n        function handleResize() {\n            if (!canvasRef.current) return;\n            canvasRef.current.width = 360;\n            canvasRef.current.height = 640;\n            // Redraw the start screen if not started\n            if (!gameStartedRef.current && !gameOverRef.current && ctx) {\n                drawStartScreen(ctx, canvasRef.current);\n            }\n        }\n        window.addEventListener(\"resize\", handleResize);\n        function flapOrStart() {\n            if (!gameStartedRef.current && !gameOverRef.current) {\n                startGame();\n            } else if (gameOverRef.current) {\n                startGame();\n            } else {\n                birdVelocityRef.current = FLAP;\n                flapAnimation();\n            }\n        }\n        function startGame() {\n            resetGame();\n            gameStartedRef.current = true;\n            lastTimeRef.current = performance.now();\n            requestIdRef.current = requestAnimationFrame(animate);\n        }\n        function flapAnimation() {\n            currentBirdFrameRef.current = 1;\n            setTimeout(()=>{\n                currentBirdFrameRef.current = 2;\n                setTimeout(()=>{\n                    currentBirdFrameRef.current = 0;\n                }, 170);\n            }, 170);\n        }\n        // Main loop\n        function animate(currentTime) {\n            if (!gameStartedRef.current) {\n                requestIdRef.current = requestAnimationFrame(animate);\n                return;\n            }\n            if (isPaused) {\n                requestIdRef.current = requestAnimationFrame(animate);\n                return;\n            }\n            if (!canvasRef.current) return;\n            const context = canvasRef.current.getContext(\"2d\");\n            if (!context) return;\n            const now = currentTime !== null && currentTime !== void 0 ? currentTime : performance.now();\n            const deltaTime = now - lastTimeRef.current;\n            lastTimeRef.current = now;\n            updateGameState(canvasRef.current, deltaTime);\n            draw(context, canvasRef.current);\n            if (!gameOverRef.current) {\n                requestIdRef.current = requestAnimationFrame(animate);\n            } else {\n                drawGameOverScreen(context, canvasRef.current);\n            }\n        }\n        function updateGameState(canvas, deltaTime) {\n            const scale = deltaTime / IDEAL_FRAME;\n            // Gravity\n            birdVelocityRef.current += GRAVITY * scale;\n            birdYRef.current += birdVelocityRef.current * scale;\n            // Pipe spawn\n            pipeSpawnTimerRef.current += deltaTime;\n            if (pipeSpawnTimerRef.current >= PIPE_SPAWN_INTERVAL) {\n                pipeSpawnTimerRef.current -= PIPE_SPAWN_INTERVAL;\n                createPipe(canvas);\n            }\n            // Move pipes & coins\n            movePipesAndCoins(scale);\n            // Rotate coin\n            coinRotationRef.current += ROTATION_SPEED * scale;\n            if (coinRotationRef.current >= 1) {\n                coinRotationRef.current = 0;\n            }\n            // Collisions\n            if (checkCollisions(canvas)) {\n                gameOverRef.current = true;\n                return;\n            }\n            // Coin collection\n            checkCoinCollection();\n            // Score\n            updateScore();\n        }\n        function draw(ctx, canvas) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawBackground(ctx, canvas);\n            drawBird(ctx);\n            drawPipes(ctx);\n            drawCoins(ctx);\n        }\n        // Scenes\n        function drawStartScreen(ctx, canvas) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawBackground(ctx, canvas);\n            ctx.font = \"bold 30px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.fillStyle = \"#ffffff\";\n            ctx.shadowColor = \"black\";\n            ctx.textBaseline = \"middle\";\n            ctx.fillText(\"Press Space to Start\", canvas.width / 2, canvas.height / 2);\n        }\n        function drawGameOverScreen(ctx, canvas) {\n            ctx.fillStyle = \"#ffcc00\";\n            ctx.font = \"bold 50px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"middle\";\n            ctx.shadowColor = \"black\";\n            ctx.shadowBlur = 10;\n            ctx.fillText(\"Game Over!\", canvas.width / 2, canvas.height / 2 - 40);\n            ctx.fillStyle = \"#ffffff\";\n            ctx.font = \"bold 30px Arial\";\n            ctx.fillText(\"Press Space to Restart\", canvas.width / 2, canvas.height / 2 + 20);\n        }\n        function drawBackground(ctx, canvas) {\n            ctx.drawImage(background, 0, 0, canvas.width, canvas.height);\n        }\n        function drawBird(ctx) {\n            const currentImage = birdImages[currentBirdFrameRef.current];\n            if (currentImage.complete) {\n                ctx.drawImage(currentImage, 100, birdYRef.current, BIRD_WIDTH, BIRD_HEIGHT);\n            }\n        }\n        function drawPipes(ctx) {\n            for (const pipe of pipesRef.current){\n                ctx.drawImage(pipeTop, pipe.x, 0, PIPE_WIDTH, pipe.topHeight);\n                ctx.drawImage(pipeBottom, pipe.x, pipe.bottomY, PIPE_WIDTH, pipe.bottomHeight);\n            }\n        }\n        function drawCoins(ctx) {\n            const scaleX = Math.abs(Math.cos(coinRotationRef.current * Math.PI * 2));\n            const halfSize = COIN_SIZE / 2;\n            for (const coin of coinsRef.current){\n                if (!coin.collected) {\n                    ctx.save();\n                    ctx.translate(coin.x + halfSize, coin.y + halfSize);\n                    ctx.scale(scaleX, 1);\n                    ctx.drawImage(coinImage, -halfSize, -halfSize, COIN_SIZE, COIN_SIZE);\n                    ctx.restore();\n                }\n            }\n        }\n        // Create pipes/coins\n        function createPipe(canvas) {\n            const pipeHeight = Math.random() * (canvas.height - PIPE_SPACING - 100) + 50;\n            const bottomY = pipeHeight + PIPE_SPACING;\n            pipesRef.current.push({\n                x: canvas.width,\n                topHeight: pipeHeight,\n                bottomY,\n                bottomHeight: canvas.height - bottomY,\n                scored: false\n            });\n            // 50% chance for coin\n            if (Math.random() > 0.5) {\n                coinsRef.current.push({\n                    x: canvas.width + PIPE_WIDTH / 2 - COIN_SIZE / 2,\n                    y: pipeHeight + PIPE_SPACING / 2 - COIN_SIZE / 2,\n                    width: COIN_SIZE,\n                    height: COIN_SIZE,\n                    collected: false\n                });\n            }\n        }\n        function movePipesAndCoins(scale) {\n            for (const pipe of pipesRef.current){\n                pipe.x -= HORIZONTAL_SPEED * scale;\n            }\n            pipesRef.current = pipesRef.current.filter((p)=>p.x + PIPE_WIDTH > 0);\n            for (const coin of coinsRef.current){\n                coin.x -= HORIZONTAL_SPEED * scale;\n            }\n            coinsRef.current = coinsRef.current.filter((c)=>c.x + c.width > 0 && !c.collected);\n        }\n        function checkCollisions(canvas) {\n            // Bird vs boundaries\n            if (birdYRef.current < 0 || birdYRef.current + BIRD_HEIGHT > canvas.height) {\n                return true;\n            }\n            const birdLeft = 100;\n            const birdRight = birdLeft + BIRD_WIDTH;\n            const birdTop = birdYRef.current;\n            const birdBottom = birdYRef.current + BIRD_HEIGHT;\n            // Bird vs pipes\n            for (const pipe of pipesRef.current){\n                const withinPipeX = birdRight > pipe.x && birdLeft < pipe.x + PIPE_WIDTH;\n                const withinPipeY = birdTop < pipe.topHeight || birdBottom > pipe.bottomY;\n                if (withinPipeX && withinPipeY) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function checkCoinCollection() {\n            const birdLeft = 100;\n            const birdRight = birdLeft + BIRD_WIDTH;\n            const birdTop = birdYRef.current;\n            const birdBottom = birdYRef.current + BIRD_HEIGHT;\n            for (const coin of coinsRef.current){\n                if (!coin.collected) {\n                    const coinLeft = coin.x;\n                    const coinRight = coin.x + coin.width;\n                    const coinTop = coin.y;\n                    const coinBottom = coin.y + coin.height;\n                    if (birdRight > coinLeft && birdLeft < coinRight && birdBottom > coinTop && birdTop < coinBottom) {\n                        // Collect coin\n                        coin.collected = true;\n                        setCurrentScore((prev)=>{\n                            const newScore = prev + 5;\n                            setHighScore((prevHigh)=>Math.max(prevHigh, newScore));\n                            return newScore;\n                        });\n                    }\n                }\n            }\n        }\n        function updateScore() {\n            for (const pipe of pipesRef.current){\n                // +1 score once the pipe has fully passed bird x=100\n                if (!pipe.scored && pipe.x + PIPE_WIDTH < 100) {\n                    pipe.scored = true;\n                    setCurrentScore((prev)=>{\n                        const newScore = prev + 1;\n                        setHighScore((prevHigh)=>{\n                            const updatedHigh = Math.max(prevHigh, newScore);\n                            if (true) {\n                                localStorage.setItem(\"highScore\", updatedHigh.toString());\n                            }\n                            return updatedHigh;\n                        });\n                        return newScore;\n                    });\n                }\n            }\n        }\n        // Handle single tap/click on canvas to flap\n        // We'll debounce with a short timeout to prevent double taps\n        const lastTapRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n        const DEBOUNCE_TIME = 300; // ms\n        function handleCanvasTap(e) {\n            e.preventDefault(); // Prevent generating multiple events\n            const now = Date.now();\n            if (now - lastTapRef.current < DEBOUNCE_TIME) {\n                // Detected a second tap in quick succession => ignore\n                return;\n            }\n            lastTapRef.current = now;\n            flapOrStart();\n        }\n        // Bind mobile & mouse input to the canvas\n        const addCanvasListeners = ()=>{\n            canvas.addEventListener(\"touchstart\", handleCanvasTap);\n            canvas.addEventListener(\"mousedown\", handleCanvasTap);\n        };\n        const removeCanvasListeners = ()=>{\n            canvas.removeEventListener(\"touchstart\", handleCanvasTap);\n            canvas.removeEventListener(\"mousedown\", handleCanvasTap);\n        };\n        addCanvasListeners();\n        // If autoStart is true, start automatically\n        if (autoStart) {\n            flapOrStart();\n        }\n        // Cleanup\n        return ()=>{\n            window.removeEventListener(\"keydown\", handleKeyDown);\n            window.removeEventListener(\"resize\", handleResize);\n            removeCanvasListeners();\n            if (requestIdRef.current) {\n                cancelAnimationFrame(requestIdRef.current);\n            }\n        };\n    }, [\n        canvasRef,\n        isPaused,\n        autoStart\n    ]);\n    // We no longer dispatch a synthetic keydown event,\n    // since that can cause multiple triggers on mobile.\n    return {\n        highScore,\n        currentScore\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LDZDQUFNQSxDQUFDO1FBQzFCLE1BQU13SixnQkFBZ0IsS0FBSyxLQUFLO1FBRWhDLFNBQVNDLGdCQUFnQmxGLENBQTBCO1lBQ2pEQSxFQUFFbUYsY0FBYyxJQUFJLHFDQUFxQztZQUN6RCxNQUFNMUUsTUFBTTJFLEtBQUszRSxHQUFHO1lBQ3BCLElBQUlBLE1BQU11RSxXQUFXeEcsT0FBTyxHQUFHeUcsZUFBZTtnQkFDNUMsc0RBQXNEO2dCQUN0RDtZQUNGO1lBQ0FELFdBQVd4RyxPQUFPLEdBQUdpQztZQUNyQlA7UUFDRjtRQUVBLDBDQUEwQztRQUMxQyxNQUFNbUYscUJBQXFCO1lBQ3pCOUcsT0FBTzZCLGdCQUFnQixDQUFDLGNBQWM4RTtZQUN0QzNHLE9BQU82QixnQkFBZ0IsQ0FBQyxhQUFhOEU7UUFDdkM7UUFFQSxNQUFNSSx3QkFBd0I7WUFDNUIvRyxPQUFPZ0gsbUJBQW1CLENBQUMsY0FBY0w7WUFDekMzRyxPQUFPZ0gsbUJBQW1CLENBQUMsYUFBYUw7UUFDMUM7UUFFQUc7UUFFQSw0Q0FBNEM7UUFDNUMsSUFBSTVJLFdBQVc7WUFDYnlEO1FBQ0Y7UUFFQSxVQUFVO1FBQ1YsT0FBTztZQUNMQyxPQUFPb0YsbUJBQW1CLENBQUMsV0FBV3hGO1lBQ3RDSSxPQUFPb0YsbUJBQW1CLENBQUMsVUFBVWxGO1lBQ3JDaUY7WUFDQSxJQUFJNUksYUFBYThCLE9BQU8sRUFBRTtnQkFDeEJnSCxxQkFBcUI5SSxhQUFhOEIsT0FBTztZQUMzQztRQUNGO0lBQ0YsR0FBRztRQUFDakM7UUFBV0M7UUFBVUM7S0FBVTtJQUVuQyxtREFBbUQ7SUFDbkQsb0RBQW9EO0lBRXBELE9BQU87UUFDTEU7UUFDQUU7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3B1YmxpYy91c2VGbGFwcHlCaXJkR2FtZS50cz81Yzc4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xyXG5cclxuLy8gVHlwZXMgZm9yIGdhbWUgb2JqZWN0c1xyXG5pbnRlcmZhY2UgUGlwZSB7XHJcbiAgeDogbnVtYmVyO1xyXG4gIHRvcEhlaWdodDogbnVtYmVyO1xyXG4gIGJvdHRvbVk6IG51bWJlcjtcclxuICBib3R0b21IZWlnaHQ6IG51bWJlcjtcclxuICBzY29yZWQ6IGJvb2xlYW47XHJcbn1cclxuXHJcbmludGVyZmFjZSBDb2luIHtcclxuICB4OiBudW1iZXI7XHJcbiAgeTogbnVtYmVyO1xyXG4gIHdpZHRoOiBudW1iZXI7XHJcbiAgaGVpZ2h0OiBudW1iZXI7XHJcbiAgY29sbGVjdGVkOiBib29sZWFuO1xyXG59XHJcblxyXG4vLyBDb25zdGFudHNcclxuY29uc3QgR1JBVklUWSA9IDAuNztcclxuY29uc3QgRkxBUCA9IC0xMTtcclxuY29uc3QgUElQRV9XSURUSCA9IDkwO1xyXG5jb25zdCBQSVBFX1NQQUNJTkcgPSAyMzA7XHJcbmNvbnN0IEJJUkRfV0lEVEggPSA1MDtcclxuY29uc3QgQklSRF9IRUlHSFQgPSA1MDtcclxuY29uc3QgQ09JTl9TSVpFID0gMTAwO1xyXG5jb25zdCBQSVBFX1NQQVdOX0lOVEVSVkFMID0gMTAwMDsgLy8gMSBzZWNvbmRcclxuY29uc3QgSE9SSVpPTlRBTF9TUEVFRCA9IDQ7XHJcbmNvbnN0IFJPVEFUSU9OX1NQRUVEID0gMC4wMTtcclxuY29uc3QgSURFQUxfRlJBTUUgPSAxNi42NzsgLy8gfjYwZnBzXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlRmxhcHB5QmlyZEdhbWUoXHJcbiAgY2FudmFzUmVmOiBSZWFjdC5SZWZPYmplY3Q8SFRNTENhbnZhc0VsZW1lbnQ+LFxyXG4gIGlzUGF1c2VkOiBib29sZWFuLFxyXG4gIGF1dG9TdGFydDogYm9vbGVhblxyXG4pIHtcclxuICBjb25zdCByZXF1ZXN0SWRSZWYgPSB1c2VSZWY8bnVtYmVyIHwgbnVsbD4obnVsbCk7XHJcblxyXG4gIC8vIFN0YXRlXHJcbiAgY29uc3QgW2hpZ2hTY29yZSwgc2V0SGlnaFNjb3JlXSA9IHVzZVN0YXRlKDApO1xyXG4gIGNvbnN0IFtjdXJyZW50U2NvcmUsIHNldEN1cnJlbnRTY29yZV0gPSB1c2VTdGF0ZSgwKTtcclxuXHJcbiAgLy8gR2FtZSByZWZzXHJcbiAgY29uc3QgYmlyZFlSZWYgPSB1c2VSZWY8bnVtYmVyPigwKTtcclxuICBjb25zdCBiaXJkVmVsb2NpdHlSZWYgPSB1c2VSZWY8bnVtYmVyPigwKTtcclxuICBjb25zdCBwaXBlc1JlZiA9IHVzZVJlZjxQaXBlW10+KFtdKTtcclxuICBjb25zdCBjb2luc1JlZiA9IHVzZVJlZjxDb2luW10+KFtdKTtcclxuICBjb25zdCBnYW1lT3ZlclJlZiA9IHVzZVJlZjxib29sZWFuPihmYWxzZSk7XHJcbiAgY29uc3QgZ2FtZVN0YXJ0ZWRSZWYgPSB1c2VSZWY8Ym9vbGVhbj4oZmFsc2UpO1xyXG5cclxuICAvLyBDb2luIHJvdGF0aW9uXHJcbiAgY29uc3QgY29pblJvdGF0aW9uUmVmID0gdXNlUmVmPG51bWJlcj4oMCk7XHJcblxyXG4gIC8vIFBpcGUgc3Bhd24gdGltZXJcclxuICBjb25zdCBwaXBlU3Bhd25UaW1lclJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xyXG5cclxuICAvLyBUaW1lc3RhbXAgZm9yIHRpbWUtYmFzZWQgbW92ZW1lbnRcclxuICBjb25zdCBsYXN0VGltZVJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xyXG5cclxuICAvLyBCaXJkIGFuaW1hdGlvbiBmcmFtZXNcclxuICBsZXQgYmlyZEltYWdlczogSFRNTEltYWdlRWxlbWVudFtdID0gW107XHJcbiAgbGV0IHBpcGVUb3A6IEhUTUxJbWFnZUVsZW1lbnQ7XHJcbiAgbGV0IHBpcGVCb3R0b206IEhUTUxJbWFnZUVsZW1lbnQ7XHJcbiAgbGV0IGJhY2tncm91bmQ6IEhUTUxJbWFnZUVsZW1lbnQ7XHJcbiAgbGV0IGNvaW5JbWFnZTogSFRNTEltYWdlRWxlbWVudDtcclxuXHJcbiAgLy8gUHJlbG9hZCBpbWFnZXMgKGNsaWVudC1zaWRlKVxyXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICBjb25zdCBiaXJkVXAgPSBuZXcgSW1hZ2UoKTtcclxuICAgIGJpcmRVcC5zcmMgPSBcIi9hc3NldHMvcmVkYmlyZC11cGZsYXAucG5nXCI7XHJcblxyXG4gICAgY29uc3QgYmlyZE1pZCA9IG5ldyBJbWFnZSgpO1xyXG4gICAgYmlyZE1pZC5zcmMgPSBcIi9hc3NldHMvcmVkYmlyZC1taWRmbGFwLnBuZ1wiO1xyXG5cclxuICAgIGNvbnN0IGJpcmREb3duID0gbmV3IEltYWdlKCk7XHJcbiAgICBiaXJkRG93bi5zcmMgPSBcIi9hc3NldHMvcmVkYmlyZC1kb3duZmxhcC5wbmdcIjtcclxuXHJcbiAgICBiaXJkSW1hZ2VzID0gW2JpcmRVcCwgYmlyZE1pZCwgYmlyZERvd25dO1xyXG5cclxuICAgIHBpcGVUb3AgPSBuZXcgSW1hZ2UoKTtcclxuICAgIHBpcGVUb3Auc3JjID0gXCIvYXNzZXRzL1RvcFRpbnkucG5nXCI7XHJcblxyXG4gICAgcGlwZUJvdHRvbSA9IG5ldyBJbWFnZSgpO1xyXG4gICAgcGlwZUJvdHRvbS5zcmMgPSBcIi9hc3NldHMvQm90dG9tVGlueS5wbmdcIjtcclxuXHJcbiAgICBiYWNrZ3JvdW5kID0gbmV3IEltYWdlKCk7XHJcbiAgICBiYWNrZ3JvdW5kLnNyYyA9IFwiL2Fzc2V0cy9iYWNrZ3JvdW5kLWRheS5wbmdcIjtcclxuXHJcbiAgICBjb2luSW1hZ2UgPSBuZXcgSW1hZ2UoKTtcclxuICAgIGNvaW5JbWFnZS5zcmMgPSBcIi9hc3NldHMvQ29pblRpbnkucG5nXCI7XHJcbiAgfVxyXG5cclxuICBjb25zdCBjdXJyZW50QmlyZEZyYW1lUmVmID0gdXNlUmVmPG51bWJlcj4oMCk7XHJcblxyXG4gIC8vIExvYWQgaGlnaCBzY29yZSBvbiBtb3VudFxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICBjb25zdCBzdG9yZWRIaWdoU2NvcmUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImhpZ2hTY29yZVwiKTtcclxuICAgICAgaWYgKHN0b3JlZEhpZ2hTY29yZSkge1xyXG4gICAgICAgIHNldEhpZ2hTY29yZShwYXJzZUludChzdG9yZWRIaWdoU2NvcmUsIDEwKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LCBbXSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcclxuICAgIGlmICghY2FudmFzKSByZXR1cm47XHJcblxyXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuICAgIGlmICghY3R4KSByZXR1cm47XHJcblxyXG4gICAgLy8gRW5zdXJlIGltYWdlcyBhcmUgZnVsbHkgbG9hZGVkXHJcbiAgICBjb25zdCBsb2FkSW1hZ2UgPSAoaW1nOiBIVE1MSW1hZ2VFbGVtZW50KTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgaWYgKGltZy5jb21wbGV0ZSkge1xyXG4gICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpbWcub25sb2FkID0gKCkgPT4gcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgaW1nLm9uZXJyb3IgPSAoKSA9PiByZWplY3QobmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCAke2ltZy5zcmN9YCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIExvYWQgYWxsIGltYWdlcywgdGhlbiBpbml0aWFsaXplXHJcbiAgICBjb25zdCBsb2FkQXNzZXRzID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgICAgICAgIC4uLmJpcmRJbWFnZXMubWFwKChpbWcpID0+IGxvYWRJbWFnZShpbWcpKSxcclxuICAgICAgICAgIGxvYWRJbWFnZShwaXBlVG9wKSxcclxuICAgICAgICAgIGxvYWRJbWFnZShwaXBlQm90dG9tKSxcclxuICAgICAgICAgIGxvYWRJbWFnZShiYWNrZ3JvdW5kKSxcclxuICAgICAgICAgIGxvYWRJbWFnZShjb2luSW1hZ2UpLFxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIGluaXRpYWxpemVHYW1lKCk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsb2FkaW5nIGFzc2V0czpcIiwgZXJyKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBsb2FkQXNzZXRzKCk7XHJcblxyXG4gICAgLy8gU2V0dXAgLyByZXNldCBnYW1lIHN0YXRlXHJcbiAgICBmdW5jdGlvbiBpbml0aWFsaXplR2FtZSgpIHtcclxuICAgICAgaWYgKCFjYW52YXNSZWYuY3VycmVudCB8fCAhY3R4KSByZXR1cm47XHJcbiAgICAgIGNhbnZhc1JlZi5jdXJyZW50LndpZHRoID0gMzYwO1xyXG4gICAgICBjYW52YXNSZWYuY3VycmVudC5oZWlnaHQgPSA2NDA7XHJcbiAgICAgIGRyYXdTdGFydFNjcmVlbihjdHgsIGNhbnZhc1JlZi5jdXJyZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZXNldEdhbWUoKSB7XHJcbiAgICAgIGlmICghY2FudmFzUmVmLmN1cnJlbnQpIHJldHVybjtcclxuICAgICAgY29uc3QgeyBoZWlnaHQgfSA9IGNhbnZhc1JlZi5jdXJyZW50O1xyXG4gICAgICBiaXJkWVJlZi5jdXJyZW50ID0gaGVpZ2h0IC8gMztcclxuICAgICAgYmlyZFZlbG9jaXR5UmVmLmN1cnJlbnQgPSAwO1xyXG4gICAgICBwaXBlc1JlZi5jdXJyZW50ID0gW107XHJcbiAgICAgIGNvaW5zUmVmLmN1cnJlbnQgPSBbXTtcclxuICAgICAgc2V0Q3VycmVudFNjb3JlKDApO1xyXG4gICAgICBnYW1lT3ZlclJlZi5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICAgIGdhbWVTdGFydGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgICAgY29pblJvdGF0aW9uUmVmLmN1cnJlbnQgPSAwO1xyXG4gICAgICBwaXBlU3Bhd25UaW1lclJlZi5jdXJyZW50ID0gMDtcclxuICAgICAgY3VycmVudEJpcmRGcmFtZVJlZi5jdXJyZW50ID0gMDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEZXNrdG9wIGtleWJvYXJkIGlucHV0XHJcbiAgICBmdW5jdGlvbiBoYW5kbGVLZXlEb3duKGU6IEtleWJvYXJkRXZlbnQpIHtcclxuICAgICAgaWYgKGUua2V5ID09PSBcIiBcIikge1xyXG4gICAgICAgIGZsYXBPclN0YXJ0KCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBoYW5kbGVLZXlEb3duKTtcclxuXHJcbiAgICAvLyBMaXN0ZW4gZm9yIGNhbnZhcyByZXNpemluZ1xyXG4gICAgZnVuY3Rpb24gaGFuZGxlUmVzaXplKCkge1xyXG4gICAgICBpZiAoIWNhbnZhc1JlZi5jdXJyZW50KSByZXR1cm47XHJcbiAgICAgIGNhbnZhc1JlZi5jdXJyZW50LndpZHRoID0gMzYwO1xyXG4gICAgICBjYW52YXNSZWYuY3VycmVudC5oZWlnaHQgPSA2NDA7XHJcbiAgICAgIC8vIFJlZHJhdyB0aGUgc3RhcnQgc2NyZWVuIGlmIG5vdCBzdGFydGVkXHJcbiAgICAgIGlmICghZ2FtZVN0YXJ0ZWRSZWYuY3VycmVudCAmJiAhZ2FtZU92ZXJSZWYuY3VycmVudCAmJiBjdHgpIHtcclxuICAgICAgICBkcmF3U3RhcnRTY3JlZW4oY3R4LCBjYW52YXNSZWYuY3VycmVudCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGhhbmRsZVJlc2l6ZSk7XHJcblxyXG4gICAgZnVuY3Rpb24gZmxhcE9yU3RhcnQoKSB7XHJcbiAgICAgIGlmICghZ2FtZVN0YXJ0ZWRSZWYuY3VycmVudCAmJiAhZ2FtZU92ZXJSZWYuY3VycmVudCkge1xyXG4gICAgICAgIHN0YXJ0R2FtZSgpO1xyXG4gICAgICB9IGVsc2UgaWYgKGdhbWVPdmVyUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBzdGFydEdhbWUoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBiaXJkVmVsb2NpdHlSZWYuY3VycmVudCA9IEZMQVA7XHJcbiAgICAgICAgZmxhcEFuaW1hdGlvbigpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc3RhcnRHYW1lKCkge1xyXG4gICAgICByZXNldEdhbWUoKTtcclxuICAgICAgZ2FtZVN0YXJ0ZWRSZWYuY3VycmVudCA9IHRydWU7XHJcbiAgICAgIGxhc3RUaW1lUmVmLmN1cnJlbnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgcmVxdWVzdElkUmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZmxhcEFuaW1hdGlvbigpIHtcclxuICAgICAgY3VycmVudEJpcmRGcmFtZVJlZi5jdXJyZW50ID0gMTtcclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgY3VycmVudEJpcmRGcmFtZVJlZi5jdXJyZW50ID0gMjtcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgIGN1cnJlbnRCaXJkRnJhbWVSZWYuY3VycmVudCA9IDA7XHJcbiAgICAgICAgfSwgMTcwKTtcclxuICAgICAgfSwgMTcwKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBNYWluIGxvb3BcclxuICAgIGZ1bmN0aW9uIGFuaW1hdGUoY3VycmVudFRpbWU/OiBudW1iZXIpIHtcclxuICAgICAgaWYgKCFnYW1lU3RhcnRlZFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgcmVxdWVzdElkUmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpc1BhdXNlZCkge1xyXG4gICAgICAgIHJlcXVlc3RJZFJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIWNhbnZhc1JlZi5jdXJyZW50KSByZXR1cm47XHJcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXNSZWYuY3VycmVudC5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICAgIGlmICghY29udGV4dCkgcmV0dXJuO1xyXG5cclxuICAgICAgY29uc3Qgbm93ID0gY3VycmVudFRpbWUgPz8gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgIGNvbnN0IGRlbHRhVGltZSA9IG5vdyAtIGxhc3RUaW1lUmVmLmN1cnJlbnQ7XHJcbiAgICAgIGxhc3RUaW1lUmVmLmN1cnJlbnQgPSBub3c7XHJcblxyXG4gICAgICB1cGRhdGVHYW1lU3RhdGUoY2FudmFzUmVmLmN1cnJlbnQsIGRlbHRhVGltZSk7XHJcbiAgICAgIGRyYXcoY29udGV4dCwgY2FudmFzUmVmLmN1cnJlbnQpO1xyXG5cclxuICAgICAgaWYgKCFnYW1lT3ZlclJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgcmVxdWVzdElkUmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZHJhd0dhbWVPdmVyU2NyZWVuKGNvbnRleHQsIGNhbnZhc1JlZi5jdXJyZW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZUdhbWVTdGF0ZShjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCBkZWx0YVRpbWU6IG51bWJlcikge1xyXG4gICAgICBjb25zdCBzY2FsZSA9IGRlbHRhVGltZSAvIElERUFMX0ZSQU1FO1xyXG5cclxuICAgICAgLy8gR3Jhdml0eVxyXG4gICAgICBiaXJkVmVsb2NpdHlSZWYuY3VycmVudCArPSBHUkFWSVRZICogc2NhbGU7XHJcbiAgICAgIGJpcmRZUmVmLmN1cnJlbnQgKz0gYmlyZFZlbG9jaXR5UmVmLmN1cnJlbnQgKiBzY2FsZTtcclxuXHJcbiAgICAgIC8vIFBpcGUgc3Bhd25cclxuICAgICAgcGlwZVNwYXduVGltZXJSZWYuY3VycmVudCArPSBkZWx0YVRpbWU7XHJcbiAgICAgIGlmIChwaXBlU3Bhd25UaW1lclJlZi5jdXJyZW50ID49IFBJUEVfU1BBV05fSU5URVJWQUwpIHtcclxuICAgICAgICBwaXBlU3Bhd25UaW1lclJlZi5jdXJyZW50IC09IFBJUEVfU1BBV05fSU5URVJWQUw7XHJcbiAgICAgICAgY3JlYXRlUGlwZShjYW52YXMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBNb3ZlIHBpcGVzICYgY29pbnNcclxuICAgICAgbW92ZVBpcGVzQW5kQ29pbnMoc2NhbGUpO1xyXG5cclxuICAgICAgLy8gUm90YXRlIGNvaW5cclxuICAgICAgY29pblJvdGF0aW9uUmVmLmN1cnJlbnQgKz0gUk9UQVRJT05fU1BFRUQgKiBzY2FsZTtcclxuICAgICAgaWYgKGNvaW5Sb3RhdGlvblJlZi5jdXJyZW50ID49IDEpIHtcclxuICAgICAgICBjb2luUm90YXRpb25SZWYuY3VycmVudCA9IDA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENvbGxpc2lvbnNcclxuICAgICAgaWYgKGNoZWNrQ29sbGlzaW9ucyhjYW52YXMpKSB7XHJcbiAgICAgICAgZ2FtZU92ZXJSZWYuY3VycmVudCA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDb2luIGNvbGxlY3Rpb25cclxuICAgICAgY2hlY2tDb2luQ29sbGVjdGlvbigpO1xyXG5cclxuICAgICAgLy8gU2NvcmVcclxuICAgICAgdXBkYXRlU2NvcmUoKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3KGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICAgICAgZHJhd0JhY2tncm91bmQoY3R4LCBjYW52YXMpO1xyXG4gICAgICBkcmF3QmlyZChjdHgpO1xyXG4gICAgICBkcmF3UGlwZXMoY3R4KTtcclxuICAgICAgZHJhd0NvaW5zKGN0eCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2NlbmVzXHJcbiAgICBmdW5jdGlvbiBkcmF3U3RhcnRTY3JlZW4oY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcclxuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICBkcmF3QmFja2dyb3VuZChjdHgsIGNhbnZhcyk7XHJcblxyXG4gICAgICBjdHguZm9udCA9IFwiYm9sZCAzMHB4IEFyaWFsXCI7XHJcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xyXG4gICAgICBjdHguZmlsbFN0eWxlID0gXCIjZmZmZmZmXCI7XHJcbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFwiYmxhY2tcIjtcclxuICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XHJcblxyXG4gICAgICBjdHguZmlsbFRleHQoXCJQcmVzcyBTcGFjZSB0byBTdGFydFwiLCBjYW52YXMud2lkdGggLyAyLCBjYW52YXMuaGVpZ2h0IC8gMik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd0dhbWVPdmVyU2NyZWVuKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNmZmNjMDBcIjtcclxuICAgICAgY3R4LmZvbnQgPSBcImJvbGQgNTBweCBBcmlhbFwiO1xyXG4gICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcclxuICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XHJcbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFwiYmxhY2tcIjtcclxuICAgICAgY3R4LnNoYWRvd0JsdXIgPSAxMDtcclxuXHJcbiAgICAgIGN0eC5maWxsVGV4dChcIkdhbWUgT3ZlciFcIiwgY2FudmFzLndpZHRoIC8gMiwgY2FudmFzLmhlaWdodCAvIDIgLSA0MCk7XHJcblxyXG4gICAgICBjdHguZmlsbFN0eWxlID0gXCIjZmZmZmZmXCI7XHJcbiAgICAgIGN0eC5mb250ID0gXCJib2xkIDMwcHggQXJpYWxcIjtcclxuICAgICAgY3R4LmZpbGxUZXh0KFxyXG4gICAgICAgIFwiUHJlc3MgU3BhY2UgdG8gUmVzdGFydFwiLFxyXG4gICAgICAgIGNhbnZhcy53aWR0aCAvIDIsXHJcbiAgICAgICAgY2FudmFzLmhlaWdodCAvIDIgKyAyMFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdCYWNrZ3JvdW5kKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgIGN0eC5kcmF3SW1hZ2UoYmFja2dyb3VuZCwgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3QmlyZChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xyXG4gICAgICBjb25zdCBjdXJyZW50SW1hZ2UgPSBiaXJkSW1hZ2VzW2N1cnJlbnRCaXJkRnJhbWVSZWYuY3VycmVudF07XHJcbiAgICAgIGlmIChjdXJyZW50SW1hZ2UuY29tcGxldGUpIHtcclxuICAgICAgICBjdHguZHJhd0ltYWdlKGN1cnJlbnRJbWFnZSwgMTAwLCBiaXJkWVJlZi5jdXJyZW50LCBCSVJEX1dJRFRILCBCSVJEX0hFSUdIVCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3UGlwZXMoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcclxuICAgICAgZm9yIChjb25zdCBwaXBlIG9mIHBpcGVzUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBjdHguZHJhd0ltYWdlKHBpcGVUb3AsIHBpcGUueCwgMCwgUElQRV9XSURUSCwgcGlwZS50b3BIZWlnaHQpO1xyXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UocGlwZUJvdHRvbSwgcGlwZS54LCBwaXBlLmJvdHRvbVksIFBJUEVfV0lEVEgsIHBpcGUuYm90dG9tSGVpZ2h0KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdDb2lucyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xyXG4gICAgICBjb25zdCBzY2FsZVggPSBNYXRoLmFicyhNYXRoLmNvcyhjb2luUm90YXRpb25SZWYuY3VycmVudCAqIE1hdGguUEkgKiAyKSk7XHJcbiAgICAgIGNvbnN0IGhhbGZTaXplID0gQ09JTl9TSVpFIC8gMjtcclxuICAgICAgZm9yIChjb25zdCBjb2luIG9mIGNvaW5zUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBpZiAoIWNvaW4uY29sbGVjdGVkKSB7XHJcbiAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgY3R4LnRyYW5zbGF0ZShjb2luLnggKyBoYWxmU2l6ZSwgY29pbi55ICsgaGFsZlNpemUpO1xyXG4gICAgICAgICAgY3R4LnNjYWxlKHNjYWxlWCwgMSk7XHJcbiAgICAgICAgICBjdHguZHJhd0ltYWdlKGNvaW5JbWFnZSwgLWhhbGZTaXplLCAtaGFsZlNpemUsIENPSU5fU0laRSwgQ09JTl9TSVpFKTtcclxuICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ3JlYXRlIHBpcGVzL2NvaW5zXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVQaXBlKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcclxuICAgICAgY29uc3QgcGlwZUhlaWdodCA9IE1hdGgucmFuZG9tKCkgKiAoY2FudmFzLmhlaWdodCAtIFBJUEVfU1BBQ0lORyAtIDEwMCkgKyA1MDtcclxuICAgICAgY29uc3QgYm90dG9tWSA9IHBpcGVIZWlnaHQgKyBQSVBFX1NQQUNJTkc7XHJcbiAgICAgIHBpcGVzUmVmLmN1cnJlbnQucHVzaCh7XHJcbiAgICAgICAgeDogY2FudmFzLndpZHRoLFxyXG4gICAgICAgIHRvcEhlaWdodDogcGlwZUhlaWdodCxcclxuICAgICAgICBib3R0b21ZLFxyXG4gICAgICAgIGJvdHRvbUhlaWdodDogY2FudmFzLmhlaWdodCAtIGJvdHRvbVksXHJcbiAgICAgICAgc2NvcmVkOiBmYWxzZSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyA1MCUgY2hhbmNlIGZvciBjb2luXHJcbiAgICAgIGlmIChNYXRoLnJhbmRvbSgpID4gMC41KSB7XHJcbiAgICAgICAgY29pbnNSZWYuY3VycmVudC5wdXNoKHtcclxuICAgICAgICAgIHg6IGNhbnZhcy53aWR0aCArIFBJUEVfV0lEVEggLyAyIC0gQ09JTl9TSVpFIC8gMixcclxuICAgICAgICAgIHk6IHBpcGVIZWlnaHQgKyBQSVBFX1NQQUNJTkcgLyAyIC0gQ09JTl9TSVpFIC8gMixcclxuICAgICAgICAgIHdpZHRoOiBDT0lOX1NJWkUsXHJcbiAgICAgICAgICBoZWlnaHQ6IENPSU5fU0laRSxcclxuICAgICAgICAgIGNvbGxlY3RlZDogZmFsc2UsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtb3ZlUGlwZXNBbmRDb2lucyhzY2FsZTogbnVtYmVyKSB7XHJcbiAgICAgIGZvciAoY29uc3QgcGlwZSBvZiBwaXBlc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgcGlwZS54IC09IEhPUklaT05UQUxfU1BFRUQgKiBzY2FsZTtcclxuICAgICAgfVxyXG4gICAgICBwaXBlc1JlZi5jdXJyZW50ID0gcGlwZXNSZWYuY3VycmVudC5maWx0ZXIoKHApID0+IHAueCArIFBJUEVfV0lEVEggPiAwKTtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgY29pbiBvZiBjb2luc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY29pbi54IC09IEhPUklaT05UQUxfU1BFRUQgKiBzY2FsZTtcclxuICAgICAgfVxyXG4gICAgICBjb2luc1JlZi5jdXJyZW50ID0gY29pbnNSZWYuY3VycmVudC5maWx0ZXIoXHJcbiAgICAgICAgKGMpID0+IGMueCArIGMud2lkdGggPiAwICYmICFjLmNvbGxlY3RlZFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNoZWNrQ29sbGlzaW9ucyhjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KTogYm9vbGVhbiB7XHJcbiAgICAgIC8vIEJpcmQgdnMgYm91bmRhcmllc1xyXG4gICAgICBpZiAoYmlyZFlSZWYuY3VycmVudCA8IDAgfHwgYmlyZFlSZWYuY3VycmVudCArIEJJUkRfSEVJR0hUID4gY2FudmFzLmhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBiaXJkTGVmdCA9IDEwMDtcclxuICAgICAgY29uc3QgYmlyZFJpZ2h0ID0gYmlyZExlZnQgKyBCSVJEX1dJRFRIO1xyXG4gICAgICBjb25zdCBiaXJkVG9wID0gYmlyZFlSZWYuY3VycmVudDtcclxuICAgICAgY29uc3QgYmlyZEJvdHRvbSA9IGJpcmRZUmVmLmN1cnJlbnQgKyBCSVJEX0hFSUdIVDtcclxuXHJcbiAgICAgIC8vIEJpcmQgdnMgcGlwZXNcclxuICAgICAgZm9yIChjb25zdCBwaXBlIG9mIHBpcGVzUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBjb25zdCB3aXRoaW5QaXBlWCA9IGJpcmRSaWdodCA+IHBpcGUueCAmJiBiaXJkTGVmdCA8IHBpcGUueCArIFBJUEVfV0lEVEg7XHJcbiAgICAgICAgY29uc3Qgd2l0aGluUGlwZVkgPSBiaXJkVG9wIDwgcGlwZS50b3BIZWlnaHQgfHwgYmlyZEJvdHRvbSA+IHBpcGUuYm90dG9tWTtcclxuICAgICAgICBpZiAod2l0aGluUGlwZVggJiYgd2l0aGluUGlwZVkpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2hlY2tDb2luQ29sbGVjdGlvbigpIHtcclxuICAgICAgY29uc3QgYmlyZExlZnQgPSAxMDA7XHJcbiAgICAgIGNvbnN0IGJpcmRSaWdodCA9IGJpcmRMZWZ0ICsgQklSRF9XSURUSDtcclxuICAgICAgY29uc3QgYmlyZFRvcCA9IGJpcmRZUmVmLmN1cnJlbnQ7XHJcbiAgICAgIGNvbnN0IGJpcmRCb3R0b20gPSBiaXJkWVJlZi5jdXJyZW50ICsgQklSRF9IRUlHSFQ7XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGNvaW4gb2YgY29pbnNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGlmICghY29pbi5jb2xsZWN0ZWQpIHtcclxuICAgICAgICAgIGNvbnN0IGNvaW5MZWZ0ID0gY29pbi54O1xyXG4gICAgICAgICAgY29uc3QgY29pblJpZ2h0ID0gY29pbi54ICsgY29pbi53aWR0aDtcclxuICAgICAgICAgIGNvbnN0IGNvaW5Ub3AgPSBjb2luLnk7XHJcbiAgICAgICAgICBjb25zdCBjb2luQm90dG9tID0gY29pbi55ICsgY29pbi5oZWlnaHQ7XHJcblxyXG4gICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICBiaXJkUmlnaHQgPiBjb2luTGVmdCAmJlxyXG4gICAgICAgICAgICBiaXJkTGVmdCA8IGNvaW5SaWdodCAmJlxyXG4gICAgICAgICAgICBiaXJkQm90dG9tID4gY29pblRvcCAmJlxyXG4gICAgICAgICAgICBiaXJkVG9wIDwgY29pbkJvdHRvbVxyXG4gICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIC8vIENvbGxlY3QgY29pblxyXG4gICAgICAgICAgICBjb2luLmNvbGxlY3RlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHNldEN1cnJlbnRTY29yZSgocHJldikgPT4ge1xyXG4gICAgICAgICAgICAgIGNvbnN0IG5ld1Njb3JlID0gcHJldiArIDU7XHJcbiAgICAgICAgICAgICAgc2V0SGlnaFNjb3JlKChwcmV2SGlnaCkgPT4gTWF0aC5tYXgocHJldkhpZ2gsIG5ld1Njb3JlKSk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIG5ld1Njb3JlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVTY29yZSgpIHtcclxuICAgICAgZm9yIChjb25zdCBwaXBlIG9mIHBpcGVzUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAvLyArMSBzY29yZSBvbmNlIHRoZSBwaXBlIGhhcyBmdWxseSBwYXNzZWQgYmlyZCB4PTEwMFxyXG4gICAgICAgIGlmICghcGlwZS5zY29yZWQgJiYgcGlwZS54ICsgUElQRV9XSURUSCA8IDEwMCkge1xyXG4gICAgICAgICAgcGlwZS5zY29yZWQgPSB0cnVlO1xyXG4gICAgICAgICAgc2V0Q3VycmVudFNjb3JlKChwcmV2KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1Njb3JlID0gcHJldiArIDE7XHJcbiAgICAgICAgICAgIHNldEhpZ2hTY29yZSgocHJldkhpZ2gpID0+IHtcclxuICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkSGlnaCA9IE1hdGgubWF4KHByZXZIaWdoLCBuZXdTY29yZSk7XHJcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwiaGlnaFNjb3JlXCIsIHVwZGF0ZWRIaWdoLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlZEhpZ2g7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3U2NvcmU7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBIYW5kbGUgc2luZ2xlIHRhcC9jbGljayBvbiBjYW52YXMgdG8gZmxhcFxyXG4gICAgLy8gV2UnbGwgZGVib3VuY2Ugd2l0aCBhIHNob3J0IHRpbWVvdXQgdG8gcHJldmVudCBkb3VibGUgdGFwc1xyXG4gICAgY29uc3QgbGFzdFRhcFJlZiA9IHVzZVJlZigwKTtcclxuICAgIGNvbnN0IERFQk9VTkNFX1RJTUUgPSAzMDA7IC8vIG1zXHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlQ2FudmFzVGFwKGU6IFRvdWNoRXZlbnQgfCBNb3VzZUV2ZW50KSB7XHJcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTsgLy8gUHJldmVudCBnZW5lcmF0aW5nIG11bHRpcGxlIGV2ZW50c1xyXG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG4gICAgICBpZiAobm93IC0gbGFzdFRhcFJlZi5jdXJyZW50IDwgREVCT1VOQ0VfVElNRSkge1xyXG4gICAgICAgIC8vIERldGVjdGVkIGEgc2Vjb25kIHRhcCBpbiBxdWljayBzdWNjZXNzaW9uID0+IGlnbm9yZVxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBsYXN0VGFwUmVmLmN1cnJlbnQgPSBub3c7XHJcbiAgICAgIGZsYXBPclN0YXJ0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQmluZCBtb2JpbGUgJiBtb3VzZSBpbnB1dCB0byB0aGUgY2FudmFzXHJcbiAgICBjb25zdCBhZGRDYW52YXNMaXN0ZW5lcnMgPSAoKSA9PiB7XHJcbiAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBoYW5kbGVDYW52YXNUYXApO1xyXG4gICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBoYW5kbGVDYW52YXNUYXApO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCByZW1vdmVDYW52YXNMaXN0ZW5lcnMgPSAoKSA9PiB7XHJcbiAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBoYW5kbGVDYW52YXNUYXApO1xyXG4gICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBoYW5kbGVDYW52YXNUYXApO1xyXG4gICAgfTtcclxuXHJcbiAgICBhZGRDYW52YXNMaXN0ZW5lcnMoKTtcclxuXHJcbiAgICAvLyBJZiBhdXRvU3RhcnQgaXMgdHJ1ZSwgc3RhcnQgYXV0b21hdGljYWxseVxyXG4gICAgaWYgKGF1dG9TdGFydCkge1xyXG4gICAgICBmbGFwT3JTdGFydCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENsZWFudXBcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBoYW5kbGVLZXlEb3duKTtcclxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgaGFuZGxlUmVzaXplKTtcclxuICAgICAgcmVtb3ZlQ2FudmFzTGlzdGVuZXJzKCk7XHJcbiAgICAgIGlmIChyZXF1ZXN0SWRSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJlcXVlc3RJZFJlZi5jdXJyZW50KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9LCBbY2FudmFzUmVmLCBpc1BhdXNlZCwgYXV0b1N0YXJ0XSk7XHJcblxyXG4gIC8vIFdlIG5vIGxvbmdlciBkaXNwYXRjaCBhIHN5bnRoZXRpYyBrZXlkb3duIGV2ZW50LFxyXG4gIC8vIHNpbmNlIHRoYXQgY2FuIGNhdXNlIG11bHRpcGxlIHRyaWdnZXJzIG9uIG1vYmlsZS5cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGhpZ2hTY29yZSxcclxuICAgIGN1cnJlbnRTY29yZSxcclxuICB9O1xyXG59XHJcbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsIkdSQVZJVFkiLCJGTEFQIiwiUElQRV9XSURUSCIsIlBJUEVfU1BBQ0lORyIsIkJJUkRfV0lEVEgiLCJCSVJEX0hFSUdIVCIsIkNPSU5fU0laRSIsIlBJUEVfU1BBV05fSU5URVJWQUwiLCJIT1JJWk9OVEFMX1NQRUVEIiwiUk9UQVRJT05fU1BFRUQiLCJJREVBTF9GUkFNRSIsInVzZUZsYXBweUJpcmRHYW1lIiwiY2FudmFzUmVmIiwiaXNQYXVzZWQiLCJhdXRvU3RhcnQiLCJyZXF1ZXN0SWRSZWYiLCJoaWdoU2NvcmUiLCJzZXRIaWdoU2NvcmUiLCJjdXJyZW50U2NvcmUiLCJzZXRDdXJyZW50U2NvcmUiLCJiaXJkWVJlZiIsImJpcmRWZWxvY2l0eVJlZiIsInBpcGVzUmVmIiwiY29pbnNSZWYiLCJnYW1lT3ZlclJlZiIsImdhbWVTdGFydGVkUmVmIiwiY29pblJvdGF0aW9uUmVmIiwicGlwZVNwYXduVGltZXJSZWYiLCJsYXN0VGltZVJlZiIsImJpcmRJbWFnZXMiLCJwaXBlVG9wIiwicGlwZUJvdHRvbSIsImJhY2tncm91bmQiLCJjb2luSW1hZ2UiLCJiaXJkVXAiLCJJbWFnZSIsInNyYyIsImJpcmRNaWQiLCJiaXJkRG93biIsImN1cnJlbnRCaXJkRnJhbWVSZWYiLCJzdG9yZWRIaWdoU2NvcmUiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwicGFyc2VJbnQiLCJjYW52YXMiLCJjdXJyZW50IiwiY3R4IiwiZ2V0Q29udGV4dCIsImxvYWRJbWFnZSIsImltZyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiY29tcGxldGUiLCJvbmxvYWQiLCJvbmVycm9yIiwiRXJyb3IiLCJsb2FkQXNzZXRzIiwiYWxsIiwibWFwIiwiaW5pdGlhbGl6ZUdhbWUiLCJlcnIiLCJjb25zb2xlIiwiZXJyb3IiLCJ3aWR0aCIsImhlaWdodCIsImRyYXdTdGFydFNjcmVlbiIsInJlc2V0R2FtZSIsImhhbmRsZUtleURvd24iLCJlIiwia2V5IiwiZmxhcE9yU3RhcnQiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwiaGFuZGxlUmVzaXplIiwic3RhcnRHYW1lIiwiZmxhcEFuaW1hdGlvbiIsInBlcmZvcm1hbmNlIiwibm93IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiYW5pbWF0ZSIsInNldFRpbWVvdXQiLCJjdXJyZW50VGltZSIsImNvbnRleHQiLCJkZWx0YVRpbWUiLCJ1cGRhdGVHYW1lU3RhdGUiLCJkcmF3IiwiZHJhd0dhbWVPdmVyU2NyZWVuIiwic2NhbGUiLCJjcmVhdGVQaXBlIiwibW92ZVBpcGVzQW5kQ29pbnMiLCJjaGVja0NvbGxpc2lvbnMiLCJjaGVja0NvaW5Db2xsZWN0aW9uIiwidXBkYXRlU2NvcmUiLCJjbGVhclJlY3QiLCJkcmF3QmFja2dyb3VuZCIsImRyYXdCaXJkIiwiZHJhd1BpcGVzIiwiZHJhd0NvaW5zIiwiZm9udCIsInRleHRBbGlnbiIsImZpbGxTdHlsZSIsInNoYWRvd0NvbG9yIiwidGV4dEJhc2VsaW5lIiwiZmlsbFRleHQiLCJzaGFkb3dCbHVyIiwiZHJhd0ltYWdlIiwiY3VycmVudEltYWdlIiwicGlwZSIsIngiLCJ0b3BIZWlnaHQiLCJib3R0b21ZIiwiYm90dG9tSGVpZ2h0Iiwic2NhbGVYIiwiTWF0aCIsImFicyIsImNvcyIsIlBJIiwiaGFsZlNpemUiLCJjb2luIiwiY29sbGVjdGVkIiwic2F2ZSIsInRyYW5zbGF0ZSIsInkiLCJyZXN0b3JlIiwicGlwZUhlaWdodCIsInJhbmRvbSIsInB1c2giLCJzY29yZWQiLCJmaWx0ZXIiLCJwIiwiYyIsImJpcmRMZWZ0IiwiYmlyZFJpZ2h0IiwiYmlyZFRvcCIsImJpcmRCb3R0b20iLCJ3aXRoaW5QaXBlWCIsIndpdGhpblBpcGVZIiwiY29pbkxlZnQiLCJjb2luUmlnaHQiLCJjb2luVG9wIiwiY29pbkJvdHRvbSIsInByZXYiLCJuZXdTY29yZSIsInByZXZIaWdoIiwibWF4IiwidXBkYXRlZEhpZ2giLCJzZXRJdGVtIiwidG9TdHJpbmciLCJsYXN0VGFwUmVmIiwiREVCT1VOQ0VfVElNRSIsImhhbmRsZUNhbnZhc1RhcCIsInByZXZlbnREZWZhdWx0IiwiRGF0ZSIsImFkZENhbnZhc0xpc3RlbmVycyIsInJlbW92ZUNhbnZhc0xpc3RlbmVycyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjYW5jZWxBbmltYXRpb25GcmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./public/useFlappyBirdGame.ts\n"));

/***/ })

});