"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./public/useFlappyBirdGame.ts":
/*!*************************************!*\
  !*** ./public/useFlappyBirdGame.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFlappyBirdGame: function() { return /* binding */ useFlappyBirdGame; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n// useFlappyBirdGame.ts\n\n/**\r\n * Constants - defined in pixels per second\r\n */ const GRAVITY = 800; // pixels per second squared\nconst FLAP_VELOCITY = -450; // pixels per second\nconst PIPE_SPEED = 200; // pixels per second\nconst PIPE_SPAWN_INTERVAL = 1500; // milliseconds\nconst PIPE_WIDTH = 90;\nconst PIPE_GAP = 200; // Vertical gap between pipes\nconst BIRD_X = 100; // Fixed X position\nconst BIRD_WIDTH = 50;\nconst BIRD_HEIGHT = 50;\nconst COIN_SPEED = 200; // pixels per second\nconst COIN_SPAWN_CHANCE = 0.25; // 25%\nconst COIN_SIZE = 80;\nconst ROTATION_SPEED = 2 * Math.PI; // radians per second (full rotation per second)\n/**\r\n * Custom hook to manage Flappy Bird game logic.\r\n * @param canvasRef Reference to the canvas element.\r\n * @param isPaused Boolean indicating if the game is paused.\r\n * @param autoStart Boolean indicating if the game should start automatically.\r\n * @returns High score, current score, and a handler for user input.\r\n */ function useFlappyBirdGame(canvasRef, isPaused, autoStart) {\n    // State for scores\n    const [highScore, setHighScore] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [currentScore, setCurrentScore] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    // Refs to track game state\n    const birdYRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const birdVelocityRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const pipesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const coinsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const gameOverRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const gameStartedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // Rotation angle for coins\n    const coinRotationRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // Time tracking\n    const lastTimeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const pipeSpawnTimerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // Asset images\n    const birdImagesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const pipeTopImgRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const pipeBottomImgRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const backgroundImgRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const coinImgRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // Current bird frame index for flap animation\n    const currentBirdFrameRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(1); // Start with mid-flap\n    /**\r\n   * Helper function to load an image fully.\r\n   * @param img HTMLImageElement\r\n   * @returns Promise that resolves when the image is loaded.\r\n   */ const loadImage = (img)=>{\n        return new Promise((resolve, reject)=>{\n            if (img.complete) {\n                resolve();\n            } else {\n                img.onload = ()=>resolve();\n                img.onerror = ()=>reject(new Error(\"Failed to load image: \".concat(img.src)));\n            }\n        });\n    };\n    /**\r\n   * Initialize and load all game assets.\r\n   */ (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (false) {}\n        // Initialize bird images\n        const birdUp = new Image();\n        birdUp.src = \"/assets/redbird-upflap.png\";\n        const birdMid = new Image();\n        birdMid.src = \"/assets/redbird-midflap.png\";\n        const birdDown = new Image();\n        birdDown.src = \"/assets/redbird-downflap.png\";\n        birdImagesRef.current = [\n            birdUp,\n            birdMid,\n            birdDown\n        ];\n        // Initialize pipe images\n        const pipeTopImg = new Image();\n        pipeTopImg.src = \"/assets/TopTiny.png\";\n        pipeTopImgRef.current = pipeTopImg;\n        const pipeBottomImg = new Image();\n        pipeBottomImg.src = \"/assets/BottomTiny.png\";\n        pipeBottomImgRef.current = pipeBottomImg;\n        // Initialize background and coin images\n        const backgroundImg = new Image();\n        backgroundImg.src = \"/assets/background-day.png\";\n        backgroundImgRef.current = backgroundImg;\n        const coinImg = new Image();\n        coinImg.src = \"/assets/CoinTiny.png\";\n        coinImgRef.current = coinImg;\n    }, []);\n    /**\r\n   * Load high score from localStorage on mount.\r\n   */ (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (false) {}\n        const storedHighScore = localStorage.getItem(\"highScore\");\n        if (storedHighScore) {\n            setHighScore(parseInt(storedHighScore, 10));\n        }\n    }, []);\n    /**\r\n   * Initialize the game by loading assets and setting up the canvas.\r\n   */ const initializeGame = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        try {\n            // Load all assets\n            const assets = [\n                ...birdImagesRef.current,\n                pipeTopImgRef.current,\n                pipeBottomImgRef.current,\n                backgroundImgRef.current,\n                coinImgRef.current\n            ];\n            await Promise.all(assets.map((img)=>loadImage(img)));\n            console.log(\"All assets loaded successfully!\");\n            // Set canvas dimensions\n            canvas.width = 360;\n            canvas.height = 640;\n            // Draw start screen\n            drawStartScreen(ctx, canvas);\n            // Auto-start if enabled\n            if (autoStart) {\n                startGame();\n            }\n        } catch (error) {\n            console.error(error);\n        }\n    }, [\n        canvasRef,\n        autoStart\n    ]);\n    /**\r\n   * Reset game state to initial conditions.\r\n   */ const resetGame = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const { height } = canvas;\n        birdYRef.current = height / 3;\n        birdVelocityRef.current = 0;\n        pipesRef.current = [];\n        coinsRef.current = [];\n        setCurrentScore(0);\n        gameOverRef.current = false;\n        gameStartedRef.current = false;\n        coinRotationRef.current = 0;\n        lastTimeRef.current = 0;\n        pipeSpawnTimerRef.current = 0;\n        currentBirdFrameRef.current = 1; // mid-flap\n    }, [\n        canvasRef\n    ]);\n    /**\r\n   * Start the game by resetting the state and initiating the game loop.\r\n   */ const startGame = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        resetGame();\n        gameStartedRef.current = true;\n        lastTimeRef.current = performance.now();\n        requestIdRef.current = requestAnimationFrame(animate);\n    }, [\n        resetGame\n    ]);\n    /**\r\n   * Handle user input (click/tap) by flapping or restarting.\r\n   */ const handleUserInput = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (!gameStartedRef.current && !gameOverRef.current) {\n            startGame();\n        } else if (gameOverRef.current) {\n            startGame();\n        } else {\n            birdVelocityRef.current = FLAP_VELOCITY;\n            flapAnimation();\n        }\n    }, [\n        startGame\n    ]);\n    /**\r\n   * Handle keydown events for space bar to flap or restart.\r\n   * @param e KeyboardEvent\r\n   */ const handleKeyDown = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        if (e.key === \" \") {\n            handleUserInput();\n        }\n    }, [\n        handleUserInput\n    ]);\n    /**\r\n   * Add keydown event listener on mount.\r\n   */ (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        window.addEventListener(\"keydown\", handleKeyDown);\n        return ()=>window.removeEventListener(\"keydown\", handleKeyDown);\n    }, [\n        handleKeyDown\n    ]);\n    /**\r\n   * Handle flap animation by cycling through bird frames.\r\n   */ const flapAnimation = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const flapFrames = [\n            0,\n            1,\n            2,\n            1\n        ];\n        let currentFrame = 0;\n        const flapInterval = 100; // milliseconds between frames\n        const flap = ()=>{\n            if (currentFrame < flapFrames.length) {\n                currentBirdFrameRef.current = flapFrames[currentFrame];\n                currentFrame++;\n                setTimeout(flap, flapInterval);\n            } else {\n                currentBirdFrameRef.current = 1; // reset to mid-flap\n            }\n        };\n        flap();\n    }, []);\n    /**\r\n   * The main game loop using requestAnimationFrame.\r\n   * @param timestamp Current timestamp\r\n   */ const animate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((timestamp)=>{\n        if (isPaused || !gameStartedRef.current) {\n            requestIdRef.current = requestAnimationFrame(animate);\n            return;\n        }\n        if (!lastTimeRef.current) {\n            lastTimeRef.current = timestamp;\n        }\n        let deltaTime = (timestamp - lastTimeRef.current) / 1000; // in seconds\n        // Cap deltaTime to 0.05 seconds to prevent big jumps\n        deltaTime = Math.min(deltaTime, 0.05);\n        lastTimeRef.current = timestamp;\n        // Update game state\n        updateGameState(deltaTime);\n        // Draw everything\n        const canvas = canvasRef.current;\n        if (canvas) {\n            const ctx = canvas.getContext(\"2d\");\n            if (ctx) {\n                draw(ctx, canvas);\n            }\n        }\n        if (!gameOverRef.current) {\n            requestIdRef.current = requestAnimationFrame(animate);\n        } else {\n            // Draw game over screen\n            const canvas = canvasRef.current;\n            if (canvas) {\n                const ctx = canvas.getContext(\"2d\");\n                if (ctx) {\n                    drawGameOverScreen(ctx, canvas);\n                }\n            }\n        }\n    }, [\n        isPaused\n    ]);\n    /**\r\n   * Update the game state based on elapsed time.\r\n   * @param deltaTime Time elapsed since last frame (in seconds)\r\n   */ const updateGameState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((deltaTime)=>{\n        // Apply gravity to the bird\n        birdVelocityRef.current += GRAVITY * deltaTime;\n        birdYRef.current += birdVelocityRef.current * deltaTime;\n        // Update pipe spawn timer and spawn pipes at intervals\n        pipeSpawnTimerRef.current += deltaTime;\n        if (pipeSpawnTimerRef.current > PIPE_SPAWN_INTERVAL / 1000) {\n            createPipe();\n            pipeSpawnTimerRef.current = 0;\n        }\n        // Move pipes based on PIPE_SPEED and deltaTime\n        const pipeMoveDelta = PIPE_SPEED * deltaTime;\n        pipesRef.current = pipesRef.current.map((pipe)=>({\n                ...pipe,\n                x: pipe.x - pipeMoveDelta\n            }));\n        // Remove offscreen pipes\n        pipesRef.current = pipesRef.current.filter((pipe)=>pipe.x + PIPE_WIDTH > 0);\n        // Move coins based on COIN_SPEED and deltaTime\n        const coinMoveDelta = COIN_SPEED * deltaTime;\n        coinsRef.current = coinsRef.current.map((coin)=>({\n                ...coin,\n                x: coin.x - coinMoveDelta\n            }));\n        // Remove offscreen or collected coins\n        coinsRef.current = coinsRef.current.filter((coin)=>coin.x + coin.width > 0 && !coin.collected);\n        // Rotate coins for visual effect\n        coinRotationRef.current += ROTATION_SPEED * deltaTime;\n        if (coinRotationRef.current >= 2 * Math.PI) {\n            coinRotationRef.current -= 2 * Math.PI;\n        }\n        // Check for collisions\n        if (checkCollisions()) {\n            gameOverRef.current = true;\n            return;\n        }\n        // Check if bird collects any coins\n        checkCoinCollection();\n        // Update the score based on pipe passing\n        updateScore();\n    }, []);\n    /**\r\n   * Render all game elements onto the canvas.\r\n   * @param ctx CanvasRenderingContext2D\r\n   * @param canvas Canvas element\r\n   */ const draw = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((ctx, canvas)=>{\n        var _backgroundImgRef_current;\n        // Clear the canvas\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        // Draw background\n        if ((_backgroundImgRef_current = backgroundImgRef.current) === null || _backgroundImgRef_current === void 0 ? void 0 : _backgroundImgRef_current.complete) {\n            ctx.drawImage(backgroundImgRef.current, 0, 0, canvas.width, canvas.height);\n        }\n        // Draw pipes\n        for (const pipe of pipesRef.current){\n            var _pipeTopImgRef_current, _pipeBottomImgRef_current;\n            // Top pipe\n            if ((_pipeTopImgRef_current = pipeTopImgRef.current) === null || _pipeTopImgRef_current === void 0 ? void 0 : _pipeTopImgRef_current.complete) {\n                ctx.drawImage(pipeTopImgRef.current, pipe.x, 0, PIPE_WIDTH, pipe.gapY);\n            }\n            // Bottom pipe\n            if ((_pipeBottomImgRef_current = pipeBottomImgRef.current) === null || _pipeBottomImgRef_current === void 0 ? void 0 : _pipeBottomImgRef_current.complete) {\n                ctx.drawImage(pipeBottomImgRef.current, pipe.x, pipe.gapY + PIPE_GAP, PIPE_WIDTH, canvas.height - (pipe.gapY + PIPE_GAP));\n            }\n        }\n        // Draw coins\n        for (const coin of coinsRef.current){\n            var _coinImgRef_current;\n            if (!coin.collected && ((_coinImgRef_current = coinImgRef.current) === null || _coinImgRef_current === void 0 ? void 0 : _coinImgRef_current.complete)) {\n                ctx.save();\n                ctx.translate(coin.x + coin.width / 2, coin.y + coin.height / 2);\n                ctx.rotate(coinRotationRef.current);\n                ctx.drawImage(coinImgRef.current, -coin.width / 2, -coin.height / 2, coin.width, coin.height);\n                ctx.restore();\n            }\n        }\n        // Draw bird\n        const currentBirdFrame = birdImagesRef.current[currentBirdFrameRef.current];\n        if (currentBirdFrame === null || currentBirdFrame === void 0 ? void 0 : currentBirdFrame.complete) {\n            ctx.drawImage(currentBirdFrame, BIRD_X, birdYRef.current, BIRD_WIDTH, BIRD_HEIGHT);\n        }\n    }, []);\n    /**\r\n   * Render the start screen.\r\n   * @param ctx CanvasRenderingContext2D\r\n   * @param canvas Canvas element\r\n   */ const drawStartScreen = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((ctx, canvas)=>{\n        var _backgroundImgRef_current;\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        // Draw background\n        if ((_backgroundImgRef_current = backgroundImgRef.current) === null || _backgroundImgRef_current === void 0 ? void 0 : _backgroundImgRef_current.complete) {\n            ctx.drawImage(backgroundImgRef.current, 0, 0, canvas.width, canvas.height);\n        }\n        // Draw start text\n        ctx.fillStyle = \"white\";\n        ctx.font = \"bold 30px Arial\";\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        ctx.fillText(\"Press Space or Tap to Start\", canvas.width / 2, canvas.height / 2);\n    }, []);\n    /**\r\n   * Render the game over screen.\r\n   * @param ctx CanvasRenderingContext2D\r\n   * @param canvas Canvas element\r\n   */ const drawGameOverScreen = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((ctx, canvas)=>{\n        // Draw semi-transparent overlay\n        ctx.fillStyle = \"rgba(0, 0, 0, 0.5)\";\n        ctx.fillRect(0, canvas.height / 2 - 100, canvas.width, 200);\n        // Draw Game Over text\n        ctx.fillStyle = \"#ffcc00\";\n        ctx.font = \"bold 50px Arial\";\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        ctx.fillText(\"Game Over!\", canvas.width / 2, canvas.height / 2 - 40);\n        // Draw restart prompt\n        ctx.fillStyle = \"white\";\n        ctx.font = \"bold 30px Arial\";\n        ctx.fillText(\"Press Space or Tap to Restart\", canvas.width / 2, canvas.height / 2 + 20);\n    }, []);\n    /**\r\n   * Create a new pipe with a random gap position and possibly spawn a coin.\r\n   */ const createPipe = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const gapY = Math.random() * (canvas.height - PIPE_GAP - 200) + 100; // Ensure gap is not too close to top or bottom\n        pipesRef.current.push({\n            x: canvas.width,\n            gapY,\n            scored: false\n        });\n        // 25% chance to spawn a coin\n        if (Math.random() < COIN_SPAWN_CHANCE) {\n            coinsRef.current.push({\n                x: canvas.width + PIPE_WIDTH / 2 - COIN_SIZE / 2,\n                y: gapY + PIPE_GAP / 2 - COIN_SIZE / 2,\n                width: COIN_SIZE,\n                height: COIN_SIZE,\n                collected: false\n            });\n        }\n    }, []);\n    /**\r\n   * Check for collisions between the bird and pipes or boundaries.\r\n   * @returns Boolean indicating if a collision occurred\r\n   */ const checkCollisions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        // Assuming canvas height is fixed at 640\n        if (birdYRef.current < 0 || birdYRef.current + BIRD_HEIGHT > 640) {\n            return true;\n        }\n        const birdLeft = BIRD_X;\n        const birdRight = BIRD_X + BIRD_WIDTH;\n        const birdTop = birdYRef.current;\n        const birdBottom = birdYRef.current + BIRD_HEIGHT;\n        // Check collision with each pipe\n        for (const pipe of pipesRef.current){\n            const pipeLeft = pipe.x;\n            const pipeRight = pipe.x + PIPE_WIDTH;\n            // If bird is within pipe's horizontal bounds\n            if (birdRight > pipeLeft && birdLeft < pipeRight) {\n                // Check if bird is within the gap\n                if (birdTop < pipe.gapY || birdBottom > pipe.gapY + PIPE_GAP) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }, []);\n    /**\r\n   * Check if the bird has collected any coins.\r\n   */ const checkCoinCollection = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const birdLeft = BIRD_X;\n        const birdRight = BIRD_X + BIRD_WIDTH;\n        const birdTop = birdYRef.current;\n        const birdBottom = birdYRef.current + BIRD_HEIGHT;\n        for (const coin of coinsRef.current){\n            if (!coin.collected) {\n                const coinLeft = coin.x;\n                const coinRight = coin.x + coin.width;\n                const coinTop = coin.y;\n                const coinBottom = coin.y + coin.height;\n                if (birdRight > coinLeft && birdLeft < coinRight && birdBottom > coinTop && birdTop < coinBottom) {\n                    coin.collected = true;\n                    setCurrentScore((prevScore)=>{\n                        const newScore = prevScore + 5;\n                        setHighScore((prevHighScore)=>{\n                            const updatedHighScore = Math.max(prevHighScore, newScore);\n                            if (true) {\n                                localStorage.setItem(\"highScore\", updatedHighScore.toString());\n                            }\n                            return updatedHighScore;\n                        });\n                        return newScore;\n                    });\n                }\n            }\n        }\n    }, []);\n    /**\r\n   * Update the score when the bird passes a pipe.\r\n   */ const updateScore = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        for (const pipe of pipesRef.current){\n            // Score +1 for passing each pipe once\n            if (!pipe.scored && pipe.x + PIPE_WIDTH < BIRD_X) {\n                setCurrentScore((prevScore)=>{\n                    const newScore = prevScore + 1;\n                    setHighScore((prevHighScore)=>{\n                        const updatedHighScore = Math.max(prevHighScore, newScore);\n                        if (true) {\n                            localStorage.setItem(\"highScore\", updatedHighScore.toString());\n                        }\n                        return updatedHighScore;\n                    });\n                    return newScore;\n                });\n                pipe.scored = true;\n            }\n        }\n    }, []);\n    /**\r\n   * Cleanup on unmount.\r\n   */ (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        initializeGame();\n        return ()=>{\n            if (requestIdRef.current) {\n                cancelAnimationFrame(requestIdRef.current);\n            }\n        };\n    }, [\n        initializeGame\n    ]);\n    return {\n        highScore,\n        currentScore,\n        handleUserInput\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LE1BQU0sR0FBRztZQUNoQjtRQUNGO0lBQ0YsR0FBRyxFQUFFO0lBRUw7O0dBRUMsR0FDRHJJLGdEQUFTQSxDQUFDO1FBQ1JpRTtRQUNBLE9BQU87WUFDTCxJQUFJaUIsYUFBYTFCLE9BQU8sRUFBRTtnQkFDeEIrRixxQkFBcUJyRSxhQUFhMUIsT0FBTztZQUMzQztRQUNGO0lBQ0YsR0FBRztRQUFDUztLQUFlO0lBRW5CLE9BQU87UUFDTDFDO1FBQ0FFO1FBQ0E0RDtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcHVibGljL3VzZUZsYXBweUJpcmRHYW1lLnRzPzVjNzgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdXNlRmxhcHB5QmlyZEdhbWUudHNcclxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gXCJyZWFjdFwiO1xyXG5cclxuLyoqXHJcbiAqIFBpcGUgcmVwcmVzZW50cyBhIHNpbmdsZSB0b3ArYm90dG9tIHBpcGUgcGFpciwgd2l0aCBhIGdhcCBpbiBiZXR3ZWVuLlxyXG4gKi9cclxuaW50ZXJmYWNlIFBpcGUge1xyXG4gIHg6IG51bWJlcjtcclxuICBnYXBZOiBudW1iZXI7IC8vIFRoZSB0b3AgWSBvZiB0aGUgZ2FwXHJcbiAgc2NvcmVkOiBib29sZWFuOyAvLyBXaGV0aGVyIHdlJ3ZlIGFscmVhZHkgYWRkZWQgKzEgdG8gc2NvcmVcclxufVxyXG5cclxuLyoqXHJcbiAqIENvaW4gcmVwcmVzZW50cyBhIGNvbGxlY3RpYmxlIGl0ZW0uXHJcbiAqL1xyXG5pbnRlcmZhY2UgQ29pbiB7XHJcbiAgeDogbnVtYmVyO1xyXG4gIHk6IG51bWJlcjtcclxuICB3aWR0aDogbnVtYmVyO1xyXG4gIGhlaWdodDogbnVtYmVyO1xyXG4gIGNvbGxlY3RlZDogYm9vbGVhbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnN0YW50cyAtIGRlZmluZWQgaW4gcGl4ZWxzIHBlciBzZWNvbmRcclxuICovXHJcbmNvbnN0IEdSQVZJVFkgPSA4MDA7IC8vIHBpeGVscyBwZXIgc2Vjb25kIHNxdWFyZWRcclxuY29uc3QgRkxBUF9WRUxPQ0lUWSA9IC00NTA7IC8vIHBpeGVscyBwZXIgc2Vjb25kXHJcbmNvbnN0IFBJUEVfU1BFRUQgPSAyMDA7IC8vIHBpeGVscyBwZXIgc2Vjb25kXHJcbmNvbnN0IFBJUEVfU1BBV05fSU5URVJWQUwgPSAxNTAwOyAvLyBtaWxsaXNlY29uZHNcclxuY29uc3QgUElQRV9XSURUSCA9IDkwO1xyXG5jb25zdCBQSVBFX0dBUCA9IDIwMDsgLy8gVmVydGljYWwgZ2FwIGJldHdlZW4gcGlwZXNcclxuY29uc3QgQklSRF9YID0gMTAwOyAvLyBGaXhlZCBYIHBvc2l0aW9uXHJcbmNvbnN0IEJJUkRfV0lEVEggPSA1MDtcclxuY29uc3QgQklSRF9IRUlHSFQgPSA1MDtcclxuY29uc3QgQ09JTl9TUEVFRCA9IDIwMDsgLy8gcGl4ZWxzIHBlciBzZWNvbmRcclxuY29uc3QgQ09JTl9TUEFXTl9DSEFOQ0UgPSAwLjI1OyAvLyAyNSVcclxuY29uc3QgQ09JTl9TSVpFID0gODA7XHJcbmNvbnN0IFJPVEFUSU9OX1NQRUVEID0gMiAqIE1hdGguUEk7IC8vIHJhZGlhbnMgcGVyIHNlY29uZCAoZnVsbCByb3RhdGlvbiBwZXIgc2Vjb25kKVxyXG5cclxuLyoqXHJcbiAqIEN1c3RvbSBob29rIHRvIG1hbmFnZSBGbGFwcHkgQmlyZCBnYW1lIGxvZ2ljLlxyXG4gKiBAcGFyYW0gY2FudmFzUmVmIFJlZmVyZW5jZSB0byB0aGUgY2FudmFzIGVsZW1lbnQuXHJcbiAqIEBwYXJhbSBpc1BhdXNlZCBCb29sZWFuIGluZGljYXRpbmcgaWYgdGhlIGdhbWUgaXMgcGF1c2VkLlxyXG4gKiBAcGFyYW0gYXV0b1N0YXJ0IEJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgZ2FtZSBzaG91bGQgc3RhcnQgYXV0b21hdGljYWxseS5cclxuICogQHJldHVybnMgSGlnaCBzY29yZSwgY3VycmVudCBzY29yZSwgYW5kIGEgaGFuZGxlciBmb3IgdXNlciBpbnB1dC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VGbGFwcHlCaXJkR2FtZShcclxuICBjYW52YXNSZWY6IFJlYWN0LlJlZk9iamVjdDxIVE1MQ2FudmFzRWxlbWVudD4sXHJcbiAgaXNQYXVzZWQ6IGJvb2xlYW4sXHJcbiAgYXV0b1N0YXJ0OiBib29sZWFuXHJcbikge1xyXG4gIC8vIFN0YXRlIGZvciBzY29yZXNcclxuICBjb25zdCBbaGlnaFNjb3JlLCBzZXRIaWdoU2NvcmVdID0gdXNlU3RhdGU8bnVtYmVyPigwKTtcclxuICBjb25zdCBbY3VycmVudFNjb3JlLCBzZXRDdXJyZW50U2NvcmVdID0gdXNlU3RhdGU8bnVtYmVyPigwKTtcclxuXHJcbiAgLy8gUmVmcyB0byB0cmFjayBnYW1lIHN0YXRlXHJcbiAgY29uc3QgYmlyZFlSZWYgPSB1c2VSZWY8bnVtYmVyPigwKTtcclxuICBjb25zdCBiaXJkVmVsb2NpdHlSZWYgPSB1c2VSZWY8bnVtYmVyPigwKTtcclxuICBjb25zdCBwaXBlc1JlZiA9IHVzZVJlZjxQaXBlW10+KFtdKTtcclxuICBjb25zdCBjb2luc1JlZiA9IHVzZVJlZjxDb2luW10+KFtdKTtcclxuICBjb25zdCBnYW1lT3ZlclJlZiA9IHVzZVJlZjxib29sZWFuPihmYWxzZSk7XHJcbiAgY29uc3QgZ2FtZVN0YXJ0ZWRSZWYgPSB1c2VSZWY8Ym9vbGVhbj4oZmFsc2UpO1xyXG5cclxuICAvLyBSb3RhdGlvbiBhbmdsZSBmb3IgY29pbnNcclxuICBjb25zdCBjb2luUm90YXRpb25SZWYgPSB1c2VSZWY8bnVtYmVyPigwKTtcclxuXHJcbiAgLy8gVGltZSB0cmFja2luZ1xyXG4gIGNvbnN0IGxhc3RUaW1lUmVmID0gdXNlUmVmPG51bWJlcj4oMCk7XHJcbiAgY29uc3QgcGlwZVNwYXduVGltZXJSZWYgPSB1c2VSZWY8bnVtYmVyPigwKTtcclxuXHJcbiAgLy8gQXNzZXQgaW1hZ2VzXHJcbiAgY29uc3QgYmlyZEltYWdlc1JlZiA9IHVzZVJlZjxIVE1MSW1hZ2VFbGVtZW50W10+KFtdKTtcclxuICBjb25zdCBwaXBlVG9wSW1nUmVmID0gdXNlUmVmPEhUTUxJbWFnZUVsZW1lbnQgfCBudWxsPihudWxsKTtcclxuICBjb25zdCBwaXBlQm90dG9tSW1nUmVmID0gdXNlUmVmPEhUTUxJbWFnZUVsZW1lbnQgfCBudWxsPihudWxsKTtcclxuICBjb25zdCBiYWNrZ3JvdW5kSW1nUmVmID0gdXNlUmVmPEhUTUxJbWFnZUVsZW1lbnQgfCBudWxsPihudWxsKTtcclxuICBjb25zdCBjb2luSW1nUmVmID0gdXNlUmVmPEhUTUxJbWFnZUVsZW1lbnQgfCBudWxsPihudWxsKTtcclxuXHJcbiAgLy8gQ3VycmVudCBiaXJkIGZyYW1lIGluZGV4IGZvciBmbGFwIGFuaW1hdGlvblxyXG4gIGNvbnN0IGN1cnJlbnRCaXJkRnJhbWVSZWYgPSB1c2VSZWY8bnVtYmVyPigxKTsgLy8gU3RhcnQgd2l0aCBtaWQtZmxhcFxyXG5cclxuICAvKipcclxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gbG9hZCBhbiBpbWFnZSBmdWxseS5cclxuICAgKiBAcGFyYW0gaW1nIEhUTUxJbWFnZUVsZW1lbnRcclxuICAgKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgaW1hZ2UgaXMgbG9hZGVkLlxyXG4gICAqL1xyXG4gIGNvbnN0IGxvYWRJbWFnZSA9IChpbWc6IEhUTUxJbWFnZUVsZW1lbnQpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGlmIChpbWcuY29tcGxldGUpIHtcclxuICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHJlc29sdmUoKTtcclxuICAgICAgICBpbWcub25lcnJvciA9ICgpID0+IHJlamVjdChuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIGltYWdlOiAke2ltZy5zcmN9YCkpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBJbml0aWFsaXplIGFuZCBsb2FkIGFsbCBnYW1lIGFzc2V0cy5cclxuICAgKi9cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybjtcclxuXHJcbiAgICAvLyBJbml0aWFsaXplIGJpcmQgaW1hZ2VzXHJcbiAgICBjb25zdCBiaXJkVXAgPSBuZXcgSW1hZ2UoKTtcclxuICAgIGJpcmRVcC5zcmMgPSBcIi9hc3NldHMvcmVkYmlyZC11cGZsYXAucG5nXCI7XHJcblxyXG4gICAgY29uc3QgYmlyZE1pZCA9IG5ldyBJbWFnZSgpO1xyXG4gICAgYmlyZE1pZC5zcmMgPSBcIi9hc3NldHMvcmVkYmlyZC1taWRmbGFwLnBuZ1wiO1xyXG5cclxuICAgIGNvbnN0IGJpcmREb3duID0gbmV3IEltYWdlKCk7XHJcbiAgICBiaXJkRG93bi5zcmMgPSBcIi9hc3NldHMvcmVkYmlyZC1kb3duZmxhcC5wbmdcIjtcclxuXHJcbiAgICBiaXJkSW1hZ2VzUmVmLmN1cnJlbnQgPSBbYmlyZFVwLCBiaXJkTWlkLCBiaXJkRG93bl07XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSBwaXBlIGltYWdlc1xyXG4gICAgY29uc3QgcGlwZVRvcEltZyA9IG5ldyBJbWFnZSgpO1xyXG4gICAgcGlwZVRvcEltZy5zcmMgPSBcIi9hc3NldHMvVG9wVGlueS5wbmdcIjtcclxuICAgIHBpcGVUb3BJbWdSZWYuY3VycmVudCA9IHBpcGVUb3BJbWc7XHJcblxyXG4gICAgY29uc3QgcGlwZUJvdHRvbUltZyA9IG5ldyBJbWFnZSgpO1xyXG4gICAgcGlwZUJvdHRvbUltZy5zcmMgPSBcIi9hc3NldHMvQm90dG9tVGlueS5wbmdcIjtcclxuICAgIHBpcGVCb3R0b21JbWdSZWYuY3VycmVudCA9IHBpcGVCb3R0b21JbWc7XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSBiYWNrZ3JvdW5kIGFuZCBjb2luIGltYWdlc1xyXG4gICAgY29uc3QgYmFja2dyb3VuZEltZyA9IG5ldyBJbWFnZSgpO1xyXG4gICAgYmFja2dyb3VuZEltZy5zcmMgPSBcIi9hc3NldHMvYmFja2dyb3VuZC1kYXkucG5nXCI7XHJcbiAgICBiYWNrZ3JvdW5kSW1nUmVmLmN1cnJlbnQgPSBiYWNrZ3JvdW5kSW1nO1xyXG5cclxuICAgIGNvbnN0IGNvaW5JbWcgPSBuZXcgSW1hZ2UoKTtcclxuICAgIGNvaW5JbWcuc3JjID0gXCIvYXNzZXRzL0NvaW5UaW55LnBuZ1wiO1xyXG4gICAgY29pbkltZ1JlZi5jdXJyZW50ID0gY29pbkltZztcclxuICB9LCBbXSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIExvYWQgaGlnaCBzY29yZSBmcm9tIGxvY2FsU3RvcmFnZSBvbiBtb3VudC5cclxuICAgKi9cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybjtcclxuICAgIGNvbnN0IHN0b3JlZEhpZ2hTY29yZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwiaGlnaFNjb3JlXCIpO1xyXG4gICAgaWYgKHN0b3JlZEhpZ2hTY29yZSkge1xyXG4gICAgICBzZXRIaWdoU2NvcmUocGFyc2VJbnQoc3RvcmVkSGlnaFNjb3JlLCAxMCkpO1xyXG4gICAgfVxyXG4gIH0sIFtdKTtcclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZSB0aGUgZ2FtZSBieSBsb2FkaW5nIGFzc2V0cyBhbmQgc2V0dGluZyB1cCB0aGUgY2FudmFzLlxyXG4gICAqL1xyXG4gIGNvbnN0IGluaXRpYWxpemVHYW1lID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XHJcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICBpZiAoIWN0eCkgcmV0dXJuO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIExvYWQgYWxsIGFzc2V0c1xyXG4gICAgICBjb25zdCBhc3NldHM6IEhUTUxJbWFnZUVsZW1lbnRbXSA9IFtcclxuICAgICAgICAuLi5iaXJkSW1hZ2VzUmVmLmN1cnJlbnQsXHJcbiAgICAgICAgcGlwZVRvcEltZ1JlZi5jdXJyZW50ISxcclxuICAgICAgICBwaXBlQm90dG9tSW1nUmVmLmN1cnJlbnQhLFxyXG4gICAgICAgIGJhY2tncm91bmRJbWdSZWYuY3VycmVudCEsXHJcbiAgICAgICAgY29pbkltZ1JlZi5jdXJyZW50ISxcclxuICAgICAgXTtcclxuXHJcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKGFzc2V0cy5tYXAoKGltZykgPT4gbG9hZEltYWdlKGltZykpKTtcclxuICAgICAgY29uc29sZS5sb2coXCJBbGwgYXNzZXRzIGxvYWRlZCBzdWNjZXNzZnVsbHkhXCIpO1xyXG5cclxuICAgICAgLy8gU2V0IGNhbnZhcyBkaW1lbnNpb25zXHJcbiAgICAgIGNhbnZhcy53aWR0aCA9IDM2MDtcclxuICAgICAgY2FudmFzLmhlaWdodCA9IDY0MDtcclxuXHJcbiAgICAgIC8vIERyYXcgc3RhcnQgc2NyZWVuXHJcbiAgICAgIGRyYXdTdGFydFNjcmVlbihjdHgsIGNhbnZhcyk7XHJcblxyXG4gICAgICAvLyBBdXRvLXN0YXJ0IGlmIGVuYWJsZWRcclxuICAgICAgaWYgKGF1dG9TdGFydCkge1xyXG4gICAgICAgIHN0YXJ0R2FtZSgpO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcclxuICAgIH1cclxuICB9LCBbY2FudmFzUmVmLCBhdXRvU3RhcnRdKTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXQgZ2FtZSBzdGF0ZSB0byBpbml0aWFsIGNvbmRpdGlvbnMuXHJcbiAgICovXHJcbiAgY29uc3QgcmVzZXRHYW1lID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XHJcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuO1xyXG4gICAgY29uc3QgeyBoZWlnaHQgfSA9IGNhbnZhcztcclxuXHJcbiAgICBiaXJkWVJlZi5jdXJyZW50ID0gaGVpZ2h0IC8gMztcclxuICAgIGJpcmRWZWxvY2l0eVJlZi5jdXJyZW50ID0gMDtcclxuICAgIHBpcGVzUmVmLmN1cnJlbnQgPSBbXTtcclxuICAgIGNvaW5zUmVmLmN1cnJlbnQgPSBbXTtcclxuICAgIHNldEN1cnJlbnRTY29yZSgwKTtcclxuICAgIGdhbWVPdmVyUmVmLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgIGdhbWVTdGFydGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgIGNvaW5Sb3RhdGlvblJlZi5jdXJyZW50ID0gMDtcclxuICAgIGxhc3RUaW1lUmVmLmN1cnJlbnQgPSAwO1xyXG4gICAgcGlwZVNwYXduVGltZXJSZWYuY3VycmVudCA9IDA7XHJcbiAgICBjdXJyZW50QmlyZEZyYW1lUmVmLmN1cnJlbnQgPSAxOyAvLyBtaWQtZmxhcFxyXG4gIH0sIFtjYW52YXNSZWZdKTtcclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnQgdGhlIGdhbWUgYnkgcmVzZXR0aW5nIHRoZSBzdGF0ZSBhbmQgaW5pdGlhdGluZyB0aGUgZ2FtZSBsb29wLlxyXG4gICAqL1xyXG4gIGNvbnN0IHN0YXJ0R2FtZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgIHJlc2V0R2FtZSgpO1xyXG4gICAgZ2FtZVN0YXJ0ZWRSZWYuY3VycmVudCA9IHRydWU7XHJcbiAgICBsYXN0VGltZVJlZi5jdXJyZW50ID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICByZXF1ZXN0SWRSZWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcclxuICB9LCBbcmVzZXRHYW1lXSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZSB1c2VyIGlucHV0IChjbGljay90YXApIGJ5IGZsYXBwaW5nIG9yIHJlc3RhcnRpbmcuXHJcbiAgICovXHJcbiAgY29uc3QgaGFuZGxlVXNlcklucHV0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgaWYgKCFnYW1lU3RhcnRlZFJlZi5jdXJyZW50ICYmICFnYW1lT3ZlclJlZi5jdXJyZW50KSB7XHJcbiAgICAgIHN0YXJ0R2FtZSgpO1xyXG4gICAgfSBlbHNlIGlmIChnYW1lT3ZlclJlZi5jdXJyZW50KSB7XHJcbiAgICAgIHN0YXJ0R2FtZSgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYmlyZFZlbG9jaXR5UmVmLmN1cnJlbnQgPSBGTEFQX1ZFTE9DSVRZO1xyXG4gICAgICBmbGFwQW5pbWF0aW9uKCk7XHJcbiAgICB9XHJcbiAgfSwgW3N0YXJ0R2FtZV0pO1xyXG5cclxuICAvKipcclxuICAgKiBIYW5kbGUga2V5ZG93biBldmVudHMgZm9yIHNwYWNlIGJhciB0byBmbGFwIG9yIHJlc3RhcnQuXHJcbiAgICogQHBhcmFtIGUgS2V5Ym9hcmRFdmVudFxyXG4gICAqL1xyXG4gIGNvbnN0IGhhbmRsZUtleURvd24gPSB1c2VDYWxsYmFjayhcclxuICAgIChlOiBLZXlib2FyZEV2ZW50KSA9PiB7XHJcbiAgICAgIGlmIChlLmtleSA9PT0gXCIgXCIpIHtcclxuICAgICAgICBoYW5kbGVVc2VySW5wdXQoKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIFtoYW5kbGVVc2VySW5wdXRdXHJcbiAgKTtcclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGtleWRvd24gZXZlbnQgbGlzdGVuZXIgb24gbW91bnQuXHJcbiAgICovXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBoYW5kbGVLZXlEb3duKTtcclxuICAgIHJldHVybiAoKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgaGFuZGxlS2V5RG93bik7XHJcbiAgfSwgW2hhbmRsZUtleURvd25dKTtcclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlIGZsYXAgYW5pbWF0aW9uIGJ5IGN5Y2xpbmcgdGhyb3VnaCBiaXJkIGZyYW1lcy5cclxuICAgKi9cclxuICBjb25zdCBmbGFwQW5pbWF0aW9uID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgY29uc3QgZmxhcEZyYW1lcyA9IFswLCAxLCAyLCAxXTtcclxuICAgIGxldCBjdXJyZW50RnJhbWUgPSAwO1xyXG4gICAgY29uc3QgZmxhcEludGVydmFsID0gMTAwOyAvLyBtaWxsaXNlY29uZHMgYmV0d2VlbiBmcmFtZXNcclxuXHJcbiAgICBjb25zdCBmbGFwID0gKCkgPT4ge1xyXG4gICAgICBpZiAoY3VycmVudEZyYW1lIDwgZmxhcEZyYW1lcy5sZW5ndGgpIHtcclxuICAgICAgICBjdXJyZW50QmlyZEZyYW1lUmVmLmN1cnJlbnQgPSBmbGFwRnJhbWVzW2N1cnJlbnRGcmFtZV07XHJcbiAgICAgICAgY3VycmVudEZyYW1lKys7XHJcbiAgICAgICAgc2V0VGltZW91dChmbGFwLCBmbGFwSW50ZXJ2YWwpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGN1cnJlbnRCaXJkRnJhbWVSZWYuY3VycmVudCA9IDE7IC8vIHJlc2V0IHRvIG1pZC1mbGFwXHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZmxhcCgpO1xyXG4gIH0sIFtdKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIG1haW4gZ2FtZSBsb29wIHVzaW5nIHJlcXVlc3RBbmltYXRpb25GcmFtZS5cclxuICAgKiBAcGFyYW0gdGltZXN0YW1wIEN1cnJlbnQgdGltZXN0YW1wXHJcbiAgICovXHJcbiAgY29uc3QgYW5pbWF0ZSA9IHVzZUNhbGxiYWNrKFxyXG4gICAgKHRpbWVzdGFtcDogbnVtYmVyKSA9PiB7XHJcbiAgICAgIGlmIChpc1BhdXNlZCB8fCAhZ2FtZVN0YXJ0ZWRSZWYuY3VycmVudCkge1xyXG4gICAgICAgIHJlcXVlc3RJZFJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFsYXN0VGltZVJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgbGFzdFRpbWVSZWYuY3VycmVudCA9IHRpbWVzdGFtcDtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IGRlbHRhVGltZSA9ICh0aW1lc3RhbXAgLSBsYXN0VGltZVJlZi5jdXJyZW50KSAvIDEwMDA7IC8vIGluIHNlY29uZHNcclxuICAgICAgLy8gQ2FwIGRlbHRhVGltZSB0byAwLjA1IHNlY29uZHMgdG8gcHJldmVudCBiaWcganVtcHNcclxuICAgICAgZGVsdGFUaW1lID0gTWF0aC5taW4oZGVsdGFUaW1lLCAwLjA1KTtcclxuICAgICAgbGFzdFRpbWVSZWYuY3VycmVudCA9IHRpbWVzdGFtcDtcclxuXHJcbiAgICAgIC8vIFVwZGF0ZSBnYW1lIHN0YXRlXHJcbiAgICAgIHVwZGF0ZUdhbWVTdGF0ZShkZWx0YVRpbWUpO1xyXG5cclxuICAgICAgLy8gRHJhdyBldmVyeXRoaW5nXHJcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xyXG4gICAgICBpZiAoY2FudmFzKSB7XHJcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuICAgICAgICBpZiAoY3R4KSB7XHJcbiAgICAgICAgICBkcmF3KGN0eCwgY2FudmFzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghZ2FtZU92ZXJSZWYuY3VycmVudCkge1xyXG4gICAgICAgIHJlcXVlc3RJZFJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIERyYXcgZ2FtZSBvdmVyIHNjcmVlblxyXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xyXG4gICAgICAgIGlmIChjYW52YXMpIHtcclxuICAgICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICAgICAgICBpZiAoY3R4KSB7XHJcbiAgICAgICAgICAgIGRyYXdHYW1lT3ZlclNjcmVlbihjdHgsIGNhbnZhcyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgW2lzUGF1c2VkXVxyXG4gICk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSB0aGUgZ2FtZSBzdGF0ZSBiYXNlZCBvbiBlbGFwc2VkIHRpbWUuXHJcbiAgICogQHBhcmFtIGRlbHRhVGltZSBUaW1lIGVsYXBzZWQgc2luY2UgbGFzdCBmcmFtZSAoaW4gc2Vjb25kcylcclxuICAgKi9cclxuICBjb25zdCB1cGRhdGVHYW1lU3RhdGUgPSB1c2VDYWxsYmFjayhcclxuICAgIChkZWx0YVRpbWU6IG51bWJlcikgPT4ge1xyXG4gICAgICAvLyBBcHBseSBncmF2aXR5IHRvIHRoZSBiaXJkXHJcbiAgICAgIGJpcmRWZWxvY2l0eVJlZi5jdXJyZW50ICs9IEdSQVZJVFkgKiBkZWx0YVRpbWU7XHJcbiAgICAgIGJpcmRZUmVmLmN1cnJlbnQgKz0gYmlyZFZlbG9jaXR5UmVmLmN1cnJlbnQgKiBkZWx0YVRpbWU7XHJcblxyXG4gICAgICAvLyBVcGRhdGUgcGlwZSBzcGF3biB0aW1lciBhbmQgc3Bhd24gcGlwZXMgYXQgaW50ZXJ2YWxzXHJcbiAgICAgIHBpcGVTcGF3blRpbWVyUmVmLmN1cnJlbnQgKz0gZGVsdGFUaW1lO1xyXG4gICAgICBpZiAocGlwZVNwYXduVGltZXJSZWYuY3VycmVudCA+IFBJUEVfU1BBV05fSU5URVJWQUwgLyAxMDAwKSB7XHJcbiAgICAgICAgY3JlYXRlUGlwZSgpO1xyXG4gICAgICAgIHBpcGVTcGF3blRpbWVyUmVmLmN1cnJlbnQgPSAwO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBNb3ZlIHBpcGVzIGJhc2VkIG9uIFBJUEVfU1BFRUQgYW5kIGRlbHRhVGltZVxyXG4gICAgICBjb25zdCBwaXBlTW92ZURlbHRhID0gUElQRV9TUEVFRCAqIGRlbHRhVGltZTtcclxuICAgICAgcGlwZXNSZWYuY3VycmVudCA9IHBpcGVzUmVmLmN1cnJlbnQubWFwKChwaXBlKSA9PiAoe1xyXG4gICAgICAgIC4uLnBpcGUsXHJcbiAgICAgICAgeDogcGlwZS54IC0gcGlwZU1vdmVEZWx0YSxcclxuICAgICAgfSkpO1xyXG5cclxuICAgICAgLy8gUmVtb3ZlIG9mZnNjcmVlbiBwaXBlc1xyXG4gICAgICBwaXBlc1JlZi5jdXJyZW50ID0gcGlwZXNSZWYuY3VycmVudC5maWx0ZXIoKHBpcGUpID0+IHBpcGUueCArIFBJUEVfV0lEVEggPiAwKTtcclxuXHJcbiAgICAgIC8vIE1vdmUgY29pbnMgYmFzZWQgb24gQ09JTl9TUEVFRCBhbmQgZGVsdGFUaW1lXHJcbiAgICAgIGNvbnN0IGNvaW5Nb3ZlRGVsdGEgPSBDT0lOX1NQRUVEICogZGVsdGFUaW1lO1xyXG4gICAgICBjb2luc1JlZi5jdXJyZW50ID0gY29pbnNSZWYuY3VycmVudC5tYXAoKGNvaW4pID0+ICh7XHJcbiAgICAgICAgLi4uY29pbixcclxuICAgICAgICB4OiBjb2luLnggLSBjb2luTW92ZURlbHRhLFxyXG4gICAgICB9KSk7XHJcblxyXG4gICAgICAvLyBSZW1vdmUgb2Zmc2NyZWVuIG9yIGNvbGxlY3RlZCBjb2luc1xyXG4gICAgICBjb2luc1JlZi5jdXJyZW50ID0gY29pbnNSZWYuY3VycmVudC5maWx0ZXIoXHJcbiAgICAgICAgKGNvaW4pID0+IGNvaW4ueCArIGNvaW4ud2lkdGggPiAwICYmICFjb2luLmNvbGxlY3RlZFxyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gUm90YXRlIGNvaW5zIGZvciB2aXN1YWwgZWZmZWN0XHJcbiAgICAgIGNvaW5Sb3RhdGlvblJlZi5jdXJyZW50ICs9IFJPVEFUSU9OX1NQRUVEICogZGVsdGFUaW1lO1xyXG4gICAgICBpZiAoY29pblJvdGF0aW9uUmVmLmN1cnJlbnQgPj0gMiAqIE1hdGguUEkpIHtcclxuICAgICAgICBjb2luUm90YXRpb25SZWYuY3VycmVudCAtPSAyICogTWF0aC5QSTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2hlY2sgZm9yIGNvbGxpc2lvbnNcclxuICAgICAgaWYgKGNoZWNrQ29sbGlzaW9ucygpKSB7XHJcbiAgICAgICAgZ2FtZU92ZXJSZWYuY3VycmVudCA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDaGVjayBpZiBiaXJkIGNvbGxlY3RzIGFueSBjb2luc1xyXG4gICAgICBjaGVja0NvaW5Db2xsZWN0aW9uKCk7XHJcblxyXG4gICAgICAvLyBVcGRhdGUgdGhlIHNjb3JlIGJhc2VkIG9uIHBpcGUgcGFzc2luZ1xyXG4gICAgICB1cGRhdGVTY29yZSgpO1xyXG4gICAgfSxcclxuICAgIFtdXHJcbiAgKTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVuZGVyIGFsbCBnYW1lIGVsZW1lbnRzIG9udG8gdGhlIGNhbnZhcy5cclxuICAgKiBAcGFyYW0gY3R4IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRFxyXG4gICAqIEBwYXJhbSBjYW52YXMgQ2FudmFzIGVsZW1lbnRcclxuICAgKi9cclxuICBjb25zdCBkcmF3ID0gdXNlQ2FsbGJhY2soXHJcbiAgICAoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpID0+IHtcclxuICAgICAgLy8gQ2xlYXIgdGhlIGNhbnZhc1xyXG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcblxyXG4gICAgICAvLyBEcmF3IGJhY2tncm91bmRcclxuICAgICAgaWYgKGJhY2tncm91bmRJbWdSZWYuY3VycmVudD8uY29tcGxldGUpIHtcclxuICAgICAgICBjdHguZHJhd0ltYWdlKGJhY2tncm91bmRJbWdSZWYuY3VycmVudCwgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRHJhdyBwaXBlc1xyXG4gICAgICBmb3IgKGNvbnN0IHBpcGUgb2YgcGlwZXNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIC8vIFRvcCBwaXBlXHJcbiAgICAgICAgaWYgKHBpcGVUb3BJbWdSZWYuY3VycmVudD8uY29tcGxldGUpIHtcclxuICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoXHJcbiAgICAgICAgICAgIHBpcGVUb3BJbWdSZWYuY3VycmVudCxcclxuICAgICAgICAgICAgcGlwZS54LFxyXG4gICAgICAgICAgICAwLFxyXG4gICAgICAgICAgICBQSVBFX1dJRFRILFxyXG4gICAgICAgICAgICBwaXBlLmdhcFlcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBCb3R0b20gcGlwZVxyXG4gICAgICAgIGlmIChwaXBlQm90dG9tSW1nUmVmLmN1cnJlbnQ/LmNvbXBsZXRlKSB7XHJcbiAgICAgICAgICBjdHguZHJhd0ltYWdlKFxyXG4gICAgICAgICAgICBwaXBlQm90dG9tSW1nUmVmLmN1cnJlbnQsXHJcbiAgICAgICAgICAgIHBpcGUueCxcclxuICAgICAgICAgICAgcGlwZS5nYXBZICsgUElQRV9HQVAsXHJcbiAgICAgICAgICAgIFBJUEVfV0lEVEgsXHJcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgLSAocGlwZS5nYXBZICsgUElQRV9HQVApXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRHJhdyBjb2luc1xyXG4gICAgICBmb3IgKGNvbnN0IGNvaW4gb2YgY29pbnNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGlmICghY29pbi5jb2xsZWN0ZWQgJiYgY29pbkltZ1JlZi5jdXJyZW50Py5jb21wbGV0ZSkge1xyXG4gICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgIGN0eC50cmFuc2xhdGUoY29pbi54ICsgY29pbi53aWR0aCAvIDIsIGNvaW4ueSArIGNvaW4uaGVpZ2h0IC8gMik7XHJcbiAgICAgICAgICBjdHgucm90YXRlKGNvaW5Sb3RhdGlvblJlZi5jdXJyZW50KTtcclxuICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoXHJcbiAgICAgICAgICAgIGNvaW5JbWdSZWYuY3VycmVudCxcclxuICAgICAgICAgICAgLWNvaW4ud2lkdGggLyAyLFxyXG4gICAgICAgICAgICAtY29pbi5oZWlnaHQgLyAyLFxyXG4gICAgICAgICAgICBjb2luLndpZHRoLFxyXG4gICAgICAgICAgICBjb2luLmhlaWdodFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBEcmF3IGJpcmRcclxuICAgICAgY29uc3QgY3VycmVudEJpcmRGcmFtZSA9IGJpcmRJbWFnZXNSZWYuY3VycmVudFtjdXJyZW50QmlyZEZyYW1lUmVmLmN1cnJlbnRdO1xyXG4gICAgICBpZiAoY3VycmVudEJpcmRGcmFtZT8uY29tcGxldGUpIHtcclxuICAgICAgICBjdHguZHJhd0ltYWdlKFxyXG4gICAgICAgICAgY3VycmVudEJpcmRGcmFtZSxcclxuICAgICAgICAgIEJJUkRfWCxcclxuICAgICAgICAgIGJpcmRZUmVmLmN1cnJlbnQsXHJcbiAgICAgICAgICBCSVJEX1dJRFRILFxyXG4gICAgICAgICAgQklSRF9IRUlHSFRcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgW11cclxuICApO1xyXG5cclxuICAvKipcclxuICAgKiBSZW5kZXIgdGhlIHN0YXJ0IHNjcmVlbi5cclxuICAgKiBAcGFyYW0gY3R4IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRFxyXG4gICAqIEBwYXJhbSBjYW52YXMgQ2FudmFzIGVsZW1lbnRcclxuICAgKi9cclxuICBjb25zdCBkcmF3U3RhcnRTY3JlZW4gPSB1c2VDYWxsYmFjayhcclxuICAgIChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkgPT4ge1xyXG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcblxyXG4gICAgICAvLyBEcmF3IGJhY2tncm91bmRcclxuICAgICAgaWYgKGJhY2tncm91bmRJbWdSZWYuY3VycmVudD8uY29tcGxldGUpIHtcclxuICAgICAgICBjdHguZHJhd0ltYWdlKGJhY2tncm91bmRJbWdSZWYuY3VycmVudCwgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRHJhdyBzdGFydCB0ZXh0XHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBcIndoaXRlXCI7XHJcbiAgICAgIGN0eC5mb250ID0gXCJib2xkIDMwcHggQXJpYWxcIjtcclxuICAgICAgY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XHJcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xyXG4gICAgICBjdHguZmlsbFRleHQoXCJQcmVzcyBTcGFjZSBvciBUYXAgdG8gU3RhcnRcIiwgY2FudmFzLndpZHRoIC8gMiwgY2FudmFzLmhlaWdodCAvIDIpO1xyXG4gICAgfSxcclxuICAgIFtdXHJcbiAgKTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVuZGVyIHRoZSBnYW1lIG92ZXIgc2NyZWVuLlxyXG4gICAqIEBwYXJhbSBjdHggQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEXHJcbiAgICogQHBhcmFtIGNhbnZhcyBDYW52YXMgZWxlbWVudFxyXG4gICAqL1xyXG4gIGNvbnN0IGRyYXdHYW1lT3ZlclNjcmVlbiA9IHVzZUNhbGxiYWNrKFxyXG4gICAgKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSA9PiB7XHJcbiAgICAgIC8vIERyYXcgc2VtaS10cmFuc3BhcmVudCBvdmVybGF5XHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBcInJnYmEoMCwgMCwgMCwgMC41KVwiO1xyXG4gICAgICBjdHguZmlsbFJlY3QoMCwgY2FudmFzLmhlaWdodCAvIDIgLSAxMDAsIGNhbnZhcy53aWR0aCwgMjAwKTtcclxuXHJcbiAgICAgIC8vIERyYXcgR2FtZSBPdmVyIHRleHRcclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiI2ZmY2MwMFwiO1xyXG4gICAgICBjdHguZm9udCA9IFwiYm9sZCA1MHB4IEFyaWFsXCI7XHJcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xyXG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcclxuICAgICAgY3R4LmZpbGxUZXh0KFwiR2FtZSBPdmVyIVwiLCBjYW52YXMud2lkdGggLyAyLCBjYW52YXMuaGVpZ2h0IC8gMiAtIDQwKTtcclxuXHJcbiAgICAgIC8vIERyYXcgcmVzdGFydCBwcm9tcHRcclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IFwid2hpdGVcIjtcclxuICAgICAgY3R4LmZvbnQgPSBcImJvbGQgMzBweCBBcmlhbFwiO1xyXG4gICAgICBjdHguZmlsbFRleHQoXCJQcmVzcyBTcGFjZSBvciBUYXAgdG8gUmVzdGFydFwiLCBjYW52YXMud2lkdGggLyAyLCBjYW52YXMuaGVpZ2h0IC8gMiArIDIwKTtcclxuICAgIH0sXHJcbiAgICBbXVxyXG4gICk7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBwaXBlIHdpdGggYSByYW5kb20gZ2FwIHBvc2l0aW9uIGFuZCBwb3NzaWJseSBzcGF3biBhIGNvaW4uXHJcbiAgICovXHJcbiAgY29uc3QgY3JlYXRlUGlwZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xyXG4gICAgaWYgKCFjYW52YXMpIHJldHVybjtcclxuICAgIGNvbnN0IGdhcFkgPSBNYXRoLnJhbmRvbSgpICogKGNhbnZhcy5oZWlnaHQgLSBQSVBFX0dBUCAtIDIwMCkgKyAxMDA7IC8vIEVuc3VyZSBnYXAgaXMgbm90IHRvbyBjbG9zZSB0byB0b3Agb3IgYm90dG9tXHJcbiAgICBwaXBlc1JlZi5jdXJyZW50LnB1c2goe1xyXG4gICAgICB4OiBjYW52YXMud2lkdGgsXHJcbiAgICAgIGdhcFksXHJcbiAgICAgIHNjb3JlZDogZmFsc2UsXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyAyNSUgY2hhbmNlIHRvIHNwYXduIGEgY29pblxyXG4gICAgaWYgKE1hdGgucmFuZG9tKCkgPCBDT0lOX1NQQVdOX0NIQU5DRSkge1xyXG4gICAgICBjb2luc1JlZi5jdXJyZW50LnB1c2goe1xyXG4gICAgICAgIHg6IGNhbnZhcy53aWR0aCArIFBJUEVfV0lEVEggLyAyIC0gQ09JTl9TSVpFIC8gMixcclxuICAgICAgICB5OiBnYXBZICsgUElQRV9HQVAgLyAyIC0gQ09JTl9TSVpFIC8gMixcclxuICAgICAgICB3aWR0aDogQ09JTl9TSVpFLFxyXG4gICAgICAgIGhlaWdodDogQ09JTl9TSVpFLFxyXG4gICAgICAgIGNvbGxlY3RlZDogZmFsc2UsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0sIFtdKTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgZm9yIGNvbGxpc2lvbnMgYmV0d2VlbiB0aGUgYmlyZCBhbmQgcGlwZXMgb3IgYm91bmRhcmllcy5cclxuICAgKiBAcmV0dXJucyBCb29sZWFuIGluZGljYXRpbmcgaWYgYSBjb2xsaXNpb24gb2NjdXJyZWRcclxuICAgKi9cclxuICBjb25zdCBjaGVja0NvbGxpc2lvbnMgPSB1c2VDYWxsYmFjaygoKTogYm9vbGVhbiA9PiB7XHJcbiAgICAvLyBBc3N1bWluZyBjYW52YXMgaGVpZ2h0IGlzIGZpeGVkIGF0IDY0MFxyXG4gICAgaWYgKGJpcmRZUmVmLmN1cnJlbnQgPCAwIHx8IGJpcmRZUmVmLmN1cnJlbnQgKyBCSVJEX0hFSUdIVCA+IDY0MCkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBiaXJkTGVmdCA9IEJJUkRfWDtcclxuICAgIGNvbnN0IGJpcmRSaWdodCA9IEJJUkRfWCArIEJJUkRfV0lEVEg7XHJcbiAgICBjb25zdCBiaXJkVG9wID0gYmlyZFlSZWYuY3VycmVudDtcclxuICAgIGNvbnN0IGJpcmRCb3R0b20gPSBiaXJkWVJlZi5jdXJyZW50ICsgQklSRF9IRUlHSFQ7XHJcblxyXG4gICAgLy8gQ2hlY2sgY29sbGlzaW9uIHdpdGggZWFjaCBwaXBlXHJcbiAgICBmb3IgKGNvbnN0IHBpcGUgb2YgcGlwZXNSZWYuY3VycmVudCkge1xyXG4gICAgICBjb25zdCBwaXBlTGVmdCA9IHBpcGUueDtcclxuICAgICAgY29uc3QgcGlwZVJpZ2h0ID0gcGlwZS54ICsgUElQRV9XSURUSDtcclxuXHJcbiAgICAgIC8vIElmIGJpcmQgaXMgd2l0aGluIHBpcGUncyBob3Jpem9udGFsIGJvdW5kc1xyXG4gICAgICBpZiAoYmlyZFJpZ2h0ID4gcGlwZUxlZnQgJiYgYmlyZExlZnQgPCBwaXBlUmlnaHQpIHtcclxuICAgICAgICAvLyBDaGVjayBpZiBiaXJkIGlzIHdpdGhpbiB0aGUgZ2FwXHJcbiAgICAgICAgaWYgKGJpcmRUb3AgPCBwaXBlLmdhcFkgfHwgYmlyZEJvdHRvbSA+IHBpcGUuZ2FwWSArIFBJUEVfR0FQKSB7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfSwgW10pO1xyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiB0aGUgYmlyZCBoYXMgY29sbGVjdGVkIGFueSBjb2lucy5cclxuICAgKi9cclxuICBjb25zdCBjaGVja0NvaW5Db2xsZWN0aW9uID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgY29uc3QgYmlyZExlZnQgPSBCSVJEX1g7XHJcbiAgICBjb25zdCBiaXJkUmlnaHQgPSBCSVJEX1ggKyBCSVJEX1dJRFRIO1xyXG4gICAgY29uc3QgYmlyZFRvcCA9IGJpcmRZUmVmLmN1cnJlbnQ7XHJcbiAgICBjb25zdCBiaXJkQm90dG9tID0gYmlyZFlSZWYuY3VycmVudCArIEJJUkRfSEVJR0hUO1xyXG5cclxuICAgIGZvciAoY29uc3QgY29pbiBvZiBjb2luc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgIGlmICghY29pbi5jb2xsZWN0ZWQpIHtcclxuICAgICAgICBjb25zdCBjb2luTGVmdCA9IGNvaW4ueDtcclxuICAgICAgICBjb25zdCBjb2luUmlnaHQgPSBjb2luLnggKyBjb2luLndpZHRoO1xyXG4gICAgICAgIGNvbnN0IGNvaW5Ub3AgPSBjb2luLnk7XHJcbiAgICAgICAgY29uc3QgY29pbkJvdHRvbSA9IGNvaW4ueSArIGNvaW4uaGVpZ2h0O1xyXG5cclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICBiaXJkUmlnaHQgPiBjb2luTGVmdCAmJlxyXG4gICAgICAgICAgYmlyZExlZnQgPCBjb2luUmlnaHQgJiZcclxuICAgICAgICAgIGJpcmRCb3R0b20gPiBjb2luVG9wICYmXHJcbiAgICAgICAgICBiaXJkVG9wIDwgY29pbkJvdHRvbVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgY29pbi5jb2xsZWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgc2V0Q3VycmVudFNjb3JlKChwcmV2U2NvcmUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbmV3U2NvcmUgPSBwcmV2U2NvcmUgKyA1O1xyXG4gICAgICAgICAgICBzZXRIaWdoU2NvcmUoKHByZXZIaWdoU2NvcmUpID0+IHtcclxuICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkSGlnaFNjb3JlID0gTWF0aC5tYXgocHJldkhpZ2hTY29yZSwgbmV3U2NvcmUpO1xyXG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcImhpZ2hTY29yZVwiLCB1cGRhdGVkSGlnaFNjb3JlLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlZEhpZ2hTY29yZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdTY29yZTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sIFtdKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIHRoZSBzY29yZSB3aGVuIHRoZSBiaXJkIHBhc3NlcyBhIHBpcGUuXHJcbiAgICovXHJcbiAgY29uc3QgdXBkYXRlU2NvcmUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICBmb3IgKGNvbnN0IHBpcGUgb2YgcGlwZXNSZWYuY3VycmVudCkge1xyXG4gICAgICAvLyBTY29yZSArMSBmb3IgcGFzc2luZyBlYWNoIHBpcGUgb25jZVxyXG4gICAgICBpZiAoIXBpcGUuc2NvcmVkICYmIHBpcGUueCArIFBJUEVfV0lEVEggPCBCSVJEX1gpIHtcclxuICAgICAgICBzZXRDdXJyZW50U2NvcmUoKHByZXZTY29yZSkgPT4ge1xyXG4gICAgICAgICAgY29uc3QgbmV3U2NvcmUgPSBwcmV2U2NvcmUgKyAxO1xyXG4gICAgICAgICAgc2V0SGlnaFNjb3JlKChwcmV2SGlnaFNjb3JlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRIaWdoU2NvcmUgPSBNYXRoLm1heChwcmV2SGlnaFNjb3JlLCBuZXdTY29yZSk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJoaWdoU2NvcmVcIiwgdXBkYXRlZEhpZ2hTY29yZS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlZEhpZ2hTY29yZTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgcmV0dXJuIG5ld1Njb3JlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHBpcGUuc2NvcmVkID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sIFtdKTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2xlYW51cCBvbiB1bm1vdW50LlxyXG4gICAqL1xyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpbml0aWFsaXplR2FtZSgpO1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgaWYgKHJlcXVlc3RJZFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmVxdWVzdElkUmVmLmN1cnJlbnQpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH0sIFtpbml0aWFsaXplR2FtZV0pO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgaGlnaFNjb3JlLFxyXG4gICAgY3VycmVudFNjb3JlLFxyXG4gICAgaGFuZGxlVXNlcklucHV0LFxyXG4gIH07XHJcbn1cclxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlQ2FsbGJhY2siLCJHUkFWSVRZIiwiRkxBUF9WRUxPQ0lUWSIsIlBJUEVfU1BFRUQiLCJQSVBFX1NQQVdOX0lOVEVSVkFMIiwiUElQRV9XSURUSCIsIlBJUEVfR0FQIiwiQklSRF9YIiwiQklSRF9XSURUSCIsIkJJUkRfSEVJR0hUIiwiQ09JTl9TUEVFRCIsIkNPSU5fU1BBV05fQ0hBTkNFIiwiQ09JTl9TSVpFIiwiUk9UQVRJT05fU1BFRUQiLCJNYXRoIiwiUEkiLCJ1c2VGbGFwcHlCaXJkR2FtZSIsImNhbnZhc1JlZiIsImlzUGF1c2VkIiwiYXV0b1N0YXJ0IiwiaGlnaFNjb3JlIiwic2V0SGlnaFNjb3JlIiwiY3VycmVudFNjb3JlIiwic2V0Q3VycmVudFNjb3JlIiwiYmlyZFlSZWYiLCJiaXJkVmVsb2NpdHlSZWYiLCJwaXBlc1JlZiIsImNvaW5zUmVmIiwiZ2FtZU92ZXJSZWYiLCJnYW1lU3RhcnRlZFJlZiIsImNvaW5Sb3RhdGlvblJlZiIsImxhc3RUaW1lUmVmIiwicGlwZVNwYXduVGltZXJSZWYiLCJiaXJkSW1hZ2VzUmVmIiwicGlwZVRvcEltZ1JlZiIsInBpcGVCb3R0b21JbWdSZWYiLCJiYWNrZ3JvdW5kSW1nUmVmIiwiY29pbkltZ1JlZiIsImN1cnJlbnRCaXJkRnJhbWVSZWYiLCJsb2FkSW1hZ2UiLCJpbWciLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImNvbXBsZXRlIiwib25sb2FkIiwib25lcnJvciIsIkVycm9yIiwic3JjIiwiYmlyZFVwIiwiSW1hZ2UiLCJiaXJkTWlkIiwiYmlyZERvd24iLCJjdXJyZW50IiwicGlwZVRvcEltZyIsInBpcGVCb3R0b21JbWciLCJiYWNrZ3JvdW5kSW1nIiwiY29pbkltZyIsInN0b3JlZEhpZ2hTY29yZSIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJwYXJzZUludCIsImluaXRpYWxpemVHYW1lIiwiY2FudmFzIiwiY3R4IiwiZ2V0Q29udGV4dCIsImFzc2V0cyIsImFsbCIsIm1hcCIsImNvbnNvbGUiLCJsb2ciLCJ3aWR0aCIsImhlaWdodCIsImRyYXdTdGFydFNjcmVlbiIsInN0YXJ0R2FtZSIsImVycm9yIiwicmVzZXRHYW1lIiwicGVyZm9ybWFuY2UiLCJub3ciLCJyZXF1ZXN0SWRSZWYiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJhbmltYXRlIiwiaGFuZGxlVXNlcklucHV0IiwiZmxhcEFuaW1hdGlvbiIsImhhbmRsZUtleURvd24iLCJlIiwia2V5Iiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJmbGFwRnJhbWVzIiwiY3VycmVudEZyYW1lIiwiZmxhcEludGVydmFsIiwiZmxhcCIsImxlbmd0aCIsInNldFRpbWVvdXQiLCJ0aW1lc3RhbXAiLCJkZWx0YVRpbWUiLCJtaW4iLCJ1cGRhdGVHYW1lU3RhdGUiLCJkcmF3IiwiZHJhd0dhbWVPdmVyU2NyZWVuIiwiY3JlYXRlUGlwZSIsInBpcGVNb3ZlRGVsdGEiLCJwaXBlIiwieCIsImZpbHRlciIsImNvaW5Nb3ZlRGVsdGEiLCJjb2luIiwiY29sbGVjdGVkIiwiY2hlY2tDb2xsaXNpb25zIiwiY2hlY2tDb2luQ29sbGVjdGlvbiIsInVwZGF0ZVNjb3JlIiwiY2xlYXJSZWN0IiwiZHJhd0ltYWdlIiwiZ2FwWSIsInNhdmUiLCJ0cmFuc2xhdGUiLCJ5Iiwicm90YXRlIiwicmVzdG9yZSIsImN1cnJlbnRCaXJkRnJhbWUiLCJmaWxsU3R5bGUiLCJmb250IiwidGV4dEFsaWduIiwidGV4dEJhc2VsaW5lIiwiZmlsbFRleHQiLCJmaWxsUmVjdCIsInJhbmRvbSIsInB1c2giLCJzY29yZWQiLCJiaXJkTGVmdCIsImJpcmRSaWdodCIsImJpcmRUb3AiLCJiaXJkQm90dG9tIiwicGlwZUxlZnQiLCJwaXBlUmlnaHQiLCJjb2luTGVmdCIsImNvaW5SaWdodCIsImNvaW5Ub3AiLCJjb2luQm90dG9tIiwicHJldlNjb3JlIiwibmV3U2NvcmUiLCJwcmV2SGlnaFNjb3JlIiwidXBkYXRlZEhpZ2hTY29yZSIsIm1heCIsInNldEl0ZW0iLCJ0b1N0cmluZyIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./public/useFlappyBirdGame.ts\n"));

/***/ })

});