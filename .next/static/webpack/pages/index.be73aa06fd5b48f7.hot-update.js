"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./public/useFlappyBirdGame.ts":
/*!*************************************!*\
  !*** ./public/useFlappyBirdGame.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFlappyBirdGame: function() { return /* binding */ useFlappyBirdGame; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n// Constants\nconst GRAVITY = 0.25;\nconst FLAP = -7.5;\nconst PIPE_WIDTH = 90;\nconst PIPE_SPACING = 250;\nconst BIRD_WIDTH = 50;\nconst BIRD_HEIGHT = 50;\nconst COIN_SIZE = 100;\nconst ROTATION_SPEED = 0.005;\n// How often to spawn pipes in terms of frames (~1.66s if 60fps)\nconst PIPE_SPAWN_FRAMES = 100;\nfunction useFlappyBirdGame(canvasRef, isPaused, autoStart) {\n    const requestIdRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // State\n    const [highScore, setHighScore] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [currentScore, setCurrentScore] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    // Refs to track game state\n    const birdYRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const birdVelocityRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const pipesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const coinsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const gameOverRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const gameStartedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const coinRotationStepRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const framesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // Assets (loaded once if window is defined)\n    let birdImages = [];\n    let pipeTop;\n    let pipeBottom;\n    let background;\n    let coinImage;\n    if (true) {\n        const birdUp = new Image();\n        birdUp.src = \"/assets/redbird-upflap.png\";\n        const birdMid = new Image();\n        birdMid.src = \"/assets/redbird-midflap.png\";\n        const birdDown = new Image();\n        birdDown.src = \"/assets/redbird-downflap.png\";\n        birdImages = [\n            birdUp,\n            birdMid,\n            birdDown\n        ];\n        pipeTop = new Image();\n        pipeTop.src = \"/assets/TopTiny.png\";\n        pipeBottom = new Image();\n        pipeBottom.src = \"/assets/BottomTiny.png\";\n        background = new Image();\n        background.src = \"/assets/background-day.png\";\n        coinImage = new Image();\n        coinImage.src = \"/assets/CoinTiny.png\";\n    }\n    // Current bird frame index\n    const currentBirdFrameRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // Load high score from localStorage on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (true) {\n            const storedHighScore = localStorage.getItem(\"highScore\");\n            if (storedHighScore) {\n                setHighScore(parseInt(storedHighScore, 10));\n            }\n        }\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        // Loads an image fully (promisify)\n        const loadImage = (img)=>{\n            return new Promise((resolve, reject)=>{\n                if (img.complete) {\n                    resolve();\n                } else {\n                    img.onload = ()=>resolve();\n                    img.onerror = ()=>reject(new Error(\"Failed to load image: \".concat(img.src)));\n                }\n            });\n        };\n        // Load all assets then init\n        const loadAssets = async ()=>{\n            try {\n                await Promise.all([\n                    ...birdImages.map((img)=>loadImage(img)),\n                    loadImage(pipeTop),\n                    loadImage(pipeBottom),\n                    loadImage(background),\n                    loadImage(coinImage)\n                ]);\n                console.log(\"All assets loaded successfully!\");\n                initializeGame();\n            } catch (error) {\n                console.error(\"Error loading assets:\", error);\n            }\n        };\n        loadAssets();\n        function resetGame() {\n            if (!canvasRef.current) return;\n            const { width, height } = canvasRef.current;\n            birdYRef.current = height / 3;\n            birdVelocityRef.current = 0;\n            pipesRef.current = [];\n            coinsRef.current = [];\n            setCurrentScore(0);\n            gameOverRef.current = false;\n            gameStartedRef.current = false;\n            coinRotationStepRef.current = 0;\n            framesRef.current = 0;\n            currentBirdFrameRef.current = 0;\n        }\n        function handleKeyDown(e) {\n            if (e.key === \" \") {\n                // If not started and not over, start. If over, restart. Otherwise flap.\n                if (!gameStartedRef.current && !gameOverRef.current) {\n                    startGame();\n                } else if (gameOverRef.current) {\n                    startGame();\n                } else {\n                    birdVelocityRef.current = FLAP;\n                    flap();\n                }\n            }\n        }\n        window.addEventListener(\"keydown\", handleKeyDown);\n        function handleResize() {\n            if (!canvasRef.current) return;\n            canvasRef.current.width = 360;\n            canvasRef.current.height = 640;\n            // If we're not started and not over, draw start screen\n            if (!gameStartedRef.current && !gameOverRef.current && ctx) {\n                drawStartScreen(ctx, canvasRef.current);\n            }\n        }\n        window.addEventListener(\"resize\", handleResize);\n        // Initialize\n        const initializeGame = ()=>{\n            if (!canvasRef.current) return;\n            canvasRef.current.width = 360;\n            canvasRef.current.height = 640;\n            drawStartScreen(ctx, canvasRef.current);\n        };\n        initializeGame();\n        function startGame() {\n            resetGame();\n            gameStartedRef.current = true;\n            animate();\n        }\n        // Expose a function (for mobile/desktop clicks) that does the same logic as space bar\n        function handleUserInput() {\n            if (!gameStartedRef.current && !gameOverRef.current) {\n                startGame();\n            } else if (gameOverRef.current) {\n                startGame();\n            } else {\n                birdVelocityRef.current = FLAP;\n                flap();\n            }\n        }\n        // Flap animation sequence\n        const flap = ()=>{\n            currentBirdFrameRef.current = 1;\n            setTimeout(()=>{\n                currentBirdFrameRef.current = 2;\n                setTimeout(()=>{\n                    currentBirdFrameRef.current = 0;\n                }, 170);\n            }, 170);\n        };\n        // Main loop\n        function animate() {\n            if (isPaused || !gameStartedRef.current) {\n                requestIdRef.current = requestAnimationFrame(animate);\n                return;\n            }\n            if (!canvasRef.current) return;\n            const context = canvasRef.current.getContext(\"2d\");\n            if (!context) return;\n            updateGameState(canvasRef.current);\n            draw(context, canvasRef.current);\n            if (!gameOverRef.current) {\n                requestIdRef.current = requestAnimationFrame(animate);\n            } else {\n                drawGameOverScreen(context, canvasRef.current);\n            }\n        }\n        function updateGameState(canvas) {\n            framesRef.current++;\n            // Gravity\n            birdVelocityRef.current += GRAVITY;\n            birdYRef.current += birdVelocityRef.current;\n            // Spawn pipes\n            if (framesRef.current % PIPE_SPAWN_FRAMES === 0) {\n                createPipe(canvas);\n            }\n            movePipesAndCoins();\n            checkCoinCollection();\n            // Check collisions\n            if (checkCollisions(canvas)) {\n                gameOverRef.current = true;\n                return;\n            }\n            updateScore();\n            // Rotate coin\n            coinRotationStepRef.current += ROTATION_SPEED;\n            if (coinRotationStepRef.current >= 1) {\n                coinRotationStepRef.current = 0;\n            }\n        }\n        function draw(ctx, canvas) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawBackground(ctx, canvas);\n            drawBird(ctx);\n            drawPipes(ctx);\n            drawCoins(ctx);\n        }\n        function drawStartScreen(ctx, canvas) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawBackground(ctx, canvas);\n            ctx.font = \"bold 30px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.fillStyle = \"#ffffff\";\n            ctx.shadowColor = \"black\";\n            ctx.textBaseline = \"middle\";\n            // Show a combined message (Space or Tap)\n            ctx.fillText(\"Press Space or Tap to Start\", canvas.width / 2, canvas.height / 2);\n        }\n        function drawGameOverScreen(ctx, canvas) {\n            ctx.fillStyle = \"#ffcc00\";\n            ctx.font = \"bold 50px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"middle\";\n            ctx.shadowColor = \"black\";\n            ctx.shadowBlur = 10;\n            ctx.fillText(\"Game Over!\", canvas.width / 2, canvas.height / 2 - 40);\n            ctx.fillStyle = \"#ffffff\";\n            ctx.font = \"bold 30px Arial\";\n            ctx.fillText(\"Press Space or Tap to Restart\", canvas.width / 2, canvas.height / 2 + 20);\n            ctx.fillStyle = \"#ffff00\";\n            ctx.font = \"30px Arial\";\n        }\n        function drawBackground(ctx, canvas) {\n            ctx.drawImage(background, 0, 0, canvas.width, canvas.height);\n        }\n        function drawBird(ctx) {\n            const currentImage = birdImages[currentBirdFrameRef.current];\n            if (currentImage.complete) {\n                ctx.drawImage(currentImage, 100, birdYRef.current, BIRD_WIDTH, BIRD_HEIGHT);\n            }\n        }\n        function drawPipes(ctx) {\n            for (const pipe of pipesRef.current){\n                ctx.drawImage(pipeTop, pipe.x, 0, PIPE_WIDTH, pipe.topHeight);\n                ctx.drawImage(pipeBottom, pipe.x, pipe.bottomY, PIPE_WIDTH, pipe.bottomHeight);\n            }\n        }\n        function drawCoins(ctx) {\n            const scaleX = Math.abs(Math.cos(coinRotationStepRef.current * Math.PI * 2));\n            const halfSize = COIN_SIZE / 2;\n            for (const coin of coinsRef.current){\n                if (!coin.collected) {\n                    ctx.save();\n                    ctx.translate(coin.x + halfSize, coin.y + halfSize);\n                    ctx.scale(scaleX, 1); // \"flip\" horizontally as it rotates\n                    ctx.drawImage(coinImage, -halfSize, -halfSize, COIN_SIZE, COIN_SIZE);\n                    ctx.restore();\n                }\n            }\n        }\n        function createPipe(canvas) {\n            const pipeHeight = Math.random() * (canvas.height - PIPE_SPACING - 100) + 50;\n            const bottomY = pipeHeight + PIPE_SPACING;\n            pipesRef.current.push({\n                x: canvas.width,\n                topHeight: pipeHeight,\n                bottomY,\n                bottomHeight: canvas.height - bottomY,\n                scored: false\n            });\n            // 50% chance to spawn a coin\n            if (Math.random() > 0.5) {\n                coinsRef.current.push({\n                    x: canvas.width + PIPE_WIDTH / 2 - COIN_SIZE / 2,\n                    y: pipeHeight + PIPE_SPACING / 2 - COIN_SIZE / 2,\n                    width: COIN_SIZE,\n                    height: COIN_SIZE,\n                    collected: false\n                });\n            }\n        }\n        function movePipesAndCoins() {\n            for (const pipe of pipesRef.current){\n                pipe.x -= 2;\n            }\n            pipesRef.current = pipesRef.current.filter((pipe)=>pipe.x + PIPE_WIDTH > 0);\n            for (const coin of coinsRef.current){\n                coin.x -= 2;\n            }\n            coinsRef.current = coinsRef.current.filter((coin)=>coin.x + coin.width > 0 && !coin.collected);\n        }\n        function checkCollisions(canvas) {\n            // Check top/bottom boundaries\n            if (birdYRef.current < 0 || birdYRef.current + BIRD_HEIGHT > canvas.height) {\n                return true;\n            }\n            const birdLeft = 100;\n            const birdRight = birdLeft + BIRD_WIDTH;\n            const birdTop = birdYRef.current;\n            const birdBottom = birdYRef.current + BIRD_HEIGHT;\n            // Pipe collision\n            for (const pipe of pipesRef.current){\n                const withinPipeX = birdRight > pipe.x && birdLeft < pipe.x + PIPE_WIDTH;\n                const withinPipeY = birdTop < pipe.topHeight || birdBottom > pipe.bottomY;\n                if (withinPipeX && withinPipeY) return true;\n            }\n            return false;\n        }\n        function checkCoinCollection() {\n            const birdLeft = 100;\n            const birdRight = birdLeft + BIRD_WIDTH;\n            const birdTop = birdYRef.current;\n            const birdBottom = birdYRef.current + BIRD_HEIGHT;\n            for (const coin of coinsRef.current){\n                if (!coin.collected) {\n                    const coinLeft = coin.x;\n                    const coinRight = coin.x + coin.width;\n                    const coinTop = coin.y;\n                    const coinBottom = coin.y + coin.height;\n                    if (birdRight > coinLeft && birdLeft < coinRight && birdBottom > coinTop && birdTop < coinBottom) {\n                        coin.collected = true;\n                        setCurrentScore((prevScore)=>{\n                            const newScore = prevScore + 5;\n                            setHighScore((prevHighScore)=>Math.max(prevHighScore, newScore));\n                            return newScore;\n                        });\n                    }\n                }\n            }\n        }\n        function updateScore() {\n            for (const pipe of pipesRef.current){\n                // Score +1 for passing each pipe, only once\n                if (!pipe.scored && pipe.x + PIPE_WIDTH < 100) {\n                    setCurrentScore((prevScore)=>{\n                        const newScore = prevScore + 1;\n                        setHighScore((prevHighScore)=>{\n                            const updatedHighScore = Math.max(prevHighScore, newScore);\n                            if (true) {\n                                localStorage.setItem(\"highScore\", updatedHighScore.toString());\n                            }\n                            return updatedHighScore;\n                        });\n                        return newScore;\n                    });\n                    pipe.scored = true;\n                }\n            }\n        }\n        return ()=>{\n            window.removeEventListener(\"keydown\", handleKeyDown);\n            window.removeEventListener(\"resize\", handleResize);\n            if (requestIdRef.current) {\n                cancelAnimationFrame(requestIdRef.current);\n            }\n        };\n    }, [\n        canvasRef,\n        isPaused,\n        autoStart\n    ]);\n    // Expose handleUserInput so the parent can attach onClick / onTouch\n    const handleUserInput = ()=>{\n    /* This will get overridden once the effect is fully loaded, \r\n       but we define it here to avoid undefined references. */ };\n    // NOTE: We must return an actual stable reference to that function.\n    // So let's do this: We'll store it in a ref that gets set inside the effect.\n    // But simpler is to define an internal stable reference:\n    // We do that by returning it from inside the effect, but that can lead to stale closures\n    // A simpler approach is to keep it as an internal function inside the effect that we store in a ref.\n    // For brevity, let's just store a no-op here and mention that the real logic is attached in the effect.\n    // In practice, you can unify the code so that handleUserInput is properly returned.\n    return {\n        highScore,\n        currentScore,\n        // We'll return a stable function that the effect re-binds behind the scenes.\n        handleUserInput: ()=>{\n            // We'll dispatch a \"keydown\" event with keyCode for space as a quick hack:\n            // This is so the same logic can be reused. Or you can directly copy the start/flap logic here.\n            const spaceEvent = new KeyboardEvent(\"keydown\", {\n                key: \" \"\n            });\n            window.dispatchEvent(spaceEvent);\n        }\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUU7UUFDQSw2RUFBNkU7UUFDN0UwRCxpQkFBaUI7WUFDZiwyRUFBMkU7WUFDM0UsK0ZBQStGO1lBQy9GLE1BQU1vRSxhQUFhLElBQUlDLGNBQWMsV0FBVztnQkFBRTdFLEtBQUs7WUFBSTtZQUMzREcsT0FBTzJFLGFBQWEsQ0FBQ0Y7UUFDdkI7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3B1YmxpYy91c2VGbGFwcHlCaXJkR2FtZS50cz81Yzc4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xyXG5cclxuLy8gVHlwZXMgZm9yIGdhbWUgb2JqZWN0c1xyXG5pbnRlcmZhY2UgUGlwZSB7XHJcbiAgeDogbnVtYmVyO1xyXG4gIHRvcEhlaWdodDogbnVtYmVyO1xyXG4gIGJvdHRvbVk6IG51bWJlcjtcclxuICBib3R0b21IZWlnaHQ6IG51bWJlcjtcclxuICBzY29yZWQ6IGJvb2xlYW47XHJcbn1cclxuXHJcbmludGVyZmFjZSBDb2luIHtcclxuICB4OiBudW1iZXI7XHJcbiAgeTogbnVtYmVyO1xyXG4gIHdpZHRoOiBudW1iZXI7XHJcbiAgaGVpZ2h0OiBudW1iZXI7XHJcbiAgY29sbGVjdGVkOiBib29sZWFuO1xyXG59XHJcblxyXG4vLyBDb25zdGFudHNcclxuY29uc3QgR1JBVklUWSA9IDAuMjU7XHJcbmNvbnN0IEZMQVAgPSAtNy41O1xyXG5jb25zdCBQSVBFX1dJRFRIID0gOTA7XHJcbmNvbnN0IFBJUEVfU1BBQ0lORyA9IDI1MDtcclxuY29uc3QgQklSRF9XSURUSCA9IDUwO1xyXG5jb25zdCBCSVJEX0hFSUdIVCA9IDUwO1xyXG5jb25zdCBDT0lOX1NJWkUgPSAxMDA7XHJcbmNvbnN0IFJPVEFUSU9OX1NQRUVEID0gMC4wMDU7XHJcblxyXG4vLyBIb3cgb2Z0ZW4gdG8gc3Bhd24gcGlwZXMgaW4gdGVybXMgb2YgZnJhbWVzICh+MS42NnMgaWYgNjBmcHMpXHJcbmNvbnN0IFBJUEVfU1BBV05fRlJBTUVTID0gMTAwO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUZsYXBweUJpcmRHYW1lKFxyXG4gIGNhbnZhc1JlZjogUmVhY3QuUmVmT2JqZWN0PEhUTUxDYW52YXNFbGVtZW50PixcclxuICBpc1BhdXNlZDogYm9vbGVhbixcclxuICBhdXRvU3RhcnQ6IGJvb2xlYW5cclxuKSB7XHJcbiAgY29uc3QgcmVxdWVzdElkUmVmID0gdXNlUmVmPG51bWJlciB8IG51bGw+KG51bGwpO1xyXG5cclxuICAvLyBTdGF0ZVxyXG4gIGNvbnN0IFtoaWdoU2NvcmUsIHNldEhpZ2hTY29yZV0gPSB1c2VTdGF0ZSgwKTtcclxuICBjb25zdCBbY3VycmVudFNjb3JlLCBzZXRDdXJyZW50U2NvcmVdID0gdXNlU3RhdGUoMCk7XHJcblxyXG4gIC8vIFJlZnMgdG8gdHJhY2sgZ2FtZSBzdGF0ZVxyXG4gIGNvbnN0IGJpcmRZUmVmID0gdXNlUmVmPG51bWJlcj4oMCk7XHJcbiAgY29uc3QgYmlyZFZlbG9jaXR5UmVmID0gdXNlUmVmPG51bWJlcj4oMCk7XHJcbiAgY29uc3QgcGlwZXNSZWYgPSB1c2VSZWY8UGlwZVtdPihbXSk7XHJcbiAgY29uc3QgY29pbnNSZWYgPSB1c2VSZWY8Q29pbltdPihbXSk7XHJcbiAgY29uc3QgZ2FtZU92ZXJSZWYgPSB1c2VSZWY8Ym9vbGVhbj4oZmFsc2UpO1xyXG4gIGNvbnN0IGdhbWVTdGFydGVkUmVmID0gdXNlUmVmPGJvb2xlYW4+KGZhbHNlKTtcclxuXHJcbiAgY29uc3QgY29pblJvdGF0aW9uU3RlcFJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xyXG4gIGNvbnN0IGZyYW1lc1JlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xyXG5cclxuICAvLyBBc3NldHMgKGxvYWRlZCBvbmNlIGlmIHdpbmRvdyBpcyBkZWZpbmVkKVxyXG4gIGxldCBiaXJkSW1hZ2VzOiBIVE1MSW1hZ2VFbGVtZW50W10gPSBbXTtcclxuICBsZXQgcGlwZVRvcDogSFRNTEltYWdlRWxlbWVudDtcclxuICBsZXQgcGlwZUJvdHRvbTogSFRNTEltYWdlRWxlbWVudDtcclxuICBsZXQgYmFja2dyb3VuZDogSFRNTEltYWdlRWxlbWVudDtcclxuICBsZXQgY29pbkltYWdlOiBIVE1MSW1hZ2VFbGVtZW50O1xyXG5cclxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgY29uc3QgYmlyZFVwID0gbmV3IEltYWdlKCk7XHJcbiAgICBiaXJkVXAuc3JjID0gXCIvYXNzZXRzL3JlZGJpcmQtdXBmbGFwLnBuZ1wiO1xyXG5cclxuICAgIGNvbnN0IGJpcmRNaWQgPSBuZXcgSW1hZ2UoKTtcclxuICAgIGJpcmRNaWQuc3JjID0gXCIvYXNzZXRzL3JlZGJpcmQtbWlkZmxhcC5wbmdcIjtcclxuXHJcbiAgICBjb25zdCBiaXJkRG93biA9IG5ldyBJbWFnZSgpO1xyXG4gICAgYmlyZERvd24uc3JjID0gXCIvYXNzZXRzL3JlZGJpcmQtZG93bmZsYXAucG5nXCI7XHJcblxyXG4gICAgYmlyZEltYWdlcyA9IFtiaXJkVXAsIGJpcmRNaWQsIGJpcmREb3duXTtcclxuXHJcbiAgICBwaXBlVG9wID0gbmV3IEltYWdlKCk7XHJcbiAgICBwaXBlVG9wLnNyYyA9IFwiL2Fzc2V0cy9Ub3BUaW55LnBuZ1wiO1xyXG5cclxuICAgIHBpcGVCb3R0b20gPSBuZXcgSW1hZ2UoKTtcclxuICAgIHBpcGVCb3R0b20uc3JjID0gXCIvYXNzZXRzL0JvdHRvbVRpbnkucG5nXCI7XHJcblxyXG4gICAgYmFja2dyb3VuZCA9IG5ldyBJbWFnZSgpO1xyXG4gICAgYmFja2dyb3VuZC5zcmMgPSBcIi9hc3NldHMvYmFja2dyb3VuZC1kYXkucG5nXCI7XHJcblxyXG4gICAgY29pbkltYWdlID0gbmV3IEltYWdlKCk7XHJcbiAgICBjb2luSW1hZ2Uuc3JjID0gXCIvYXNzZXRzL0NvaW5UaW55LnBuZ1wiO1xyXG4gIH1cclxuXHJcbiAgLy8gQ3VycmVudCBiaXJkIGZyYW1lIGluZGV4XHJcbiAgY29uc3QgY3VycmVudEJpcmRGcmFtZVJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xyXG5cclxuICAvLyBMb2FkIGhpZ2ggc2NvcmUgZnJvbSBsb2NhbFN0b3JhZ2Ugb24gbW91bnRcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgY29uc3Qgc3RvcmVkSGlnaFNjb3JlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJoaWdoU2NvcmVcIik7XHJcbiAgICAgIGlmIChzdG9yZWRIaWdoU2NvcmUpIHtcclxuICAgICAgICBzZXRIaWdoU2NvcmUocGFyc2VJbnQoc3RvcmVkSGlnaFNjb3JlLCAxMCkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSwgW10pO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XHJcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICBpZiAoIWN0eCkgcmV0dXJuO1xyXG5cclxuICAgIC8vIExvYWRzIGFuIGltYWdlIGZ1bGx5IChwcm9taXNpZnkpXHJcbiAgICBjb25zdCBsb2FkSW1hZ2UgPSAoaW1nOiBIVE1MSW1hZ2VFbGVtZW50KTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgaWYgKGltZy5jb21wbGV0ZSkge1xyXG4gICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpbWcub25sb2FkID0gKCkgPT4gcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgaW1nLm9uZXJyb3IgPSAoKSA9PiByZWplY3QobmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBpbWFnZTogJHtpbWcuc3JjfWApKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBMb2FkIGFsbCBhc3NldHMgdGhlbiBpbml0XHJcbiAgICBjb25zdCBsb2FkQXNzZXRzID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgICAgICAgIC4uLmJpcmRJbWFnZXMubWFwKChpbWcpID0+IGxvYWRJbWFnZShpbWcpKSxcclxuICAgICAgICAgIGxvYWRJbWFnZShwaXBlVG9wKSxcclxuICAgICAgICAgIGxvYWRJbWFnZShwaXBlQm90dG9tKSxcclxuICAgICAgICAgIGxvYWRJbWFnZShiYWNrZ3JvdW5kKSxcclxuICAgICAgICAgIGxvYWRJbWFnZShjb2luSW1hZ2UpLFxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQWxsIGFzc2V0cyBsb2FkZWQgc3VjY2Vzc2Z1bGx5IVwiKTtcclxuICAgICAgICBpbml0aWFsaXplR2FtZSgpO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsb2FkaW5nIGFzc2V0czpcIiwgZXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGxvYWRBc3NldHMoKTtcclxuXHJcbiAgICBmdW5jdGlvbiByZXNldEdhbWUoKSB7XHJcbiAgICAgIGlmICghY2FudmFzUmVmLmN1cnJlbnQpIHJldHVybjtcclxuICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBjYW52YXNSZWYuY3VycmVudDtcclxuXHJcbiAgICAgIGJpcmRZUmVmLmN1cnJlbnQgPSBoZWlnaHQgLyAzO1xyXG4gICAgICBiaXJkVmVsb2NpdHlSZWYuY3VycmVudCA9IDA7XHJcbiAgICAgIHBpcGVzUmVmLmN1cnJlbnQgPSBbXTtcclxuICAgICAgY29pbnNSZWYuY3VycmVudCA9IFtdO1xyXG4gICAgICBzZXRDdXJyZW50U2NvcmUoMCk7XHJcbiAgICAgIGdhbWVPdmVyUmVmLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgICAgZ2FtZVN0YXJ0ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xyXG4gICAgICBjb2luUm90YXRpb25TdGVwUmVmLmN1cnJlbnQgPSAwO1xyXG4gICAgICBmcmFtZXNSZWYuY3VycmVudCA9IDA7XHJcbiAgICAgIGN1cnJlbnRCaXJkRnJhbWVSZWYuY3VycmVudCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlS2V5RG93bihlOiBLZXlib2FyZEV2ZW50KSB7XHJcbiAgICAgIGlmIChlLmtleSA9PT0gXCIgXCIpIHtcclxuICAgICAgICAvLyBJZiBub3Qgc3RhcnRlZCBhbmQgbm90IG92ZXIsIHN0YXJ0LiBJZiBvdmVyLCByZXN0YXJ0LiBPdGhlcndpc2UgZmxhcC5cclxuICAgICAgICBpZiAoIWdhbWVTdGFydGVkUmVmLmN1cnJlbnQgJiYgIWdhbWVPdmVyUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgIHN0YXJ0R2FtZSgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZ2FtZU92ZXJSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgc3RhcnRHYW1lKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGJpcmRWZWxvY2l0eVJlZi5jdXJyZW50ID0gRkxBUDtcclxuICAgICAgICAgIGZsYXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgaGFuZGxlS2V5RG93bik7XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlUmVzaXplKCkge1xyXG4gICAgICBpZiAoIWNhbnZhc1JlZi5jdXJyZW50KSByZXR1cm47XHJcbiAgICAgIGNhbnZhc1JlZi5jdXJyZW50LndpZHRoID0gMzYwO1xyXG4gICAgICBjYW52YXNSZWYuY3VycmVudC5oZWlnaHQgPSA2NDA7XHJcblxyXG4gICAgICAvLyBJZiB3ZSdyZSBub3Qgc3RhcnRlZCBhbmQgbm90IG92ZXIsIGRyYXcgc3RhcnQgc2NyZWVuXHJcbiAgICAgIGlmICghZ2FtZVN0YXJ0ZWRSZWYuY3VycmVudCAmJiAhZ2FtZU92ZXJSZWYuY3VycmVudCAmJiBjdHgpIHtcclxuICAgICAgICBkcmF3U3RhcnRTY3JlZW4oY3R4LCBjYW52YXNSZWYuY3VycmVudCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGhhbmRsZVJlc2l6ZSk7XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZVxyXG4gICAgY29uc3QgaW5pdGlhbGl6ZUdhbWUgPSAoKSA9PiB7XHJcbiAgICAgIGlmICghY2FudmFzUmVmLmN1cnJlbnQpIHJldHVybjtcclxuICAgICAgY2FudmFzUmVmLmN1cnJlbnQud2lkdGggPSAzNjA7XHJcbiAgICAgIGNhbnZhc1JlZi5jdXJyZW50LmhlaWdodCA9IDY0MDtcclxuICAgICAgZHJhd1N0YXJ0U2NyZWVuKGN0eCwgY2FudmFzUmVmLmN1cnJlbnQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBpbml0aWFsaXplR2FtZSgpO1xyXG5cclxuICAgIGZ1bmN0aW9uIHN0YXJ0R2FtZSgpIHtcclxuICAgICAgcmVzZXRHYW1lKCk7XHJcbiAgICAgIGdhbWVTdGFydGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xyXG4gICAgICBhbmltYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRXhwb3NlIGEgZnVuY3Rpb24gKGZvciBtb2JpbGUvZGVza3RvcCBjbGlja3MpIHRoYXQgZG9lcyB0aGUgc2FtZSBsb2dpYyBhcyBzcGFjZSBiYXJcclxuICAgIGZ1bmN0aW9uIGhhbmRsZVVzZXJJbnB1dCgpIHtcclxuICAgICAgaWYgKCFnYW1lU3RhcnRlZFJlZi5jdXJyZW50ICYmICFnYW1lT3ZlclJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgc3RhcnRHYW1lKCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoZ2FtZU92ZXJSZWYuY3VycmVudCkge1xyXG4gICAgICAgIHN0YXJ0R2FtZSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGJpcmRWZWxvY2l0eVJlZi5jdXJyZW50ID0gRkxBUDtcclxuICAgICAgICBmbGFwKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBGbGFwIGFuaW1hdGlvbiBzZXF1ZW5jZVxyXG4gICAgY29uc3QgZmxhcCA9ICgpID0+IHtcclxuICAgICAgY3VycmVudEJpcmRGcmFtZVJlZi5jdXJyZW50ID0gMTtcclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgY3VycmVudEJpcmRGcmFtZVJlZi5jdXJyZW50ID0gMjtcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgIGN1cnJlbnRCaXJkRnJhbWVSZWYuY3VycmVudCA9IDA7XHJcbiAgICAgICAgfSwgMTcwKTtcclxuICAgICAgfSwgMTcwKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gTWFpbiBsb29wXHJcbiAgICBmdW5jdGlvbiBhbmltYXRlKCkge1xyXG4gICAgICBpZiAoaXNQYXVzZWQgfHwgIWdhbWVTdGFydGVkUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICByZXF1ZXN0SWRSZWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFjYW52YXNSZWYuY3VycmVudCkgcmV0dXJuO1xyXG4gICAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzUmVmLmN1cnJlbnQuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgICBpZiAoIWNvbnRleHQpIHJldHVybjtcclxuXHJcbiAgICAgIHVwZGF0ZUdhbWVTdGF0ZShjYW52YXNSZWYuY3VycmVudCk7XHJcbiAgICAgIGRyYXcoY29udGV4dCwgY2FudmFzUmVmLmN1cnJlbnQpO1xyXG5cclxuICAgICAgaWYgKCFnYW1lT3ZlclJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgcmVxdWVzdElkUmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZHJhd0dhbWVPdmVyU2NyZWVuKGNvbnRleHQsIGNhbnZhc1JlZi5jdXJyZW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZUdhbWVTdGF0ZShjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgIGZyYW1lc1JlZi5jdXJyZW50Kys7XHJcblxyXG4gICAgICAvLyBHcmF2aXR5XHJcbiAgICAgIGJpcmRWZWxvY2l0eVJlZi5jdXJyZW50ICs9IEdSQVZJVFk7XHJcbiAgICAgIGJpcmRZUmVmLmN1cnJlbnQgKz0gYmlyZFZlbG9jaXR5UmVmLmN1cnJlbnQ7XHJcblxyXG4gICAgICAvLyBTcGF3biBwaXBlc1xyXG4gICAgICBpZiAoZnJhbWVzUmVmLmN1cnJlbnQgJSBQSVBFX1NQQVdOX0ZSQU1FUyA9PT0gMCkge1xyXG4gICAgICAgIGNyZWF0ZVBpcGUoY2FudmFzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbW92ZVBpcGVzQW5kQ29pbnMoKTtcclxuICAgICAgY2hlY2tDb2luQ29sbGVjdGlvbigpO1xyXG5cclxuICAgICAgLy8gQ2hlY2sgY29sbGlzaW9uc1xyXG4gICAgICBpZiAoY2hlY2tDb2xsaXNpb25zKGNhbnZhcykpIHtcclxuICAgICAgICBnYW1lT3ZlclJlZi5jdXJyZW50ID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHVwZGF0ZVNjb3JlKCk7XHJcblxyXG4gICAgICAvLyBSb3RhdGUgY29pblxyXG4gICAgICBjb2luUm90YXRpb25TdGVwUmVmLmN1cnJlbnQgKz0gUk9UQVRJT05fU1BFRUQ7XHJcbiAgICAgIGlmIChjb2luUm90YXRpb25TdGVwUmVmLmN1cnJlbnQgPj0gMSkge1xyXG4gICAgICAgIGNvaW5Sb3RhdGlvblN0ZXBSZWYuY3VycmVudCA9IDA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3KGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICAgICAgZHJhd0JhY2tncm91bmQoY3R4LCBjYW52YXMpO1xyXG4gICAgICBkcmF3QmlyZChjdHgpO1xyXG4gICAgICBkcmF3UGlwZXMoY3R4KTtcclxuICAgICAgZHJhd0NvaW5zKGN0eCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd1N0YXJ0U2NyZWVuKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICAgICAgZHJhd0JhY2tncm91bmQoY3R4LCBjYW52YXMpO1xyXG4gICAgICBjdHguZm9udCA9IFwiYm9sZCAzMHB4IEFyaWFsXCI7XHJcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xyXG4gICAgICBjdHguZmlsbFN0eWxlID0gXCIjZmZmZmZmXCI7XHJcbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFwiYmxhY2tcIjtcclxuICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XHJcbiAgICAgIC8vIFNob3cgYSBjb21iaW5lZCBtZXNzYWdlIChTcGFjZSBvciBUYXApXHJcbiAgICAgIGN0eC5maWxsVGV4dChcIlByZXNzIFNwYWNlIG9yIFRhcCB0byBTdGFydFwiLCBjYW52YXMud2lkdGggLyAyLCBjYW52YXMuaGVpZ2h0IC8gMik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd0dhbWVPdmVyU2NyZWVuKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNmZmNjMDBcIjtcclxuICAgICAgY3R4LmZvbnQgPSBcImJvbGQgNTBweCBBcmlhbFwiO1xyXG4gICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcclxuICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XHJcbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFwiYmxhY2tcIjtcclxuICAgICAgY3R4LnNoYWRvd0JsdXIgPSAxMDtcclxuXHJcbiAgICAgIGN0eC5maWxsVGV4dChcIkdhbWUgT3ZlciFcIiwgY2FudmFzLndpZHRoIC8gMiwgY2FudmFzLmhlaWdodCAvIDIgLSA0MCk7XHJcblxyXG4gICAgICBjdHguZmlsbFN0eWxlID0gXCIjZmZmZmZmXCI7XHJcbiAgICAgIGN0eC5mb250ID0gXCJib2xkIDMwcHggQXJpYWxcIjtcclxuICAgICAgY3R4LmZpbGxUZXh0KFwiUHJlc3MgU3BhY2Ugb3IgVGFwIHRvIFJlc3RhcnRcIiwgY2FudmFzLndpZHRoIC8gMiwgY2FudmFzLmhlaWdodCAvIDIgKyAyMCk7XHJcblxyXG4gICAgICBjdHguZmlsbFN0eWxlID0gXCIjZmZmZjAwXCI7XHJcbiAgICAgIGN0eC5mb250ID0gXCIzMHB4IEFyaWFsXCI7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd0JhY2tncm91bmQoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcclxuICAgICAgY3R4LmRyYXdJbWFnZShiYWNrZ3JvdW5kLCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdCaXJkKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XHJcbiAgICAgIGNvbnN0IGN1cnJlbnRJbWFnZSA9IGJpcmRJbWFnZXNbY3VycmVudEJpcmRGcmFtZVJlZi5jdXJyZW50XTtcclxuICAgICAgaWYgKGN1cnJlbnRJbWFnZS5jb21wbGV0ZSkge1xyXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoY3VycmVudEltYWdlLCAxMDAsIGJpcmRZUmVmLmN1cnJlbnQsIEJJUkRfV0lEVEgsIEJJUkRfSEVJR0hUKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdQaXBlcyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xyXG4gICAgICBmb3IgKGNvbnN0IHBpcGUgb2YgcGlwZXNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UocGlwZVRvcCwgcGlwZS54LCAwLCBQSVBFX1dJRFRILCBwaXBlLnRvcEhlaWdodCk7XHJcbiAgICAgICAgY3R4LmRyYXdJbWFnZShwaXBlQm90dG9tLCBwaXBlLngsIHBpcGUuYm90dG9tWSwgUElQRV9XSURUSCwgcGlwZS5ib3R0b21IZWlnaHQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd0NvaW5zKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XHJcbiAgICAgIGNvbnN0IHNjYWxlWCA9IE1hdGguYWJzKE1hdGguY29zKGNvaW5Sb3RhdGlvblN0ZXBSZWYuY3VycmVudCAqIE1hdGguUEkgKiAyKSk7XHJcbiAgICAgIGNvbnN0IGhhbGZTaXplID0gQ09JTl9TSVpFIC8gMjtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgY29pbiBvZiBjb2luc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgaWYgKCFjb2luLmNvbGxlY3RlZCkge1xyXG4gICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgIGN0eC50cmFuc2xhdGUoY29pbi54ICsgaGFsZlNpemUsIGNvaW4ueSArIGhhbGZTaXplKTtcclxuICAgICAgICAgIGN0eC5zY2FsZShzY2FsZVgsIDEpOyAvLyBcImZsaXBcIiBob3Jpem9udGFsbHkgYXMgaXQgcm90YXRlc1xyXG4gICAgICAgICAgY3R4LmRyYXdJbWFnZShjb2luSW1hZ2UsIC1oYWxmU2l6ZSwgLWhhbGZTaXplLCBDT0lOX1NJWkUsIENPSU5fU0laRSk7XHJcbiAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBpcGUoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkge1xyXG4gICAgICBjb25zdCBwaXBlSGVpZ2h0ID1cclxuICAgICAgICBNYXRoLnJhbmRvbSgpICogKGNhbnZhcy5oZWlnaHQgLSBQSVBFX1NQQUNJTkcgLSAxMDApICsgNTA7XHJcbiAgICAgIGNvbnN0IGJvdHRvbVkgPSBwaXBlSGVpZ2h0ICsgUElQRV9TUEFDSU5HO1xyXG4gICAgICBwaXBlc1JlZi5jdXJyZW50LnB1c2goe1xyXG4gICAgICAgIHg6IGNhbnZhcy53aWR0aCxcclxuICAgICAgICB0b3BIZWlnaHQ6IHBpcGVIZWlnaHQsXHJcbiAgICAgICAgYm90dG9tWSxcclxuICAgICAgICBib3R0b21IZWlnaHQ6IGNhbnZhcy5oZWlnaHQgLSBib3R0b21ZLFxyXG4gICAgICAgIHNjb3JlZDogZmFsc2UsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gNTAlIGNoYW5jZSB0byBzcGF3biBhIGNvaW5cclxuICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPiAwLjUpIHtcclxuICAgICAgICBjb2luc1JlZi5jdXJyZW50LnB1c2goe1xyXG4gICAgICAgICAgeDogY2FudmFzLndpZHRoICsgUElQRV9XSURUSCAvIDIgLSBDT0lOX1NJWkUgLyAyLFxyXG4gICAgICAgICAgeTogcGlwZUhlaWdodCArIFBJUEVfU1BBQ0lORyAvIDIgLSBDT0lOX1NJWkUgLyAyLFxyXG4gICAgICAgICAgd2lkdGg6IENPSU5fU0laRSxcclxuICAgICAgICAgIGhlaWdodDogQ09JTl9TSVpFLFxyXG4gICAgICAgICAgY29sbGVjdGVkOiBmYWxzZSxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1vdmVQaXBlc0FuZENvaW5zKCkge1xyXG4gICAgICBmb3IgKGNvbnN0IHBpcGUgb2YgcGlwZXNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIHBpcGUueCAtPSAyO1xyXG4gICAgICB9XHJcbiAgICAgIHBpcGVzUmVmLmN1cnJlbnQgPSBwaXBlc1JlZi5jdXJyZW50LmZpbHRlcihcclxuICAgICAgICAocGlwZSkgPT4gcGlwZS54ICsgUElQRV9XSURUSCA+IDBcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgY29pbiBvZiBjb2luc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY29pbi54IC09IDI7XHJcbiAgICAgIH1cclxuICAgICAgY29pbnNSZWYuY3VycmVudCA9IGNvaW5zUmVmLmN1cnJlbnQuZmlsdGVyKFxyXG4gICAgICAgIChjb2luKSA9PiBjb2luLnggKyBjb2luLndpZHRoID4gMCAmJiAhY29pbi5jb2xsZWN0ZWRcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjaGVja0NvbGxpc2lvbnMoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCk6IGJvb2xlYW4ge1xyXG4gICAgICAvLyBDaGVjayB0b3AvYm90dG9tIGJvdW5kYXJpZXNcclxuICAgICAgaWYgKGJpcmRZUmVmLmN1cnJlbnQgPCAwIHx8IGJpcmRZUmVmLmN1cnJlbnQgKyBCSVJEX0hFSUdIVCA+IGNhbnZhcy5oZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgYmlyZExlZnQgPSAxMDA7XHJcbiAgICAgIGNvbnN0IGJpcmRSaWdodCA9IGJpcmRMZWZ0ICsgQklSRF9XSURUSDtcclxuICAgICAgY29uc3QgYmlyZFRvcCA9IGJpcmRZUmVmLmN1cnJlbnQ7XHJcbiAgICAgIGNvbnN0IGJpcmRCb3R0b20gPSBiaXJkWVJlZi5jdXJyZW50ICsgQklSRF9IRUlHSFQ7XHJcblxyXG4gICAgICAvLyBQaXBlIGNvbGxpc2lvblxyXG4gICAgICBmb3IgKGNvbnN0IHBpcGUgb2YgcGlwZXNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGNvbnN0IHdpdGhpblBpcGVYID1cclxuICAgICAgICAgIGJpcmRSaWdodCA+IHBpcGUueCAmJiBiaXJkTGVmdCA8IHBpcGUueCArIFBJUEVfV0lEVEg7XHJcbiAgICAgICAgY29uc3Qgd2l0aGluUGlwZVkgPVxyXG4gICAgICAgICAgYmlyZFRvcCA8IHBpcGUudG9wSGVpZ2h0IHx8IGJpcmRCb3R0b20gPiBwaXBlLmJvdHRvbVk7XHJcbiAgICAgICAgaWYgKHdpdGhpblBpcGVYICYmIHdpdGhpblBpcGVZKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2hlY2tDb2luQ29sbGVjdGlvbigpIHtcclxuICAgICAgY29uc3QgYmlyZExlZnQgPSAxMDA7XHJcbiAgICAgIGNvbnN0IGJpcmRSaWdodCA9IGJpcmRMZWZ0ICsgQklSRF9XSURUSDtcclxuICAgICAgY29uc3QgYmlyZFRvcCA9IGJpcmRZUmVmLmN1cnJlbnQ7XHJcbiAgICAgIGNvbnN0IGJpcmRCb3R0b20gPSBiaXJkWVJlZi5jdXJyZW50ICsgQklSRF9IRUlHSFQ7XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGNvaW4gb2YgY29pbnNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGlmICghY29pbi5jb2xsZWN0ZWQpIHtcclxuICAgICAgICAgIGNvbnN0IGNvaW5MZWZ0ID0gY29pbi54O1xyXG4gICAgICAgICAgY29uc3QgY29pblJpZ2h0ID0gY29pbi54ICsgY29pbi53aWR0aDtcclxuICAgICAgICAgIGNvbnN0IGNvaW5Ub3AgPSBjb2luLnk7XHJcbiAgICAgICAgICBjb25zdCBjb2luQm90dG9tID0gY29pbi55ICsgY29pbi5oZWlnaHQ7XHJcblxyXG4gICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICBiaXJkUmlnaHQgPiBjb2luTGVmdCAmJlxyXG4gICAgICAgICAgICBiaXJkTGVmdCA8IGNvaW5SaWdodCAmJlxyXG4gICAgICAgICAgICBiaXJkQm90dG9tID4gY29pblRvcCAmJlxyXG4gICAgICAgICAgICBiaXJkVG9wIDwgY29pbkJvdHRvbVxyXG4gICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIGNvaW4uY29sbGVjdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgc2V0Q3VycmVudFNjb3JlKChwcmV2U2NvcmUpID0+IHtcclxuICAgICAgICAgICAgICBjb25zdCBuZXdTY29yZSA9IHByZXZTY29yZSArIDU7XHJcbiAgICAgICAgICAgICAgc2V0SGlnaFNjb3JlKChwcmV2SGlnaFNjb3JlKSA9PiBNYXRoLm1heChwcmV2SGlnaFNjb3JlLCBuZXdTY29yZSkpO1xyXG4gICAgICAgICAgICAgIHJldHVybiBuZXdTY29yZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdXBkYXRlU2NvcmUoKSB7XHJcbiAgICAgIGZvciAoY29uc3QgcGlwZSBvZiBwaXBlc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgLy8gU2NvcmUgKzEgZm9yIHBhc3NpbmcgZWFjaCBwaXBlLCBvbmx5IG9uY2VcclxuICAgICAgICBpZiAoIXBpcGUuc2NvcmVkICYmIHBpcGUueCArIFBJUEVfV0lEVEggPCAxMDApIHtcclxuICAgICAgICAgIHNldEN1cnJlbnRTY29yZSgocHJldlNjb3JlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1Njb3JlID0gcHJldlNjb3JlICsgMTtcclxuICAgICAgICAgICAgc2V0SGlnaFNjb3JlKChwcmV2SGlnaFNjb3JlKSA9PiB7XHJcbiAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZEhpZ2hTY29yZSA9IE1hdGgubWF4KHByZXZIaWdoU2NvcmUsIG5ld1Njb3JlKTtcclxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJoaWdoU2NvcmVcIiwgdXBkYXRlZEhpZ2hTY29yZS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZWRIaWdoU2NvcmU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3U2NvcmU7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHBpcGUuc2NvcmVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgaGFuZGxlS2V5RG93bik7XHJcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGhhbmRsZVJlc2l6ZSk7XHJcbiAgICAgIGlmIChyZXF1ZXN0SWRSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJlcXVlc3RJZFJlZi5jdXJyZW50KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9LCBbY2FudmFzUmVmLCBpc1BhdXNlZCwgYXV0b1N0YXJ0XSk7XHJcblxyXG4gIC8vIEV4cG9zZSBoYW5kbGVVc2VySW5wdXQgc28gdGhlIHBhcmVudCBjYW4gYXR0YWNoIG9uQ2xpY2sgLyBvblRvdWNoXHJcbiAgY29uc3QgaGFuZGxlVXNlcklucHV0ID0gKCkgPT4ge1xyXG4gICAgLyogVGhpcyB3aWxsIGdldCBvdmVycmlkZGVuIG9uY2UgdGhlIGVmZmVjdCBpcyBmdWxseSBsb2FkZWQsIFxyXG4gICAgICAgYnV0IHdlIGRlZmluZSBpdCBoZXJlIHRvIGF2b2lkIHVuZGVmaW5lZCByZWZlcmVuY2VzLiAqL1xyXG4gIH07XHJcblxyXG4gIC8vIE5PVEU6IFdlIG11c3QgcmV0dXJuIGFuIGFjdHVhbCBzdGFibGUgcmVmZXJlbmNlIHRvIHRoYXQgZnVuY3Rpb24uXHJcbiAgLy8gU28gbGV0J3MgZG8gdGhpczogV2UnbGwgc3RvcmUgaXQgaW4gYSByZWYgdGhhdCBnZXRzIHNldCBpbnNpZGUgdGhlIGVmZmVjdC5cclxuICAvLyBCdXQgc2ltcGxlciBpcyB0byBkZWZpbmUgYW4gaW50ZXJuYWwgc3RhYmxlIHJlZmVyZW5jZTpcclxuICAvLyBXZSBkbyB0aGF0IGJ5IHJldHVybmluZyBpdCBmcm9tIGluc2lkZSB0aGUgZWZmZWN0LCBidXQgdGhhdCBjYW4gbGVhZCB0byBzdGFsZSBjbG9zdXJlc1xyXG4gIC8vIEEgc2ltcGxlciBhcHByb2FjaCBpcyB0byBrZWVwIGl0IGFzIGFuIGludGVybmFsIGZ1bmN0aW9uIGluc2lkZSB0aGUgZWZmZWN0IHRoYXQgd2Ugc3RvcmUgaW4gYSByZWYuXHJcbiAgLy8gRm9yIGJyZXZpdHksIGxldCdzIGp1c3Qgc3RvcmUgYSBuby1vcCBoZXJlIGFuZCBtZW50aW9uIHRoYXQgdGhlIHJlYWwgbG9naWMgaXMgYXR0YWNoZWQgaW4gdGhlIGVmZmVjdC5cclxuICAvLyBJbiBwcmFjdGljZSwgeW91IGNhbiB1bmlmeSB0aGUgY29kZSBzbyB0aGF0IGhhbmRsZVVzZXJJbnB1dCBpcyBwcm9wZXJseSByZXR1cm5lZC5cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGhpZ2hTY29yZSxcclxuICAgIGN1cnJlbnRTY29yZSxcclxuICAgIC8vIFdlJ2xsIHJldHVybiBhIHN0YWJsZSBmdW5jdGlvbiB0aGF0IHRoZSBlZmZlY3QgcmUtYmluZHMgYmVoaW5kIHRoZSBzY2VuZXMuXHJcbiAgICBoYW5kbGVVc2VySW5wdXQ6ICgpID0+IHtcclxuICAgICAgLy8gV2UnbGwgZGlzcGF0Y2ggYSBcImtleWRvd25cIiBldmVudCB3aXRoIGtleUNvZGUgZm9yIHNwYWNlIGFzIGEgcXVpY2sgaGFjazpcclxuICAgICAgLy8gVGhpcyBpcyBzbyB0aGUgc2FtZSBsb2dpYyBjYW4gYmUgcmV1c2VkLiBPciB5b3UgY2FuIGRpcmVjdGx5IGNvcHkgdGhlIHN0YXJ0L2ZsYXAgbG9naWMgaGVyZS5cclxuICAgICAgY29uc3Qgc3BhY2VFdmVudCA9IG5ldyBLZXlib2FyZEV2ZW50KFwia2V5ZG93blwiLCB7IGtleTogXCIgXCIgfSk7XHJcbiAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KHNwYWNlRXZlbnQpO1xyXG4gICAgfSxcclxuICB9O1xyXG59XHJcbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsIkdSQVZJVFkiLCJGTEFQIiwiUElQRV9XSURUSCIsIlBJUEVfU1BBQ0lORyIsIkJJUkRfV0lEVEgiLCJCSVJEX0hFSUdIVCIsIkNPSU5fU0laRSIsIlJPVEFUSU9OX1NQRUVEIiwiUElQRV9TUEFXTl9GUkFNRVMiLCJ1c2VGbGFwcHlCaXJkR2FtZSIsImNhbnZhc1JlZiIsImlzUGF1c2VkIiwiYXV0b1N0YXJ0IiwicmVxdWVzdElkUmVmIiwiaGlnaFNjb3JlIiwic2V0SGlnaFNjb3JlIiwiY3VycmVudFNjb3JlIiwic2V0Q3VycmVudFNjb3JlIiwiYmlyZFlSZWYiLCJiaXJkVmVsb2NpdHlSZWYiLCJwaXBlc1JlZiIsImNvaW5zUmVmIiwiZ2FtZU92ZXJSZWYiLCJnYW1lU3RhcnRlZFJlZiIsImNvaW5Sb3RhdGlvblN0ZXBSZWYiLCJmcmFtZXNSZWYiLCJiaXJkSW1hZ2VzIiwicGlwZVRvcCIsInBpcGVCb3R0b20iLCJiYWNrZ3JvdW5kIiwiY29pbkltYWdlIiwiYmlyZFVwIiwiSW1hZ2UiLCJzcmMiLCJiaXJkTWlkIiwiYmlyZERvd24iLCJjdXJyZW50QmlyZEZyYW1lUmVmIiwic3RvcmVkSGlnaFNjb3JlIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInBhcnNlSW50IiwiY2FudmFzIiwiY3VycmVudCIsImN0eCIsImdldENvbnRleHQiLCJsb2FkSW1hZ2UiLCJpbWciLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImNvbXBsZXRlIiwib25sb2FkIiwib25lcnJvciIsIkVycm9yIiwibG9hZEFzc2V0cyIsImFsbCIsIm1hcCIsImNvbnNvbGUiLCJsb2ciLCJpbml0aWFsaXplR2FtZSIsImVycm9yIiwicmVzZXRHYW1lIiwid2lkdGgiLCJoZWlnaHQiLCJoYW5kbGVLZXlEb3duIiwiZSIsImtleSIsInN0YXJ0R2FtZSIsImZsYXAiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwiaGFuZGxlUmVzaXplIiwiZHJhd1N0YXJ0U2NyZWVuIiwiYW5pbWF0ZSIsImhhbmRsZVVzZXJJbnB1dCIsInNldFRpbWVvdXQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjb250ZXh0IiwidXBkYXRlR2FtZVN0YXRlIiwiZHJhdyIsImRyYXdHYW1lT3ZlclNjcmVlbiIsImNyZWF0ZVBpcGUiLCJtb3ZlUGlwZXNBbmRDb2lucyIsImNoZWNrQ29pbkNvbGxlY3Rpb24iLCJjaGVja0NvbGxpc2lvbnMiLCJ1cGRhdGVTY29yZSIsImNsZWFyUmVjdCIsImRyYXdCYWNrZ3JvdW5kIiwiZHJhd0JpcmQiLCJkcmF3UGlwZXMiLCJkcmF3Q29pbnMiLCJmb250IiwidGV4dEFsaWduIiwiZmlsbFN0eWxlIiwic2hhZG93Q29sb3IiLCJ0ZXh0QmFzZWxpbmUiLCJmaWxsVGV4dCIsInNoYWRvd0JsdXIiLCJkcmF3SW1hZ2UiLCJjdXJyZW50SW1hZ2UiLCJwaXBlIiwieCIsInRvcEhlaWdodCIsImJvdHRvbVkiLCJib3R0b21IZWlnaHQiLCJzY2FsZVgiLCJNYXRoIiwiYWJzIiwiY29zIiwiUEkiLCJoYWxmU2l6ZSIsImNvaW4iLCJjb2xsZWN0ZWQiLCJzYXZlIiwidHJhbnNsYXRlIiwieSIsInNjYWxlIiwicmVzdG9yZSIsInBpcGVIZWlnaHQiLCJyYW5kb20iLCJwdXNoIiwic2NvcmVkIiwiZmlsdGVyIiwiYmlyZExlZnQiLCJiaXJkUmlnaHQiLCJiaXJkVG9wIiwiYmlyZEJvdHRvbSIsIndpdGhpblBpcGVYIiwid2l0aGluUGlwZVkiLCJjb2luTGVmdCIsImNvaW5SaWdodCIsImNvaW5Ub3AiLCJjb2luQm90dG9tIiwicHJldlNjb3JlIiwibmV3U2NvcmUiLCJwcmV2SGlnaFNjb3JlIiwibWF4IiwidXBkYXRlZEhpZ2hTY29yZSIsInNldEl0ZW0iLCJ0b1N0cmluZyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInNwYWNlRXZlbnQiLCJLZXlib2FyZEV2ZW50IiwiZGlzcGF0Y2hFdmVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./public/useFlappyBirdGame.ts\n"));

/***/ })

});