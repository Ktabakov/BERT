"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./contracts/vesting.hl":
/*!******************************!*\
  !*** ./contracts/vesting.hl ***!
  \******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Program; }\n/* harmony export */ });\n/* harmony import */ var _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hyperionbt/helios */ \"./node_modules/@hyperionbt/helios/helios.js\");\n\n//wraps helios.Program\nclass Program {\n    #program\n\n    constructor(parameters = {}) {\n        // load all the dependencies\n        const allDeps = []\n\n        const depSrcs = new Map()\n\n        function addDepSrcs(dep) {\n            depSrcs.set(dep.name, dep.src)\n\n            for (let d of dep.dependencies) {\n                addDepSrcs(d)\n            }\n        }\n\n        for (let d of allDeps) {\n            addDepSrcs(d)\n        }\n\n        this.#program = _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_0__.Program.new(`spending vesting\r\n/* \r\n Create a datum with the benefitiary PubKeyHash that will be included \r\n into each UTXO locked at this script address.\r\n*/\r\nstruct Datum {\r\n    benefitiary: PubKeyHash\r\n}\r\n\r\n/*\r\n The vesting contract can be either canceled by the benefitiary\r\n or claimed by the beneficiary\r\n */\r\nenum Redeemer {\r\n    Cancel\r\n    Claim\r\n}\r\n\r\nconst TOKEN_POLICY_ID: MintingPolicyHash = MintingPolicyHash::new(#e16c2dc8ae937e8d3790c7fd7168d7b994621ba14ca11415f39fed72)\r\n   \r\nconst HALVING_PERIOD: Int = 2592000  // 1 month in seconds\r\nconst MAX_HALVINGS: Int = 5\r\nconst BASE_REWARD: Int = 1000  // Initial reward in tokens\r\n\r\nfunc calculate_reward(current_time: Time) -> Int {\r\n    // Start contract at \r\n    TimeBeginContract: Time = Time::new(1733665500000);  \r\n\r\n    // Calculate time elapsed in seconds\r\n    time_elapsed: Duration = current_time - TimeBeginContract;\r\n    time_elapsed_in_seconds: Int = time_elapsed / Duration::new(1_000);  // Convert to seconds\r\n\r\n    // Calculate the number of halving periods (each period is 1 month)\r\n    halving_steps: Int = time_elapsed_in_seconds / HALVING_PERIOD;\r\n    print(current_time.show());\r\n    // Ensure the number of halvings doesn't exceed the maximum allowed\r\n    halving_steps = if (halving_steps > MAX_HALVINGS) { MAX_HALVINGS } else { halving_steps };\r\n    print(halving_steps.show());\r\n    // Calculate reward using simple multiplication and division\r\n    if (halving_steps == 0) {\r\n        BASE_REWARD\r\n    } else if (halving_steps == 1) {\r\n        BASE_REWARD / 2\r\n    } else if (halving_steps == 2) {\r\n        BASE_REWARD / 4\r\n    } else if (halving_steps == 3) {\r\n        BASE_REWARD / 8\r\n    } else if (halving_steps == 4) {\r\n        BASE_REWARD / 16\r\n    } else {\r\n        BASE_REWARD / 32\r\n    }\r\n\r\n}\r\n\r\nconst CLAIM_WINDOW: Int = 540 \r\nconst CYCLE_DURATION: Int = 540 \r\n\r\nfunc IsClaimWindow(current_time: Time) -> Bool {\r\n    // Start contract \r\n    TimeBeginContract: Time = Time::new(1733665500000);  \r\n\r\n     // Calculate the offset from the deployment start\r\n     elapsed_time: Duration = current_time - TimeBeginContract;\r\n     time_elapsed_in_seconds: Int = elapsed_time / Duration::new(1_000);  // Convert to seconds\r\n\r\n // Determine the position within the current cycle\r\n    position_in_cycle: Int = time_elapsed_in_seconds % CYCLE_DURATION;\r\n    in_claim_window: Bool = position_in_cycle <= CLAIM_WINDOW;\r\n    print(position_in_cycle.show());\r\n    in_claim_window\r\n}\r\n\r\n// Define the main validator function\r\nfunc main(datum: Datum, redeemer: Redeemer, ctx: ScriptContext) -> Bool {\r\n    tx: Tx = ctx.tx;\r\n\r\n        // AssetClass for the treasury tokens\r\n        asset_class: AssetClass = AssetClass::new(\r\n            TOKEN_POLICY_ID,  \r\n            \"MIN\".encode_utf8()\r\n        );\r\n\r\n       validator_hash: ValidatorHash = ctx.get_current_validator_hash();\r\n\r\n        // Get all outputs locked at the script address\r\n       script_outputs: []TxOutput = tx.outputs_locked_by(validator_hash);\r\n\r\n          total_tokens_begin: Int = tx.inputs.fold(\r\n            (sum: Int, input: TxInput) -> Int {\r\n              \r\n                sum + input.output.value.get_safe(asset_class)\r\n            },\r\n            0\r\n        );\r\n\r\n            // Sum up all tokens in these outputs\r\n            total_tokens_in_script: Int = script_outputs.fold(\r\n                (sum: Int, output: TxOutput) -> Int {\r\n                sum + output.value.get_safe(asset_class)\r\n                },\r\n               0 // Initial sum\r\n            );\r\n            \r\n        // Calculate total ADA in script inputs\r\n        total_ada_begin: Int = tx.inputs.fold((sum: Int, input: TxInput) -> Int {\r\n            if (input.output.address.credential.switch {\r\n                vh_credential: Validator => vh_credential.hash == validator_hash,\r\n                _ => false\r\n            }) {\r\n                sum + input.output.value.get_lovelace()\r\n            } else {\r\n                sum\r\n            }\r\n        }, 0);\r\n\r\n        // Calculate total ADA in script outputs\r\n        total_ada_in_script: Int = tx.outputs.fold((sum: Int, output: TxOutput) -> Int {\r\n            if (output.address.credential.switch {\r\n                vh_credential: Validator => vh_credential.hash == validator_hash,\r\n                _ => false\r\n            }) {\r\n                sum + output.value.get_lovelace()\r\n            } else {\r\n                sum\r\n            }\r\n        }, 0);\r\n\r\n    print(total_ada_begin.show());\r\n    print(total_ada_in_script.show());\r\n\r\n\r\n    current_time: Time = tx.time_range.start;  // Get current time as POSIXTime (seconds since Unix epoch)\r\n    // Calculate dynamic reward based on the remaining supply\r\n    dynamic_reward: Int = calculate_reward(current_time);\r\n\r\n    isClaimWindow: Bool = IsClaimWindow(current_time);\r\n\r\n     //expected_value: Value = Value::new(asset_class, EXPECTED_AMOUNT);\r\n    // Depending on the redeemer provided in the transaction, process accordingly.\r\n    redeemer.switch {\r\n        Cancel => {\r\n            // Tx must be signed by pkh in datum\r\n            tx.is_signed_by(datum.benefitiary) \r\n        },\r\n        Claim => {\r\n\r\n            // Determine how many tokens to give\r\n            tokens_to_give: Int = if (dynamic_reward > total_tokens_begin) { total_tokens_begin } else { dynamic_reward };\r\n            print(tokens_to_give.show());\r\n            print(dynamic_reward.show()); \r\n\r\n            assert(total_tokens_begin - tokens_to_give == total_tokens_in_script, \"Not enough tokens sent back to script\");\r\n\r\n              // Check that the user receives exactly tokens_to_give\r\n            assert(tx.value_sent_to(datum.benefitiary).get_safe(asset_class) == tokens_to_give, \"Incorrect token payout\");\r\n            assert(isClaimWindow == true, \"Not in claim window\");\r\n            \r\n             // Now handle ADA and script outputs logic\r\n             if (total_tokens_in_script == 0) {\r\n                // Final claim scenario: no tokens remain\r\n                // All ADA can be returned to the claimant, so no script outputs allowed\r\n                assert(script_outputs.length == 0, \"No script outputs should remain at final claim\");\r\n                // In this scenario, we don't need to enforce total_ada_in_script >= total_ada_begin,\r\n                // since all ADA should now be leaving the script and going to the claimant.\r\n                true\r\n            } else {\r\n                // Not final claim: tokens remain in the script\r\n                // Require at least 2 script outputs for concurrency (adjust as needed)\r\n                assert(script_outputs.length == 2, \"I need 2 outputs\");\r\n\r\n                // Ensure no ADA leaves the contract yet\r\n                assert(total_ada_in_script >= total_ada_begin, \"No ADA can leave the contract\");\r\n\r\n                true\r\n            }\r\n        }\r\n    }    \r\n}`, Array.from(depSrcs.values()))\n\n        if (Object.keys(parameters).length > 0) {\n            this.#program.parameters = parameters\n        }\n    }\n\n    get name() {\n        return this.#program.name\n    }\n\n    get paramTypes() {\n        return this.#program.paramTypes\n    }\n\n    get parameters() {\n        return this.#program.parameters\n    }\n\n    get types() {\n        return this.#program.types\n    }\n\n    set parameters(params) {\n        this.#program.parameters = params\n    }\n\n    compile(optimize = false) {\n        return this.#program.compile(optimize)\n    }\n\n    evalParam(paramName) {\n        return this.#program.evalParam(paramName)\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb250cmFjdHMvdmVzdGluZy5obCIsIm1hcHBpbmdzIjoiOzs7OztBQUE0QztBQUM1QztBQUNlO0FBQ2Y7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLHVEQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxlQUFlLE9BQU87QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUscUJBQXFCLE9BQU87QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb250cmFjdHMvdmVzdGluZy5obD9hYTQ5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGhlbGlvcyBmcm9tIFwiQGh5cGVyaW9uYnQvaGVsaW9zXCJcbi8vd3JhcHMgaGVsaW9zLlByb2dyYW1cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByb2dyYW0ge1xuICAgICNwcm9ncmFtXG5cbiAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcbiAgICAgICAgLy8gbG9hZCBhbGwgdGhlIGRlcGVuZGVuY2llc1xuICAgICAgICBjb25zdCBhbGxEZXBzID0gW11cblxuICAgICAgICBjb25zdCBkZXBTcmNzID0gbmV3IE1hcCgpXG5cbiAgICAgICAgZnVuY3Rpb24gYWRkRGVwU3JjcyhkZXApIHtcbiAgICAgICAgICAgIGRlcFNyY3Muc2V0KGRlcC5uYW1lLCBkZXAuc3JjKVxuXG4gICAgICAgICAgICBmb3IgKGxldCBkIG9mIGRlcC5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgICAgICBhZGREZXBTcmNzKGQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBkIG9mIGFsbERlcHMpIHtcbiAgICAgICAgICAgIGFkZERlcFNyY3MoZClcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuI3Byb2dyYW0gPSBoZWxpb3MuUHJvZ3JhbS5uZXcoYHNwZW5kaW5nIHZlc3RpbmdcclxuLyogXHJcbiBDcmVhdGUgYSBkYXR1bSB3aXRoIHRoZSBiZW5lZml0aWFyeSBQdWJLZXlIYXNoIHRoYXQgd2lsbCBiZSBpbmNsdWRlZCBcclxuIGludG8gZWFjaCBVVFhPIGxvY2tlZCBhdCB0aGlzIHNjcmlwdCBhZGRyZXNzLlxyXG4qL1xyXG5zdHJ1Y3QgRGF0dW0ge1xyXG4gICAgYmVuZWZpdGlhcnk6IFB1YktleUhhc2hcclxufVxyXG5cclxuLypcclxuIFRoZSB2ZXN0aW5nIGNvbnRyYWN0IGNhbiBiZSBlaXRoZXIgY2FuY2VsZWQgYnkgdGhlIGJlbmVmaXRpYXJ5XHJcbiBvciBjbGFpbWVkIGJ5IHRoZSBiZW5lZmljaWFyeVxyXG4gKi9cclxuZW51bSBSZWRlZW1lciB7XHJcbiAgICBDYW5jZWxcclxuICAgIENsYWltXHJcbn1cclxuXHJcbmNvbnN0IFRPS0VOX1BPTElDWV9JRDogTWludGluZ1BvbGljeUhhc2ggPSBNaW50aW5nUG9saWN5SGFzaDo6bmV3KCNlMTZjMmRjOGFlOTM3ZThkMzc5MGM3ZmQ3MTY4ZDdiOTk0NjIxYmExNGNhMTE0MTVmMzlmZWQ3MilcclxuICAgXHJcbmNvbnN0IEhBTFZJTkdfUEVSSU9EOiBJbnQgPSAyNTkyMDAwICAvLyAxIG1vbnRoIGluIHNlY29uZHNcclxuY29uc3QgTUFYX0hBTFZJTkdTOiBJbnQgPSA1XHJcbmNvbnN0IEJBU0VfUkVXQVJEOiBJbnQgPSAxMDAwICAvLyBJbml0aWFsIHJld2FyZCBpbiB0b2tlbnNcclxuXHJcbmZ1bmMgY2FsY3VsYXRlX3Jld2FyZChjdXJyZW50X3RpbWU6IFRpbWUpIC0+IEludCB7XHJcbiAgICAvLyBTdGFydCBjb250cmFjdCBhdCBcclxuICAgIFRpbWVCZWdpbkNvbnRyYWN0OiBUaW1lID0gVGltZTo6bmV3KDE3MzM2NjU1MDAwMDApOyAgXHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIHRpbWUgZWxhcHNlZCBpbiBzZWNvbmRzXHJcbiAgICB0aW1lX2VsYXBzZWQ6IER1cmF0aW9uID0gY3VycmVudF90aW1lIC0gVGltZUJlZ2luQ29udHJhY3Q7XHJcbiAgICB0aW1lX2VsYXBzZWRfaW5fc2Vjb25kczogSW50ID0gdGltZV9lbGFwc2VkIC8gRHVyYXRpb246Om5ldygxXzAwMCk7ICAvLyBDb252ZXJ0IHRvIHNlY29uZHNcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgdGhlIG51bWJlciBvZiBoYWx2aW5nIHBlcmlvZHMgKGVhY2ggcGVyaW9kIGlzIDEgbW9udGgpXHJcbiAgICBoYWx2aW5nX3N0ZXBzOiBJbnQgPSB0aW1lX2VsYXBzZWRfaW5fc2Vjb25kcyAvIEhBTFZJTkdfUEVSSU9EO1xyXG4gICAgcHJpbnQoY3VycmVudF90aW1lLnNob3coKSk7XHJcbiAgICAvLyBFbnN1cmUgdGhlIG51bWJlciBvZiBoYWx2aW5ncyBkb2Vzbid0IGV4Y2VlZCB0aGUgbWF4aW11bSBhbGxvd2VkXHJcbiAgICBoYWx2aW5nX3N0ZXBzID0gaWYgKGhhbHZpbmdfc3RlcHMgPiBNQVhfSEFMVklOR1MpIHsgTUFYX0hBTFZJTkdTIH0gZWxzZSB7IGhhbHZpbmdfc3RlcHMgfTtcclxuICAgIHByaW50KGhhbHZpbmdfc3RlcHMuc2hvdygpKTtcclxuICAgIC8vIENhbGN1bGF0ZSByZXdhcmQgdXNpbmcgc2ltcGxlIG11bHRpcGxpY2F0aW9uIGFuZCBkaXZpc2lvblxyXG4gICAgaWYgKGhhbHZpbmdfc3RlcHMgPT0gMCkge1xyXG4gICAgICAgIEJBU0VfUkVXQVJEXHJcbiAgICB9IGVsc2UgaWYgKGhhbHZpbmdfc3RlcHMgPT0gMSkge1xyXG4gICAgICAgIEJBU0VfUkVXQVJEIC8gMlxyXG4gICAgfSBlbHNlIGlmIChoYWx2aW5nX3N0ZXBzID09IDIpIHtcclxuICAgICAgICBCQVNFX1JFV0FSRCAvIDRcclxuICAgIH0gZWxzZSBpZiAoaGFsdmluZ19zdGVwcyA9PSAzKSB7XHJcbiAgICAgICAgQkFTRV9SRVdBUkQgLyA4XHJcbiAgICB9IGVsc2UgaWYgKGhhbHZpbmdfc3RlcHMgPT0gNCkge1xyXG4gICAgICAgIEJBU0VfUkVXQVJEIC8gMTZcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgQkFTRV9SRVdBUkQgLyAzMlxyXG4gICAgfVxyXG5cclxufVxyXG5cclxuY29uc3QgQ0xBSU1fV0lORE9XOiBJbnQgPSA1NDAgXHJcbmNvbnN0IENZQ0xFX0RVUkFUSU9OOiBJbnQgPSA1NDAgXHJcblxyXG5mdW5jIElzQ2xhaW1XaW5kb3coY3VycmVudF90aW1lOiBUaW1lKSAtPiBCb29sIHtcclxuICAgIC8vIFN0YXJ0IGNvbnRyYWN0IFxyXG4gICAgVGltZUJlZ2luQ29udHJhY3Q6IFRpbWUgPSBUaW1lOjpuZXcoMTczMzY2NTUwMDAwMCk7ICBcclxuXHJcbiAgICAgLy8gQ2FsY3VsYXRlIHRoZSBvZmZzZXQgZnJvbSB0aGUgZGVwbG95bWVudCBzdGFydFxyXG4gICAgIGVsYXBzZWRfdGltZTogRHVyYXRpb24gPSBjdXJyZW50X3RpbWUgLSBUaW1lQmVnaW5Db250cmFjdDtcclxuICAgICB0aW1lX2VsYXBzZWRfaW5fc2Vjb25kczogSW50ID0gZWxhcHNlZF90aW1lIC8gRHVyYXRpb246Om5ldygxXzAwMCk7ICAvLyBDb252ZXJ0IHRvIHNlY29uZHNcclxuXHJcbiAvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIHdpdGhpbiB0aGUgY3VycmVudCBjeWNsZVxyXG4gICAgcG9zaXRpb25faW5fY3ljbGU6IEludCA9IHRpbWVfZWxhcHNlZF9pbl9zZWNvbmRzICUgQ1lDTEVfRFVSQVRJT047XHJcbiAgICBpbl9jbGFpbV93aW5kb3c6IEJvb2wgPSBwb3NpdGlvbl9pbl9jeWNsZSA8PSBDTEFJTV9XSU5ET1c7XHJcbiAgICBwcmludChwb3NpdGlvbl9pbl9jeWNsZS5zaG93KCkpO1xyXG4gICAgaW5fY2xhaW1fd2luZG93XHJcbn1cclxuXHJcbi8vIERlZmluZSB0aGUgbWFpbiB2YWxpZGF0b3IgZnVuY3Rpb25cclxuZnVuYyBtYWluKGRhdHVtOiBEYXR1bSwgcmVkZWVtZXI6IFJlZGVlbWVyLCBjdHg6IFNjcmlwdENvbnRleHQpIC0+IEJvb2wge1xyXG4gICAgdHg6IFR4ID0gY3R4LnR4O1xyXG5cclxuICAgICAgICAvLyBBc3NldENsYXNzIGZvciB0aGUgdHJlYXN1cnkgdG9rZW5zXHJcbiAgICAgICAgYXNzZXRfY2xhc3M6IEFzc2V0Q2xhc3MgPSBBc3NldENsYXNzOjpuZXcoXHJcbiAgICAgICAgICAgIFRPS0VOX1BPTElDWV9JRCwgIFxyXG4gICAgICAgICAgICBcIk1JTlwiLmVuY29kZV91dGY4KClcclxuICAgICAgICApO1xyXG5cclxuICAgICAgIHZhbGlkYXRvcl9oYXNoOiBWYWxpZGF0b3JIYXNoID0gY3R4LmdldF9jdXJyZW50X3ZhbGlkYXRvcl9oYXNoKCk7XHJcblxyXG4gICAgICAgIC8vIEdldCBhbGwgb3V0cHV0cyBsb2NrZWQgYXQgdGhlIHNjcmlwdCBhZGRyZXNzXHJcbiAgICAgICBzY3JpcHRfb3V0cHV0czogW11UeE91dHB1dCA9IHR4Lm91dHB1dHNfbG9ja2VkX2J5KHZhbGlkYXRvcl9oYXNoKTtcclxuXHJcbiAgICAgICAgICB0b3RhbF90b2tlbnNfYmVnaW46IEludCA9IHR4LmlucHV0cy5mb2xkKFxyXG4gICAgICAgICAgICAoc3VtOiBJbnQsIGlucHV0OiBUeElucHV0KSAtPiBJbnQge1xyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgc3VtICsgaW5wdXQub3V0cHV0LnZhbHVlLmdldF9zYWZlKGFzc2V0X2NsYXNzKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAwXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFN1bSB1cCBhbGwgdG9rZW5zIGluIHRoZXNlIG91dHB1dHNcclxuICAgICAgICAgICAgdG90YWxfdG9rZW5zX2luX3NjcmlwdDogSW50ID0gc2NyaXB0X291dHB1dHMuZm9sZChcclxuICAgICAgICAgICAgICAgIChzdW06IEludCwgb3V0cHV0OiBUeE91dHB1dCkgLT4gSW50IHtcclxuICAgICAgICAgICAgICAgIHN1bSArIG91dHB1dC52YWx1ZS5nZXRfc2FmZShhc3NldF9jbGFzcylcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgIDAgLy8gSW5pdGlhbCBzdW1cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRvdGFsIEFEQSBpbiBzY3JpcHQgaW5wdXRzXHJcbiAgICAgICAgdG90YWxfYWRhX2JlZ2luOiBJbnQgPSB0eC5pbnB1dHMuZm9sZCgoc3VtOiBJbnQsIGlucHV0OiBUeElucHV0KSAtPiBJbnQge1xyXG4gICAgICAgICAgICBpZiAoaW5wdXQub3V0cHV0LmFkZHJlc3MuY3JlZGVudGlhbC5zd2l0Y2gge1xyXG4gICAgICAgICAgICAgICAgdmhfY3JlZGVudGlhbDogVmFsaWRhdG9yID0+IHZoX2NyZWRlbnRpYWwuaGFzaCA9PSB2YWxpZGF0b3JfaGFzaCxcclxuICAgICAgICAgICAgICAgIF8gPT4gZmFsc2VcclxuICAgICAgICAgICAgfSkge1xyXG4gICAgICAgICAgICAgICAgc3VtICsgaW5wdXQub3V0cHV0LnZhbHVlLmdldF9sb3ZlbGFjZSgpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzdW1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIDApO1xyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgdG90YWwgQURBIGluIHNjcmlwdCBvdXRwdXRzXHJcbiAgICAgICAgdG90YWxfYWRhX2luX3NjcmlwdDogSW50ID0gdHgub3V0cHV0cy5mb2xkKChzdW06IEludCwgb3V0cHV0OiBUeE91dHB1dCkgLT4gSW50IHtcclxuICAgICAgICAgICAgaWYgKG91dHB1dC5hZGRyZXNzLmNyZWRlbnRpYWwuc3dpdGNoIHtcclxuICAgICAgICAgICAgICAgIHZoX2NyZWRlbnRpYWw6IFZhbGlkYXRvciA9PiB2aF9jcmVkZW50aWFsLmhhc2ggPT0gdmFsaWRhdG9yX2hhc2gsXHJcbiAgICAgICAgICAgICAgICBfID0+IGZhbHNlXHJcbiAgICAgICAgICAgIH0pIHtcclxuICAgICAgICAgICAgICAgIHN1bSArIG91dHB1dC52YWx1ZS5nZXRfbG92ZWxhY2UoKVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3VtXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCAwKTtcclxuXHJcbiAgICBwcmludCh0b3RhbF9hZGFfYmVnaW4uc2hvdygpKTtcclxuICAgIHByaW50KHRvdGFsX2FkYV9pbl9zY3JpcHQuc2hvdygpKTtcclxuXHJcblxyXG4gICAgY3VycmVudF90aW1lOiBUaW1lID0gdHgudGltZV9yYW5nZS5zdGFydDsgIC8vIEdldCBjdXJyZW50IHRpbWUgYXMgUE9TSVhUaW1lIChzZWNvbmRzIHNpbmNlIFVuaXggZXBvY2gpXHJcbiAgICAvLyBDYWxjdWxhdGUgZHluYW1pYyByZXdhcmQgYmFzZWQgb24gdGhlIHJlbWFpbmluZyBzdXBwbHlcclxuICAgIGR5bmFtaWNfcmV3YXJkOiBJbnQgPSBjYWxjdWxhdGVfcmV3YXJkKGN1cnJlbnRfdGltZSk7XHJcblxyXG4gICAgaXNDbGFpbVdpbmRvdzogQm9vbCA9IElzQ2xhaW1XaW5kb3coY3VycmVudF90aW1lKTtcclxuXHJcbiAgICAgLy9leHBlY3RlZF92YWx1ZTogVmFsdWUgPSBWYWx1ZTo6bmV3KGFzc2V0X2NsYXNzLCBFWFBFQ1RFRF9BTU9VTlQpO1xyXG4gICAgLy8gRGVwZW5kaW5nIG9uIHRoZSByZWRlZW1lciBwcm92aWRlZCBpbiB0aGUgdHJhbnNhY3Rpb24sIHByb2Nlc3MgYWNjb3JkaW5nbHkuXHJcbiAgICByZWRlZW1lci5zd2l0Y2gge1xyXG4gICAgICAgIENhbmNlbCA9PiB7XHJcbiAgICAgICAgICAgIC8vIFR4IG11c3QgYmUgc2lnbmVkIGJ5IHBraCBpbiBkYXR1bVxyXG4gICAgICAgICAgICB0eC5pc19zaWduZWRfYnkoZGF0dW0uYmVuZWZpdGlhcnkpIFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgQ2xhaW0gPT4ge1xyXG5cclxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGhvdyBtYW55IHRva2VucyB0byBnaXZlXHJcbiAgICAgICAgICAgIHRva2Vuc190b19naXZlOiBJbnQgPSBpZiAoZHluYW1pY19yZXdhcmQgPiB0b3RhbF90b2tlbnNfYmVnaW4pIHsgdG90YWxfdG9rZW5zX2JlZ2luIH0gZWxzZSB7IGR5bmFtaWNfcmV3YXJkIH07XHJcbiAgICAgICAgICAgIHByaW50KHRva2Vuc190b19naXZlLnNob3coKSk7XHJcbiAgICAgICAgICAgIHByaW50KGR5bmFtaWNfcmV3YXJkLnNob3coKSk7IFxyXG5cclxuICAgICAgICAgICAgYXNzZXJ0KHRvdGFsX3Rva2Vuc19iZWdpbiAtIHRva2Vuc190b19naXZlID09IHRvdGFsX3Rva2Vuc19pbl9zY3JpcHQsIFwiTm90IGVub3VnaCB0b2tlbnMgc2VudCBiYWNrIHRvIHNjcmlwdFwiKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgdXNlciByZWNlaXZlcyBleGFjdGx5IHRva2Vuc190b19naXZlXHJcbiAgICAgICAgICAgIGFzc2VydCh0eC52YWx1ZV9zZW50X3RvKGRhdHVtLmJlbmVmaXRpYXJ5KS5nZXRfc2FmZShhc3NldF9jbGFzcykgPT0gdG9rZW5zX3RvX2dpdmUsIFwiSW5jb3JyZWN0IHRva2VuIHBheW91dFwiKTtcclxuICAgICAgICAgICAgYXNzZXJ0KGlzQ2xhaW1XaW5kb3cgPT0gdHJ1ZSwgXCJOb3QgaW4gY2xhaW0gd2luZG93XCIpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgIC8vIE5vdyBoYW5kbGUgQURBIGFuZCBzY3JpcHQgb3V0cHV0cyBsb2dpY1xyXG4gICAgICAgICAgICAgaWYgKHRvdGFsX3Rva2Vuc19pbl9zY3JpcHQgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gRmluYWwgY2xhaW0gc2NlbmFyaW86IG5vIHRva2VucyByZW1haW5cclxuICAgICAgICAgICAgICAgIC8vIEFsbCBBREEgY2FuIGJlIHJldHVybmVkIHRvIHRoZSBjbGFpbWFudCwgc28gbm8gc2NyaXB0IG91dHB1dHMgYWxsb3dlZFxyXG4gICAgICAgICAgICAgICAgYXNzZXJ0KHNjcmlwdF9vdXRwdXRzLmxlbmd0aCA9PSAwLCBcIk5vIHNjcmlwdCBvdXRwdXRzIHNob3VsZCByZW1haW4gYXQgZmluYWwgY2xhaW1cIik7XHJcbiAgICAgICAgICAgICAgICAvLyBJbiB0aGlzIHNjZW5hcmlvLCB3ZSBkb24ndCBuZWVkIHRvIGVuZm9yY2UgdG90YWxfYWRhX2luX3NjcmlwdCA+PSB0b3RhbF9hZGFfYmVnaW4sXHJcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSBhbGwgQURBIHNob3VsZCBub3cgYmUgbGVhdmluZyB0aGUgc2NyaXB0IGFuZCBnb2luZyB0byB0aGUgY2xhaW1hbnQuXHJcbiAgICAgICAgICAgICAgICB0cnVlXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOb3QgZmluYWwgY2xhaW06IHRva2VucyByZW1haW4gaW4gdGhlIHNjcmlwdFxyXG4gICAgICAgICAgICAgICAgLy8gUmVxdWlyZSBhdCBsZWFzdCAyIHNjcmlwdCBvdXRwdXRzIGZvciBjb25jdXJyZW5jeSAoYWRqdXN0IGFzIG5lZWRlZClcclxuICAgICAgICAgICAgICAgIGFzc2VydChzY3JpcHRfb3V0cHV0cy5sZW5ndGggPT0gMiwgXCJJIG5lZWQgMiBvdXRwdXRzXCIpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBubyBBREEgbGVhdmVzIHRoZSBjb250cmFjdCB5ZXRcclxuICAgICAgICAgICAgICAgIGFzc2VydCh0b3RhbF9hZGFfaW5fc2NyaXB0ID49IHRvdGFsX2FkYV9iZWdpbiwgXCJObyBBREEgY2FuIGxlYXZlIHRoZSBjb250cmFjdFwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9ICAgIFxyXG59YCwgQXJyYXkuZnJvbShkZXBTcmNzLnZhbHVlcygpKSlcblxuICAgICAgICBpZiAoT2JqZWN0LmtleXMocGFyYW1ldGVycykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy4jcHJvZ3JhbS5wYXJhbWV0ZXJzID0gcGFyYW1ldGVyc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNwcm9ncmFtLm5hbWVcbiAgICB9XG5cbiAgICBnZXQgcGFyYW1UeXBlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3Byb2dyYW0ucGFyYW1UeXBlc1xuICAgIH1cblxuICAgIGdldCBwYXJhbWV0ZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcHJvZ3JhbS5wYXJhbWV0ZXJzXG4gICAgfVxuXG4gICAgZ2V0IHR5cGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcHJvZ3JhbS50eXBlc1xuICAgIH1cblxuICAgIHNldCBwYXJhbWV0ZXJzKHBhcmFtcykge1xuICAgICAgICB0aGlzLiNwcm9ncmFtLnBhcmFtZXRlcnMgPSBwYXJhbXNcbiAgICB9XG5cbiAgICBjb21waWxlKG9wdGltaXplID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3Byb2dyYW0uY29tcGlsZShvcHRpbWl6ZSlcbiAgICB9XG5cbiAgICBldmFsUGFyYW0ocGFyYW1OYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNwcm9ncmFtLmV2YWxQYXJhbShwYXJhbU5hbWUpXG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./contracts/vesting.hl\n"));

/***/ })

});