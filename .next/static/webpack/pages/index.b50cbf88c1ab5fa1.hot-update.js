"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./public/walletActions.ts":
/*!*********************************!*\
  !*** ./public/walletActions.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateCountdown: function() { return /* binding */ calculateCountdown; },\n/* harmony export */   claimTokens: function() { return /* binding */ claimTokens; },\n/* harmony export */   send: function() { return /* binding */ send; }\n/* harmony export */ });\n/* harmony import */ var _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @hyperionbt/helios */ \"./node_modules/@hyperionbt/helios/helios.js\");\n/* harmony import */ var _common_network__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/network */ \"./common/network.ts\");\n/* harmony import */ var _contracts_GameReward_hl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../contracts/GameReward.hl */ \"./contracts/GameReward.hl\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\n\n // Ensure correct path to your contract\nconst optimize = false;\nfunction pickUtxos(utxos, targetAmount, assetClass) {\n    const selected = [];\n    let totalAmount = 0n;\n    // Keep track of the indices we've already picked\n    const usedIndices = new Set();\n    while(totalAmount < targetAmount){\n        // Generate a random index within the bounds of the UTXOs array\n        const randomIndex = Math.floor(Math.random() * utxos.length);\n        // If we've already selected this index, skip it\n        if (usedIndices.has(randomIndex)) {\n            continue;\n        }\n        // Mark the index as used\n        usedIndices.add(randomIndex);\n        // Add the UTXO to the selected list\n        const selectedUtxo = utxos[randomIndex];\n        selected.push(selectedUtxo);\n        const tokens = selectedUtxo.value.assets.getTokens(assetClass.mintingPolicyHash);\n        tokens.forEach((param)=>{\n            let [tokenName, amount] = param;\n            totalAmount += BigInt(amount.value); // Add the amount to the total\n        });\n    }\n    return {\n        selected,\n        totalAmount\n    };\n}\n// Calculate the reward based on the time elapsed since contract deployment\nfunction calculateRewardInTime() {\n    const TimeBeginContract = Math.floor(new Date(Date.UTC(2024, 11, 25, 13, 45, 0)).getTime()) / 1000;\n    console.log(\"TimeBeginContract\" + TimeBeginContract);\n    const HALVING_PERIOD = 7776000; // 3 months in seconds \n    const MAX_HALVINGS = 2; // Limit halvings to 2 times\n    const BASE_REWARD = 10000; // Initial reward in tokens\n    // Get current time in seconds\n    const TimeNow = Math.floor(Date.now() / 1000);\n    // Calculate the elapsed time in seconds\n    const timeElapsed = TimeNow - TimeBeginContract;\n    // Determine halving steps based on elapsed time, but limit to MAX_HALVINGS\n    let halvingSteps = Math.floor(timeElapsed / HALVING_PERIOD);\n    halvingSteps = Math.min(halvingSteps, MAX_HALVINGS); // Cap halvings at MAX_HALVINGS\n    // Ensure the number of halving steps doesn't exceed the maximum allowed\n    const effectiveHalvings = Math.min(halvingSteps, MAX_HALVINGS);\n    console.log(\"Halvings\" + effectiveHalvings);\n    // Directly calculate reward based on halving steps using a bit shift\n    const reward = BASE_REWARD / 2 ** effectiveHalvings;\n    // Return the reward, ensuring it doesn't fall below a minimum value\n    return reward < 1 ? 1 : reward;\n}\nfunction calculateCountdown() {\n    const TimeBeginContract = Math.floor(new Date(Date.UTC(2024, 11, 25, 13, 45, 0)).getTime());\n    const TimeNow = Math.floor(Date.now());\n    const CYCLE_DURATION = 600 // 10 minutes \n    ;\n    const offsetInMs = 89680;\n    const elapsedTime = TimeNow - offsetInMs - TimeBeginContract;\n    const elapsedTimeInSeconds = elapsedTime / 1000;\n    const positionInCycle = elapsedTimeInSeconds % CYCLE_DURATION;\n    return positionInCycle;\n}\nasync function claimTokens(walletAPI, setIsLoading, setTx) {\n    setIsLoading(true);\n    if (!walletAPI) {\n        throw new Error(\"Wallet API is not set.\");\n    }\n    try {\n        const cip30WalletAPI = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Cip30Wallet(walletAPI);\n        const walletHelper = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.WalletHelper(cip30WalletAPI);\n        // Read in the network parameter file\n        const networkParamsJson = await (0,_common_network__WEBPACK_IMPORTED_MODULE_0__.getNetworkParams)(_common_network__WEBPACK_IMPORTED_MODULE_0__.network);\n        const networkParams = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.NetworkParams(networkParamsJson);\n        const policyId = \"e16c2dc8ae937e8d3790c7fd7168d7b994621ba14ca11415f39fed72\";\n        const name = Buffer.from(\"MIN\", \"utf8\").toString(\"hex\");\n        // const policyId = \"\";\n        // const name = Buffer.from(\"\", 'utf8').toString('hex');\n        const mph = _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.MintingPolicyHash.fromHex(policyId);\n        const assetClass = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.AssetClass({\n            mph: mph,\n            tokenName: name // Convert to hex string\n        });\n        console.log(assetClass);\n        // const tokenAmount = BigInt(3000000);\n        // const tokenVal = new Value(tokenAmount);\n        const utxos = await walletHelper.getUtxos();\n        console.log(\"utxos\" + utxos);\n        // Get change address\n        const benefitiary = await walletHelper.changeAddress;\n        // Load in the vesting validator script (program)\n        const gameReward = new _contracts_GameReward_hl__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n        // Compile the vesting validator\n        const compiledProgram = gameReward.compile(optimize);\n        console.log(\"Wallet address: \" + benefitiary);\n        const scriptAddress = _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Address.fromHashes(compiledProgram.validatorHash);\n        console.log(scriptAddress.toBech32());\n        console.log(\"Script Address:\" + scriptAddress);\n        console.dir(scriptAddress, {\n            depth: null\n        });\n        const filteredUtxos = await fetchUtxos(scriptAddress.toBech32());\n        if (filteredUtxos.length == 0) throw new Error(\"No more tokens to claim. Game Over!\");\n        // const TOTAL_SUPPLY = 10000; // Total token supply\n        const CLAIM_WINDOW = 20; // 20 seconds \n        console.log(\"filteredUtxos\" + filteredUtxos);\n        //const remainingSupply = getTokenAmountFromUtxos(filteredUtxos, assetClass);\n        const dynamicReward = calculateRewardInTime();\n        const positionInCycle = calculateCountdown();\n        console.log(\"positionInCycle\" + positionInCycle);\n        window.onerror = ()=>positionInCycle < CLAIM_WINDOW;\n        //const dynamicReward = calculateReward(Number(remainingSupply), TOTAL_SUPPLY, BASE_REWARD);\n        const testValueBenefitiary = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Assets([\n            [\n                assetClass,\n                BigInt(dynamicReward)\n            ]\n        ]);\n        //const result = pickRandomTxInputWithSufficientValue(filteredUtxos, BigInt(dynamicReward), assetClass);\n        //console.log(\"randomUTXO:\" + result.txInput)\n        //const amountToSendBack = result.tokenAmount - BigInt(dynamicReward);\n        // console.log(\"amountToSendBack\" + amountToSendBack)\n        // console.log(\"UtxoAmount\" + result.tokenAmount)\n        // console.log(\"The rest\" + result.remainingUtxos)\n        //console.log(filteredUtxos)\n        // const remoteWallet = new RemoteWallet(false, [scriptAddress], [], txInputs);\n        // const walletHelperScript = new WalletHelper(remoteWallet);\n        const sortedUtxos = pickUtxos(filteredUtxos, BigInt(dynamicReward), assetClass);\n        sortedUtxos.selected.forEach((element)=>{\n            console.dir(\"selected utxo\" + element);\n        });\n        sortedUtxos.selected.forEach((element)=>{\n            console.dir(\"selected utxo Id\" + element.outputId);\n        });\n        //const totalAmountUtxo = getTokenAmountFromUtxos(sortedUtxos.selected, assetClass);\n        const amountToSendBack = BigInt(sortedUtxos.totalAmount) - BigInt(dynamicReward);\n        const firstPartToSendBack = amountToSendBack / 2n; // First part is half of the total amount\n        const secondPartToSendBack = amountToSendBack - firstPartToSendBack; // Second part is the remainder\n        console.log(\"First \" + firstPartToSendBack);\n        console.log(\"Sevond \" + secondPartToSendBack);\n        console.log(dynamicReward);\n        const valueContract1 = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Assets([\n            [\n                assetClass,\n                firstPartToSendBack\n            ]\n        ]);\n        const valueContract2 = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Assets([\n            [\n                assetClass,\n                secondPartToSendBack\n            ]\n        ]);\n        const gameDatum = new gameReward.types.Datum(benefitiary.pubKeyHash);\n        // Create the vesting claim redeemer\n        const redeember = new gameReward.types.Redeemer.Claim(benefitiary.pubKeyHash)._toUplcData();\n        //console.log(filteredUtxos);\n        const tx = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Tx();\n        //tx.addInputs(utxos[0]);\n        tx.addInputs(sortedUtxos.selected, redeember);\n        tx.attachScript(compiledProgram);\n        var userClaimOutput = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.TxOutput(benefitiary, new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Value(undefined, testValueBenefitiary));\n        tx.addOutput(userClaimOutput);\n        //Shiiit, fix. Someone could rediredt the rest of the tokens\n        // const addressStr = \"addr_test1qrarqhmklnhwcw3q0zm6sgm3g3l7pua0y36sql9k5ru8dsucglsked5f5yrcf9e9xgxjgmt7xk52knh8h0dgayc00arqlh7g60\";\n        // const address = Address.fromBech32(addressStr);\n        // tx.addOutput(new TxOutput(\n        //   address,\n        //   new Value(undefined, testValueContract) // The amount being claimed\n        // ));\n        // Calculate total ADA in the selected script inputs\n        let totalAdaInInputs = BigInt(0);\n        sortedUtxos.selected.forEach((utxo)=>{\n            totalAdaInInputs += BigInt(utxo.output.value.lovelace);\n        });\n        // Distribute ADA equally (or as required) among script outputs\n        const adaPerScriptOutput = totalAdaInInputs / 2n; // Assuming two script outputs\n        if (amountToSendBack != BigInt(0)) {\n            var scriptUtxo1 = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.TxOutput(scriptAddress, new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Value(adaPerScriptOutput, valueContract1), _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Datum.inline(gameDatum) // Contract requires datum\n            );\n            tx.addOutput(scriptUtxo1);\n            var scriptUtxo2 = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.TxOutput(scriptAddress, new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Value(totalAdaInInputs - adaPerScriptOutput, valueContract2), _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Datum.inline(gameDatum) // Contract requires datum\n            );\n            tx.addOutput(scriptUtxo2);\n        }\n        //var inputFees = await walletHelper.pickUtxos(new Value(tokenAmountFees));\n        //tx.addInputs(inputFees[0]);\n        console.log(\"We attatched everything!\");\n        await tx.finalize(networkParams, benefitiary, utxos);\n        console.log(\"dali finalizirahme?\");\n        // Sign the unsigned tx to get the witness\n        const signatures = await cip30WalletAPI.signTx(tx);\n        tx.addSignatures(signatures);\n        console.log(\"Dali q signirahme?\");\n        const txHash = await cip30WalletAPI.submitTx(tx);\n        setTx({\n            txId: txHash.hex\n        });\n        setIsLoading(false);\n    } catch (err) {\n        setIsLoading(false);\n        console.error(\"submit tx failed\", err);\n        throw err;\n    }\n}\nasync function send(walletAPI, setIsLoading, setTx) {\n    setIsLoading(true);\n    if (!walletAPI) {\n        throw console.error(\"walletAPI is not set\");\n    }\n    try {\n        const cip30WalletAPI = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Cip30Wallet(walletAPI);\n        // const blockfrost = new BlockFrostIPFS({\n        //   network: network,\n        //   projectId: \"preprodJExO0MAMRgfpXz9Il4IqB2u9ddoylZBT\",\n        // });\n        console.log(\"gmmm\");\n        const walletHelper = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.WalletHelper(cip30WalletAPI);\n        const policyId = \"e16c2dc8ae937e8d3790c7fd7168d7b994621ba14ca11415f39fed72\";\n        const name = Buffer.from(\"MIN\", \"utf8\").toString(\"hex\");\n        // const policyId = \"\";\n        // const name = Buffer.from(\"\", 'utf8').toString('hex');\n        const mph = _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.MintingPolicyHash.fromHex(policyId);\n        const assetClass = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.AssetClass({\n            mph: mph,\n            tokenName: name // Convert to hex string\n        });\n        console.log(assetClass);\n        const minAda = 1000000; // minimum lovelace to send\n        const minAdaVal = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Value(BigInt(minAda));\n        //  const benefitiaryValue = new Value(BigInt(10000), new Assets([\n        //   [mph, [[name, BigInt(10000)]]]\n        // ]))\n        const testValueScript = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Assets([\n            [\n                assetClass,\n                BigInt(125550)\n            ]\n        ]);\n        // Get wallet UTXOs\n        const utxos = await walletHelper.pickUtxos(new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Value(undefined, testValueScript));\n        console.log(utxos);\n        // Get change address\n        const benefitiary = await walletHelper.changeAddress;\n        // Load in the vesting validator script (program)\n        const gameReward = new _contracts_GameReward_hl__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n        // Compile the vesting validator\n        const compiledProgram = gameReward.compile(optimize);\n        console.log(\"Wallet address: \" + benefitiary);\n        const scriptAddress = _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Address.fromHashes(compiledProgram.validatorHash);\n        //remove\n        console.log(scriptAddress.toBech32());\n        console.log(\"Script Address:\" + scriptAddress);\n        // Construct the vesting datum\n        const gameDatum = new gameReward.types.Datum(benefitiary.pubKeyHash);\n        //const redeember = (new gameReward.types.Redeemer.Claim())._toUplcData();\n        const tx = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Tx();\n        tx.addInputs(utxos[0]);\n        tx.addOutput(new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.TxOutput(scriptAddress, new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Value(undefined, testValueScript), _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.Datum.inline(gameDatum)));\n        // tx.addOutput(new TxOutput(\n        //   benefitiary,\n        //   minAdaVal,\n        // ));\n        console.log(\"We attatched everything!\");\n        // Read in the network parameter file\n        const networkParamsJson = await (0,_common_network__WEBPACK_IMPORTED_MODULE_0__.getNetworkParams)(_common_network__WEBPACK_IMPORTED_MODULE_0__.network);\n        const networkParams = new _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.NetworkParams(networkParamsJson);\n        // Send any change back to the buyer\n        await tx.finalize(networkParams, benefitiary, utxos[1]);\n        // Sign the unsigned tx to get the witness\n        const signatures = await cip30WalletAPI.signTx(tx);\n        tx.addSignatures(signatures);\n        console.log(\"signed\");\n        // Submit the signed tx\n        const txHash = await cip30WalletAPI.submitTx(tx);\n        setTx({\n            txId: txHash.hex\n        });\n        setIsLoading(false);\n    } catch (err) {\n        setIsLoading(false);\n        throw console.error(\"submit tx failed\", err);\n    }\n}\nasync function fetchUtxos(scriptAddress, targetAmount) {\n    const response = await fetch(\"http://192.168.1.101:3001/api/getUtxos\", {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n            scriptAddress,\n            targetAmount: targetAmount.toString()\n        })\n    });\n    const data = await response.json(); // Raw JSON array from backend\n    // `Convert JSON back to TxInput objects\n    const filteredUtxos = data.selected.map((utxo)=>_hyperionbt_helios__WEBPACK_IMPORTED_MODULE_2__.TxInput.fromFullCbor(utxo));\n    const totalAmount = BigInt(data.totalAmount);\n    return filteredUtxos;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TTZILFdBQVcsTUFBTUMsTUFBTywwQ0FBeUM7UUFDckVDLFFBQVE7UUFDUkMsU0FBUztZQUFFLGdCQUFnQjtRQUFtQjtRQUM5Q0MsTUFBTUMsS0FBS0MsU0FBUyxDQUFDO1lBQUU5RDtZQUFnQnJFLGNBQWNBLGFBQWE0RCxRQUFRO1FBQUU7SUFDOUU7SUFFQSxNQUFNd0UsT0FBTyxNQUFNUCxTQUFTUSxJQUFJLElBQUksOEJBQThCO0lBRWxFLHdDQUF3QztJQUN4QyxNQUFNMUQsZ0JBQWdCeUQsS0FBS2xJLFFBQVEsQ0FBQ29JLEdBQUcsQ0FBQyxDQUFDOUIsT0FBY3RILHVEQUFPQSxDQUFDcUosWUFBWSxDQUFDL0I7SUFDNUUsTUFBTXJHLGNBQXNCb0IsT0FBTzZHLEtBQUtqSSxXQUFXO0lBRW5ELE9BQU93RTtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3B1YmxpYy93YWxsZXRBY3Rpb25zLnRzPzViMDgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgXHJcbiAgICBOZXR3b3JrUGFyYW1zLFxyXG4gICAgVmFsdWUsXHJcbiAgICBUeE91dHB1dCxcclxuICAgIFR4LFxyXG4gICAgVHhJbnB1dCxcclxuICAgIENpcDMwV2FsbGV0LFxyXG4gICAgRGF0dW0sXHJcbiAgICBBc3NldHMsXHJcbiAgICBXYWxsZXRIZWxwZXIsXHJcbiAgICBNaW50aW5nUG9saWN5SGFzaCxcclxuICAgIEFzc2V0Q2xhc3MsXHJcbiAgICBBZGRyZXNzLFxyXG4gIH0gZnJvbSBcIkBoeXBlcmlvbmJ0L2hlbGlvc1wiO1xyXG4gIGltcG9ydCB7IG5ldHdvcmssIGdldE5ldHdvcmtQYXJhbXMgfSBmcm9tICcuLi9jb21tb24vbmV0d29yayc7XHJcbiAgaW1wb3J0IEdhbWVSZXdhcmQgZnJvbSAnLi4vY29udHJhY3RzL0dhbWVSZXdhcmQuaGwnOyAvLyBFbnN1cmUgY29ycmVjdCBwYXRoIHRvIHlvdXIgY29udHJhY3RcclxuICBcclxuICBjb25zdCBvcHRpbWl6ZSA9IGZhbHNlO1xyXG4gIFxyXG4gIGZ1bmN0aW9uIHBpY2tVdHhvcyh1dHhvczogVHhJbnB1dFtdLCB0YXJnZXRBbW91bnQ6IGJpZ2ludCwgYXNzZXRDbGFzczogQXNzZXRDbGFzcyk6IHsgc2VsZWN0ZWQ6IFR4SW5wdXRbXTsgdG90YWxBbW91bnQ6IGJpZ2ludCB9IHtcclxuICAgIGNvbnN0IHNlbGVjdGVkOiBUeElucHV0W10gPSBbXTtcclxuICAgIGxldCB0b3RhbEFtb3VudDogYmlnaW50ID0gMG47XHJcbiAgXHJcbiAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBpbmRpY2VzIHdlJ3ZlIGFscmVhZHkgcGlja2VkXHJcbiAgICBjb25zdCB1c2VkSW5kaWNlcyA9IG5ldyBTZXQ8bnVtYmVyPigpO1xyXG4gIFxyXG4gICAgd2hpbGUgKHRvdGFsQW1vdW50IDwgdGFyZ2V0QW1vdW50KSB7XHJcbiAgICAgICAgLy8gR2VuZXJhdGUgYSByYW5kb20gaW5kZXggd2l0aGluIHRoZSBib3VuZHMgb2YgdGhlIFVUWE9zIGFycmF5XHJcbiAgICAgICAgY29uc3QgcmFuZG9tSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB1dHhvcy5sZW5ndGgpO1xyXG4gIFxyXG4gICAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgc2VsZWN0ZWQgdGhpcyBpbmRleCwgc2tpcCBpdFxyXG4gICAgICAgIGlmICh1c2VkSW5kaWNlcy5oYXMocmFuZG9tSW5kZXgpKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICBcclxuICAgICAgICAvLyBNYXJrIHRoZSBpbmRleCBhcyB1c2VkXHJcbiAgICAgICAgdXNlZEluZGljZXMuYWRkKHJhbmRvbUluZGV4KTtcclxuICBcclxuICAgICAgICAvLyBBZGQgdGhlIFVUWE8gdG8gdGhlIHNlbGVjdGVkIGxpc3RcclxuICAgICAgICBjb25zdCBzZWxlY3RlZFV0eG8gPSB1dHhvc1tyYW5kb21JbmRleF07XHJcbiAgICAgICAgc2VsZWN0ZWQucHVzaChzZWxlY3RlZFV0eG8pO1xyXG4gICAgICAgIGNvbnN0IHRva2VucyA9IHNlbGVjdGVkVXR4by52YWx1ZS5hc3NldHMuZ2V0VG9rZW5zKGFzc2V0Q2xhc3MubWludGluZ1BvbGljeUhhc2gpO1xyXG4gICAgICAgIHRva2Vucy5mb3JFYWNoKChbdG9rZW5OYW1lLCBhbW91bnRdKSA9PiB7XHJcbiAgICAgICAgICB0b3RhbEFtb3VudCArPSBCaWdJbnQoYW1vdW50LnZhbHVlKTsgLy8gQWRkIHRoZSBhbW91bnQgdG8gdGhlIHRvdGFsXHJcbiAgICAgICAgICB9KTtcclxuICAgIH1cclxuICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc2VsZWN0ZWQsXHJcbiAgICAgICAgdG90YWxBbW91bnQsXHJcbiAgICB9O1xyXG4gIH1cclxuICBcclxuICAvLyBDYWxjdWxhdGUgdGhlIHJld2FyZCBiYXNlZCBvbiB0aGUgdGltZSBlbGFwc2VkIHNpbmNlIGNvbnRyYWN0IGRlcGxveW1lbnRcclxuICBmdW5jdGlvbiBjYWxjdWxhdGVSZXdhcmRJblRpbWUoKTogbnVtYmVyIHtcclxuICAgIGNvbnN0IFRpbWVCZWdpbkNvbnRyYWN0ID0gTWF0aC5mbG9vcihuZXcgRGF0ZShEYXRlLlVUQygyMDI0LCAxMSwgMjUsIDEzLCA0NSwgMCkpLmdldFRpbWUoKSkgLyAxMDAwO1xyXG4gICAgY29uc29sZS5sb2coXCJUaW1lQmVnaW5Db250cmFjdFwiICsgVGltZUJlZ2luQ29udHJhY3QpXHJcblxyXG4gICAgY29uc3QgSEFMVklOR19QRVJJT0Q6IG51bWJlciA9IDc3NzYwMDA7IC8vIDMgbW9udGhzIGluIHNlY29uZHMgXHJcbiAgICBjb25zdCBNQVhfSEFMVklOR1M6IG51bWJlciA9IDI7IC8vIExpbWl0IGhhbHZpbmdzIHRvIDIgdGltZXNcclxuICAgIGNvbnN0IEJBU0VfUkVXQVJEOiBudW1iZXIgPSAxMDAwMDsgLy8gSW5pdGlhbCByZXdhcmQgaW4gdG9rZW5zXHJcbiAgXHJcbiAgICAvLyBHZXQgY3VycmVudCB0aW1lIGluIHNlY29uZHNcclxuICAgIGNvbnN0IFRpbWVOb3c6IG51bWJlciA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApOyBcclxuICBcclxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZWxhcHNlZCB0aW1lIGluIHNlY29uZHNcclxuICAgIGNvbnN0IHRpbWVFbGFwc2VkOiBudW1iZXIgPSBUaW1lTm93IC0gVGltZUJlZ2luQ29udHJhY3Q7XHJcbiAgICAvLyBEZXRlcm1pbmUgaGFsdmluZyBzdGVwcyBiYXNlZCBvbiBlbGFwc2VkIHRpbWUsIGJ1dCBsaW1pdCB0byBNQVhfSEFMVklOR1NcclxuICAgIGxldCBoYWx2aW5nU3RlcHM6IG51bWJlciA9IE1hdGguZmxvb3IodGltZUVsYXBzZWQgLyBIQUxWSU5HX1BFUklPRCk7XHJcbiAgICBoYWx2aW5nU3RlcHMgPSBNYXRoLm1pbihoYWx2aW5nU3RlcHMsIE1BWF9IQUxWSU5HUyk7IC8vIENhcCBoYWx2aW5ncyBhdCBNQVhfSEFMVklOR1NcclxuICBcclxuICAgICAvLyBFbnN1cmUgdGhlIG51bWJlciBvZiBoYWx2aW5nIHN0ZXBzIGRvZXNuJ3QgZXhjZWVkIHRoZSBtYXhpbXVtIGFsbG93ZWRcclxuICAgICBjb25zdCBlZmZlY3RpdmVIYWx2aW5nczogbnVtYmVyID0gTWF0aC5taW4oaGFsdmluZ1N0ZXBzLCBNQVhfSEFMVklOR1MpO1xyXG4gICAgY29uc29sZS5sb2coXCJIYWx2aW5nc1wiICsgZWZmZWN0aXZlSGFsdmluZ3MpXHJcbiAgICAgLy8gRGlyZWN0bHkgY2FsY3VsYXRlIHJld2FyZCBiYXNlZCBvbiBoYWx2aW5nIHN0ZXBzIHVzaW5nIGEgYml0IHNoaWZ0XHJcbiAgICAgY29uc3QgcmV3YXJkOiBudW1iZXIgPSBCQVNFX1JFV0FSRCAvICgyICoqIGVmZmVjdGl2ZUhhbHZpbmdzKTtcclxuICAgXHJcbiAgICAgLy8gUmV0dXJuIHRoZSByZXdhcmQsIGVuc3VyaW5nIGl0IGRvZXNuJ3QgZmFsbCBiZWxvdyBhIG1pbmltdW0gdmFsdWVcclxuICAgICByZXR1cm4gcmV3YXJkIDwgMSA/IDEgOiByZXdhcmQ7XHJcbiAgfVxyXG4gIFxyXG4gIGV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVDb3VudGRvd24oKTogbnVtYmVyIHtcclxuICBcclxuICAgIGNvbnN0IFRpbWVCZWdpbkNvbnRyYWN0ID0gTWF0aC5mbG9vcihuZXcgRGF0ZShEYXRlLlVUQygyMDI0LCAxMSwgMjUsIDEzLCA0NSwgMCkpLmdldFRpbWUoKSk7XHJcblxyXG4gICAgY29uc3QgVGltZU5vdzogbnVtYmVyID0gTWF0aC5mbG9vcihEYXRlLm5vdygpKTsgXHJcbiAgICBjb25zdCBDWUNMRV9EVVJBVElPTiA9IDYwMCAvLyAxMCBtaW51dGVzIFxyXG4gICAgY29uc3Qgb2Zmc2V0SW5NcyA9IDg5NjgwO1xyXG4gICAgY29uc3QgZWxhcHNlZFRpbWUgPSBUaW1lTm93IC0gKG9mZnNldEluTXMpIC0gVGltZUJlZ2luQ29udHJhY3Q7XHJcbiAgICBjb25zdCBlbGFwc2VkVGltZUluU2Vjb25kcyA9IGVsYXBzZWRUaW1lIC8gMTAwMDtcclxuICAgIGNvbnN0IHBvc2l0aW9uSW5DeWNsZSA9IGVsYXBzZWRUaW1lSW5TZWNvbmRzICUgQ1lDTEVfRFVSQVRJT047XHJcbiAgXHJcbiAgICByZXR1cm4gcG9zaXRpb25JbkN5Y2xlO1xyXG4gIH0gXHJcbiAgXHJcbiAgZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNsYWltVG9rZW5zKHdhbGxldEFQSTogYW55LCBzZXRJc0xvYWRpbmc6ICh2YWw6IGJvb2xlYW4pID0+IHZvaWQsIHNldFR4OiAodmFsOiB7dHhJZDogc3RyaW5nfSkgPT4gdm9pZCkge1xyXG4gICAgc2V0SXNMb2FkaW5nKHRydWUpO1xyXG5cclxuICAgIGlmICghd2FsbGV0QVBJKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2FsbGV0IEFQSSBpcyBub3Qgc2V0LlwiKTtcclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGNpcDMwV2FsbGV0QVBJID0gbmV3IENpcDMwV2FsbGV0KHdhbGxldEFQSSk7XHJcblxyXG4gICAgICBjb25zdCB3YWxsZXRIZWxwZXIgPSBuZXcgV2FsbGV0SGVscGVyKGNpcDMwV2FsbGV0QVBJKTtcclxuICAgICAgLy8gUmVhZCBpbiB0aGUgbmV0d29yayBwYXJhbWV0ZXIgZmlsZVxyXG4gICAgICBjb25zdCBuZXR3b3JrUGFyYW1zSnNvbiA9IGF3YWl0IGdldE5ldHdvcmtQYXJhbXMobmV0d29yayk7XHJcbiAgICAgIGNvbnN0IG5ldHdvcmtQYXJhbXMgPSBuZXcgTmV0d29ya1BhcmFtcyhuZXR3b3JrUGFyYW1zSnNvbik7XHJcblxyXG4gICAgICBjb25zdCBwb2xpY3lJZCA9IFwiZTE2YzJkYzhhZTkzN2U4ZDM3OTBjN2ZkNzE2OGQ3Yjk5NDYyMWJhMTRjYTExNDE1ZjM5ZmVkNzJcIjtcclxuICAgICAgY29uc3QgbmFtZSA9IEJ1ZmZlci5mcm9tKFwiTUlOXCIsICd1dGY4JykudG9TdHJpbmcoJ2hleCcpO1xyXG5cclxuICAgICAgLy8gY29uc3QgcG9saWN5SWQgPSBcIlwiO1xyXG4gICAgICAvLyBjb25zdCBuYW1lID0gQnVmZmVyLmZyb20oXCJcIiwgJ3V0ZjgnKS50b1N0cmluZygnaGV4Jyk7XHJcblxyXG4gICAgICBjb25zdCBtcGggPSBNaW50aW5nUG9saWN5SGFzaC5mcm9tSGV4KHBvbGljeUlkKTtcclxuXHJcbiAgICAgIGNvbnN0IGFzc2V0Q2xhc3MgPSBuZXcgQXNzZXRDbGFzcyh7XHJcbiAgICAgICAgbXBoOiBtcGgsIC8vIFlvdXIgcG9saWN5IGhhc2hcclxuICAgICAgICB0b2tlbk5hbWU6IG5hbWUvLyBDb252ZXJ0IHRvIGhleCBzdHJpbmdcclxuICAgICAgfSk7IFxyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhhc3NldENsYXNzKVxyXG5cclxuICAgICAgLy8gY29uc3QgdG9rZW5BbW91bnQgPSBCaWdJbnQoMzAwMDAwMCk7XHJcbiAgICAgIC8vIGNvbnN0IHRva2VuVmFsID0gbmV3IFZhbHVlKHRva2VuQW1vdW50KTtcclxuICAgICAgY29uc3QgdXR4b3MgPSBhd2FpdCB3YWxsZXRIZWxwZXIuZ2V0VXR4b3MoKTtcclxuICAgICAgY29uc29sZS5sb2coXCJ1dHhvc1wiICsgdXR4b3MpO1xyXG5cclxuICAgICAgLy8gR2V0IGNoYW5nZSBhZGRyZXNzXHJcbiAgICAgIGNvbnN0IGJlbmVmaXRpYXJ5ID0gYXdhaXQgd2FsbGV0SGVscGVyLmNoYW5nZUFkZHJlc3M7XHJcbiAgICAgIC8vIExvYWQgaW4gdGhlIHZlc3RpbmcgdmFsaWRhdG9yIHNjcmlwdCAocHJvZ3JhbSlcclxuICAgICAgY29uc3QgZ2FtZVJld2FyZCA9IG5ldyBHYW1lUmV3YXJkKCk7XHJcblxyXG4gICAgICAvLyBDb21waWxlIHRoZSB2ZXN0aW5nIHZhbGlkYXRvclxyXG4gICAgICBjb25zdCBjb21waWxlZFByb2dyYW0gPSBnYW1lUmV3YXJkLmNvbXBpbGUob3B0aW1pemUpO1xyXG4gICAgICBjb25zb2xlLmxvZyhcIldhbGxldCBhZGRyZXNzOiBcIiArIGJlbmVmaXRpYXJ5KVxyXG4gICAgICBjb25zdCBzY3JpcHRBZGRyZXNzID0gQWRkcmVzcy5mcm9tSGFzaGVzKGNvbXBpbGVkUHJvZ3JhbS52YWxpZGF0b3JIYXNoKVxyXG4gICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKHNjcmlwdEFkZHJlc3MudG9CZWNoMzIoKSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiU2NyaXB0IEFkZHJlc3M6XCIgKyBzY3JpcHRBZGRyZXNzKVxyXG4gICAgICBcclxuICAgICAgY29uc29sZS5kaXIoc2NyaXB0QWRkcmVzcywgeyBkZXB0aDogbnVsbCB9KTtcclxuXHJcbiAgICAgIGNvbnN0IGZpbHRlcmVkVXR4b3MgPSBhd2FpdCBmZXRjaFV0eG9zKHNjcmlwdEFkZHJlc3MudG9CZWNoMzIoKSlcclxuXHJcbiAgICAgIGlmIChmaWx0ZXJlZFV0eG9zLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIG1vcmUgdG9rZW5zIHRvIGNsYWltLiBHYW1lIE92ZXIhXCIpO1xyXG4gICBcclxuICAgICAgLy8gY29uc3QgVE9UQUxfU1VQUExZID0gMTAwMDA7IC8vIFRvdGFsIHRva2VuIHN1cHBseVxyXG4gICAgICBjb25zdCBDTEFJTV9XSU5ET1cgPSAyMDsgLy8gMjAgc2Vjb25kcyBcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKFwiZmlsdGVyZWRVdHhvc1wiICsgZmlsdGVyZWRVdHhvcylcclxuXHJcbiAgICAgIC8vY29uc3QgcmVtYWluaW5nU3VwcGx5ID0gZ2V0VG9rZW5BbW91bnRGcm9tVXR4b3MoZmlsdGVyZWRVdHhvcywgYXNzZXRDbGFzcyk7XHJcbiAgICAgIGNvbnN0IGR5bmFtaWNSZXdhcmQgPSBjYWxjdWxhdGVSZXdhcmRJblRpbWUoKVxyXG4gICAgICBjb25zdCBwb3NpdGlvbkluQ3ljbGUgPSBjYWxjdWxhdGVDb3VudGRvd24oKTtcclxuICAgICAgY29uc29sZS5sb2coXCJwb3NpdGlvbkluQ3ljbGVcIiArIHBvc2l0aW9uSW5DeWNsZSk7XHJcbiAgICAgIHdpbmRvdy5vbmVycm9yID0gKCkgPT4gcG9zaXRpb25JbkN5Y2xlIDwgQ0xBSU1fV0lORE9XO1xyXG4gICAgICAvL2NvbnN0IGR5bmFtaWNSZXdhcmQgPSBjYWxjdWxhdGVSZXdhcmQoTnVtYmVyKHJlbWFpbmluZ1N1cHBseSksIFRPVEFMX1NVUFBMWSwgQkFTRV9SRVdBUkQpO1xyXG4gICAgICBjb25zdCB0ZXN0VmFsdWVCZW5lZml0aWFyeT0gbmV3IEFzc2V0cyhbW2Fzc2V0Q2xhc3MsIEJpZ0ludChkeW5hbWljUmV3YXJkKV1dKTtcclxuXHJcbiAgICAgIC8vY29uc3QgcmVzdWx0ID0gcGlja1JhbmRvbVR4SW5wdXRXaXRoU3VmZmljaWVudFZhbHVlKGZpbHRlcmVkVXR4b3MsIEJpZ0ludChkeW5hbWljUmV3YXJkKSwgYXNzZXRDbGFzcyk7XHJcbiAgICAgIC8vY29uc29sZS5sb2coXCJyYW5kb21VVFhPOlwiICsgcmVzdWx0LnR4SW5wdXQpXHJcblxyXG4gICAgICAvL2NvbnN0IGFtb3VudFRvU2VuZEJhY2sgPSByZXN1bHQudG9rZW5BbW91bnQgLSBCaWdJbnQoZHluYW1pY1Jld2FyZCk7XHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiYW1vdW50VG9TZW5kQmFja1wiICsgYW1vdW50VG9TZW5kQmFjaylcclxuICAgICAgLy8gY29uc29sZS5sb2coXCJVdHhvQW1vdW50XCIgKyByZXN1bHQudG9rZW5BbW91bnQpXHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiVGhlIHJlc3RcIiArIHJlc3VsdC5yZW1haW5pbmdVdHhvcylcclxuICAgICAgXHJcbiAgICAgIC8vY29uc29sZS5sb2coZmlsdGVyZWRVdHhvcylcclxuICAgICAgLy8gY29uc3QgcmVtb3RlV2FsbGV0ID0gbmV3IFJlbW90ZVdhbGxldChmYWxzZSwgW3NjcmlwdEFkZHJlc3NdLCBbXSwgdHhJbnB1dHMpO1xyXG4gICAgICAvLyBjb25zdCB3YWxsZXRIZWxwZXJTY3JpcHQgPSBuZXcgV2FsbGV0SGVscGVyKHJlbW90ZVdhbGxldCk7XHJcbiAgICAgIGNvbnN0IHNvcnRlZFV0eG9zID0gcGlja1V0eG9zKGZpbHRlcmVkVXR4b3MsIEJpZ0ludChkeW5hbWljUmV3YXJkKSwgYXNzZXRDbGFzcyk7IFxyXG4gICAgICBcclxuICAgICAgc29ydGVkVXR4b3Muc2VsZWN0ZWQuZm9yRWFjaChlbGVtZW50ID0+IHtcclxuICAgICAgICAgIGNvbnNvbGUuZGlyKFwic2VsZWN0ZWQgdXR4b1wiICsgZWxlbWVudClcclxuICAgICAgfSk7XHJcbiAgICAgIHNvcnRlZFV0eG9zLnNlbGVjdGVkLmZvckVhY2goZWxlbWVudCA9PiB7XHJcbiAgICAgICAgY29uc29sZS5kaXIoXCJzZWxlY3RlZCB1dHhvIElkXCIgKyBlbGVtZW50Lm91dHB1dElkKVxyXG4gICAgfSk7XHJcbiAgICAgIC8vY29uc3QgdG90YWxBbW91bnRVdHhvID0gZ2V0VG9rZW5BbW91bnRGcm9tVXR4b3Moc29ydGVkVXR4b3Muc2VsZWN0ZWQsIGFzc2V0Q2xhc3MpO1xyXG4gICAgICBjb25zdCBhbW91bnRUb1NlbmRCYWNrID0gQmlnSW50KHNvcnRlZFV0eG9zLnRvdGFsQW1vdW50KSAtIEJpZ0ludChkeW5hbWljUmV3YXJkKTtcclxuXHJcbiAgICAgIGNvbnN0IGZpcnN0UGFydFRvU2VuZEJhY2sgPSBhbW91bnRUb1NlbmRCYWNrIC8gMm47IC8vIEZpcnN0IHBhcnQgaXMgaGFsZiBvZiB0aGUgdG90YWwgYW1vdW50XHJcbiAgICAgIGNvbnN0IHNlY29uZFBhcnRUb1NlbmRCYWNrID0gYW1vdW50VG9TZW5kQmFjayAtIGZpcnN0UGFydFRvU2VuZEJhY2s7IC8vIFNlY29uZCBwYXJ0IGlzIHRoZSByZW1haW5kZXJcclxuICAgICAgY29uc29sZS5sb2coXCJGaXJzdCBcIiArIGZpcnN0UGFydFRvU2VuZEJhY2spXHJcbiAgICAgIGNvbnNvbGUubG9nKFwiU2V2b25kIFwiICsgc2Vjb25kUGFydFRvU2VuZEJhY2spXHJcbiAgICAgIGNvbnNvbGUubG9nKGR5bmFtaWNSZXdhcmRcdClcclxuXHJcbiAgICAgIGNvbnN0IHZhbHVlQ29udHJhY3QxPSBuZXcgQXNzZXRzKFtbYXNzZXRDbGFzcywgZmlyc3RQYXJ0VG9TZW5kQmFja11dKTtcclxuICAgICAgY29uc3QgdmFsdWVDb250cmFjdDI9IG5ldyBBc3NldHMoW1thc3NldENsYXNzLCBzZWNvbmRQYXJ0VG9TZW5kQmFja11dKTtcclxuXHJcblxyXG4gICAgICBjb25zdCBnYW1lRGF0dW0gPSBuZXcgZ2FtZVJld2FyZC50eXBlcy5EYXR1bShcclxuICAgICAgICBiZW5lZml0aWFyeS5wdWJLZXlIYXNoLFxyXG4gICAgICApXHJcblxyXG4gICAgICAgLy8gQ3JlYXRlIHRoZSB2ZXN0aW5nIGNsYWltIHJlZGVlbWVyXHJcbiAgICAgICBjb25zdCByZWRlZW1iZXIgPSAobmV3IGdhbWVSZXdhcmQudHlwZXMuUmVkZWVtZXIuQ2xhaW0oYmVuZWZpdGlhcnkucHViS2V5SGFzaCkpXHJcbiAgICAgICAuX3RvVXBsY0RhdGEoKTtcclxuICAgIFxyXG4gICAgICAvL2NvbnNvbGUubG9nKGZpbHRlcmVkVXR4b3MpO1xyXG4gICAgICBjb25zdCB0eCA9IG5ldyBUeCgpO1xyXG5cclxuICAgICAgLy90eC5hZGRJbnB1dHModXR4b3NbMF0pO1xyXG4gICAgICB0eC5hZGRJbnB1dHMoc29ydGVkVXR4b3Muc2VsZWN0ZWQsIHJlZGVlbWJlcik7XHJcbiAgICAgIHR4LmF0dGFjaFNjcmlwdChjb21waWxlZFByb2dyYW0pO1xyXG5cclxuICAgICAgdmFyIHVzZXJDbGFpbU91dHB1dCA9IG5ldyBUeE91dHB1dChcclxuICAgICAgICBiZW5lZml0aWFyeSxcclxuICAgICAgICBuZXcgVmFsdWUodW5kZWZpbmVkLCB0ZXN0VmFsdWVCZW5lZml0aWFyeSkpO1xyXG5cclxuICAgICAgdHguYWRkT3V0cHV0KHVzZXJDbGFpbU91dHB1dCk7XHJcblxyXG4gICAgXHJcbiAgICAvL1NoaWlpdCwgZml4LiBTb21lb25lIGNvdWxkIHJlZGlyZWR0IHRoZSByZXN0IG9mIHRoZSB0b2tlbnNcclxuICAgIC8vIGNvbnN0IGFkZHJlc3NTdHIgPSBcImFkZHJfdGVzdDFxcmFycWhta2xuaHdjdzNxMHptNnNnbTNnM2w3cHVhMHkzNnNxbDlrNXJ1OGRzdWNnbHNrZWQ1ZjV5cmNmOWU5eGd4amdtdDd4azUya25oOGgwZGdheWMwMGFycWxoN2c2MFwiO1xyXG4gICAgLy8gY29uc3QgYWRkcmVzcyA9IEFkZHJlc3MuZnJvbUJlY2gzMihhZGRyZXNzU3RyKTtcclxuICAgIC8vIHR4LmFkZE91dHB1dChuZXcgVHhPdXRwdXQoXHJcbiAgICAvLyAgIGFkZHJlc3MsXHJcbiAgICAvLyAgIG5ldyBWYWx1ZSh1bmRlZmluZWQsIHRlc3RWYWx1ZUNvbnRyYWN0KSAvLyBUaGUgYW1vdW50IGJlaW5nIGNsYWltZWRcclxuICAgIC8vICkpO1xyXG4gICAgXHJcbiAgICAvLyBDYWxjdWxhdGUgdG90YWwgQURBIGluIHRoZSBzZWxlY3RlZCBzY3JpcHQgaW5wdXRzXHJcbiAgICBsZXQgdG90YWxBZGFJbklucHV0cyA9IEJpZ0ludCgwKTtcclxuICAgIHNvcnRlZFV0eG9zLnNlbGVjdGVkLmZvckVhY2godXR4byA9PiB7XHJcbiAgICAgICAgdG90YWxBZGFJbklucHV0cyArPSBCaWdJbnQodXR4by5vdXRwdXQudmFsdWUubG92ZWxhY2UpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gRGlzdHJpYnV0ZSBBREEgZXF1YWxseSAob3IgYXMgcmVxdWlyZWQpIGFtb25nIHNjcmlwdCBvdXRwdXRzXHJcbiAgICBjb25zdCBhZGFQZXJTY3JpcHRPdXRwdXQgPSB0b3RhbEFkYUluSW5wdXRzIC8gMm47IC8vIEFzc3VtaW5nIHR3byBzY3JpcHQgb3V0cHV0c1xyXG5cclxuICAgIGlmIChhbW91bnRUb1NlbmRCYWNrICE9IEJpZ0ludCgwKSl7XHJcbiAgICAgIHZhciBzY3JpcHRVdHhvMSA9bmV3IFR4T3V0cHV0KFxyXG4gICAgICAgIHNjcmlwdEFkZHJlc3MsXHJcbiAgICAgICAgbmV3IFZhbHVlKGFkYVBlclNjcmlwdE91dHB1dCwgdmFsdWVDb250cmFjdDEpLCAgLy8gUmVtYWluaW5nIHRyZWFzdXJ5IHRva2Vuc1xyXG4gICAgICAgIERhdHVtLmlubGluZShnYW1lRGF0dW0pIC8vIENvbnRyYWN0IHJlcXVpcmVzIGRhdHVtXHJcbiAgICAgICApO1xyXG5cclxuICAgICAgIHR4LmFkZE91dHB1dChzY3JpcHRVdHhvMSk7XHJcblxyXG4gICAgICB2YXIgc2NyaXB0VXR4bzIgPSBuZXcgVHhPdXRwdXQoXHJcbiAgICAgICAgc2NyaXB0QWRkcmVzcyxcclxuICAgICAgICBuZXcgVmFsdWUodG90YWxBZGFJbklucHV0cyAtIGFkYVBlclNjcmlwdE91dHB1dCwgdmFsdWVDb250cmFjdDIpLCAgLy8gUmVtYWluaW5nIHRyZWFzdXJ5IHRva2Vuc1xyXG4gICAgICAgIERhdHVtLmlubGluZShnYW1lRGF0dW0pIC8vIENvbnRyYWN0IHJlcXVpcmVzIGRhdHVtXHJcbiAgICAgICApO1xyXG4gICAgXHJcbiAgICAgICB0eC5hZGRPdXRwdXQoc2NyaXB0VXR4bzIpO1xyXG4gICAgfSAgXHJcblxyXG4gICAgICAvL3ZhciBpbnB1dEZlZXMgPSBhd2FpdCB3YWxsZXRIZWxwZXIucGlja1V0eG9zKG5ldyBWYWx1ZSh0b2tlbkFtb3VudEZlZXMpKTtcclxuICAgICAgXHJcbiAgICAgIC8vdHguYWRkSW5wdXRzKGlucHV0RmVlc1swXSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiV2UgYXR0YXRjaGVkIGV2ZXJ5dGhpbmchXCIpXHJcblxyXG4gICAgICBcclxuXHJcbiAgICAgIGF3YWl0IHR4LmZpbmFsaXplKG5ldHdvcmtQYXJhbXMsIGJlbmVmaXRpYXJ5LCB1dHhvcyk7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiZGFsaSBmaW5hbGl6aXJhaG1lP1wiKVxyXG4gICAgICAvLyBTaWduIHRoZSB1bnNpZ25lZCB0eCB0byBnZXQgdGhlIHdpdG5lc3NcclxuICAgICAgY29uc3Qgc2lnbmF0dXJlcyA9IGF3YWl0IGNpcDMwV2FsbGV0QVBJLnNpZ25UeCh0eCk7XHJcbiAgICAgIHR4LmFkZFNpZ25hdHVyZXMoc2lnbmF0dXJlcyk7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiRGFsaSBxIHNpZ25pcmFobWU/XCIpXHJcblxyXG4gICAgICBjb25zdCB0eEhhc2ggPSBhd2FpdCBjaXAzMFdhbGxldEFQSS5zdWJtaXRUeCh0eCk7XHJcblxyXG4gICAgICBzZXRUeCh7IHR4SWQ6IHR4SGFzaC5oZXggfSk7XHJcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XHJcblxyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwic3VibWl0IHR4IGZhaWxlZFwiLCBlcnIpO1xyXG4gICAgICAgIHRocm93IGVycjsgXHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIGV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZW5kKHdhbGxldEFQSTogYW55LCBzZXRJc0xvYWRpbmc6ICh2YWw6IGJvb2xlYW4pID0+IHZvaWQsIHNldFR4OiAodmFsOiB7dHhJZDogc3RyaW5nfSkgPT4gdm9pZCkge1xyXG4gICAgc2V0SXNMb2FkaW5nKHRydWUpO1xyXG5cclxuICAgIGlmICghd2FsbGV0QVBJKSB7XHJcbiAgICAgIHRocm93IGNvbnNvbGUuZXJyb3IoXCJ3YWxsZXRBUEkgaXMgbm90IHNldFwiKTtcclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGNpcDMwV2FsbGV0QVBJID0gbmV3IENpcDMwV2FsbGV0KHdhbGxldEFQSSk7XHJcbiAgICAgIC8vIGNvbnN0IGJsb2NrZnJvc3QgPSBuZXcgQmxvY2tGcm9zdElQRlMoe1xyXG4gICAgICAvLyAgIG5ldHdvcms6IG5ldHdvcmssXHJcbiAgICAgIC8vICAgcHJvamVjdElkOiBcInByZXByb2RKRXhPME1BTVJnZnBYejlJbDRJcUIydTlkZG95bFpCVFwiLFxyXG4gICAgICAvLyB9KTtcclxuICAgICAgY29uc29sZS5sb2coXCJnbW1tXCIpXHJcblxyXG4gICAgICBjb25zdCB3YWxsZXRIZWxwZXIgPSBuZXcgV2FsbGV0SGVscGVyKGNpcDMwV2FsbGV0QVBJKTtcclxuXHJcbiAgICAgIGNvbnN0IHBvbGljeUlkID0gXCJlMTZjMmRjOGFlOTM3ZThkMzc5MGM3ZmQ3MTY4ZDdiOTk0NjIxYmExNGNhMTE0MTVmMzlmZWQ3MlwiO1xyXG4gICAgICBjb25zdCBuYW1lID0gQnVmZmVyLmZyb20oXCJNSU5cIiwgJ3V0ZjgnKS50b1N0cmluZygnaGV4Jyk7XHJcblxyXG4gICAgICAvLyBjb25zdCBwb2xpY3lJZCA9IFwiXCI7XHJcbiAgICAgIC8vIGNvbnN0IG5hbWUgPSBCdWZmZXIuZnJvbShcIlwiLCAndXRmOCcpLnRvU3RyaW5nKCdoZXgnKTtcclxuXHJcbiAgICAgIGNvbnN0IG1waCA9IE1pbnRpbmdQb2xpY3lIYXNoLmZyb21IZXgocG9saWN5SWQpO1xyXG5cclxuICAgICAgY29uc3QgYXNzZXRDbGFzcyA9IG5ldyBBc3NldENsYXNzKHtcclxuICAgICAgICBtcGg6IG1waCwgLy8gWW91ciBwb2xpY3kgaGFzaFxyXG4gICAgICAgIHRva2VuTmFtZTogbmFtZS8vIENvbnZlcnQgdG8gaGV4IHN0cmluZ1xyXG4gICAgICB9KTsgXHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKGFzc2V0Q2xhc3MpXHJcblxyXG4gICAgICBjb25zdCBtaW5BZGEgOiBudW1iZXIgPSAxXzAwMF8wMDA7IC8vIG1pbmltdW0gbG92ZWxhY2UgdG8gc2VuZFxyXG4gICAgICBjb25zdCBtaW5BZGFWYWwgPSBuZXcgVmFsdWUoQmlnSW50KG1pbkFkYSkpO1xyXG5cclxuICAgICAgLy8gIGNvbnN0IGJlbmVmaXRpYXJ5VmFsdWUgPSBuZXcgVmFsdWUoQmlnSW50KDEwMDAwKSwgbmV3IEFzc2V0cyhbXHJcbiAgICAgIC8vICAgW21waCwgW1tuYW1lLCBCaWdJbnQoMTAwMDApXV1dXHJcbiAgICAgIC8vIF0pKVxyXG5cclxuXHJcbiAgICAgIGNvbnN0IHRlc3RWYWx1ZVNjcmlwdCA9IG5ldyBBc3NldHMoW1thc3NldENsYXNzLCBCaWdJbnQoMTI1NTUwKV1dKTtcclxuXHJcblxyXG4gICAgICAvLyBHZXQgd2FsbGV0IFVUWE9zXHJcbiAgICAgIGNvbnN0IHV0eG9zID0gYXdhaXQgd2FsbGV0SGVscGVyLnBpY2tVdHhvcyhuZXcgVmFsdWUodW5kZWZpbmVkLCB0ZXN0VmFsdWVTY3JpcHQpKTtcclxuICAgICAgY29uc29sZS5sb2codXR4b3MpO1xyXG5cclxuICAgICAgLy8gR2V0IGNoYW5nZSBhZGRyZXNzXHJcbiAgICAgIGNvbnN0IGJlbmVmaXRpYXJ5ID0gYXdhaXQgd2FsbGV0SGVscGVyLmNoYW5nZUFkZHJlc3M7XHJcbiAgICAgIC8vIExvYWQgaW4gdGhlIHZlc3RpbmcgdmFsaWRhdG9yIHNjcmlwdCAocHJvZ3JhbSlcclxuICAgICAgY29uc3QgZ2FtZVJld2FyZCA9IG5ldyBHYW1lUmV3YXJkKCk7XHJcblxyXG4gICAgICAvLyBDb21waWxlIHRoZSB2ZXN0aW5nIHZhbGlkYXRvclxyXG4gICAgICBjb25zdCBjb21waWxlZFByb2dyYW0gPSBnYW1lUmV3YXJkLmNvbXBpbGUob3B0aW1pemUpO1xyXG4gICAgICBjb25zb2xlLmxvZyhcIldhbGxldCBhZGRyZXNzOiBcIiArIGJlbmVmaXRpYXJ5KVxyXG4gICAgICBjb25zdCBzY3JpcHRBZGRyZXNzID0gQWRkcmVzcy5mcm9tSGFzaGVzKGNvbXBpbGVkUHJvZ3JhbS52YWxpZGF0b3JIYXNoKVxyXG4gICAgXHJcbiAgICAgICAgLy9yZW1vdmVcclxuICAgICAgY29uc29sZS5sb2coc2NyaXB0QWRkcmVzcy50b0JlY2gzMigpKTtcclxuICAgICAgY29uc29sZS5sb2coXCJTY3JpcHQgQWRkcmVzczpcIiArIHNjcmlwdEFkZHJlc3MpXHJcbiAgICAgIFxyXG4gICAgICAvLyBDb25zdHJ1Y3QgdGhlIHZlc3RpbmcgZGF0dW1cclxuICAgICAgY29uc3QgZ2FtZURhdHVtID0gbmV3IGdhbWVSZXdhcmQudHlwZXMuRGF0dW0oXHJcbiAgICAgICAgYmVuZWZpdGlhcnkucHViS2V5SGFzaCxcclxuICAgICAgKVxyXG4gICAgXHJcbiAgICAvL2NvbnN0IHJlZGVlbWJlciA9IChuZXcgZ2FtZVJld2FyZC50eXBlcy5SZWRlZW1lci5DbGFpbSgpKS5fdG9VcGxjRGF0YSgpO1xyXG4gICAgXHJcbiAgICAgIGNvbnN0IHR4ID0gbmV3IFR4KCk7XHJcbiAgICAgIHR4LmFkZElucHV0cyh1dHhvc1swXSk7XHJcbiAgICAgIHR4LmFkZE91dHB1dChuZXcgVHhPdXRwdXQoXHJcbiAgICAgICAgc2NyaXB0QWRkcmVzcyxcclxuICAgICAgICBuZXcgVmFsdWUodW5kZWZpbmVkLCB0ZXN0VmFsdWVTY3JpcHQpLFxyXG4gICAgICAgIERhdHVtLmlubGluZShnYW1lRGF0dW0pXHJcbiAgICAgICkpO1xyXG5cclxuICAgICAgLy8gdHguYWRkT3V0cHV0KG5ldyBUeE91dHB1dChcclxuICAgICAgLy8gICBiZW5lZml0aWFyeSxcclxuICAgICAgLy8gICBtaW5BZGFWYWwsXHJcbiAgICAgIC8vICkpO1xyXG4gICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKFwiV2UgYXR0YXRjaGVkIGV2ZXJ5dGhpbmchXCIpXHJcblxyXG4gICAgICAvLyBSZWFkIGluIHRoZSBuZXR3b3JrIHBhcmFtZXRlciBmaWxlXHJcbiAgICAgIGNvbnN0IG5ldHdvcmtQYXJhbXNKc29uID0gYXdhaXQgZ2V0TmV0d29ya1BhcmFtcyhuZXR3b3JrKTtcclxuICAgICAgY29uc3QgbmV0d29ya1BhcmFtcyA9IG5ldyBOZXR3b3JrUGFyYW1zKG5ldHdvcmtQYXJhbXNKc29uKTtcclxuXHJcbiAgICAgIC8vIFNlbmQgYW55IGNoYW5nZSBiYWNrIHRvIHRoZSBidXllclxyXG4gICAgICBhd2FpdCB0eC5maW5hbGl6ZShuZXR3b3JrUGFyYW1zLCBiZW5lZml0aWFyeSwgdXR4b3NbMV0pO1xyXG5cclxuICAgICAgLy8gU2lnbiB0aGUgdW5zaWduZWQgdHggdG8gZ2V0IHRoZSB3aXRuZXNzXHJcbiAgICAgIGNvbnN0IHNpZ25hdHVyZXMgPSBhd2FpdCBjaXAzMFdhbGxldEFQSS5zaWduVHgodHgpO1xyXG4gICAgICB0eC5hZGRTaWduYXR1cmVzKHNpZ25hdHVyZXMpO1xyXG5cclxuICAgICAgY29uc29sZS5sb2coXCJzaWduZWRcIik7XHJcbiAgICAgIC8vIFN1Ym1pdCB0aGUgc2lnbmVkIHR4XHJcbiAgICAgIGNvbnN0IHR4SGFzaCA9IGF3YWl0IGNpcDMwV2FsbGV0QVBJLnN1Ym1pdFR4KHR4KTtcclxuXHJcbiAgICAgIHNldFR4KHsgdHhJZDogdHhIYXNoLmhleCB9KTtcclxuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcclxuXHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgIHRocm93IGNvbnNvbGUuZXJyb3IoXCJzdWJtaXQgdHggZmFpbGVkXCIsIGVycik7XHJcbiAgICB9XHJcbiAgfVxyXG4gICAgXHJcbiAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hVdHhvcyhzY3JpcHRBZGRyZXNzOiBzdHJpbmcsdGFyZ2V0QW1vdW50OiBiaWdpbnQpOiBQcm9taXNlPFR4SW5wdXRbXT4ge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgaHR0cDovLzE5Mi4xNjguMS4xMDE6MzAwMS9hcGkvZ2V0VXR4b3NgLCB7XHJcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbiAgICAgIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcclxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBzY3JpcHRBZGRyZXNzLCAgdGFyZ2V0QW1vdW50OiB0YXJnZXRBbW91bnQudG9TdHJpbmcoKX0pLFxyXG4gICAgfSk7XHJcbiAgXHJcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpOyAvLyBSYXcgSlNPTiBhcnJheSBmcm9tIGJhY2tlbmRcclxuICBcclxuICAgIC8vIGBDb252ZXJ0IEpTT04gYmFjayB0byBUeElucHV0IG9iamVjdHNcclxuICAgIGNvbnN0IGZpbHRlcmVkVXR4b3MgPSBkYXRhLnNlbGVjdGVkLm1hcCgodXR4bzogYW55KSA9PiBUeElucHV0LmZyb21GdWxsQ2Jvcih1dHhvKSk7XHJcbiAgICBjb25zdCB0b3RhbEFtb3VudDogYmlnaW50ID0gQmlnSW50KGRhdGEudG90YWxBbW91bnQpO1xyXG5cclxuICAgIHJldHVybiBmaWx0ZXJlZFV0eG9zO1xyXG4gIH1cclxuICAiXSwibmFtZXMiOlsiTmV0d29ya1BhcmFtcyIsIlZhbHVlIiwiVHhPdXRwdXQiLCJUeCIsIlR4SW5wdXQiLCJDaXAzMFdhbGxldCIsIkRhdHVtIiwiQXNzZXRzIiwiV2FsbGV0SGVscGVyIiwiTWludGluZ1BvbGljeUhhc2giLCJBc3NldENsYXNzIiwiQWRkcmVzcyIsIm5ldHdvcmsiLCJnZXROZXR3b3JrUGFyYW1zIiwiR2FtZVJld2FyZCIsIm9wdGltaXplIiwicGlja1V0eG9zIiwidXR4b3MiLCJ0YXJnZXRBbW91bnQiLCJhc3NldENsYXNzIiwic2VsZWN0ZWQiLCJ0b3RhbEFtb3VudCIsInVzZWRJbmRpY2VzIiwiU2V0IiwicmFuZG9tSW5kZXgiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJsZW5ndGgiLCJoYXMiLCJhZGQiLCJzZWxlY3RlZFV0eG8iLCJwdXNoIiwidG9rZW5zIiwidmFsdWUiLCJhc3NldHMiLCJnZXRUb2tlbnMiLCJtaW50aW5nUG9saWN5SGFzaCIsImZvckVhY2giLCJ0b2tlbk5hbWUiLCJhbW91bnQiLCJCaWdJbnQiLCJjYWxjdWxhdGVSZXdhcmRJblRpbWUiLCJUaW1lQmVnaW5Db250cmFjdCIsIkRhdGUiLCJVVEMiLCJnZXRUaW1lIiwiY29uc29sZSIsImxvZyIsIkhBTFZJTkdfUEVSSU9EIiwiTUFYX0hBTFZJTkdTIiwiQkFTRV9SRVdBUkQiLCJUaW1lTm93Iiwibm93IiwidGltZUVsYXBzZWQiLCJoYWx2aW5nU3RlcHMiLCJtaW4iLCJlZmZlY3RpdmVIYWx2aW5ncyIsInJld2FyZCIsImNhbGN1bGF0ZUNvdW50ZG93biIsIkNZQ0xFX0RVUkFUSU9OIiwib2Zmc2V0SW5NcyIsImVsYXBzZWRUaW1lIiwiZWxhcHNlZFRpbWVJblNlY29uZHMiLCJwb3NpdGlvbkluQ3ljbGUiLCJjbGFpbVRva2VucyIsIndhbGxldEFQSSIsInNldElzTG9hZGluZyIsInNldFR4IiwiRXJyb3IiLCJjaXAzMFdhbGxldEFQSSIsIndhbGxldEhlbHBlciIsIm5ldHdvcmtQYXJhbXNKc29uIiwibmV0d29ya1BhcmFtcyIsInBvbGljeUlkIiwibmFtZSIsIkJ1ZmZlciIsImZyb20iLCJ0b1N0cmluZyIsIm1waCIsImZyb21IZXgiLCJnZXRVdHhvcyIsImJlbmVmaXRpYXJ5IiwiY2hhbmdlQWRkcmVzcyIsImdhbWVSZXdhcmQiLCJjb21waWxlZFByb2dyYW0iLCJjb21waWxlIiwic2NyaXB0QWRkcmVzcyIsImZyb21IYXNoZXMiLCJ2YWxpZGF0b3JIYXNoIiwidG9CZWNoMzIiLCJkaXIiLCJkZXB0aCIsImZpbHRlcmVkVXR4b3MiLCJmZXRjaFV0eG9zIiwiQ0xBSU1fV0lORE9XIiwiZHluYW1pY1Jld2FyZCIsIndpbmRvdyIsIm9uZXJyb3IiLCJ0ZXN0VmFsdWVCZW5lZml0aWFyeSIsInNvcnRlZFV0eG9zIiwiZWxlbWVudCIsIm91dHB1dElkIiwiYW1vdW50VG9TZW5kQmFjayIsImZpcnN0UGFydFRvU2VuZEJhY2siLCJzZWNvbmRQYXJ0VG9TZW5kQmFjayIsInZhbHVlQ29udHJhY3QxIiwidmFsdWVDb250cmFjdDIiLCJnYW1lRGF0dW0iLCJ0eXBlcyIsInB1YktleUhhc2giLCJyZWRlZW1iZXIiLCJSZWRlZW1lciIsIkNsYWltIiwiX3RvVXBsY0RhdGEiLCJ0eCIsImFkZElucHV0cyIsImF0dGFjaFNjcmlwdCIsInVzZXJDbGFpbU91dHB1dCIsInVuZGVmaW5lZCIsImFkZE91dHB1dCIsInRvdGFsQWRhSW5JbnB1dHMiLCJ1dHhvIiwib3V0cHV0IiwibG92ZWxhY2UiLCJhZGFQZXJTY3JpcHRPdXRwdXQiLCJzY3JpcHRVdHhvMSIsImlubGluZSIsInNjcmlwdFV0eG8yIiwiZmluYWxpemUiLCJzaWduYXR1cmVzIiwic2lnblR4IiwiYWRkU2lnbmF0dXJlcyIsInR4SGFzaCIsInN1Ym1pdFR4IiwidHhJZCIsImhleCIsImVyciIsImVycm9yIiwic2VuZCIsIm1pbkFkYSIsIm1pbkFkYVZhbCIsInRlc3RWYWx1ZVNjcmlwdCIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJkYXRhIiwianNvbiIsIm1hcCIsImZyb21GdWxsQ2JvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./public/walletActions.ts\n"));

/***/ })

});