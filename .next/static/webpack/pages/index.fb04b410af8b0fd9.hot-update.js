"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./public/useFlappyBirdGame.ts":
/*!*************************************!*\
  !*** ./public/useFlappyBirdGame.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFlappyBirdGame: function() { return /* binding */ useFlappyBirdGame; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n// useFlappyBirdGame.ts\n\n// Constants\nconst GRAVITY = 800; // pixels per second squared\nconst FLAP_VELOCITY = -450; // pixels per second\nconst PIPE_SPEED = 200; // pixels per second\nconst PIPE_SPAWN_INTERVAL = 1500; // milliseconds\nconst PIPE_WIDTH = 90;\nconst PIPE_GAP = 200; // Vertical gap between pipes\nconst BIRD_X = 100; // Fixed X position\nconst BIRD_WIDTH = 50;\nconst BIRD_HEIGHT = 50;\nconst COIN_SPEED = 200; // pixels per second\nconst COIN_SPAWN_CHANCE = 0.25; // 25%\nconst COIN_SIZE = 80;\nconst ROTATION_SPEED = 2 * Math.PI; // radians per second (full rotation per second)\n/**\r\n * Custom hook to manage Flappy Bird game logic.\r\n * @param canvasRef Reference to the canvas element.\r\n * @param isPaused Boolean indicating if the game is paused.\r\n * @param autoStart Boolean indicating if the game should start automatically.\r\n * @returns High score, current score, and a handler for user input.\r\n */ function useFlappyBirdGame(canvasRef, isPaused, autoStart) {\n    // State for scores\n    const [highScore, setHighScore] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [currentScore, setCurrentScore] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    // Refs to track game state\n    const birdYRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const birdVelocityRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const pipesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const coinsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const gameOverRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const gameStartedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // Rotation angle for coins\n    const coinRotationRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // Time tracking\n    const lastTimeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const pipeSpawnTimerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // Request ID for animation frame\n    const requestIdRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // Asset images\n    const birdImagesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const pipeTopImgRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const pipeBottomImgRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const backgroundImgRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const coinImgRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // Current bird frame index for flap animation\n    const currentBirdFrameRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(1); // Start with mid-flap\n    /**\r\n   * Helper function to load an image fully.\r\n   * @param img HTMLImageElement\r\n   * @returns Promise that resolves when the image is loaded.\r\n   */ const loadImage = (img)=>{\n        return new Promise((resolve, reject)=>{\n            if (img.complete) {\n                resolve();\n            } else {\n                img.onload = ()=>resolve();\n                img.onerror = ()=>reject(new Error(\"Failed to load image: \".concat(img.src)));\n            }\n        });\n    };\n    /**\r\n   * Flap animation by cycling through bird frames.\r\n   */ const flapAnimation = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const flapFrames = [\n            0,\n            1,\n            2,\n            1\n        ];\n        let currentFrame = 0;\n        const flapInterval = 100; // milliseconds between frames\n        const flap = ()=>{\n            if (currentFrame < flapFrames.length) {\n                currentBirdFrameRef.current = flapFrames[currentFrame];\n                currentFrame++;\n                setTimeout(flap, flapInterval);\n            } else {\n                currentBirdFrameRef.current = 1; // reset to mid-flap\n            }\n        };\n        flap();\n    }, []);\n    /**\r\n   * Initialize the game by loading assets and setting up the canvas.\r\n   */ const initializeGame = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        try {\n            // Load all assets\n            const assets = [\n                ...birdImagesRef.current,\n                pipeTopImgRef.current,\n                pipeBottomImgRef.current,\n                backgroundImgRef.current,\n                coinImgRef.current\n            ];\n            await Promise.all(assets.map((img)=>img ? loadImage(img) : Promise.resolve()));\n            console.log(\"All assets loaded successfully!\");\n            // Set canvas dimensions\n            canvas.width = 360;\n            canvas.height = 640;\n            // Draw start screen\n            drawStartScreen(ctx, canvas);\n            // Auto-start if enabled\n            if (autoStart) {\n                startGame();\n            }\n        } catch (error) {\n            console.error(\"Error loading assets:\", error);\n        }\n    }, [\n        canvasRef,\n        autoStart\n    ]);\n    /**\r\n   * Render the start screen.\r\n   * @param ctx CanvasRenderingContext2D\r\n   * @param canvas Canvas element\r\n   */ const drawStartScreen = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((ctx, canvas)=>{\n        var _backgroundImgRef_current;\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        // Draw background\n        if ((_backgroundImgRef_current = backgroundImgRef.current) === null || _backgroundImgRef_current === void 0 ? void 0 : _backgroundImgRef_current.complete) {\n            ctx.drawImage(backgroundImgRef.current, 0, 0, canvas.width, canvas.height);\n        }\n        // Draw start text\n        ctx.fillStyle = \"white\";\n        ctx.font = \"bold 30px Arial\";\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        ctx.fillText(\"Press Space or Tap to Start\", canvas.width / 2, canvas.height / 2);\n    }, []);\n    /**\r\n   * Render the game over screen.\r\n   * @param ctx CanvasRenderingContext2D\r\n   * @param canvas Canvas element\r\n   */ const drawGameOverScreen = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((ctx, canvas)=>{\n        // Draw semi-transparent overlay\n        ctx.fillStyle = \"rgba(0, 0, 0, 0.5)\";\n        ctx.fillRect(0, canvas.height / 2 - 100, canvas.width, 200);\n        // Draw Game Over text\n        ctx.fillStyle = \"#ffcc00\";\n        ctx.font = \"bold 50px Arial\";\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        ctx.fillText(\"Game Over!\", canvas.width / 2, canvas.height / 2 - 40);\n        // Draw restart prompt\n        ctx.fillStyle = \"white\";\n        ctx.font = \"bold 30px Arial\";\n        ctx.fillText(\"Press Space or Tap to Restart\", canvas.width / 2, canvas.height / 2 + 20);\n    }, []);\n    /**\r\n   * Create a new pipe with a random gap position and possibly spawn a coin.\r\n   */ const createPipe = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const gapY = Math.random() * (canvas.height - PIPE_GAP - 200) + 100; // Ensure gap is not too close to top or bottom\n        pipesRef.current.push({\n            x: canvas.width,\n            gapY,\n            scored: false\n        });\n        // 25% chance to spawn a coin\n        if (Math.random() < COIN_SPAWN_CHANCE) {\n            coinsRef.current.push({\n                x: canvas.width + PIPE_WIDTH / 2 - COIN_SIZE / 2,\n                y: gapY + PIPE_GAP / 2 - COIN_SIZE / 2,\n                width: COIN_SIZE,\n                height: COIN_SIZE,\n                collected: false\n            });\n        }\n    }, []);\n    /**\r\n   * Update the game state based on elapsed time.\r\n   * @param deltaTime Time elapsed since last frame (in seconds)\r\n   */ const updateGameState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((deltaTime)=>{\n        // Apply gravity to the bird\n        birdVelocityRef.current += GRAVITY * deltaTime;\n        birdYRef.current += birdVelocityRef.current * deltaTime;\n        // Update pipe spawn timer and spawn pipes at intervals\n        pipeSpawnTimerRef.current += deltaTime;\n        if (pipeSpawnTimerRef.current > PIPE_SPAWN_INTERVAL / 1000) {\n            createPipe();\n            pipeSpawnTimerRef.current = 0;\n        }\n        // Move pipes based on PIPE_SPEED and deltaTime\n        const pipeMoveDelta = PIPE_SPEED * deltaTime;\n        pipesRef.current = pipesRef.current.map((pipe)=>({\n                ...pipe,\n                x: pipe.x - pipeMoveDelta\n            }));\n        // Remove offscreen pipes\n        pipesRef.current = pipesRef.current.filter((pipe)=>pipe.x + PIPE_WIDTH > 0);\n        // Move coins based on COIN_SPEED and deltaTime\n        const coinMoveDelta = COIN_SPEED * deltaTime;\n        coinsRef.current = coinsRef.current.map((coin)=>({\n                ...coin,\n                x: coin.x - coinMoveDelta\n            }));\n        // Remove offscreen or collected coins\n        coinsRef.current = coinsRef.current.filter((coin)=>coin.x + coin.width > 0 && !coin.collected);\n        // Rotate coins for visual effect\n        coinRotationRef.current += ROTATION_SPEED * deltaTime;\n        if (coinRotationRef.current >= 2 * Math.PI) {\n            coinRotationRef.current -= 2 * Math.PI;\n        }\n        // Check for collisions\n        if (checkCollisions()) {\n            gameOverRef.current = true;\n            return;\n        }\n        // Check if bird collects any coins\n        checkCoinCollection();\n        // Update the score based on pipe passing\n        updateScore();\n    }, [\n        createPipe\n    ]);\n    /**\r\n   * Check for collisions between the bird and pipes or boundaries.\r\n   * @returns Boolean indicating if a collision occurred\r\n   */ const checkCollisions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        // Assuming canvas height is fixed at 640\n        if (birdYRef.current < 0 || birdYRef.current + BIRD_HEIGHT > 640) {\n            return true;\n        }\n        const birdLeft = BIRD_X;\n        const birdRight = BIRD_X + BIRD_WIDTH;\n        const birdTop = birdYRef.current;\n        const birdBottom = birdYRef.current + BIRD_HEIGHT;\n        // Check collision with each pipe\n        for (const pipe of pipesRef.current){\n            const pipeLeft = pipe.x;\n            const pipeRight = pipe.x + PIPE_WIDTH;\n            // If bird is within pipe's horizontal bounds\n            if (birdRight > pipeLeft && birdLeft < pipeRight) {\n                // Check if bird is within the gap\n                if (birdTop < pipe.gapY || birdBottom > pipe.gapY + PIPE_GAP) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }, []);\n    /**\r\n   * Check if the bird has collected any coins.\r\n   */ const checkCoinCollection = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const birdLeft = BIRD_X;\n        const birdRight = BIRD_X + BIRD_WIDTH;\n        const birdTop = birdYRef.current;\n        const birdBottom = birdYRef.current + BIRD_HEIGHT;\n        for (const coin of coinsRef.current){\n            if (!coin.collected) {\n                const coinLeft = coin.x;\n                const coinRight = coin.x + coin.width;\n                const coinTop = coin.y;\n                const coinBottom = coin.y + coin.height;\n                if (birdRight > coinLeft && birdLeft < coinRight && birdBottom > coinTop && birdTop < coinBottom) {\n                    coin.collected = true;\n                    setCurrentScore((prevScore)=>{\n                        const newScore = prevScore + 5;\n                        setHighScore((prevHighScore)=>{\n                            const updatedHighScore = Math.max(prevHighScore, newScore);\n                            if (true) {\n                                localStorage.setItem(\"highScore\", updatedHighScore.toString());\n                            }\n                            return updatedHighScore;\n                        });\n                        return newScore;\n                    });\n                }\n            }\n        }\n    }, []);\n    /**\r\n   * Update the score when the bird passes a pipe.\r\n   */ const updateScore = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        for (const pipe of pipesRef.current){\n            // Score +1 for passing each pipe once\n            if (!pipe.scored && pipe.x + PIPE_WIDTH < BIRD_X) {\n                setCurrentScore((prevScore)=>{\n                    const newScore = prevScore + 1;\n                    setHighScore((prevHighScore)=>{\n                        const updatedHighScore = Math.max(prevHighScore, newScore);\n                        if (true) {\n                            localStorage.setItem(\"highScore\", updatedHighScore.toString());\n                        }\n                        return updatedHighScore;\n                    });\n                    return newScore;\n                });\n                pipe.scored = true;\n            }\n        }\n    }, []);\n    /**\r\n   * Render all game elements onto the canvas.\r\n   * @param ctx CanvasRenderingContext2D\r\n   * @param canvas Canvas element\r\n   */ const draw = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((ctx, canvas)=>{\n        var _backgroundImgRef_current;\n        // Clear the canvas\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        // Draw background\n        if ((_backgroundImgRef_current = backgroundImgRef.current) === null || _backgroundImgRef_current === void 0 ? void 0 : _backgroundImgRef_current.complete) {\n            ctx.drawImage(backgroundImgRef.current, 0, 0, canvas.width, canvas.height);\n        }\n        // Draw pipes\n        for (const pipe of pipesRef.current){\n            var _pipeTopImgRef_current, _pipeBottomImgRef_current;\n            // Top pipe\n            if ((_pipeTopImgRef_current = pipeTopImgRef.current) === null || _pipeTopImgRef_current === void 0 ? void 0 : _pipeTopImgRef_current.complete) {\n                ctx.drawImage(pipeTopImgRef.current, pipe.x, 0, PIPE_WIDTH, pipe.gapY);\n            }\n            // Bottom pipe\n            if ((_pipeBottomImgRef_current = pipeBottomImgRef.current) === null || _pipeBottomImgRef_current === void 0 ? void 0 : _pipeBottomImgRef_current.complete) {\n                ctx.drawImage(pipeBottomImgRef.current, pipe.x, pipe.gapY + PIPE_GAP, PIPE_WIDTH, canvas.height - (pipe.gapY + PIPE_GAP));\n            }\n        }\n        // Draw coins\n        for (const coin of coinsRef.current){\n            var _coinImgRef_current;\n            if (!coin.collected && ((_coinImgRef_current = coinImgRef.current) === null || _coinImgRef_current === void 0 ? void 0 : _coinImgRef_current.complete)) {\n                ctx.save();\n                ctx.translate(coin.x + coin.width / 2, coin.y + coin.height / 2);\n                ctx.rotate(coinRotationRef.current);\n                ctx.drawImage(coinImgRef.current, -coin.width / 2, -coin.height / 2, coin.width, coin.height);\n                ctx.restore();\n            }\n        }\n        // Draw bird\n        const currentBirdFrame = birdImagesRef.current[currentBirdFrameRef.current];\n        if (currentBirdFrame === null || currentBirdFrame === void 0 ? void 0 : currentBirdFrame.complete) {\n            ctx.drawImage(currentBirdFrame, BIRD_X, birdYRef.current, BIRD_WIDTH, BIRD_HEIGHT);\n        }\n    }, []);\n    /**\r\n   * The main game loop using requestAnimationFrame.\r\n   * @param timestamp Current timestamp\r\n   */ const animate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((timestamp)=>{\n        if (isPaused || !gameStartedRef.current) {\n            requestIdRef.current = requestAnimationFrame(animate);\n            return;\n        }\n        if (!lastTimeRef.current) {\n            lastTimeRef.current = timestamp;\n        }\n        let deltaTime = (timestamp - lastTimeRef.current) / 1000; // in seconds\n        // Cap deltaTime to 0.05 seconds to prevent big jumps\n        deltaTime = Math.min(deltaTime, 0.05);\n        lastTimeRef.current = timestamp;\n        // Update game state\n        updateGameState(deltaTime);\n        // Draw everything\n        const canvas = canvasRef.current;\n        if (canvas) {\n            const ctx = canvas.getContext(\"2d\");\n            if (ctx) {\n                draw(ctx, canvas);\n            }\n        }\n        if (!gameOverRef.current) {\n            requestIdRef.current = requestAnimationFrame(animate);\n        } else {\n            // Draw game over screen\n            const canvas = canvasRef.current;\n            if (canvas) {\n                const ctx = canvas.getContext(\"2d\");\n                if (ctx) {\n                    drawGameOverScreen(ctx, canvas);\n                }\n            }\n        }\n    }, [\n        isPaused,\n        updateGameState,\n        draw,\n        drawGameOverScreen\n    ]);\n    /**\r\n   * Start the game by resetting the state and initiating the game loop.\r\n   */ const startGame = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        resetGame();\n        gameStartedRef.current = true;\n        lastTimeRef.current = performance.now();\n        requestIdRef.current = requestAnimationFrame(animate);\n    }, [\n        resetGame,\n        animate\n    ]);\n    /**\r\n   * Handle user input (click/tap) by flapping or restarting.\r\n   */ const handleUserInput = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (!gameStartedRef.current && !gameOverRef.current) {\n            startGame();\n        } else if (gameOverRef.current) {\n            startGame();\n        } else {\n            birdVelocityRef.current = FLAP_VELOCITY;\n            flapAnimation();\n        }\n    }, [\n        startGame,\n        flapAnimation\n    ]);\n    /**\r\n   * Handle keydown events for space bar to flap or restart.\r\n   * @param e KeyboardEvent\r\n   */ const handleKeyDown = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        if (e.key === \" \") {\n            handleUserInput();\n        }\n    }, [\n        handleUserInput\n    ]);\n    /**\r\n   * Add keydown event listener on mount.\r\n   */ (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        window.addEventListener(\"keydown\", handleKeyDown);\n        return ()=>window.removeEventListener(\"keydown\", handleKeyDown);\n    }, [\n        handleKeyDown\n    ]);\n    /**\r\n   * Cleanup on unmount.\r\n   */ (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>{\n            if (requestIdRef.current) {\n                cancelAnimationFrame(requestIdRef.current);\n            }\n        };\n    }, []);\n    /**\r\n   * Initialize the game by loading assets.\r\n   */ (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        initializeGame();\n    }, [\n        initializeGame\n    ]);\n    return {\n        highScore,\n        currentScore,\n        handleUserInput\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QWU7SUFFbkIsT0FBTztRQUNMdEM7UUFDQUU7UUFDQTRHO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wdWJsaWMvdXNlRmxhcHB5QmlyZEdhbWUudHM/NWM3OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB1c2VGbGFwcHlCaXJkR2FtZS50c1xyXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSBcInJlYWN0XCI7XHJcblxyXG4vLyBUeXBlcyBmb3IgZ2FtZSBvYmplY3RzXHJcbmludGVyZmFjZSBQaXBlIHtcclxuICB4OiBudW1iZXI7XHJcbiAgZ2FwWTogbnVtYmVyO1xyXG4gIHNjb3JlZDogYm9vbGVhbjtcclxufVxyXG5cclxuaW50ZXJmYWNlIENvaW4ge1xyXG4gIHg6IG51bWJlcjtcclxuICB5OiBudW1iZXI7XHJcbiAgd2lkdGg6IG51bWJlcjtcclxuICBoZWlnaHQ6IG51bWJlcjtcclxuICBjb2xsZWN0ZWQ6IGJvb2xlYW47XHJcbn1cclxuXHJcbi8vIENvbnN0YW50c1xyXG5jb25zdCBHUkFWSVRZID0gODAwOyAvLyBwaXhlbHMgcGVyIHNlY29uZCBzcXVhcmVkXHJcbmNvbnN0IEZMQVBfVkVMT0NJVFkgPSAtNDUwOyAvLyBwaXhlbHMgcGVyIHNlY29uZFxyXG5jb25zdCBQSVBFX1NQRUVEID0gMjAwOyAvLyBwaXhlbHMgcGVyIHNlY29uZFxyXG5jb25zdCBQSVBFX1NQQVdOX0lOVEVSVkFMID0gMTUwMDsgLy8gbWlsbGlzZWNvbmRzXHJcbmNvbnN0IFBJUEVfV0lEVEggPSA5MDtcclxuY29uc3QgUElQRV9HQVAgPSAyMDA7IC8vIFZlcnRpY2FsIGdhcCBiZXR3ZWVuIHBpcGVzXHJcbmNvbnN0IEJJUkRfWCA9IDEwMDsgLy8gRml4ZWQgWCBwb3NpdGlvblxyXG5jb25zdCBCSVJEX1dJRFRIID0gNTA7XHJcbmNvbnN0IEJJUkRfSEVJR0hUID0gNTA7XHJcbmNvbnN0IENPSU5fU1BFRUQgPSAyMDA7IC8vIHBpeGVscyBwZXIgc2Vjb25kXHJcbmNvbnN0IENPSU5fU1BBV05fQ0hBTkNFID0gMC4yNTsgLy8gMjUlXHJcbmNvbnN0IENPSU5fU0laRSA9IDgwO1xyXG5jb25zdCBST1RBVElPTl9TUEVFRCA9IDIgKiBNYXRoLlBJOyAvLyByYWRpYW5zIHBlciBzZWNvbmQgKGZ1bGwgcm90YXRpb24gcGVyIHNlY29uZClcclxuXHJcbi8qKlxyXG4gKiBDdXN0b20gaG9vayB0byBtYW5hZ2UgRmxhcHB5IEJpcmQgZ2FtZSBsb2dpYy5cclxuICogQHBhcmFtIGNhbnZhc1JlZiBSZWZlcmVuY2UgdG8gdGhlIGNhbnZhcyBlbGVtZW50LlxyXG4gKiBAcGFyYW0gaXNQYXVzZWQgQm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBnYW1lIGlzIHBhdXNlZC5cclxuICogQHBhcmFtIGF1dG9TdGFydCBCb29sZWFuIGluZGljYXRpbmcgaWYgdGhlIGdhbWUgc2hvdWxkIHN0YXJ0IGF1dG9tYXRpY2FsbHkuXHJcbiAqIEByZXR1cm5zIEhpZ2ggc2NvcmUsIGN1cnJlbnQgc2NvcmUsIGFuZCBhIGhhbmRsZXIgZm9yIHVzZXIgaW5wdXQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlRmxhcHB5QmlyZEdhbWUoXHJcbiAgY2FudmFzUmVmOiBSZWFjdC5SZWZPYmplY3Q8SFRNTENhbnZhc0VsZW1lbnQ+LFxyXG4gIGlzUGF1c2VkOiBib29sZWFuLFxyXG4gIGF1dG9TdGFydDogYm9vbGVhblxyXG4pIHtcclxuICAvLyBTdGF0ZSBmb3Igc2NvcmVzXHJcbiAgY29uc3QgW2hpZ2hTY29yZSwgc2V0SGlnaFNjb3JlXSA9IHVzZVN0YXRlPG51bWJlcj4oMCk7XHJcbiAgY29uc3QgW2N1cnJlbnRTY29yZSwgc2V0Q3VycmVudFNjb3JlXSA9IHVzZVN0YXRlPG51bWJlcj4oMCk7XHJcblxyXG4gIC8vIFJlZnMgdG8gdHJhY2sgZ2FtZSBzdGF0ZVxyXG4gIGNvbnN0IGJpcmRZUmVmID0gdXNlUmVmPG51bWJlcj4oMCk7XHJcbiAgY29uc3QgYmlyZFZlbG9jaXR5UmVmID0gdXNlUmVmPG51bWJlcj4oMCk7XHJcbiAgY29uc3QgcGlwZXNSZWYgPSB1c2VSZWY8UGlwZVtdPihbXSk7XHJcbiAgY29uc3QgY29pbnNSZWYgPSB1c2VSZWY8Q29pbltdPihbXSk7XHJcbiAgY29uc3QgZ2FtZU92ZXJSZWYgPSB1c2VSZWY8Ym9vbGVhbj4oZmFsc2UpO1xyXG4gIGNvbnN0IGdhbWVTdGFydGVkUmVmID0gdXNlUmVmPGJvb2xlYW4+KGZhbHNlKTtcclxuXHJcbiAgLy8gUm90YXRpb24gYW5nbGUgZm9yIGNvaW5zXHJcbiAgY29uc3QgY29pblJvdGF0aW9uUmVmID0gdXNlUmVmPG51bWJlcj4oMCk7XHJcblxyXG4gIC8vIFRpbWUgdHJhY2tpbmdcclxuICBjb25zdCBsYXN0VGltZVJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xyXG4gIGNvbnN0IHBpcGVTcGF3blRpbWVyUmVmID0gdXNlUmVmPG51bWJlcj4oMCk7XHJcblxyXG4gIC8vIFJlcXVlc3QgSUQgZm9yIGFuaW1hdGlvbiBmcmFtZVxyXG4gIGNvbnN0IHJlcXVlc3RJZFJlZiA9IHVzZVJlZjxudW1iZXIgfCBudWxsPihudWxsKTtcclxuXHJcbiAgLy8gQXNzZXQgaW1hZ2VzXHJcbiAgY29uc3QgYmlyZEltYWdlc1JlZiA9IHVzZVJlZjxIVE1MSW1hZ2VFbGVtZW50W10+KFtdKTtcclxuICBjb25zdCBwaXBlVG9wSW1nUmVmID0gdXNlUmVmPEhUTUxJbWFnZUVsZW1lbnQgfCBudWxsPihudWxsKTtcclxuICBjb25zdCBwaXBlQm90dG9tSW1nUmVmID0gdXNlUmVmPEhUTUxJbWFnZUVsZW1lbnQgfCBudWxsPihudWxsKTtcclxuICBjb25zdCBiYWNrZ3JvdW5kSW1nUmVmID0gdXNlUmVmPEhUTUxJbWFnZUVsZW1lbnQgfCBudWxsPihudWxsKTtcclxuICBjb25zdCBjb2luSW1nUmVmID0gdXNlUmVmPEhUTUxJbWFnZUVsZW1lbnQgfCBudWxsPihudWxsKTtcclxuXHJcbiAgLy8gQ3VycmVudCBiaXJkIGZyYW1lIGluZGV4IGZvciBmbGFwIGFuaW1hdGlvblxyXG4gIGNvbnN0IGN1cnJlbnRCaXJkRnJhbWVSZWYgPSB1c2VSZWY8bnVtYmVyPigxKTsgLy8gU3RhcnQgd2l0aCBtaWQtZmxhcFxyXG5cclxuICAvKipcclxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gbG9hZCBhbiBpbWFnZSBmdWxseS5cclxuICAgKiBAcGFyYW0gaW1nIEhUTUxJbWFnZUVsZW1lbnRcclxuICAgKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgaW1hZ2UgaXMgbG9hZGVkLlxyXG4gICAqL1xyXG4gIGNvbnN0IGxvYWRJbWFnZSA9IChpbWc6IEhUTUxJbWFnZUVsZW1lbnQpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGlmIChpbWcuY29tcGxldGUpIHtcclxuICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHJlc29sdmUoKTtcclxuICAgICAgICBpbWcub25lcnJvciA9ICgpID0+IHJlamVjdChuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIGltYWdlOiAke2ltZy5zcmN9YCkpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBGbGFwIGFuaW1hdGlvbiBieSBjeWNsaW5nIHRocm91Z2ggYmlyZCBmcmFtZXMuXHJcbiAgICovXHJcbiAgY29uc3QgZmxhcEFuaW1hdGlvbiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgIGNvbnN0IGZsYXBGcmFtZXMgPSBbMCwgMSwgMiwgMV07XHJcbiAgICBsZXQgY3VycmVudEZyYW1lID0gMDtcclxuICAgIGNvbnN0IGZsYXBJbnRlcnZhbCA9IDEwMDsgLy8gbWlsbGlzZWNvbmRzIGJldHdlZW4gZnJhbWVzXHJcblxyXG4gICAgY29uc3QgZmxhcCA9ICgpID0+IHtcclxuICAgICAgaWYgKGN1cnJlbnRGcmFtZSA8IGZsYXBGcmFtZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgY3VycmVudEJpcmRGcmFtZVJlZi5jdXJyZW50ID0gZmxhcEZyYW1lc1tjdXJyZW50RnJhbWVdO1xyXG4gICAgICAgIGN1cnJlbnRGcmFtZSsrO1xyXG4gICAgICAgIHNldFRpbWVvdXQoZmxhcCwgZmxhcEludGVydmFsKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjdXJyZW50QmlyZEZyYW1lUmVmLmN1cnJlbnQgPSAxOyAvLyByZXNldCB0byBtaWQtZmxhcFxyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGZsYXAoKTtcclxuICB9LCBbXSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemUgdGhlIGdhbWUgYnkgbG9hZGluZyBhc3NldHMgYW5kIHNldHRpbmcgdXAgdGhlIGNhbnZhcy5cclxuICAgKi9cclxuICBjb25zdCBpbml0aWFsaXplR2FtZSA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcclxuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xyXG4gICAgaWYgKCFjYW52YXMpIHJldHVybjtcclxuXHJcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgaWYgKCFjdHgpIHJldHVybjtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBMb2FkIGFsbCBhc3NldHNcclxuICAgICAgY29uc3QgYXNzZXRzOiBIVE1MSW1hZ2VFbGVtZW50W10gPSBbXHJcbiAgICAgICAgLi4uYmlyZEltYWdlc1JlZi5jdXJyZW50LFxyXG4gICAgICAgIHBpcGVUb3BJbWdSZWYuY3VycmVudCEsXHJcbiAgICAgICAgcGlwZUJvdHRvbUltZ1JlZi5jdXJyZW50ISxcclxuICAgICAgICBiYWNrZ3JvdW5kSW1nUmVmLmN1cnJlbnQhLFxyXG4gICAgICAgIGNvaW5JbWdSZWYuY3VycmVudCEsXHJcbiAgICAgIF07XHJcblxyXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChcclxuICAgICAgICBhc3NldHMubWFwKChpbWcpID0+IChpbWcgPyBsb2FkSW1hZ2UoaW1nKSA6IFByb21pc2UucmVzb2x2ZSgpKSlcclxuICAgICAgKTtcclxuICAgICAgY29uc29sZS5sb2coXCJBbGwgYXNzZXRzIGxvYWRlZCBzdWNjZXNzZnVsbHkhXCIpO1xyXG5cclxuICAgICAgLy8gU2V0IGNhbnZhcyBkaW1lbnNpb25zXHJcbiAgICAgIGNhbnZhcy53aWR0aCA9IDM2MDtcclxuICAgICAgY2FudmFzLmhlaWdodCA9IDY0MDtcclxuXHJcbiAgICAgIC8vIERyYXcgc3RhcnQgc2NyZWVuXHJcbiAgICAgIGRyYXdTdGFydFNjcmVlbihjdHgsIGNhbnZhcyk7XHJcblxyXG4gICAgICAvLyBBdXRvLXN0YXJ0IGlmIGVuYWJsZWRcclxuICAgICAgaWYgKGF1dG9TdGFydCkge1xyXG4gICAgICAgIHN0YXJ0R2FtZSgpO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgbG9hZGluZyBhc3NldHM6XCIsIGVycm9yKTtcclxuICAgIH1cclxuICB9LCBbY2FudmFzUmVmLCBhdXRvU3RhcnRdKTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVuZGVyIHRoZSBzdGFydCBzY3JlZW4uXHJcbiAgICogQHBhcmFtIGN0eCBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcclxuICAgKiBAcGFyYW0gY2FudmFzIENhbnZhcyBlbGVtZW50XHJcbiAgICovXHJcbiAgY29uc3QgZHJhd1N0YXJ0U2NyZWVuID0gdXNlQ2FsbGJhY2soXHJcbiAgICAoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpID0+IHtcclxuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG5cclxuICAgICAgLy8gRHJhdyBiYWNrZ3JvdW5kXHJcbiAgICAgIGlmIChiYWNrZ3JvdW5kSW1nUmVmLmN1cnJlbnQ/LmNvbXBsZXRlKSB7XHJcbiAgICAgICAgY3R4LmRyYXdJbWFnZShiYWNrZ3JvdW5kSW1nUmVmLmN1cnJlbnQsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIERyYXcgc3RhcnQgdGV4dFxyXG4gICAgICBjdHguZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xyXG4gICAgICBjdHguZm9udCA9IFwiYm9sZCAzMHB4IEFyaWFsXCI7XHJcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xyXG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcclxuICAgICAgY3R4LmZpbGxUZXh0KFwiUHJlc3MgU3BhY2Ugb3IgVGFwIHRvIFN0YXJ0XCIsIGNhbnZhcy53aWR0aCAvIDIsIGNhbnZhcy5oZWlnaHQgLyAyKTtcclxuICAgIH0sXHJcbiAgICBbXVxyXG4gICk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbmRlciB0aGUgZ2FtZSBvdmVyIHNjcmVlbi5cclxuICAgKiBAcGFyYW0gY3R4IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRFxyXG4gICAqIEBwYXJhbSBjYW52YXMgQ2FudmFzIGVsZW1lbnRcclxuICAgKi9cclxuICBjb25zdCBkcmF3R2FtZU92ZXJTY3JlZW4gPSB1c2VDYWxsYmFjayhcclxuICAgIChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkgPT4ge1xyXG4gICAgICAvLyBEcmF3IHNlbWktdHJhbnNwYXJlbnQgb3ZlcmxheVxyXG4gICAgICBjdHguZmlsbFN0eWxlID0gXCJyZ2JhKDAsIDAsIDAsIDAuNSlcIjtcclxuICAgICAgY3R4LmZpbGxSZWN0KDAsIGNhbnZhcy5oZWlnaHQgLyAyIC0gMTAwLCBjYW52YXMud2lkdGgsIDIwMCk7XHJcblxyXG4gICAgICAvLyBEcmF3IEdhbWUgT3ZlciB0ZXh0XHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNmZmNjMDBcIjtcclxuICAgICAgY3R4LmZvbnQgPSBcImJvbGQgNTBweCBBcmlhbFwiO1xyXG4gICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcclxuICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XHJcbiAgICAgIGN0eC5maWxsVGV4dChcIkdhbWUgT3ZlciFcIiwgY2FudmFzLndpZHRoIC8gMiwgY2FudmFzLmhlaWdodCAvIDIgLSA0MCk7XHJcblxyXG4gICAgICAvLyBEcmF3IHJlc3RhcnQgcHJvbXB0XHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBcIndoaXRlXCI7XHJcbiAgICAgIGN0eC5mb250ID0gXCJib2xkIDMwcHggQXJpYWxcIjtcclxuICAgICAgY3R4LmZpbGxUZXh0KFwiUHJlc3MgU3BhY2Ugb3IgVGFwIHRvIFJlc3RhcnRcIiwgY2FudmFzLndpZHRoIC8gMiwgY2FudmFzLmhlaWdodCAvIDIgKyAyMCk7XHJcbiAgICB9LFxyXG4gICAgW11cclxuICApO1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgcGlwZSB3aXRoIGEgcmFuZG9tIGdhcCBwb3NpdGlvbiBhbmQgcG9zc2libHkgc3Bhd24gYSBjb2luLlxyXG4gICAqL1xyXG4gIGNvbnN0IGNyZWF0ZVBpcGUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcclxuICAgIGlmICghY2FudmFzKSByZXR1cm47XHJcbiAgICBjb25zdCBnYXBZID0gTWF0aC5yYW5kb20oKSAqIChjYW52YXMuaGVpZ2h0IC0gUElQRV9HQVAgLSAyMDApICsgMTAwOyAvLyBFbnN1cmUgZ2FwIGlzIG5vdCB0b28gY2xvc2UgdG8gdG9wIG9yIGJvdHRvbVxyXG4gICAgcGlwZXNSZWYuY3VycmVudC5wdXNoKHtcclxuICAgICAgeDogY2FudmFzLndpZHRoLFxyXG4gICAgICBnYXBZLFxyXG4gICAgICBzY29yZWQ6IGZhbHNlLFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gMjUlIGNoYW5jZSB0byBzcGF3biBhIGNvaW5cclxuICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgQ09JTl9TUEFXTl9DSEFOQ0UpIHtcclxuICAgICAgY29pbnNSZWYuY3VycmVudC5wdXNoKHtcclxuICAgICAgICB4OiBjYW52YXMud2lkdGggKyBQSVBFX1dJRFRIIC8gMiAtIENPSU5fU0laRSAvIDIsXHJcbiAgICAgICAgeTogZ2FwWSArIFBJUEVfR0FQIC8gMiAtIENPSU5fU0laRSAvIDIsXHJcbiAgICAgICAgd2lkdGg6IENPSU5fU0laRSxcclxuICAgICAgICBoZWlnaHQ6IENPSU5fU0laRSxcclxuICAgICAgICBjb2xsZWN0ZWQ6IGZhbHNlLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9LCBbXSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSB0aGUgZ2FtZSBzdGF0ZSBiYXNlZCBvbiBlbGFwc2VkIHRpbWUuXHJcbiAgICogQHBhcmFtIGRlbHRhVGltZSBUaW1lIGVsYXBzZWQgc2luY2UgbGFzdCBmcmFtZSAoaW4gc2Vjb25kcylcclxuICAgKi9cclxuICBjb25zdCB1cGRhdGVHYW1lU3RhdGUgPSB1c2VDYWxsYmFjayhcclxuICAgIChkZWx0YVRpbWU6IG51bWJlcikgPT4ge1xyXG4gICAgICAvLyBBcHBseSBncmF2aXR5IHRvIHRoZSBiaXJkXHJcbiAgICAgIGJpcmRWZWxvY2l0eVJlZi5jdXJyZW50ICs9IEdSQVZJVFkgKiBkZWx0YVRpbWU7XHJcbiAgICAgIGJpcmRZUmVmLmN1cnJlbnQgKz0gYmlyZFZlbG9jaXR5UmVmLmN1cnJlbnQgKiBkZWx0YVRpbWU7XHJcblxyXG4gICAgICAvLyBVcGRhdGUgcGlwZSBzcGF3biB0aW1lciBhbmQgc3Bhd24gcGlwZXMgYXQgaW50ZXJ2YWxzXHJcbiAgICAgIHBpcGVTcGF3blRpbWVyUmVmLmN1cnJlbnQgKz0gZGVsdGFUaW1lO1xyXG4gICAgICBpZiAocGlwZVNwYXduVGltZXJSZWYuY3VycmVudCA+IFBJUEVfU1BBV05fSU5URVJWQUwgLyAxMDAwKSB7XHJcbiAgICAgICAgY3JlYXRlUGlwZSgpO1xyXG4gICAgICAgIHBpcGVTcGF3blRpbWVyUmVmLmN1cnJlbnQgPSAwO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBNb3ZlIHBpcGVzIGJhc2VkIG9uIFBJUEVfU1BFRUQgYW5kIGRlbHRhVGltZVxyXG4gICAgICBjb25zdCBwaXBlTW92ZURlbHRhID0gUElQRV9TUEVFRCAqIGRlbHRhVGltZTtcclxuICAgICAgcGlwZXNSZWYuY3VycmVudCA9IHBpcGVzUmVmLmN1cnJlbnQubWFwKChwaXBlKSA9PiAoe1xyXG4gICAgICAgIC4uLnBpcGUsXHJcbiAgICAgICAgeDogcGlwZS54IC0gcGlwZU1vdmVEZWx0YSxcclxuICAgICAgfSkpO1xyXG5cclxuICAgICAgLy8gUmVtb3ZlIG9mZnNjcmVlbiBwaXBlc1xyXG4gICAgICBwaXBlc1JlZi5jdXJyZW50ID0gcGlwZXNSZWYuY3VycmVudC5maWx0ZXIoKHBpcGUpID0+IHBpcGUueCArIFBJUEVfV0lEVEggPiAwKTtcclxuXHJcbiAgICAgIC8vIE1vdmUgY29pbnMgYmFzZWQgb24gQ09JTl9TUEVFRCBhbmQgZGVsdGFUaW1lXHJcbiAgICAgIGNvbnN0IGNvaW5Nb3ZlRGVsdGEgPSBDT0lOX1NQRUVEICogZGVsdGFUaW1lO1xyXG4gICAgICBjb2luc1JlZi5jdXJyZW50ID0gY29pbnNSZWYuY3VycmVudC5tYXAoKGNvaW4pID0+ICh7XHJcbiAgICAgICAgLi4uY29pbixcclxuICAgICAgICB4OiBjb2luLnggLSBjb2luTW92ZURlbHRhLFxyXG4gICAgICB9KSk7XHJcblxyXG4gICAgICAvLyBSZW1vdmUgb2Zmc2NyZWVuIG9yIGNvbGxlY3RlZCBjb2luc1xyXG4gICAgICBjb2luc1JlZi5jdXJyZW50ID0gY29pbnNSZWYuY3VycmVudC5maWx0ZXIoXHJcbiAgICAgICAgKGNvaW4pID0+IGNvaW4ueCArIGNvaW4ud2lkdGggPiAwICYmICFjb2luLmNvbGxlY3RlZFxyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gUm90YXRlIGNvaW5zIGZvciB2aXN1YWwgZWZmZWN0XHJcbiAgICAgIGNvaW5Sb3RhdGlvblJlZi5jdXJyZW50ICs9IFJPVEFUSU9OX1NQRUVEICogZGVsdGFUaW1lO1xyXG4gICAgICBpZiAoY29pblJvdGF0aW9uUmVmLmN1cnJlbnQgPj0gMiAqIE1hdGguUEkpIHtcclxuICAgICAgICBjb2luUm90YXRpb25SZWYuY3VycmVudCAtPSAyICogTWF0aC5QSTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2hlY2sgZm9yIGNvbGxpc2lvbnNcclxuICAgICAgaWYgKGNoZWNrQ29sbGlzaW9ucygpKSB7XHJcbiAgICAgICAgZ2FtZU92ZXJSZWYuY3VycmVudCA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDaGVjayBpZiBiaXJkIGNvbGxlY3RzIGFueSBjb2luc1xyXG4gICAgICBjaGVja0NvaW5Db2xsZWN0aW9uKCk7XHJcblxyXG4gICAgICAvLyBVcGRhdGUgdGhlIHNjb3JlIGJhc2VkIG9uIHBpcGUgcGFzc2luZ1xyXG4gICAgICB1cGRhdGVTY29yZSgpO1xyXG4gICAgfSxcclxuICAgIFtjcmVhdGVQaXBlXVxyXG4gICk7XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIGZvciBjb2xsaXNpb25zIGJldHdlZW4gdGhlIGJpcmQgYW5kIHBpcGVzIG9yIGJvdW5kYXJpZXMuXHJcbiAgICogQHJldHVybnMgQm9vbGVhbiBpbmRpY2F0aW5nIGlmIGEgY29sbGlzaW9uIG9jY3VycmVkXHJcbiAgICovXHJcbiAgY29uc3QgY2hlY2tDb2xsaXNpb25zID0gdXNlQ2FsbGJhY2soKCk6IGJvb2xlYW4gPT4ge1xyXG4gICAgLy8gQXNzdW1pbmcgY2FudmFzIGhlaWdodCBpcyBmaXhlZCBhdCA2NDBcclxuICAgIGlmIChiaXJkWVJlZi5jdXJyZW50IDwgMCB8fCBiaXJkWVJlZi5jdXJyZW50ICsgQklSRF9IRUlHSFQgPiA2NDApIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYmlyZExlZnQgPSBCSVJEX1g7XHJcbiAgICBjb25zdCBiaXJkUmlnaHQgPSBCSVJEX1ggKyBCSVJEX1dJRFRIO1xyXG4gICAgY29uc3QgYmlyZFRvcCA9IGJpcmRZUmVmLmN1cnJlbnQ7XHJcbiAgICBjb25zdCBiaXJkQm90dG9tID0gYmlyZFlSZWYuY3VycmVudCArIEJJUkRfSEVJR0hUO1xyXG5cclxuICAgIC8vIENoZWNrIGNvbGxpc2lvbiB3aXRoIGVhY2ggcGlwZVxyXG4gICAgZm9yIChjb25zdCBwaXBlIG9mIHBpcGVzUmVmLmN1cnJlbnQpIHtcclxuICAgICAgY29uc3QgcGlwZUxlZnQgPSBwaXBlLng7XHJcbiAgICAgIGNvbnN0IHBpcGVSaWdodCA9IHBpcGUueCArIFBJUEVfV0lEVEg7XHJcblxyXG4gICAgICAvLyBJZiBiaXJkIGlzIHdpdGhpbiBwaXBlJ3MgaG9yaXpvbnRhbCBib3VuZHNcclxuICAgICAgaWYgKGJpcmRSaWdodCA+IHBpcGVMZWZ0ICYmIGJpcmRMZWZ0IDwgcGlwZVJpZ2h0KSB7XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgYmlyZCBpcyB3aXRoaW4gdGhlIGdhcFxyXG4gICAgICAgIGlmIChiaXJkVG9wIDwgcGlwZS5nYXBZIHx8IGJpcmRCb3R0b20gPiBwaXBlLmdhcFkgKyBQSVBFX0dBUCkge1xyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH0sIFtdKTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgdGhlIGJpcmQgaGFzIGNvbGxlY3RlZCBhbnkgY29pbnMuXHJcbiAgICovXHJcbiAgY29uc3QgY2hlY2tDb2luQ29sbGVjdGlvbiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgIGNvbnN0IGJpcmRMZWZ0ID0gQklSRF9YO1xyXG4gICAgY29uc3QgYmlyZFJpZ2h0ID0gQklSRF9YICsgQklSRF9XSURUSDtcclxuICAgIGNvbnN0IGJpcmRUb3AgPSBiaXJkWVJlZi5jdXJyZW50O1xyXG4gICAgY29uc3QgYmlyZEJvdHRvbSA9IGJpcmRZUmVmLmN1cnJlbnQgKyBCSVJEX0hFSUdIVDtcclxuXHJcbiAgICBmb3IgKGNvbnN0IGNvaW4gb2YgY29pbnNSZWYuY3VycmVudCkge1xyXG4gICAgICBpZiAoIWNvaW4uY29sbGVjdGVkKSB7XHJcbiAgICAgICAgY29uc3QgY29pbkxlZnQgPSBjb2luLng7XHJcbiAgICAgICAgY29uc3QgY29pblJpZ2h0ID0gY29pbi54ICsgY29pbi53aWR0aDtcclxuICAgICAgICBjb25zdCBjb2luVG9wID0gY29pbi55O1xyXG4gICAgICAgIGNvbnN0IGNvaW5Cb3R0b20gPSBjb2luLnkgKyBjb2luLmhlaWdodDtcclxuXHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgYmlyZFJpZ2h0ID4gY29pbkxlZnQgJiZcclxuICAgICAgICAgIGJpcmRMZWZ0IDwgY29pblJpZ2h0ICYmXHJcbiAgICAgICAgICBiaXJkQm90dG9tID4gY29pblRvcCAmJlxyXG4gICAgICAgICAgYmlyZFRvcCA8IGNvaW5Cb3R0b21cclxuICAgICAgICApIHtcclxuICAgICAgICAgIGNvaW4uY29sbGVjdGVkID0gdHJ1ZTtcclxuICAgICAgICAgIHNldEN1cnJlbnRTY29yZSgocHJldlNjb3JlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1Njb3JlID0gcHJldlNjb3JlICsgNTtcclxuICAgICAgICAgICAgc2V0SGlnaFNjb3JlKChwcmV2SGlnaFNjb3JlKSA9PiB7XHJcbiAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZEhpZ2hTY29yZSA9IE1hdGgubWF4KHByZXZIaWdoU2NvcmUsIG5ld1Njb3JlKTtcclxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJoaWdoU2NvcmVcIiwgdXBkYXRlZEhpZ2hTY29yZS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZWRIaWdoU2NvcmU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3U2NvcmU7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LCBbXSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSB0aGUgc2NvcmUgd2hlbiB0aGUgYmlyZCBwYXNzZXMgYSBwaXBlLlxyXG4gICAqL1xyXG4gIGNvbnN0IHVwZGF0ZVNjb3JlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgZm9yIChjb25zdCBwaXBlIG9mIHBpcGVzUmVmLmN1cnJlbnQpIHtcclxuICAgICAgLy8gU2NvcmUgKzEgZm9yIHBhc3NpbmcgZWFjaCBwaXBlIG9uY2VcclxuICAgICAgaWYgKCFwaXBlLnNjb3JlZCAmJiBwaXBlLnggKyBQSVBFX1dJRFRIIDwgQklSRF9YKSB7XHJcbiAgICAgICAgc2V0Q3VycmVudFNjb3JlKChwcmV2U2NvcmUpID0+IHtcclxuICAgICAgICAgIGNvbnN0IG5ld1Njb3JlID0gcHJldlNjb3JlICsgMTtcclxuICAgICAgICAgIHNldEhpZ2hTY29yZSgocHJldkhpZ2hTY29yZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkSGlnaFNjb3JlID0gTWF0aC5tYXgocHJldkhpZ2hTY29yZSwgbmV3U2NvcmUpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwiaGlnaFNjb3JlXCIsIHVwZGF0ZWRIaWdoU2NvcmUudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZWRIaWdoU2NvcmU7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHJldHVybiBuZXdTY29yZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBwaXBlLnNjb3JlZCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LCBbXSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbmRlciBhbGwgZ2FtZSBlbGVtZW50cyBvbnRvIHRoZSBjYW52YXMuXHJcbiAgICogQHBhcmFtIGN0eCBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcclxuICAgKiBAcGFyYW0gY2FudmFzIENhbnZhcyBlbGVtZW50XHJcbiAgICovXHJcbiAgY29uc3QgZHJhdyA9IHVzZUNhbGxiYWNrKFxyXG4gICAgKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSA9PiB7XHJcbiAgICAgIC8vIENsZWFyIHRoZSBjYW52YXNcclxuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG5cclxuICAgICAgLy8gRHJhdyBiYWNrZ3JvdW5kXHJcbiAgICAgIGlmIChiYWNrZ3JvdW5kSW1nUmVmLmN1cnJlbnQ/LmNvbXBsZXRlKSB7XHJcbiAgICAgICAgY3R4LmRyYXdJbWFnZShiYWNrZ3JvdW5kSW1nUmVmLmN1cnJlbnQsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIERyYXcgcGlwZXNcclxuICAgICAgZm9yIChjb25zdCBwaXBlIG9mIHBpcGVzUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAvLyBUb3AgcGlwZVxyXG4gICAgICAgIGlmIChwaXBlVG9wSW1nUmVmLmN1cnJlbnQ/LmNvbXBsZXRlKSB7XHJcbiAgICAgICAgICBjdHguZHJhd0ltYWdlKHBpcGVUb3BJbWdSZWYuY3VycmVudCwgcGlwZS54LCAwLCBQSVBFX1dJRFRILCBwaXBlLmdhcFkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQm90dG9tIHBpcGVcclxuICAgICAgICBpZiAocGlwZUJvdHRvbUltZ1JlZi5jdXJyZW50Py5jb21wbGV0ZSkge1xyXG4gICAgICAgICAgY3R4LmRyYXdJbWFnZShcclxuICAgICAgICAgICAgcGlwZUJvdHRvbUltZ1JlZi5jdXJyZW50LFxyXG4gICAgICAgICAgICBwaXBlLngsXHJcbiAgICAgICAgICAgIHBpcGUuZ2FwWSArIFBJUEVfR0FQLFxyXG4gICAgICAgICAgICBQSVBFX1dJRFRILFxyXG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0IC0gKHBpcGUuZ2FwWSArIFBJUEVfR0FQKVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIERyYXcgY29pbnNcclxuICAgICAgZm9yIChjb25zdCBjb2luIG9mIGNvaW5zUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBpZiAoIWNvaW4uY29sbGVjdGVkICYmIGNvaW5JbWdSZWYuY3VycmVudD8uY29tcGxldGUpIHtcclxuICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICBjdHgudHJhbnNsYXRlKGNvaW4ueCArIGNvaW4ud2lkdGggLyAyLCBjb2luLnkgKyBjb2luLmhlaWdodCAvIDIpO1xyXG4gICAgICAgICAgY3R4LnJvdGF0ZShjb2luUm90YXRpb25SZWYuY3VycmVudCk7XHJcbiAgICAgICAgICBjdHguZHJhd0ltYWdlKFxyXG4gICAgICAgICAgICBjb2luSW1nUmVmLmN1cnJlbnQsXHJcbiAgICAgICAgICAgIC1jb2luLndpZHRoIC8gMixcclxuICAgICAgICAgICAgLWNvaW4uaGVpZ2h0IC8gMixcclxuICAgICAgICAgICAgY29pbi53aWR0aCxcclxuICAgICAgICAgICAgY29pbi5oZWlnaHRcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRHJhdyBiaXJkXHJcbiAgICAgIGNvbnN0IGN1cnJlbnRCaXJkRnJhbWUgPSBiaXJkSW1hZ2VzUmVmLmN1cnJlbnRbY3VycmVudEJpcmRGcmFtZVJlZi5jdXJyZW50XTtcclxuICAgICAgaWYgKGN1cnJlbnRCaXJkRnJhbWU/LmNvbXBsZXRlKSB7XHJcbiAgICAgICAgY3R4LmRyYXdJbWFnZShcclxuICAgICAgICAgIGN1cnJlbnRCaXJkRnJhbWUsXHJcbiAgICAgICAgICBCSVJEX1gsXHJcbiAgICAgICAgICBiaXJkWVJlZi5jdXJyZW50LFxyXG4gICAgICAgICAgQklSRF9XSURUSCxcclxuICAgICAgICAgIEJJUkRfSEVJR0hUXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIFtdXHJcbiAgKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIG1haW4gZ2FtZSBsb29wIHVzaW5nIHJlcXVlc3RBbmltYXRpb25GcmFtZS5cclxuICAgKiBAcGFyYW0gdGltZXN0YW1wIEN1cnJlbnQgdGltZXN0YW1wXHJcbiAgICovXHJcbiAgY29uc3QgYW5pbWF0ZSA9IHVzZUNhbGxiYWNrKFxyXG4gICAgKHRpbWVzdGFtcDogbnVtYmVyKSA9PiB7XHJcbiAgICAgIGlmIChpc1BhdXNlZCB8fCAhZ2FtZVN0YXJ0ZWRSZWYuY3VycmVudCkge1xyXG4gICAgICAgIHJlcXVlc3RJZFJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFsYXN0VGltZVJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgbGFzdFRpbWVSZWYuY3VycmVudCA9IHRpbWVzdGFtcDtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IGRlbHRhVGltZSA9ICh0aW1lc3RhbXAgLSBsYXN0VGltZVJlZi5jdXJyZW50KSAvIDEwMDA7IC8vIGluIHNlY29uZHNcclxuICAgICAgLy8gQ2FwIGRlbHRhVGltZSB0byAwLjA1IHNlY29uZHMgdG8gcHJldmVudCBiaWcganVtcHNcclxuICAgICAgZGVsdGFUaW1lID0gTWF0aC5taW4oZGVsdGFUaW1lLCAwLjA1KTtcclxuICAgICAgbGFzdFRpbWVSZWYuY3VycmVudCA9IHRpbWVzdGFtcDtcclxuXHJcbiAgICAgIC8vIFVwZGF0ZSBnYW1lIHN0YXRlXHJcbiAgICAgIHVwZGF0ZUdhbWVTdGF0ZShkZWx0YVRpbWUpO1xyXG5cclxuICAgICAgLy8gRHJhdyBldmVyeXRoaW5nXHJcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xyXG4gICAgICBpZiAoY2FudmFzKSB7XHJcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuICAgICAgICBpZiAoY3R4KSB7XHJcbiAgICAgICAgICBkcmF3KGN0eCwgY2FudmFzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghZ2FtZU92ZXJSZWYuY3VycmVudCkge1xyXG4gICAgICAgIHJlcXVlc3RJZFJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIERyYXcgZ2FtZSBvdmVyIHNjcmVlblxyXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xyXG4gICAgICAgIGlmIChjYW52YXMpIHtcclxuICAgICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICAgICAgICBpZiAoY3R4KSB7XHJcbiAgICAgICAgICAgIGRyYXdHYW1lT3ZlclNjcmVlbihjdHgsIGNhbnZhcyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgW2lzUGF1c2VkLCB1cGRhdGVHYW1lU3RhdGUsIGRyYXcsIGRyYXdHYW1lT3ZlclNjcmVlbl1cclxuICApO1xyXG5cclxuICAvKipcclxuICAgKiBTdGFydCB0aGUgZ2FtZSBieSByZXNldHRpbmcgdGhlIHN0YXRlIGFuZCBpbml0aWF0aW5nIHRoZSBnYW1lIGxvb3AuXHJcbiAgICovXHJcbiAgY29uc3Qgc3RhcnRHYW1lID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgcmVzZXRHYW1lKCk7XHJcbiAgICBnYW1lU3RhcnRlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcclxuICAgIGxhc3RUaW1lUmVmLmN1cnJlbnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgIHJlcXVlc3RJZFJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4gIH0sIFtyZXNldEdhbWUsIGFuaW1hdGVdKTtcclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlIHVzZXIgaW5wdXQgKGNsaWNrL3RhcCkgYnkgZmxhcHBpbmcgb3IgcmVzdGFydGluZy5cclxuICAgKi9cclxuICBjb25zdCBoYW5kbGVVc2VySW5wdXQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICBpZiAoIWdhbWVTdGFydGVkUmVmLmN1cnJlbnQgJiYgIWdhbWVPdmVyUmVmLmN1cnJlbnQpIHtcclxuICAgICAgc3RhcnRHYW1lKCk7XHJcbiAgICB9IGVsc2UgaWYgKGdhbWVPdmVyUmVmLmN1cnJlbnQpIHtcclxuICAgICAgc3RhcnRHYW1lKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBiaXJkVmVsb2NpdHlSZWYuY3VycmVudCA9IEZMQVBfVkVMT0NJVFk7XHJcbiAgICAgIGZsYXBBbmltYXRpb24oKTtcclxuICAgIH1cclxuICB9LCBbc3RhcnRHYW1lLCBmbGFwQW5pbWF0aW9uXSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZSBrZXlkb3duIGV2ZW50cyBmb3Igc3BhY2UgYmFyIHRvIGZsYXAgb3IgcmVzdGFydC5cclxuICAgKiBAcGFyYW0gZSBLZXlib2FyZEV2ZW50XHJcbiAgICovXHJcbiAgY29uc3QgaGFuZGxlS2V5RG93biA9IHVzZUNhbGxiYWNrKFxyXG4gICAgKGU6IEtleWJvYXJkRXZlbnQpID0+IHtcclxuICAgICAgaWYgKGUua2V5ID09PSBcIiBcIikge1xyXG4gICAgICAgIGhhbmRsZVVzZXJJbnB1dCgpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgW2hhbmRsZVVzZXJJbnB1dF1cclxuICApO1xyXG5cclxuICAvKipcclxuICAgKiBBZGQga2V5ZG93biBldmVudCBsaXN0ZW5lciBvbiBtb3VudC5cclxuICAgKi9cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGhhbmRsZUtleURvd24pO1xyXG4gICAgcmV0dXJuICgpID0+IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBoYW5kbGVLZXlEb3duKTtcclxuICB9LCBbaGFuZGxlS2V5RG93bl0pO1xyXG5cclxuICAvKipcclxuICAgKiBDbGVhbnVwIG9uIHVubW91bnQuXHJcbiAgICovXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGlmIChyZXF1ZXN0SWRSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJlcXVlc3RJZFJlZi5jdXJyZW50KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9LCBbXSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemUgdGhlIGdhbWUgYnkgbG9hZGluZyBhc3NldHMuXHJcbiAgICovXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGluaXRpYWxpemVHYW1lKCk7XHJcbiAgfSwgW2luaXRpYWxpemVHYW1lXSk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBoaWdoU2NvcmUsXHJcbiAgICBjdXJyZW50U2NvcmUsXHJcbiAgICBoYW5kbGVVc2VySW5wdXQsXHJcbiAgfTtcclxufVxyXG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsIkdSQVZJVFkiLCJGTEFQX1ZFTE9DSVRZIiwiUElQRV9TUEVFRCIsIlBJUEVfU1BBV05fSU5URVJWQUwiLCJQSVBFX1dJRFRIIiwiUElQRV9HQVAiLCJCSVJEX1giLCJCSVJEX1dJRFRIIiwiQklSRF9IRUlHSFQiLCJDT0lOX1NQRUVEIiwiQ09JTl9TUEFXTl9DSEFOQ0UiLCJDT0lOX1NJWkUiLCJST1RBVElPTl9TUEVFRCIsIk1hdGgiLCJQSSIsInVzZUZsYXBweUJpcmRHYW1lIiwiY2FudmFzUmVmIiwiaXNQYXVzZWQiLCJhdXRvU3RhcnQiLCJoaWdoU2NvcmUiLCJzZXRIaWdoU2NvcmUiLCJjdXJyZW50U2NvcmUiLCJzZXRDdXJyZW50U2NvcmUiLCJiaXJkWVJlZiIsImJpcmRWZWxvY2l0eVJlZiIsInBpcGVzUmVmIiwiY29pbnNSZWYiLCJnYW1lT3ZlclJlZiIsImdhbWVTdGFydGVkUmVmIiwiY29pblJvdGF0aW9uUmVmIiwibGFzdFRpbWVSZWYiLCJwaXBlU3Bhd25UaW1lclJlZiIsInJlcXVlc3RJZFJlZiIsImJpcmRJbWFnZXNSZWYiLCJwaXBlVG9wSW1nUmVmIiwicGlwZUJvdHRvbUltZ1JlZiIsImJhY2tncm91bmRJbWdSZWYiLCJjb2luSW1nUmVmIiwiY3VycmVudEJpcmRGcmFtZVJlZiIsImxvYWRJbWFnZSIsImltZyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiY29tcGxldGUiLCJvbmxvYWQiLCJvbmVycm9yIiwiRXJyb3IiLCJzcmMiLCJmbGFwQW5pbWF0aW9uIiwiZmxhcEZyYW1lcyIsImN1cnJlbnRGcmFtZSIsImZsYXBJbnRlcnZhbCIsImZsYXAiLCJsZW5ndGgiLCJjdXJyZW50Iiwic2V0VGltZW91dCIsImluaXRpYWxpemVHYW1lIiwiY2FudmFzIiwiY3R4IiwiZ2V0Q29udGV4dCIsImFzc2V0cyIsImFsbCIsIm1hcCIsImNvbnNvbGUiLCJsb2ciLCJ3aWR0aCIsImhlaWdodCIsImRyYXdTdGFydFNjcmVlbiIsInN0YXJ0R2FtZSIsImVycm9yIiwiY2xlYXJSZWN0IiwiZHJhd0ltYWdlIiwiZmlsbFN0eWxlIiwiZm9udCIsInRleHRBbGlnbiIsInRleHRCYXNlbGluZSIsImZpbGxUZXh0IiwiZHJhd0dhbWVPdmVyU2NyZWVuIiwiZmlsbFJlY3QiLCJjcmVhdGVQaXBlIiwiZ2FwWSIsInJhbmRvbSIsInB1c2giLCJ4Iiwic2NvcmVkIiwieSIsImNvbGxlY3RlZCIsInVwZGF0ZUdhbWVTdGF0ZSIsImRlbHRhVGltZSIsInBpcGVNb3ZlRGVsdGEiLCJwaXBlIiwiZmlsdGVyIiwiY29pbk1vdmVEZWx0YSIsImNvaW4iLCJjaGVja0NvbGxpc2lvbnMiLCJjaGVja0NvaW5Db2xsZWN0aW9uIiwidXBkYXRlU2NvcmUiLCJiaXJkTGVmdCIsImJpcmRSaWdodCIsImJpcmRUb3AiLCJiaXJkQm90dG9tIiwicGlwZUxlZnQiLCJwaXBlUmlnaHQiLCJjb2luTGVmdCIsImNvaW5SaWdodCIsImNvaW5Ub3AiLCJjb2luQm90dG9tIiwicHJldlNjb3JlIiwibmV3U2NvcmUiLCJwcmV2SGlnaFNjb3JlIiwidXBkYXRlZEhpZ2hTY29yZSIsIm1heCIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJ0b1N0cmluZyIsImRyYXciLCJzYXZlIiwidHJhbnNsYXRlIiwicm90YXRlIiwicmVzdG9yZSIsImN1cnJlbnRCaXJkRnJhbWUiLCJhbmltYXRlIiwidGltZXN0YW1wIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibWluIiwicmVzZXRHYW1lIiwicGVyZm9ybWFuY2UiLCJub3ciLCJoYW5kbGVVc2VySW5wdXQiLCJoYW5kbGVLZXlEb3duIiwiZSIsImtleSIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./public/useFlappyBirdGame.ts\n"));

/***/ })

});