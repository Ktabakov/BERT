"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./contracts/vesting.hl":
/*!******************************!*\
  !*** ./contracts/vesting.hl ***!
  \******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Program; }\n/* harmony export */ });\n/* harmony import */ var _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hyperionbt/helios */ \"./node_modules/@hyperionbt/helios/helios.js\");\n\n//wraps helios.Program\nclass Program {\n    #program\n\n    constructor(parameters = {}) {\n        // load all the dependencies\n        const allDeps = []\n\n        const depSrcs = new Map()\n\n        function addDepSrcs(dep) {\n            depSrcs.set(dep.name, dep.src)\n\n            for (let d of dep.dependencies) {\n                addDepSrcs(d)\n            }\n        }\n\n        for (let d of allDeps) {\n            addDepSrcs(d)\n        }\n\n        this.#program = _hyperionbt_helios__WEBPACK_IMPORTED_MODULE_0__.Program.new(`spending vesting\r\n/* \r\n Create a datum with the benefitiary PubKeyHash that will be included \r\n into each UTXO locked at this script address.\r\n*/\r\nstruct Datum {\r\n    benefitiary: PubKeyHash\r\n}\r\n\r\n/*\r\n The vesting contract can be either canceled by the benefitiary\r\n or claimed by the beneficiary\r\n */\r\nenum Redeemer {\r\n    Cancel\r\n    Claim {\r\n        recepiant: PubKeyHash\r\n    }\r\n}\r\n\r\nconst TOKEN_POLICY_ID: MintingPolicyHash = MintingPolicyHash::new(#e16c2dc8ae937e8d3790c7fd7168d7b994621ba14ca11415f39fed72)\r\n   \r\nconst HALVING_PERIOD: Int = 2592000  // 1 month in seconds\r\nconst MAX_HALVINGS: Int = 5\r\nconst BASE_REWARD: Int = 1000  // Initial reward in tokens\r\n\r\nfunc calculate_reward(current_time: Time) -> Int {\r\n    // Start contract at \r\n    TimeBeginContract: Time = Time::new(1733665500000);  \r\n\r\n    // Calculate time elapsed in seconds\r\n    time_elapsed: Duration = current_time - TimeBeginContract;\r\n    time_elapsed_in_seconds: Int = time_elapsed / Duration::new(1_000);  // Convert to seconds\r\n\r\n    // Calculate the number of halving periods (each period is 1 month)\r\n    halving_steps: Int = time_elapsed_in_seconds / HALVING_PERIOD;\r\n    print(current_time.show());\r\n    // Ensure the number of halvings doesn't exceed the maximum allowed\r\n    halving_steps = if (halving_steps > MAX_HALVINGS) { MAX_HALVINGS } else { halving_steps };\r\n    print(halving_steps.show());\r\n    // Calculate reward using simple multiplication and division\r\n    if (halving_steps == 0) {\r\n        BASE_REWARD\r\n    } else if (halving_steps == 1) {\r\n        BASE_REWARD / 2\r\n    } else if (halving_steps == 2) {\r\n        BASE_REWARD / 4\r\n    } else if (halving_steps == 3) {\r\n        BASE_REWARD / 8\r\n    } else if (halving_steps == 4) {\r\n        BASE_REWARD / 16\r\n    } else {\r\n        BASE_REWARD / 32\r\n    }\r\n\r\n}\r\n\r\nconst CLAIM_WINDOW: Int = 540 \r\nconst CYCLE_DURATION: Int = 540 \r\n\r\nfunc IsClaimWindow(current_time: Time) -> Bool {\r\n    // Start contract \r\n    TimeBeginContract: Time = Time::new(1733665500000);  \r\n\r\n     // Calculate the offset from the deployment start\r\n     elapsed_time: Duration = current_time - TimeBeginContract;\r\n     time_elapsed_in_seconds: Int = elapsed_time / Duration::new(1_000);  // Convert to seconds\r\n\r\n // Determine the position within the current cycle\r\n    position_in_cycle: Int = time_elapsed_in_seconds % CYCLE_DURATION;\r\n    in_claim_window: Bool = position_in_cycle <= CLAIM_WINDOW;\r\n    print(position_in_cycle.show());\r\n    in_claim_window\r\n}\r\n\r\n// Define the main validator function\r\nfunc main(datum: Datum, redeemer: Redeemer, ctx: ScriptContext) -> Bool {\r\n    tx: Tx = ctx.tx;\r\n\r\n        // AssetClass for the treasury tokens\r\n        asset_class: AssetClass = AssetClass::new(\r\n            TOKEN_POLICY_ID,  \r\n            \"MIN\".encode_utf8()\r\n        );\r\n\r\n       validator_hash: ValidatorHash = ctx.get_current_validator_hash();\r\n\r\n        // Get all outputs locked at the script address\r\n       script_outputs: []TxOutput = tx.outputs_locked_by(validator_hash);\r\n\r\n          total_tokens_begin: Int = tx.inputs.fold(\r\n            (sum: Int, input: TxInput) -> Int {\r\n              \r\n                sum + input.output.value.get_safe(asset_class)\r\n            },\r\n            0\r\n        );\r\n\r\n            // Sum up all tokens in these outputs\r\n            total_tokens_in_script: Int = script_outputs.fold(\r\n                (sum: Int, output: TxOutput) -> Int {\r\n                sum + output.value.get_safe(asset_class)\r\n                },\r\n               0 // Initial sum\r\n            );\r\n            \r\n        // Calculate total ADA in script inputs\r\n        total_ada_begin: Int = tx.inputs.fold((sum: Int, input: TxInput) -> Int {\r\n            if (input.output.address.credential.switch {\r\n                vh_credential: Validator => vh_credential.hash == validator_hash,\r\n                _ => false\r\n            }) {\r\n                sum + input.output.value.get_lovelace()\r\n            } else {\r\n                sum\r\n            }\r\n        }, 0);\r\n\r\n        // Calculate total ADA in script outputs\r\n        total_ada_in_script: Int = tx.outputs.fold((sum: Int, output: TxOutput) -> Int {\r\n            if (output.address.credential.switch {\r\n                vh_credential: Validator => vh_credential.hash == validator_hash,\r\n                _ => false\r\n            }) {\r\n                sum + output.value.get_lovelace()\r\n            } else {\r\n                sum\r\n            }\r\n        }, 0);\r\n\r\n    print(total_ada_begin.show());\r\n    print(total_ada_in_script.show());\r\n\r\n\r\n    current_time: Time = tx.time_range.start;  // Get current time as POSIXTime (seconds since Unix epoch)\r\n    // Calculate dynamic reward based on the remaining supply\r\n    dynamic_reward: Int = calculate_reward(current_time);\r\n\r\n    isClaimWindow: Bool = IsClaimWindow(current_time);\r\n\r\n     //expected_value: Value = Value::new(asset_class, EXPECTED_AMOUNT);\r\n    // Depending on the redeemer provided in the transaction, process accordingly.\r\n    redeemer.switch {\r\n        Cancel => {\r\n            // Tx must be signed by pkh in datum\r\n            tx.is_signed_by(datum.benefitiary) \r\n        },\r\n        red: Claim => {\r\n\r\n                        // Determine how many tokens to give\r\n            tokens_to_give: Int = if (dynamic_reward > total_tokens_begin) { total_tokens_begin } else { dynamic_reward };\r\n\r\n            assert(total_tokens_begin - tokens_to_give == total_tokens_in_script, \"Not enough tokens sent back to script\");\r\n            \r\n              // Check that the user receives exactly tokens_to_give\r\n            assert(tx.value_sent_to(red.recepiant).get_safe(asset_class) == tokens_to_give, \"Incorrect token payout\");\r\n            assert(isClaimWindow == true, \"Not in claim window\");\r\n            \r\n             // Now handle ADA and script outputs logic\r\n             if (total_tokens_in_script == 0) {\r\n                // Final claim scenario: no tokens remain\r\n                // All ADA can be returned to the claimant, so no script outputs allowed\r\n                assert(script_outputs.length == 0, \"No script outputs should remain at final claim\");\r\n                // In this scenario, we don't need to enforce total_ada_in_script >= total_ada_begin,\r\n                // since all ADA should now be leaving the script and going to the claimant.\r\n                true\r\n            } else {\r\n                // Not final claim: tokens remain in the script\r\n                // Require at least 2 script outputs for concurrency (adjust as needed)\r\n                assert(script_outputs.length == 2, \"I need 2 outputs\");\r\n\r\n                // Ensure no ADA leaves the contract yet\r\n                assert(total_ada_in_script >= total_ada_begin, \"No ADA can leave the contract\");\r\n\r\n                true\r\n            }\r\n        }\r\n    }    \r\n}`, Array.from(depSrcs.values()))\n\n        if (Object.keys(parameters).length > 0) {\n            this.#program.parameters = parameters\n        }\n    }\n\n    get name() {\n        return this.#program.name\n    }\n\n    get paramTypes() {\n        return this.#program.paramTypes\n    }\n\n    get parameters() {\n        return this.#program.parameters\n    }\n\n    get types() {\n        return this.#program.types\n    }\n\n    set parameters(params) {\n        this.#program.parameters = params\n    }\n\n    compile(optimize = false) {\n        return this.#program.compile(optimize)\n    }\n\n    evalParam(paramName) {\n        return this.#program.evalParam(paramName)\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb250cmFjdHMvdmVzdGluZy5obCIsIm1hcHBpbmdzIjoiOzs7OztBQUE0QztBQUM1QztBQUNlO0FBQ2Y7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLHVEQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsZUFBZSxPQUFPO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLHFCQUFxQixPQUFPO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb250cmFjdHMvdmVzdGluZy5obD9hYTQ5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGhlbGlvcyBmcm9tIFwiQGh5cGVyaW9uYnQvaGVsaW9zXCJcbi8vd3JhcHMgaGVsaW9zLlByb2dyYW1cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByb2dyYW0ge1xuICAgICNwcm9ncmFtXG5cbiAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcbiAgICAgICAgLy8gbG9hZCBhbGwgdGhlIGRlcGVuZGVuY2llc1xuICAgICAgICBjb25zdCBhbGxEZXBzID0gW11cblxuICAgICAgICBjb25zdCBkZXBTcmNzID0gbmV3IE1hcCgpXG5cbiAgICAgICAgZnVuY3Rpb24gYWRkRGVwU3JjcyhkZXApIHtcbiAgICAgICAgICAgIGRlcFNyY3Muc2V0KGRlcC5uYW1lLCBkZXAuc3JjKVxuXG4gICAgICAgICAgICBmb3IgKGxldCBkIG9mIGRlcC5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgICAgICBhZGREZXBTcmNzKGQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBkIG9mIGFsbERlcHMpIHtcbiAgICAgICAgICAgIGFkZERlcFNyY3MoZClcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuI3Byb2dyYW0gPSBoZWxpb3MuUHJvZ3JhbS5uZXcoYHNwZW5kaW5nIHZlc3RpbmdcclxuLyogXHJcbiBDcmVhdGUgYSBkYXR1bSB3aXRoIHRoZSBiZW5lZml0aWFyeSBQdWJLZXlIYXNoIHRoYXQgd2lsbCBiZSBpbmNsdWRlZCBcclxuIGludG8gZWFjaCBVVFhPIGxvY2tlZCBhdCB0aGlzIHNjcmlwdCBhZGRyZXNzLlxyXG4qL1xyXG5zdHJ1Y3QgRGF0dW0ge1xyXG4gICAgYmVuZWZpdGlhcnk6IFB1YktleUhhc2hcclxufVxyXG5cclxuLypcclxuIFRoZSB2ZXN0aW5nIGNvbnRyYWN0IGNhbiBiZSBlaXRoZXIgY2FuY2VsZWQgYnkgdGhlIGJlbmVmaXRpYXJ5XHJcbiBvciBjbGFpbWVkIGJ5IHRoZSBiZW5lZmljaWFyeVxyXG4gKi9cclxuZW51bSBSZWRlZW1lciB7XHJcbiAgICBDYW5jZWxcclxuICAgIENsYWltIHtcclxuICAgICAgICByZWNlcGlhbnQ6IFB1YktleUhhc2hcclxuICAgIH1cclxufVxyXG5cclxuY29uc3QgVE9LRU5fUE9MSUNZX0lEOiBNaW50aW5nUG9saWN5SGFzaCA9IE1pbnRpbmdQb2xpY3lIYXNoOjpuZXcoI2UxNmMyZGM4YWU5MzdlOGQzNzkwYzdmZDcxNjhkN2I5OTQ2MjFiYTE0Y2ExMTQxNWYzOWZlZDcyKVxyXG4gICBcclxuY29uc3QgSEFMVklOR19QRVJJT0Q6IEludCA9IDI1OTIwMDAgIC8vIDEgbW9udGggaW4gc2Vjb25kc1xyXG5jb25zdCBNQVhfSEFMVklOR1M6IEludCA9IDVcclxuY29uc3QgQkFTRV9SRVdBUkQ6IEludCA9IDEwMDAgIC8vIEluaXRpYWwgcmV3YXJkIGluIHRva2Vuc1xyXG5cclxuZnVuYyBjYWxjdWxhdGVfcmV3YXJkKGN1cnJlbnRfdGltZTogVGltZSkgLT4gSW50IHtcclxuICAgIC8vIFN0YXJ0IGNvbnRyYWN0IGF0IFxyXG4gICAgVGltZUJlZ2luQ29udHJhY3Q6IFRpbWUgPSBUaW1lOjpuZXcoMTczMzY2NTUwMDAwMCk7ICBcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgdGltZSBlbGFwc2VkIGluIHNlY29uZHNcclxuICAgIHRpbWVfZWxhcHNlZDogRHVyYXRpb24gPSBjdXJyZW50X3RpbWUgLSBUaW1lQmVnaW5Db250cmFjdDtcclxuICAgIHRpbWVfZWxhcHNlZF9pbl9zZWNvbmRzOiBJbnQgPSB0aW1lX2VsYXBzZWQgLyBEdXJhdGlvbjo6bmV3KDFfMDAwKTsgIC8vIENvbnZlcnQgdG8gc2Vjb25kc1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIGhhbHZpbmcgcGVyaW9kcyAoZWFjaCBwZXJpb2QgaXMgMSBtb250aClcclxuICAgIGhhbHZpbmdfc3RlcHM6IEludCA9IHRpbWVfZWxhcHNlZF9pbl9zZWNvbmRzIC8gSEFMVklOR19QRVJJT0Q7XHJcbiAgICBwcmludChjdXJyZW50X3RpbWUuc2hvdygpKTtcclxuICAgIC8vIEVuc3VyZSB0aGUgbnVtYmVyIG9mIGhhbHZpbmdzIGRvZXNuJ3QgZXhjZWVkIHRoZSBtYXhpbXVtIGFsbG93ZWRcclxuICAgIGhhbHZpbmdfc3RlcHMgPSBpZiAoaGFsdmluZ19zdGVwcyA+IE1BWF9IQUxWSU5HUykgeyBNQVhfSEFMVklOR1MgfSBlbHNlIHsgaGFsdmluZ19zdGVwcyB9O1xyXG4gICAgcHJpbnQoaGFsdmluZ19zdGVwcy5zaG93KCkpO1xyXG4gICAgLy8gQ2FsY3VsYXRlIHJld2FyZCB1c2luZyBzaW1wbGUgbXVsdGlwbGljYXRpb24gYW5kIGRpdmlzaW9uXHJcbiAgICBpZiAoaGFsdmluZ19zdGVwcyA9PSAwKSB7XHJcbiAgICAgICAgQkFTRV9SRVdBUkRcclxuICAgIH0gZWxzZSBpZiAoaGFsdmluZ19zdGVwcyA9PSAxKSB7XHJcbiAgICAgICAgQkFTRV9SRVdBUkQgLyAyXHJcbiAgICB9IGVsc2UgaWYgKGhhbHZpbmdfc3RlcHMgPT0gMikge1xyXG4gICAgICAgIEJBU0VfUkVXQVJEIC8gNFxyXG4gICAgfSBlbHNlIGlmIChoYWx2aW5nX3N0ZXBzID09IDMpIHtcclxuICAgICAgICBCQVNFX1JFV0FSRCAvIDhcclxuICAgIH0gZWxzZSBpZiAoaGFsdmluZ19zdGVwcyA9PSA0KSB7XHJcbiAgICAgICAgQkFTRV9SRVdBUkQgLyAxNlxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBCQVNFX1JFV0FSRCAvIDMyXHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5jb25zdCBDTEFJTV9XSU5ET1c6IEludCA9IDU0MCBcclxuY29uc3QgQ1lDTEVfRFVSQVRJT046IEludCA9IDU0MCBcclxuXHJcbmZ1bmMgSXNDbGFpbVdpbmRvdyhjdXJyZW50X3RpbWU6IFRpbWUpIC0+IEJvb2wge1xyXG4gICAgLy8gU3RhcnQgY29udHJhY3QgXHJcbiAgICBUaW1lQmVnaW5Db250cmFjdDogVGltZSA9IFRpbWU6Om5ldygxNzMzNjY1NTAwMDAwKTsgIFxyXG5cclxuICAgICAvLyBDYWxjdWxhdGUgdGhlIG9mZnNldCBmcm9tIHRoZSBkZXBsb3ltZW50IHN0YXJ0XHJcbiAgICAgZWxhcHNlZF90aW1lOiBEdXJhdGlvbiA9IGN1cnJlbnRfdGltZSAtIFRpbWVCZWdpbkNvbnRyYWN0O1xyXG4gICAgIHRpbWVfZWxhcHNlZF9pbl9zZWNvbmRzOiBJbnQgPSBlbGFwc2VkX3RpbWUgLyBEdXJhdGlvbjo6bmV3KDFfMDAwKTsgIC8vIENvbnZlcnQgdG8gc2Vjb25kc1xyXG5cclxuIC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gd2l0aGluIHRoZSBjdXJyZW50IGN5Y2xlXHJcbiAgICBwb3NpdGlvbl9pbl9jeWNsZTogSW50ID0gdGltZV9lbGFwc2VkX2luX3NlY29uZHMgJSBDWUNMRV9EVVJBVElPTjtcclxuICAgIGluX2NsYWltX3dpbmRvdzogQm9vbCA9IHBvc2l0aW9uX2luX2N5Y2xlIDw9IENMQUlNX1dJTkRPVztcclxuICAgIHByaW50KHBvc2l0aW9uX2luX2N5Y2xlLnNob3coKSk7XHJcbiAgICBpbl9jbGFpbV93aW5kb3dcclxufVxyXG5cclxuLy8gRGVmaW5lIHRoZSBtYWluIHZhbGlkYXRvciBmdW5jdGlvblxyXG5mdW5jIG1haW4oZGF0dW06IERhdHVtLCByZWRlZW1lcjogUmVkZWVtZXIsIGN0eDogU2NyaXB0Q29udGV4dCkgLT4gQm9vbCB7XHJcbiAgICB0eDogVHggPSBjdHgudHg7XHJcblxyXG4gICAgICAgIC8vIEFzc2V0Q2xhc3MgZm9yIHRoZSB0cmVhc3VyeSB0b2tlbnNcclxuICAgICAgICBhc3NldF9jbGFzczogQXNzZXRDbGFzcyA9IEFzc2V0Q2xhc3M6Om5ldyhcclxuICAgICAgICAgICAgVE9LRU5fUE9MSUNZX0lELCAgXHJcbiAgICAgICAgICAgIFwiTUlOXCIuZW5jb2RlX3V0ZjgoKVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgdmFsaWRhdG9yX2hhc2g6IFZhbGlkYXRvckhhc2ggPSBjdHguZ2V0X2N1cnJlbnRfdmFsaWRhdG9yX2hhc2goKTtcclxuXHJcbiAgICAgICAgLy8gR2V0IGFsbCBvdXRwdXRzIGxvY2tlZCBhdCB0aGUgc2NyaXB0IGFkZHJlc3NcclxuICAgICAgIHNjcmlwdF9vdXRwdXRzOiBbXVR4T3V0cHV0ID0gdHgub3V0cHV0c19sb2NrZWRfYnkodmFsaWRhdG9yX2hhc2gpO1xyXG5cclxuICAgICAgICAgIHRvdGFsX3Rva2Vuc19iZWdpbjogSW50ID0gdHguaW5wdXRzLmZvbGQoXHJcbiAgICAgICAgICAgIChzdW06IEludCwgaW5wdXQ6IFR4SW5wdXQpIC0+IEludCB7XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBzdW0gKyBpbnB1dC5vdXRwdXQudmFsdWUuZ2V0X3NhZmUoYXNzZXRfY2xhc3MpXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIDBcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgLy8gU3VtIHVwIGFsbCB0b2tlbnMgaW4gdGhlc2Ugb3V0cHV0c1xyXG4gICAgICAgICAgICB0b3RhbF90b2tlbnNfaW5fc2NyaXB0OiBJbnQgPSBzY3JpcHRfb3V0cHV0cy5mb2xkKFxyXG4gICAgICAgICAgICAgICAgKHN1bTogSW50LCBvdXRwdXQ6IFR4T3V0cHV0KSAtPiBJbnQge1xyXG4gICAgICAgICAgICAgICAgc3VtICsgb3V0cHV0LnZhbHVlLmdldF9zYWZlKGFzc2V0X2NsYXNzKVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgMCAvLyBJbml0aWFsIHN1bVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAvLyBDYWxjdWxhdGUgdG90YWwgQURBIGluIHNjcmlwdCBpbnB1dHNcclxuICAgICAgICB0b3RhbF9hZGFfYmVnaW46IEludCA9IHR4LmlucHV0cy5mb2xkKChzdW06IEludCwgaW5wdXQ6IFR4SW5wdXQpIC0+IEludCB7XHJcbiAgICAgICAgICAgIGlmIChpbnB1dC5vdXRwdXQuYWRkcmVzcy5jcmVkZW50aWFsLnN3aXRjaCB7XHJcbiAgICAgICAgICAgICAgICB2aF9jcmVkZW50aWFsOiBWYWxpZGF0b3IgPT4gdmhfY3JlZGVudGlhbC5oYXNoID09IHZhbGlkYXRvcl9oYXNoLFxyXG4gICAgICAgICAgICAgICAgXyA9PiBmYWxzZVxyXG4gICAgICAgICAgICB9KSB7XHJcbiAgICAgICAgICAgICAgICBzdW0gKyBpbnB1dC5vdXRwdXQudmFsdWUuZ2V0X2xvdmVsYWNlKClcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN1bVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgMCk7XHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0b3RhbCBBREEgaW4gc2NyaXB0IG91dHB1dHNcclxuICAgICAgICB0b3RhbF9hZGFfaW5fc2NyaXB0OiBJbnQgPSB0eC5vdXRwdXRzLmZvbGQoKHN1bTogSW50LCBvdXRwdXQ6IFR4T3V0cHV0KSAtPiBJbnQge1xyXG4gICAgICAgICAgICBpZiAob3V0cHV0LmFkZHJlc3MuY3JlZGVudGlhbC5zd2l0Y2gge1xyXG4gICAgICAgICAgICAgICAgdmhfY3JlZGVudGlhbDogVmFsaWRhdG9yID0+IHZoX2NyZWRlbnRpYWwuaGFzaCA9PSB2YWxpZGF0b3JfaGFzaCxcclxuICAgICAgICAgICAgICAgIF8gPT4gZmFsc2VcclxuICAgICAgICAgICAgfSkge1xyXG4gICAgICAgICAgICAgICAgc3VtICsgb3V0cHV0LnZhbHVlLmdldF9sb3ZlbGFjZSgpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzdW1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIDApO1xyXG5cclxuICAgIHByaW50KHRvdGFsX2FkYV9iZWdpbi5zaG93KCkpO1xyXG4gICAgcHJpbnQodG90YWxfYWRhX2luX3NjcmlwdC5zaG93KCkpO1xyXG5cclxuXHJcbiAgICBjdXJyZW50X3RpbWU6IFRpbWUgPSB0eC50aW1lX3JhbmdlLnN0YXJ0OyAgLy8gR2V0IGN1cnJlbnQgdGltZSBhcyBQT1NJWFRpbWUgKHNlY29uZHMgc2luY2UgVW5peCBlcG9jaClcclxuICAgIC8vIENhbGN1bGF0ZSBkeW5hbWljIHJld2FyZCBiYXNlZCBvbiB0aGUgcmVtYWluaW5nIHN1cHBseVxyXG4gICAgZHluYW1pY19yZXdhcmQ6IEludCA9IGNhbGN1bGF0ZV9yZXdhcmQoY3VycmVudF90aW1lKTtcclxuXHJcbiAgICBpc0NsYWltV2luZG93OiBCb29sID0gSXNDbGFpbVdpbmRvdyhjdXJyZW50X3RpbWUpO1xyXG5cclxuICAgICAvL2V4cGVjdGVkX3ZhbHVlOiBWYWx1ZSA9IFZhbHVlOjpuZXcoYXNzZXRfY2xhc3MsIEVYUEVDVEVEX0FNT1VOVCk7XHJcbiAgICAvLyBEZXBlbmRpbmcgb24gdGhlIHJlZGVlbWVyIHByb3ZpZGVkIGluIHRoZSB0cmFuc2FjdGlvbiwgcHJvY2VzcyBhY2NvcmRpbmdseS5cclxuICAgIHJlZGVlbWVyLnN3aXRjaCB7XHJcbiAgICAgICAgQ2FuY2VsID0+IHtcclxuICAgICAgICAgICAgLy8gVHggbXVzdCBiZSBzaWduZWQgYnkgcGtoIGluIGRhdHVtXHJcbiAgICAgICAgICAgIHR4LmlzX3NpZ25lZF9ieShkYXR1bS5iZW5lZml0aWFyeSkgXHJcbiAgICAgICAgfSxcclxuICAgICAgICByZWQ6IENsYWltID0+IHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERldGVybWluZSBob3cgbWFueSB0b2tlbnMgdG8gZ2l2ZVxyXG4gICAgICAgICAgICB0b2tlbnNfdG9fZ2l2ZTogSW50ID0gaWYgKGR5bmFtaWNfcmV3YXJkID4gdG90YWxfdG9rZW5zX2JlZ2luKSB7IHRvdGFsX3Rva2Vuc19iZWdpbiB9IGVsc2UgeyBkeW5hbWljX3Jld2FyZCB9O1xyXG5cclxuICAgICAgICAgICAgYXNzZXJ0KHRvdGFsX3Rva2Vuc19iZWdpbiAtIHRva2Vuc190b19naXZlID09IHRvdGFsX3Rva2Vuc19pbl9zY3JpcHQsIFwiTm90IGVub3VnaCB0b2tlbnMgc2VudCBiYWNrIHRvIHNjcmlwdFwiKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgdXNlciByZWNlaXZlcyBleGFjdGx5IHRva2Vuc190b19naXZlXHJcbiAgICAgICAgICAgIGFzc2VydCh0eC52YWx1ZV9zZW50X3RvKHJlZC5yZWNlcGlhbnQpLmdldF9zYWZlKGFzc2V0X2NsYXNzKSA9PSB0b2tlbnNfdG9fZ2l2ZSwgXCJJbmNvcnJlY3QgdG9rZW4gcGF5b3V0XCIpO1xyXG4gICAgICAgICAgICBhc3NlcnQoaXNDbGFpbVdpbmRvdyA9PSB0cnVlLCBcIk5vdCBpbiBjbGFpbSB3aW5kb3dcIik7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgLy8gTm93IGhhbmRsZSBBREEgYW5kIHNjcmlwdCBvdXRwdXRzIGxvZ2ljXHJcbiAgICAgICAgICAgICBpZiAodG90YWxfdG9rZW5zX2luX3NjcmlwdCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBGaW5hbCBjbGFpbSBzY2VuYXJpbzogbm8gdG9rZW5zIHJlbWFpblxyXG4gICAgICAgICAgICAgICAgLy8gQWxsIEFEQSBjYW4gYmUgcmV0dXJuZWQgdG8gdGhlIGNsYWltYW50LCBzbyBubyBzY3JpcHQgb3V0cHV0cyBhbGxvd2VkXHJcbiAgICAgICAgICAgICAgICBhc3NlcnQoc2NyaXB0X291dHB1dHMubGVuZ3RoID09IDAsIFwiTm8gc2NyaXB0IG91dHB1dHMgc2hvdWxkIHJlbWFpbiBhdCBmaW5hbCBjbGFpbVwiKTtcclxuICAgICAgICAgICAgICAgIC8vIEluIHRoaXMgc2NlbmFyaW8sIHdlIGRvbid0IG5lZWQgdG8gZW5mb3JjZSB0b3RhbF9hZGFfaW5fc2NyaXB0ID49IHRvdGFsX2FkYV9iZWdpbixcclxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIGFsbCBBREEgc2hvdWxkIG5vdyBiZSBsZWF2aW5nIHRoZSBzY3JpcHQgYW5kIGdvaW5nIHRvIHRoZSBjbGFpbWFudC5cclxuICAgICAgICAgICAgICAgIHRydWVcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vdCBmaW5hbCBjbGFpbTogdG9rZW5zIHJlbWFpbiBpbiB0aGUgc2NyaXB0XHJcbiAgICAgICAgICAgICAgICAvLyBSZXF1aXJlIGF0IGxlYXN0IDIgc2NyaXB0IG91dHB1dHMgZm9yIGNvbmN1cnJlbmN5IChhZGp1c3QgYXMgbmVlZGVkKVxyXG4gICAgICAgICAgICAgICAgYXNzZXJ0KHNjcmlwdF9vdXRwdXRzLmxlbmd0aCA9PSAyLCBcIkkgbmVlZCAyIG91dHB1dHNcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIG5vIEFEQSBsZWF2ZXMgdGhlIGNvbnRyYWN0IHlldFxyXG4gICAgICAgICAgICAgICAgYXNzZXJ0KHRvdGFsX2FkYV9pbl9zY3JpcHQgPj0gdG90YWxfYWRhX2JlZ2luLCBcIk5vIEFEQSBjYW4gbGVhdmUgdGhlIGNvbnRyYWN0XCIpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0gICAgXHJcbn1gLCBBcnJheS5mcm9tKGRlcFNyY3MudmFsdWVzKCkpKVxuXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhwYXJhbWV0ZXJzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLiNwcm9ncmFtLnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3Byb2dyYW0ubmFtZVxuICAgIH1cblxuICAgIGdldCBwYXJhbVR5cGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcHJvZ3JhbS5wYXJhbVR5cGVzXG4gICAgfVxuXG4gICAgZ2V0IHBhcmFtZXRlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNwcm9ncmFtLnBhcmFtZXRlcnNcbiAgICB9XG5cbiAgICBnZXQgdHlwZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNwcm9ncmFtLnR5cGVzXG4gICAgfVxuXG4gICAgc2V0IHBhcmFtZXRlcnMocGFyYW1zKSB7XG4gICAgICAgIHRoaXMuI3Byb2dyYW0ucGFyYW1ldGVycyA9IHBhcmFtc1xuICAgIH1cblxuICAgIGNvbXBpbGUob3B0aW1pemUgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcHJvZ3JhbS5jb21waWxlKG9wdGltaXplKVxuICAgIH1cblxuICAgIGV2YWxQYXJhbShwYXJhbU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3Byb2dyYW0uZXZhbFBhcmFtKHBhcmFtTmFtZSlcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./contracts/vesting.hl\n"));

/***/ })

});