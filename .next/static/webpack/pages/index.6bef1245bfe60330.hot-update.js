"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./public/useFlappyBirdGame.ts":
/*!*************************************!*\
  !*** ./public/useFlappyBirdGame.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFlappyBirdGame: function() { return /* binding */ useFlappyBirdGame; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n// Constants\nconst GRAVITY = 0.5; // Adjusted for time-based loop\nconst FLAP = -12; // Adjusted for time-based loop\nconst PIPE_WIDTH = 90;\nconst PIPE_SPACING = 250;\nconst BIRD_WIDTH = 50;\nconst BIRD_HEIGHT = 50;\nconst COIN_SIZE = 80;\nconst ROTATION_SPEED = 0.002; // Reduced rotation speed\nconst PIPE_SPAWN_INTERVAL = 1500; // milliseconds\nconst COIN_SPAWN_CHANCE = 0.25; // 25%\nfunction useFlappyBirdGame(canvasRef, isPaused, autoStart) {\n    const requestIdRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // State\n    const [highScore, setHighScore] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [currentScore, setCurrentScore] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    // Refs to track game state\n    const birdYRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const birdVelocityRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const pipesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const coinsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const gameOverRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const gameStartedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const coinRotationStepRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // Time tracking\n    const lastTimeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const pipeSpawnTimerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // Assets\n    const birdImages = [];\n    let pipeTop;\n    let pipeBottom;\n    let background;\n    let coinImage;\n    if (true) {\n        const birdUp = new Image();\n        birdUp.src = \"/assets/redbird-upflap.png\";\n        const birdMid = new Image();\n        birdMid.src = \"/assets/redbird-midflap.png\";\n        const birdDown = new Image();\n        birdDown.src = \"/assets/redbird-downflap.png\";\n        birdImages.push(birdUp, birdMid, birdDown);\n        pipeTop = new Image();\n        pipeTop.src = \"/assets/TopTiny.png\";\n        pipeBottom = new Image();\n        pipeBottom.src = \"/assets/BottomTiny.png\";\n        background = new Image();\n        background.src = \"/assets/background-day.png\";\n        coinImage = new Image();\n        coinImage.src = \"/assets/CoinTiny.png\";\n    }\n    // Current bird frame index\n    const currentBirdFrameRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // Load high score from localStorage\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (true) {\n            const storedHighScore = localStorage.getItem(\"highScore\");\n            if (storedHighScore) {\n                setHighScore(parseInt(storedHighScore, 10));\n            }\n        }\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        // Helper function to load an image fully\n        const loadImage = (img)=>{\n            return new Promise((resolve, reject)=>{\n                if (img.complete) {\n                    resolve();\n                } else {\n                    img.onload = ()=>resolve();\n                    img.onerror = ()=>reject(new Error(\"Failed to load image: \".concat(img.src)));\n                }\n            });\n        };\n        // Load all assets then initialize the game\n        const loadAssets = async ()=>{\n            try {\n                await Promise.all([\n                    ...birdImages.map((img)=>loadImage(img)),\n                    loadImage(pipeTop),\n                    loadImage(pipeBottom),\n                    loadImage(background),\n                    loadImage(coinImage)\n                ]);\n                console.log(\"All assets loaded successfully!\");\n                initializeGame();\n            } catch (error) {\n                console.error(\"Error loading assets:\", error);\n            }\n        };\n        function initializeGame() {\n            if (!canvasRef.current) return;\n            if (!ctx) return;\n            const rect = canvasRef.current.getBoundingClientRect();\n            canvasRef.current.width = rect.width;\n            canvasRef.current.height = rect.height;\n            drawStartScreen(ctx, canvasRef.current);\n        }\n        loadAssets();\n        function resetGame() {\n            if (!canvasRef.current) return;\n            const { height } = canvasRef.current;\n            birdYRef.current = height / 3;\n            birdVelocityRef.current = 0;\n            pipesRef.current = [];\n            coinsRef.current = [];\n            setCurrentScore(0);\n            gameOverRef.current = false;\n            gameStartedRef.current = false;\n            coinRotationStepRef.current = 0;\n            lastTimeRef.current = 0;\n            pipeSpawnTimerRef.current = 0;\n            currentBirdFrameRef.current = 0;\n        }\n        function handleKeyDown(e) {\n            if (e.key === \" \") {\n                if (!gameStartedRef.current && !gameOverRef.current) {\n                    startGame();\n                } else if (gameOverRef.current) {\n                    startGame();\n                } else {\n                    birdVelocityRef.current = FLAP;\n                    flap();\n                }\n            }\n        }\n        window.addEventListener(\"keydown\", handleKeyDown);\n        function startGame() {\n            resetGame();\n            gameStartedRef.current = true;\n            lastTimeRef.current = 0; // Reset for frame-limiting\n            requestIdRef.current = requestAnimationFrame(animate);\n        }\n        function handleUserInput() {\n            if (!gameStartedRef.current && !gameOverRef.current) {\n                startGame();\n            } else if (gameOverRef.current) {\n                startGame();\n            } else {\n                birdVelocityRef.current = FLAP;\n                flap();\n            }\n        }\n        const flap = ()=>{\n            currentBirdFrameRef.current = 1;\n            setTimeout(()=>{\n                currentBirdFrameRef.current = 2;\n                setTimeout(()=>{\n                    currentBirdFrameRef.current = 0;\n                }, 170);\n            }, 170);\n        };\n        // The main loop with time-based updates\n        function animate(timestamp) {\n            if (isPaused || !gameStartedRef.current) {\n                requestIdRef.current = requestAnimationFrame(animate);\n                return;\n            }\n            if (!canvasRef.current) return;\n            const context = canvasRef.current.getContext(\"2d\");\n            if (!context) return;\n            if (!lastTimeRef.current) {\n                lastTimeRef.current = timestamp;\n            }\n            const deltaTime = timestamp - lastTimeRef.current;\n            // Update game state based on deltaTime\n            updateGameState(deltaTime, canvasRef.current);\n            // Draw everything\n            draw(context, canvasRef.current);\n            if (!gameOverRef.current) {\n                lastTimeRef.current = timestamp;\n                requestIdRef.current = requestAnimationFrame(animate);\n            } else {\n                drawGameOverScreen(context, canvasRef.current);\n            }\n        }\n        function updateGameState(deltaTime, canvas) {\n            // Update bird position based on deltaTime\n            birdVelocityRef.current += GRAVITY;\n            birdYRef.current += birdVelocityRef.current * (deltaTime / 16); // Assuming 60 FPS as base\n            // Update pipe spawn timer\n            pipeSpawnTimerRef.current += deltaTime;\n            if (pipeSpawnTimerRef.current > PIPE_SPAWN_INTERVAL) {\n                createPipe(canvas);\n                pipeSpawnTimerRef.current = 0;\n            }\n            movePipesAndCoins();\n            checkCoinCollection();\n            // Check collisions\n            if (checkCollisions(canvas)) {\n                gameOverRef.current = true;\n                return;\n            }\n            updateScore();\n            // Rotate coin\n            coinRotationStepRef.current += ROTATION_SPEED * (deltaTime / 16);\n            if (coinRotationStepRef.current >= 1) {\n                coinRotationStepRef.current = 0;\n            }\n        }\n        function draw(ctx, canvas) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawBackground(ctx, canvas);\n            drawBird(ctx);\n            drawPipes(ctx);\n            drawCoins(ctx);\n        }\n        function drawStartScreen(ctx, canvas) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawBackground(ctx, canvas);\n            ctx.font = \"bold 22px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.fillStyle = \"#ffffff\";\n            ctx.shadowColor = \"black\";\n            ctx.shadowBlur = 2;\n            ctx.textBaseline = \"middle\";\n            ctx.fillText(\"Press Space or Tap to Start\", canvas.width / 2, canvas.height / 2);\n        }\n        function drawGameOverScreen(ctx, canvas) {\n            ctx.fillStyle = \"#ffcc00\";\n            ctx.font = \"bold 36px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"middle\";\n            ctx.shadowColor = \"black\";\n            ctx.shadowBlur = 6;\n            ctx.fillText(\"Game Over!\", canvas.width / 2, canvas.height / 2 - 30);\n            ctx.fillStyle = \"#ffffff\";\n            ctx.font = \"bold 20px Arial\";\n            ctx.fillText(\"Press Space or Tap to Restart\", canvas.width / 2, canvas.height / 2 + 10);\n        }\n        function drawBackground(ctx, canvas) {\n            ctx.drawImage(background, 0, 0, canvas.width, canvas.height);\n        }\n        function drawBird(ctx) {\n            const currentImage = birdImages[currentBirdFrameRef.current];\n            if (currentImage.complete) {\n                ctx.drawImage(currentImage, 100, birdYRef.current, BIRD_WIDTH, BIRD_HEIGHT);\n            }\n        }\n        function drawPipes(ctx) {\n            for (const pipe of pipesRef.current){\n                ctx.drawImage(pipeTop, pipe.x, 0, PIPE_WIDTH, pipe.topHeight);\n                ctx.drawImage(pipeBottom, pipe.x, pipe.bottomY, PIPE_WIDTH, pipe.bottomHeight);\n            }\n        }\n        function drawCoins(ctx) {\n            const scaleX = Math.abs(Math.cos(coinRotationStepRef.current * Math.PI * 2));\n            const halfSize = COIN_SIZE / 2;\n            for (const coin of coinsRef.current){\n                if (!coin.collected) {\n                    ctx.save();\n                    ctx.translate(coin.x + halfSize, coin.y + halfSize);\n                    ctx.scale(scaleX, 1);\n                    ctx.drawImage(coinImage, -halfSize, -halfSize, COIN_SIZE, COIN_SIZE);\n                    ctx.restore();\n                }\n            }\n        }\n        function createPipe(canvas) {\n            const pipeHeight = Math.random() * (canvas.height - PIPE_SPACING - 100) + 50;\n            const bottomY = pipeHeight + PIPE_SPACING;\n            pipesRef.current.push({\n                x: canvas.width,\n                topHeight: pipeHeight,\n                bottomY,\n                bottomHeight: canvas.height - bottomY,\n                scored: false\n            });\n            // Spawn coin only 25% chance\n            if (Math.random() > 1 - COIN_SPAWN_CHANCE) {\n                coinsRef.current.push({\n                    x: canvas.width + PIPE_WIDTH / 2 - COIN_SIZE / 2,\n                    y: pipeHeight + PIPE_SPACING / 2 - COIN_SIZE / 2,\n                    width: COIN_SIZE,\n                    height: COIN_SIZE,\n                    collected: false\n                });\n            }\n        }\n        function movePipesAndCoins() {\n            for (const pipe of pipesRef.current){\n                pipe.x -= 2;\n            }\n            pipesRef.current = pipesRef.current.filter((pipe)=>pipe.x + PIPE_WIDTH > 0);\n            for (const coin of coinsRef.current){\n                coin.x -= 2;\n            }\n            coinsRef.current = coinsRef.current.filter((coin)=>coin.x + coin.width > 0 && !coin.collected);\n        }\n        function checkCollisions(canvas) {\n            // Bird out of bounds\n            if (birdYRef.current < 0 || birdYRef.current + BIRD_HEIGHT > canvas.height) {\n                return true;\n            }\n            const birdLeft = 100;\n            const birdRight = birdLeft + BIRD_WIDTH;\n            const birdTop = birdYRef.current;\n            const birdBottom = birdYRef.current + BIRD_HEIGHT;\n            // Pipe collision\n            for (const pipe of pipesRef.current){\n                const withinPipeX = birdRight > pipe.x && birdLeft < pipe.x + PIPE_WIDTH;\n                const withinPipeY = birdTop < pipe.topHeight || birdBottom > pipe.bottomY;\n                if (withinPipeX && withinPipeY) return true;\n            }\n            return false;\n        }\n        function checkCoinCollection() {\n            const birdLeft = 100;\n            const birdRight = birdLeft + BIRD_WIDTH;\n            const birdTop = birdYRef.current;\n            const birdBottom = birdYRef.current + BIRD_HEIGHT;\n            for (const coin of coinsRef.current){\n                if (!coin.collected) {\n                    const coinLeft = coin.x;\n                    const coinRight = coin.x + coin.width;\n                    const coinTop = coin.y;\n                    const coinBottom = coin.y + coin.height;\n                    if (birdRight > coinLeft && birdLeft < coinRight && birdBottom > coinTop && birdTop < coinBottom) {\n                        coin.collected = true;\n                        setCurrentScore((prevScore)=>{\n                            const newScore = prevScore + 5;\n                            setHighScore((prevHighScore)=>Math.max(prevHighScore, newScore));\n                            return newScore;\n                        });\n                    }\n                }\n            }\n        }\n        function updateScore() {\n            for (const pipe of pipesRef.current){\n                // Score +1 for passing each pipe once\n                if (!pipe.scored && pipe.x + PIPE_WIDTH < 100) {\n                    setCurrentScore((prevScore)=>{\n                        const newScore = prevScore + 1;\n                        setHighScore((prevHighScore)=>{\n                            const updatedHighScore = Math.max(prevHighScore, newScore);\n                            if (true) {\n                                localStorage.setItem(\"highScore\", updatedHighScore.toString());\n                            }\n                            return updatedHighScore;\n                        });\n                        return newScore;\n                    });\n                    pipe.scored = true;\n                }\n            }\n        }\n        // Cleanup\n        return ()=>{\n            window.removeEventListener(\"keydown\", handleKeyDown);\n            if (requestIdRef.current) {\n                cancelAnimationFrame(requestIdRef.current);\n            }\n        };\n    }, [\n        canvasRef,\n        isPaused,\n        autoStart\n    ]);\n    // Expose handleUserInput\n    const handleUserInput = ()=>{\n        // Dispatch a \"keydown\" event with key \" \"\n        const spaceEvent = new KeyboardEvent(\"keydown\", {\n            key: \" \"\n        });\n        window.dispatchEvent(spaceEvent);\n    };\n    return {\n        highScore,\n        currentScore,\n        handleUserInput\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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S0FBVTtJQUVuQyx5QkFBeUI7SUFDekIsTUFBTWtFLGtCQUFrQjtRQUN0QiwwQ0FBMEM7UUFDMUMsTUFBTW9FLGFBQWEsSUFBSUMsY0FBYyxXQUFXO1lBQUU1RSxLQUFLO1FBQUk7UUFDM0RHLE9BQU8wRSxhQUFhLENBQUNGO0lBQ3ZCO0lBRUEsT0FBTztRQUNMcEk7UUFDQUU7UUFDQThEO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wdWJsaWMvdXNlRmxhcHB5QmlyZEdhbWUudHM/NWM3OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcclxuXHJcbi8vIFR5cGVzIGZvciBnYW1lIG9iamVjdHNcclxuaW50ZXJmYWNlIFBpcGUge1xyXG4gIHg6IG51bWJlcjtcclxuICB0b3BIZWlnaHQ6IG51bWJlcjtcclxuICBib3R0b21ZOiBudW1iZXI7XHJcbiAgYm90dG9tSGVpZ2h0OiBudW1iZXI7XHJcbiAgc2NvcmVkOiBib29sZWFuO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgQ29pbiB7XHJcbiAgeDogbnVtYmVyO1xyXG4gIHk6IG51bWJlcjtcclxuICB3aWR0aDogbnVtYmVyO1xyXG4gIGhlaWdodDogbnVtYmVyO1xyXG4gIGNvbGxlY3RlZDogYm9vbGVhbjtcclxufVxyXG5cclxuLy8gQ29uc3RhbnRzXHJcbmNvbnN0IEdSQVZJVFkgPSAwLjU7IC8vIEFkanVzdGVkIGZvciB0aW1lLWJhc2VkIGxvb3BcclxuY29uc3QgRkxBUCA9IC0xMjsgLy8gQWRqdXN0ZWQgZm9yIHRpbWUtYmFzZWQgbG9vcFxyXG5jb25zdCBQSVBFX1dJRFRIID0gOTA7XHJcbmNvbnN0IFBJUEVfU1BBQ0lORyA9IDI1MDtcclxuY29uc3QgQklSRF9XSURUSCA9IDUwO1xyXG5jb25zdCBCSVJEX0hFSUdIVCA9IDUwO1xyXG5jb25zdCBDT0lOX1NJWkUgPSA4MDtcclxuY29uc3QgUk9UQVRJT05fU1BFRUQgPSAwLjAwMjsgLy8gUmVkdWNlZCByb3RhdGlvbiBzcGVlZFxyXG5jb25zdCBQSVBFX1NQQVdOX0lOVEVSVkFMID0gMTUwMDsgLy8gbWlsbGlzZWNvbmRzXHJcbmNvbnN0IENPSU5fU1BBV05fQ0hBTkNFID0gMC4yNTsgLy8gMjUlXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlRmxhcHB5QmlyZEdhbWUoXHJcbiAgY2FudmFzUmVmOiBSZWFjdC5SZWZPYmplY3Q8SFRNTENhbnZhc0VsZW1lbnQ+LFxyXG4gIGlzUGF1c2VkOiBib29sZWFuLFxyXG4gIGF1dG9TdGFydDogYm9vbGVhblxyXG4pIHtcclxuICBjb25zdCByZXF1ZXN0SWRSZWYgPSB1c2VSZWY8bnVtYmVyIHwgbnVsbD4obnVsbCk7XHJcblxyXG4gIC8vIFN0YXRlXHJcbiAgY29uc3QgW2hpZ2hTY29yZSwgc2V0SGlnaFNjb3JlXSA9IHVzZVN0YXRlKDApO1xyXG4gIGNvbnN0IFtjdXJyZW50U2NvcmUsIHNldEN1cnJlbnRTY29yZV0gPSB1c2VTdGF0ZSgwKTtcclxuXHJcbiAgLy8gUmVmcyB0byB0cmFjayBnYW1lIHN0YXRlXHJcbiAgY29uc3QgYmlyZFlSZWYgPSB1c2VSZWY8bnVtYmVyPigwKTtcclxuICBjb25zdCBiaXJkVmVsb2NpdHlSZWYgPSB1c2VSZWY8bnVtYmVyPigwKTtcclxuICBjb25zdCBwaXBlc1JlZiA9IHVzZVJlZjxQaXBlW10+KFtdKTtcclxuICBjb25zdCBjb2luc1JlZiA9IHVzZVJlZjxDb2luW10+KFtdKTtcclxuICBjb25zdCBnYW1lT3ZlclJlZiA9IHVzZVJlZjxib29sZWFuPihmYWxzZSk7XHJcbiAgY29uc3QgZ2FtZVN0YXJ0ZWRSZWYgPSB1c2VSZWY8Ym9vbGVhbj4oZmFsc2UpO1xyXG5cclxuICBjb25zdCBjb2luUm90YXRpb25TdGVwUmVmID0gdXNlUmVmPG51bWJlcj4oMCk7XHJcbiAgXHJcbiAgLy8gVGltZSB0cmFja2luZ1xyXG4gIGNvbnN0IGxhc3RUaW1lUmVmID0gdXNlUmVmPG51bWJlcj4oMCk7XHJcbiAgY29uc3QgcGlwZVNwYXduVGltZXJSZWYgPSB1c2VSZWY8bnVtYmVyPigwKTtcclxuXHJcbiAgLy8gQXNzZXRzXHJcbiAgY29uc3QgYmlyZEltYWdlczogSFRNTEltYWdlRWxlbWVudFtdID0gW107XHJcbiAgbGV0IHBpcGVUb3A6IEhUTUxJbWFnZUVsZW1lbnQ7XHJcbiAgbGV0IHBpcGVCb3R0b206IEhUTUxJbWFnZUVsZW1lbnQ7XHJcbiAgbGV0IGJhY2tncm91bmQ6IEhUTUxJbWFnZUVsZW1lbnQ7XHJcbiAgbGV0IGNvaW5JbWFnZTogSFRNTEltYWdlRWxlbWVudDtcclxuXHJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgIGNvbnN0IGJpcmRVcCA9IG5ldyBJbWFnZSgpO1xyXG4gICAgYmlyZFVwLnNyYyA9IFwiL2Fzc2V0cy9yZWRiaXJkLXVwZmxhcC5wbmdcIjtcclxuXHJcbiAgICBjb25zdCBiaXJkTWlkID0gbmV3IEltYWdlKCk7XHJcbiAgICBiaXJkTWlkLnNyYyA9IFwiL2Fzc2V0cy9yZWRiaXJkLW1pZGZsYXAucG5nXCI7XHJcblxyXG4gICAgY29uc3QgYmlyZERvd24gPSBuZXcgSW1hZ2UoKTtcclxuICAgIGJpcmREb3duLnNyYyA9IFwiL2Fzc2V0cy9yZWRiaXJkLWRvd25mbGFwLnBuZ1wiO1xyXG5cclxuICAgIGJpcmRJbWFnZXMucHVzaChiaXJkVXAsIGJpcmRNaWQsIGJpcmREb3duKTtcclxuXHJcbiAgICBwaXBlVG9wID0gbmV3IEltYWdlKCk7XHJcbiAgICBwaXBlVG9wLnNyYyA9IFwiL2Fzc2V0cy9Ub3BUaW55LnBuZ1wiO1xyXG5cclxuICAgIHBpcGVCb3R0b20gPSBuZXcgSW1hZ2UoKTtcclxuICAgIHBpcGVCb3R0b20uc3JjID0gXCIvYXNzZXRzL0JvdHRvbVRpbnkucG5nXCI7XHJcblxyXG4gICAgYmFja2dyb3VuZCA9IG5ldyBJbWFnZSgpO1xyXG4gICAgYmFja2dyb3VuZC5zcmMgPSBcIi9hc3NldHMvYmFja2dyb3VuZC1kYXkucG5nXCI7XHJcblxyXG4gICAgY29pbkltYWdlID0gbmV3IEltYWdlKCk7XHJcbiAgICBjb2luSW1hZ2Uuc3JjID0gXCIvYXNzZXRzL0NvaW5UaW55LnBuZ1wiO1xyXG4gIH1cclxuXHJcbiAgLy8gQ3VycmVudCBiaXJkIGZyYW1lIGluZGV4XHJcbiAgY29uc3QgY3VycmVudEJpcmRGcmFtZVJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xyXG5cclxuICAvLyBMb2FkIGhpZ2ggc2NvcmUgZnJvbSBsb2NhbFN0b3JhZ2VcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgY29uc3Qgc3RvcmVkSGlnaFNjb3JlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJoaWdoU2NvcmVcIik7XHJcbiAgICAgIGlmIChzdG9yZWRIaWdoU2NvcmUpIHtcclxuICAgICAgICBzZXRIaWdoU2NvcmUocGFyc2VJbnQoc3RvcmVkSGlnaFNjb3JlLCAxMCkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSwgW10pO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XHJcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICBpZiAoIWN0eCkgcmV0dXJuO1xyXG5cclxuICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBsb2FkIGFuIGltYWdlIGZ1bGx5XHJcbiAgICBjb25zdCBsb2FkSW1hZ2UgPSAoaW1nOiBIVE1MSW1hZ2VFbGVtZW50KTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgaWYgKGltZy5jb21wbGV0ZSkge1xyXG4gICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpbWcub25sb2FkID0gKCkgPT4gcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgaW1nLm9uZXJyb3IgPSAoKSA9PlxyXG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBpbWFnZTogJHtpbWcuc3JjfWApKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBMb2FkIGFsbCBhc3NldHMgdGhlbiBpbml0aWFsaXplIHRoZSBnYW1lXHJcbiAgICBjb25zdCBsb2FkQXNzZXRzID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgICAgICAgIC4uLmJpcmRJbWFnZXMubWFwKChpbWcpID0+IGxvYWRJbWFnZShpbWcpKSxcclxuICAgICAgICAgIGxvYWRJbWFnZShwaXBlVG9wKSxcclxuICAgICAgICAgIGxvYWRJbWFnZShwaXBlQm90dG9tKSxcclxuICAgICAgICAgIGxvYWRJbWFnZShiYWNrZ3JvdW5kKSxcclxuICAgICAgICAgIGxvYWRJbWFnZShjb2luSW1hZ2UpLFxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQWxsIGFzc2V0cyBsb2FkZWQgc3VjY2Vzc2Z1bGx5IVwiKTtcclxuICAgICAgICBpbml0aWFsaXplR2FtZSgpO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsb2FkaW5nIGFzc2V0czpcIiwgZXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGluaXRpYWxpemVHYW1lKCkge1xyXG4gICAgICBpZiAoIWNhbnZhc1JlZi5jdXJyZW50KSByZXR1cm47XHJcbiAgICAgIGlmICghY3R4KSByZXR1cm47XHJcbiAgICAgIGNvbnN0IHJlY3QgPSBjYW52YXNSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgY2FudmFzUmVmLmN1cnJlbnQud2lkdGggPSByZWN0LndpZHRoO1xyXG4gICAgICBjYW52YXNSZWYuY3VycmVudC5oZWlnaHQgPSByZWN0LmhlaWdodDtcclxuICAgICAgZHJhd1N0YXJ0U2NyZWVuKGN0eCwgY2FudmFzUmVmLmN1cnJlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIGxvYWRBc3NldHMoKTtcclxuXHJcbiAgICBmdW5jdGlvbiByZXNldEdhbWUoKSB7XHJcbiAgICAgIGlmICghY2FudmFzUmVmLmN1cnJlbnQpIHJldHVybjtcclxuICAgICAgY29uc3QgeyBoZWlnaHQgfSA9IGNhbnZhc1JlZi5jdXJyZW50O1xyXG5cclxuICAgICAgYmlyZFlSZWYuY3VycmVudCA9IGhlaWdodCAvIDM7XHJcbiAgICAgIGJpcmRWZWxvY2l0eVJlZi5jdXJyZW50ID0gMDtcclxuICAgICAgcGlwZXNSZWYuY3VycmVudCA9IFtdO1xyXG4gICAgICBjb2luc1JlZi5jdXJyZW50ID0gW107XHJcbiAgICAgIHNldEN1cnJlbnRTY29yZSgwKTtcclxuICAgICAgZ2FtZU92ZXJSZWYuY3VycmVudCA9IGZhbHNlO1xyXG4gICAgICBnYW1lU3RhcnRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICAgIGNvaW5Sb3RhdGlvblN0ZXBSZWYuY3VycmVudCA9IDA7XHJcbiAgICAgIGxhc3RUaW1lUmVmLmN1cnJlbnQgPSAwO1xyXG4gICAgICBwaXBlU3Bhd25UaW1lclJlZi5jdXJyZW50ID0gMDtcclxuICAgICAgY3VycmVudEJpcmRGcmFtZVJlZi5jdXJyZW50ID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVLZXlEb3duKGU6IEtleWJvYXJkRXZlbnQpIHtcclxuICAgICAgaWYgKGUua2V5ID09PSBcIiBcIikge1xyXG4gICAgICAgIGlmICghZ2FtZVN0YXJ0ZWRSZWYuY3VycmVudCAmJiAhZ2FtZU92ZXJSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgc3RhcnRHYW1lKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChnYW1lT3ZlclJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICBzdGFydEdhbWUoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYmlyZFZlbG9jaXR5UmVmLmN1cnJlbnQgPSBGTEFQO1xyXG4gICAgICAgICAgZmxhcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBoYW5kbGVLZXlEb3duKTtcclxuXHJcbiAgICBmdW5jdGlvbiBzdGFydEdhbWUoKSB7XHJcbiAgICAgIHJlc2V0R2FtZSgpO1xyXG4gICAgICBnYW1lU3RhcnRlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcclxuICAgICAgbGFzdFRpbWVSZWYuY3VycmVudCA9IDA7IC8vIFJlc2V0IGZvciBmcmFtZS1saW1pdGluZ1xyXG4gICAgICByZXF1ZXN0SWRSZWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVVc2VySW5wdXQoKSB7XHJcbiAgICAgIGlmICghZ2FtZVN0YXJ0ZWRSZWYuY3VycmVudCAmJiAhZ2FtZU92ZXJSZWYuY3VycmVudCkge1xyXG4gICAgICAgIHN0YXJ0R2FtZSgpO1xyXG4gICAgICB9IGVsc2UgaWYgKGdhbWVPdmVyUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBzdGFydEdhbWUoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBiaXJkVmVsb2NpdHlSZWYuY3VycmVudCA9IEZMQVA7XHJcbiAgICAgICAgZmxhcCgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZmxhcCA9ICgpID0+IHtcclxuICAgICAgY3VycmVudEJpcmRGcmFtZVJlZi5jdXJyZW50ID0gMTtcclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgY3VycmVudEJpcmRGcmFtZVJlZi5jdXJyZW50ID0gMjtcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgIGN1cnJlbnRCaXJkRnJhbWVSZWYuY3VycmVudCA9IDA7XHJcbiAgICAgICAgfSwgMTcwKTtcclxuICAgICAgfSwgMTcwKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gVGhlIG1haW4gbG9vcCB3aXRoIHRpbWUtYmFzZWQgdXBkYXRlc1xyXG4gICAgZnVuY3Rpb24gYW5pbWF0ZSh0aW1lc3RhbXA6IG51bWJlcikge1xyXG4gICAgICBpZiAoaXNQYXVzZWQgfHwgIWdhbWVTdGFydGVkUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICByZXF1ZXN0SWRSZWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFjYW52YXNSZWYuY3VycmVudCkgcmV0dXJuO1xyXG5cclxuICAgICAgY29uc3QgY29udGV4dCA9IGNhbnZhc1JlZi5jdXJyZW50LmdldENvbnRleHQoXCIyZFwiKTtcclxuICAgICAgaWYgKCFjb250ZXh0KSByZXR1cm47XHJcblxyXG4gICAgICBpZiAoIWxhc3RUaW1lUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBsYXN0VGltZVJlZi5jdXJyZW50ID0gdGltZXN0YW1wO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGRlbHRhVGltZSA9IHRpbWVzdGFtcCAtIGxhc3RUaW1lUmVmLmN1cnJlbnQ7XHJcblxyXG4gICAgICAvLyBVcGRhdGUgZ2FtZSBzdGF0ZSBiYXNlZCBvbiBkZWx0YVRpbWVcclxuICAgICAgdXBkYXRlR2FtZVN0YXRlKGRlbHRhVGltZSwgY2FudmFzUmVmLmN1cnJlbnQpO1xyXG5cclxuICAgICAgLy8gRHJhdyBldmVyeXRoaW5nXHJcbiAgICAgIGRyYXcoY29udGV4dCwgY2FudmFzUmVmLmN1cnJlbnQpO1xyXG5cclxuICAgICAgaWYgKCFnYW1lT3ZlclJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgbGFzdFRpbWVSZWYuY3VycmVudCA9IHRpbWVzdGFtcDtcclxuICAgICAgICByZXF1ZXN0SWRSZWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBkcmF3R2FtZU92ZXJTY3JlZW4oY29udGV4dCwgY2FudmFzUmVmLmN1cnJlbnQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdXBkYXRlR2FtZVN0YXRlKGRlbHRhVGltZTogbnVtYmVyLCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgIC8vIFVwZGF0ZSBiaXJkIHBvc2l0aW9uIGJhc2VkIG9uIGRlbHRhVGltZVxyXG4gICAgICBiaXJkVmVsb2NpdHlSZWYuY3VycmVudCArPSBHUkFWSVRZO1xyXG4gICAgICBiaXJkWVJlZi5jdXJyZW50ICs9IGJpcmRWZWxvY2l0eVJlZi5jdXJyZW50ICogKGRlbHRhVGltZSAvIDE2KTsgLy8gQXNzdW1pbmcgNjAgRlBTIGFzIGJhc2VcclxuXHJcbiAgICAgIC8vIFVwZGF0ZSBwaXBlIHNwYXduIHRpbWVyXHJcbiAgICAgIHBpcGVTcGF3blRpbWVyUmVmLmN1cnJlbnQgKz0gZGVsdGFUaW1lO1xyXG4gICAgICBpZiAocGlwZVNwYXduVGltZXJSZWYuY3VycmVudCA+IFBJUEVfU1BBV05fSU5URVJWQUwpIHtcclxuICAgICAgICBjcmVhdGVQaXBlKGNhbnZhcyk7XHJcbiAgICAgICAgcGlwZVNwYXduVGltZXJSZWYuY3VycmVudCA9IDA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG1vdmVQaXBlc0FuZENvaW5zKCk7XHJcbiAgICAgIGNoZWNrQ29pbkNvbGxlY3Rpb24oKTtcclxuXHJcbiAgICAgIC8vIENoZWNrIGNvbGxpc2lvbnNcclxuICAgICAgaWYgKGNoZWNrQ29sbGlzaW9ucyhjYW52YXMpKSB7XHJcbiAgICAgICAgZ2FtZU92ZXJSZWYuY3VycmVudCA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB1cGRhdGVTY29yZSgpO1xyXG5cclxuICAgICAgLy8gUm90YXRlIGNvaW5cclxuICAgICAgY29pblJvdGF0aW9uU3RlcFJlZi5jdXJyZW50ICs9IFJPVEFUSU9OX1NQRUVEICogKGRlbHRhVGltZSAvIDE2KTtcclxuICAgICAgaWYgKGNvaW5Sb3RhdGlvblN0ZXBSZWYuY3VycmVudCA+PSAxKSB7XHJcbiAgICAgICAgY29pblJvdGF0aW9uU3RlcFJlZi5jdXJyZW50ID0gMDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXcoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcclxuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICBkcmF3QmFja2dyb3VuZChjdHgsIGNhbnZhcyk7XHJcbiAgICAgIGRyYXdCaXJkKGN0eCk7XHJcbiAgICAgIGRyYXdQaXBlcyhjdHgpO1xyXG4gICAgICBkcmF3Q29pbnMoY3R4KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3U3RhcnRTY3JlZW4oY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcclxuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICBkcmF3QmFja2dyb3VuZChjdHgsIGNhbnZhcyk7XHJcbiAgICAgIGN0eC5mb250ID0gXCJib2xkIDIycHggQXJpYWxcIjtcclxuICAgICAgY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNmZmZmZmZcIjtcclxuICAgICAgY3R4LnNoYWRvd0NvbG9yID0gXCJibGFja1wiO1xyXG4gICAgICBjdHguc2hhZG93Qmx1ciA9IDI7XHJcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xyXG5cclxuICAgICAgY3R4LmZpbGxUZXh0KFxyXG4gICAgICAgIFwiUHJlc3MgU3BhY2Ugb3IgVGFwIHRvIFN0YXJ0XCIsXHJcbiAgICAgICAgY2FudmFzLndpZHRoIC8gMixcclxuICAgICAgICBjYW52YXMuaGVpZ2h0IC8gMlxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdHYW1lT3ZlclNjcmVlbihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkge1xyXG4gICAgICBjdHguZmlsbFN0eWxlID0gXCIjZmZjYzAwXCI7XHJcbiAgICAgIGN0eC5mb250ID0gXCJib2xkIDM2cHggQXJpYWxcIjtcclxuICAgICAgY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XHJcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xyXG4gICAgICBjdHguc2hhZG93Q29sb3IgPSBcImJsYWNrXCI7XHJcbiAgICAgIGN0eC5zaGFkb3dCbHVyID0gNjtcclxuXHJcbiAgICAgIGN0eC5maWxsVGV4dChcIkdhbWUgT3ZlciFcIiwgY2FudmFzLndpZHRoIC8gMiwgY2FudmFzLmhlaWdodCAvIDIgLSAzMCk7XHJcblxyXG4gICAgICBjdHguZmlsbFN0eWxlID0gXCIjZmZmZmZmXCI7XHJcbiAgICAgIGN0eC5mb250ID0gXCJib2xkIDIwcHggQXJpYWxcIjtcclxuICAgICAgY3R4LmZpbGxUZXh0KFxyXG4gICAgICAgIFwiUHJlc3MgU3BhY2Ugb3IgVGFwIHRvIFJlc3RhcnRcIixcclxuICAgICAgICBjYW52YXMud2lkdGggLyAyLFxyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgLyAyICsgMTBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3QmFja2dyb3VuZChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkge1xyXG4gICAgICBjdHguZHJhd0ltYWdlKGJhY2tncm91bmQsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd0JpcmQoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcclxuICAgICAgY29uc3QgY3VycmVudEltYWdlID0gYmlyZEltYWdlc1tjdXJyZW50QmlyZEZyYW1lUmVmLmN1cnJlbnRdO1xyXG4gICAgICBpZiAoY3VycmVudEltYWdlLmNvbXBsZXRlKSB7XHJcbiAgICAgICAgY3R4LmRyYXdJbWFnZShjdXJyZW50SW1hZ2UsIDEwMCwgYmlyZFlSZWYuY3VycmVudCwgQklSRF9XSURUSCwgQklSRF9IRUlHSFQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd1BpcGVzKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XHJcbiAgICAgIGZvciAoY29uc3QgcGlwZSBvZiBwaXBlc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY3R4LmRyYXdJbWFnZShwaXBlVG9wLCBwaXBlLngsIDAsIFBJUEVfV0lEVEgsIHBpcGUudG9wSGVpZ2h0KTtcclxuICAgICAgICBjdHguZHJhd0ltYWdlKFxyXG4gICAgICAgICAgcGlwZUJvdHRvbSxcclxuICAgICAgICAgIHBpcGUueCxcclxuICAgICAgICAgIHBpcGUuYm90dG9tWSxcclxuICAgICAgICAgIFBJUEVfV0lEVEgsXHJcbiAgICAgICAgICBwaXBlLmJvdHRvbUhlaWdodFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3Q29pbnMoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcclxuICAgICAgY29uc3Qgc2NhbGVYID0gTWF0aC5hYnMoTWF0aC5jb3MoY29pblJvdGF0aW9uU3RlcFJlZi5jdXJyZW50ICogTWF0aC5QSSAqIDIpKTtcclxuICAgICAgY29uc3QgaGFsZlNpemUgPSBDT0lOX1NJWkUgLyAyO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBjb2luIG9mIGNvaW5zUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBpZiAoIWNvaW4uY29sbGVjdGVkKSB7XHJcbiAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgY3R4LnRyYW5zbGF0ZShjb2luLnggKyBoYWxmU2l6ZSwgY29pbi55ICsgaGFsZlNpemUpO1xyXG4gICAgICAgICAgY3R4LnNjYWxlKHNjYWxlWCwgMSk7XHJcbiAgICAgICAgICBjdHguZHJhd0ltYWdlKGNvaW5JbWFnZSwgLWhhbGZTaXplLCAtaGFsZlNpemUsIENPSU5fU0laRSwgQ09JTl9TSVpFKTtcclxuICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlUGlwZShjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgIGNvbnN0IHBpcGVIZWlnaHQgPVxyXG4gICAgICAgIE1hdGgucmFuZG9tKCkgKiAoY2FudmFzLmhlaWdodCAtIFBJUEVfU1BBQ0lORyAtIDEwMCkgKyA1MDtcclxuICAgICAgY29uc3QgYm90dG9tWSA9IHBpcGVIZWlnaHQgKyBQSVBFX1NQQUNJTkc7XHJcbiAgICAgIHBpcGVzUmVmLmN1cnJlbnQucHVzaCh7XHJcbiAgICAgICAgeDogY2FudmFzLndpZHRoLFxyXG4gICAgICAgIHRvcEhlaWdodDogcGlwZUhlaWdodCxcclxuICAgICAgICBib3R0b21ZLFxyXG4gICAgICAgIGJvdHRvbUhlaWdodDogY2FudmFzLmhlaWdodCAtIGJvdHRvbVksXHJcbiAgICAgICAgc2NvcmVkOiBmYWxzZSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBTcGF3biBjb2luIG9ubHkgMjUlIGNoYW5jZVxyXG4gICAgICBpZiAoTWF0aC5yYW5kb20oKSA+ICgxIC0gQ09JTl9TUEFXTl9DSEFOQ0UpKSB7XHJcbiAgICAgICAgY29pbnNSZWYuY3VycmVudC5wdXNoKHtcclxuICAgICAgICAgIHg6IGNhbnZhcy53aWR0aCArIFBJUEVfV0lEVEggLyAyIC0gQ09JTl9TSVpFIC8gMixcclxuICAgICAgICAgIHk6IHBpcGVIZWlnaHQgKyBQSVBFX1NQQUNJTkcgLyAyIC0gQ09JTl9TSVpFIC8gMixcclxuICAgICAgICAgIHdpZHRoOiBDT0lOX1NJWkUsXHJcbiAgICAgICAgICBoZWlnaHQ6IENPSU5fU0laRSxcclxuICAgICAgICAgIGNvbGxlY3RlZDogZmFsc2UsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtb3ZlUGlwZXNBbmRDb2lucygpIHtcclxuICAgICAgZm9yIChjb25zdCBwaXBlIG9mIHBpcGVzUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBwaXBlLnggLT0gMjtcclxuICAgICAgfVxyXG4gICAgICBwaXBlc1JlZi5jdXJyZW50ID0gcGlwZXNSZWYuY3VycmVudC5maWx0ZXIoXHJcbiAgICAgICAgKHBpcGUpID0+IHBpcGUueCArIFBJUEVfV0lEVEggPiAwXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGNvaW4gb2YgY29pbnNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGNvaW4ueCAtPSAyO1xyXG4gICAgICB9XHJcbiAgICAgIGNvaW5zUmVmLmN1cnJlbnQgPSBjb2luc1JlZi5jdXJyZW50LmZpbHRlcihcclxuICAgICAgICAoY29pbikgPT4gY29pbi54ICsgY29pbi53aWR0aCA+IDAgJiYgIWNvaW4uY29sbGVjdGVkXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2hlY2tDb2xsaXNpb25zKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpOiBib29sZWFuIHtcclxuICAgICAgLy8gQmlyZCBvdXQgb2YgYm91bmRzXHJcbiAgICAgIGlmIChiaXJkWVJlZi5jdXJyZW50IDwgMCB8fCBiaXJkWVJlZi5jdXJyZW50ICsgQklSRF9IRUlHSFQgPiBjYW52YXMuaGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGJpcmRMZWZ0ID0gMTAwO1xyXG4gICAgICBjb25zdCBiaXJkUmlnaHQgPSBiaXJkTGVmdCArIEJJUkRfV0lEVEg7XHJcbiAgICAgIGNvbnN0IGJpcmRUb3AgPSBiaXJkWVJlZi5jdXJyZW50O1xyXG4gICAgICBjb25zdCBiaXJkQm90dG9tID0gYmlyZFlSZWYuY3VycmVudCArIEJJUkRfSEVJR0hUO1xyXG5cclxuICAgICAgLy8gUGlwZSBjb2xsaXNpb25cclxuICAgICAgZm9yIChjb25zdCBwaXBlIG9mIHBpcGVzUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBjb25zdCB3aXRoaW5QaXBlWCA9XHJcbiAgICAgICAgICBiaXJkUmlnaHQgPiBwaXBlLnggJiYgYmlyZExlZnQgPCBwaXBlLnggKyBQSVBFX1dJRFRIO1xyXG4gICAgICAgIGNvbnN0IHdpdGhpblBpcGVZID1cclxuICAgICAgICAgIGJpcmRUb3AgPCBwaXBlLnRvcEhlaWdodCB8fCBiaXJkQm90dG9tID4gcGlwZS5ib3R0b21ZO1xyXG4gICAgICAgIGlmICh3aXRoaW5QaXBlWCAmJiB3aXRoaW5QaXBlWSkgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNoZWNrQ29pbkNvbGxlY3Rpb24oKSB7XHJcbiAgICAgIGNvbnN0IGJpcmRMZWZ0ID0gMTAwO1xyXG4gICAgICBjb25zdCBiaXJkUmlnaHQgPSBiaXJkTGVmdCArIEJJUkRfV0lEVEg7XHJcbiAgICAgIGNvbnN0IGJpcmRUb3AgPSBiaXJkWVJlZi5jdXJyZW50O1xyXG4gICAgICBjb25zdCBiaXJkQm90dG9tID0gYmlyZFlSZWYuY3VycmVudCArIEJJUkRfSEVJR0hUO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBjb2luIG9mIGNvaW5zUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBpZiAoIWNvaW4uY29sbGVjdGVkKSB7XHJcbiAgICAgICAgICBjb25zdCBjb2luTGVmdCA9IGNvaW4ueDtcclxuICAgICAgICAgIGNvbnN0IGNvaW5SaWdodCA9IGNvaW4ueCArIGNvaW4ud2lkdGg7XHJcbiAgICAgICAgICBjb25zdCBjb2luVG9wID0gY29pbi55O1xyXG4gICAgICAgICAgY29uc3QgY29pbkJvdHRvbSA9IGNvaW4ueSArIGNvaW4uaGVpZ2h0O1xyXG5cclxuICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgYmlyZFJpZ2h0ID4gY29pbkxlZnQgJiZcclxuICAgICAgICAgICAgYmlyZExlZnQgPCBjb2luUmlnaHQgJiZcclxuICAgICAgICAgICAgYmlyZEJvdHRvbSA+IGNvaW5Ub3AgJiZcclxuICAgICAgICAgICAgYmlyZFRvcCA8IGNvaW5Cb3R0b21cclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICBjb2luLmNvbGxlY3RlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHNldEN1cnJlbnRTY29yZSgocHJldlNjb3JlKSA9PiB7XHJcbiAgICAgICAgICAgICAgY29uc3QgbmV3U2NvcmUgPSBwcmV2U2NvcmUgKyA1O1xyXG4gICAgICAgICAgICAgIHNldEhpZ2hTY29yZSgocHJldkhpZ2hTY29yZSkgPT4gTWF0aC5tYXgocHJldkhpZ2hTY29yZSwgbmV3U2NvcmUpKTtcclxuICAgICAgICAgICAgICByZXR1cm4gbmV3U2NvcmU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZVNjb3JlKCkge1xyXG4gICAgICBmb3IgKGNvbnN0IHBpcGUgb2YgcGlwZXNSZWYuY3VycmVudCkge1xyXG4gICAgICAgIC8vIFNjb3JlICsxIGZvciBwYXNzaW5nIGVhY2ggcGlwZSBvbmNlXHJcbiAgICAgICAgaWYgKCFwaXBlLnNjb3JlZCAmJiBwaXBlLnggKyBQSVBFX1dJRFRIIDwgMTAwKSB7XHJcbiAgICAgICAgICBzZXRDdXJyZW50U2NvcmUoKHByZXZTY29yZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdTY29yZSA9IHByZXZTY29yZSArIDE7XHJcbiAgICAgICAgICAgIHNldEhpZ2hTY29yZSgocHJldkhpZ2hTY29yZSkgPT4ge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRIaWdoU2NvcmUgPSBNYXRoLm1heChwcmV2SGlnaFNjb3JlLCBuZXdTY29yZSk7XHJcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwiaGlnaFNjb3JlXCIsIHVwZGF0ZWRIaWdoU2NvcmUudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVkSGlnaFNjb3JlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld1Njb3JlO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBwaXBlLnNjb3JlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2xlYW51cFxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGhhbmRsZUtleURvd24pO1xyXG4gICAgICBpZiAocmVxdWVzdElkUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyZXF1ZXN0SWRSZWYuY3VycmVudCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfSwgW2NhbnZhc1JlZiwgaXNQYXVzZWQsIGF1dG9TdGFydF0pO1xyXG5cclxuICAvLyBFeHBvc2UgaGFuZGxlVXNlcklucHV0XHJcbiAgY29uc3QgaGFuZGxlVXNlcklucHV0ID0gKCkgPT4ge1xyXG4gICAgLy8gRGlzcGF0Y2ggYSBcImtleWRvd25cIiBldmVudCB3aXRoIGtleSBcIiBcIlxyXG4gICAgY29uc3Qgc3BhY2VFdmVudCA9IG5ldyBLZXlib2FyZEV2ZW50KFwia2V5ZG93blwiLCB7IGtleTogXCIgXCIgfSk7XHJcbiAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChzcGFjZUV2ZW50KTtcclxuICB9O1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgaGlnaFNjb3JlLFxyXG4gICAgY3VycmVudFNjb3JlLFxyXG4gICAgaGFuZGxlVXNlcklucHV0LFxyXG4gIH07XHJcbn1cclxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwiR1JBVklUWSIsIkZMQVAiLCJQSVBFX1dJRFRIIiwiUElQRV9TUEFDSU5HIiwiQklSRF9XSURUSCIsIkJJUkRfSEVJR0hUIiwiQ09JTl9TSVpFIiwiUk9UQVRJT05fU1BFRUQiLCJQSVBFX1NQQVdOX0lOVEVSVkFMIiwiQ09JTl9TUEFXTl9DSEFOQ0UiLCJ1c2VGbGFwcHlCaXJkR2FtZSIsImNhbnZhc1JlZiIsImlzUGF1c2VkIiwiYXV0b1N0YXJ0IiwicmVxdWVzdElkUmVmIiwiaGlnaFNjb3JlIiwic2V0SGlnaFNjb3JlIiwiY3VycmVudFNjb3JlIiwic2V0Q3VycmVudFNjb3JlIiwiYmlyZFlSZWYiLCJiaXJkVmVsb2NpdHlSZWYiLCJwaXBlc1JlZiIsImNvaW5zUmVmIiwiZ2FtZU92ZXJSZWYiLCJnYW1lU3RhcnRlZFJlZiIsImNvaW5Sb3RhdGlvblN0ZXBSZWYiLCJsYXN0VGltZVJlZiIsInBpcGVTcGF3blRpbWVyUmVmIiwiYmlyZEltYWdlcyIsInBpcGVUb3AiLCJwaXBlQm90dG9tIiwiYmFja2dyb3VuZCIsImNvaW5JbWFnZSIsImJpcmRVcCIsIkltYWdlIiwic3JjIiwiYmlyZE1pZCIsImJpcmREb3duIiwicHVzaCIsImN1cnJlbnRCaXJkRnJhbWVSZWYiLCJzdG9yZWRIaWdoU2NvcmUiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwicGFyc2VJbnQiLCJjYW52YXMiLCJjdXJyZW50IiwiY3R4IiwiZ2V0Q29udGV4dCIsImxvYWRJbWFnZSIsImltZyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiY29tcGxldGUiLCJvbmxvYWQiLCJvbmVycm9yIiwiRXJyb3IiLCJsb2FkQXNzZXRzIiwiYWxsIiwibWFwIiwiY29uc29sZSIsImxvZyIsImluaXRpYWxpemVHYW1lIiwiZXJyb3IiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJkcmF3U3RhcnRTY3JlZW4iLCJyZXNldEdhbWUiLCJoYW5kbGVLZXlEb3duIiwiZSIsImtleSIsInN0YXJ0R2FtZSIsImZsYXAiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiYW5pbWF0ZSIsImhhbmRsZVVzZXJJbnB1dCIsInNldFRpbWVvdXQiLCJ0aW1lc3RhbXAiLCJjb250ZXh0IiwiZGVsdGFUaW1lIiwidXBkYXRlR2FtZVN0YXRlIiwiZHJhdyIsImRyYXdHYW1lT3ZlclNjcmVlbiIsImNyZWF0ZVBpcGUiLCJtb3ZlUGlwZXNBbmRDb2lucyIsImNoZWNrQ29pbkNvbGxlY3Rpb24iLCJjaGVja0NvbGxpc2lvbnMiLCJ1cGRhdGVTY29yZSIsImNsZWFyUmVjdCIsImRyYXdCYWNrZ3JvdW5kIiwiZHJhd0JpcmQiLCJkcmF3UGlwZXMiLCJkcmF3Q29pbnMiLCJmb250IiwidGV4dEFsaWduIiwiZmlsbFN0eWxlIiwic2hhZG93Q29sb3IiLCJzaGFkb3dCbHVyIiwidGV4dEJhc2VsaW5lIiwiZmlsbFRleHQiLCJkcmF3SW1hZ2UiLCJjdXJyZW50SW1hZ2UiLCJwaXBlIiwieCIsInRvcEhlaWdodCIsImJvdHRvbVkiLCJib3R0b21IZWlnaHQiLCJzY2FsZVgiLCJNYXRoIiwiYWJzIiwiY29zIiwiUEkiLCJoYWxmU2l6ZSIsImNvaW4iLCJjb2xsZWN0ZWQiLCJzYXZlIiwidHJhbnNsYXRlIiwieSIsInNjYWxlIiwicmVzdG9yZSIsInBpcGVIZWlnaHQiLCJyYW5kb20iLCJzY29yZWQiLCJmaWx0ZXIiLCJiaXJkTGVmdCIsImJpcmRSaWdodCIsImJpcmRUb3AiLCJiaXJkQm90dG9tIiwid2l0aGluUGlwZVgiLCJ3aXRoaW5QaXBlWSIsImNvaW5MZWZ0IiwiY29pblJpZ2h0IiwiY29pblRvcCIsImNvaW5Cb3R0b20iLCJwcmV2U2NvcmUiLCJuZXdTY29yZSIsInByZXZIaWdoU2NvcmUiLCJtYXgiLCJ1cGRhdGVkSGlnaFNjb3JlIiwic2V0SXRlbSIsInRvU3RyaW5nIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwic3BhY2VFdmVudCIsIktleWJvYXJkRXZlbnQiLCJkaXNwYXRjaEV2ZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./public/useFlappyBirdGame.ts\n"));

/***/ })

});